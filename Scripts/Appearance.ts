let CharacterAppearancePreviousEmoticon = null;

/**
 * Resets the character to it's default appearance
 */
function CharacterAppearanceSetDefault(C: Character): void {
	C.Appearance = [];
	C.Pose = [];
}

/**
 * Removes all items that can be removed, making the character naked. Checks for a blocking of CosPlayItem removal.
 */
function CharacterAppearanceNaked(C: Character): void {
	for (let A = C.Appearance.length - 1; A >= 0; A--)
		if (!C.Appearance[A].Model?.Protected)
			C.Appearance.splice(A, 1);
}

/**
 * Draws the character canvas
 */
function CharacterAppearanceBuildCanvas(C: Character): void {}

/**
 * Returns a value from the character current appearance
 * @param C - The character to get values from
 * @param Group - The name of the group, whose values we want to get
 * @param Type - The name of the value, we want to get
 */
function CharacterAppearanceGetCurrentValue(C: Character, Group: string, Type: string): any {

	// Finds the value
	for (let A = 0; A < C.Appearance.length; A++)
		if ((C.Appearance[A].Asset.Group.Family == C.AssetFamily) && (C.Appearance[A].Asset.Group.Name == Group)) {
			if (Type == "Name") return C.Appearance[A].Asset.Name;
			if (Type == "Description") return C.Appearance[A].Asset.Description;
			if (Type == "Color") return CommonColorsEqual(C.Appearance[A].Color, C.Appearance[A].Asset.DefaultColor) ? "Default" : C.Appearance[A].Color;
			if (Type == "ID") return A;
			if (Type == "Effect") return C.Appearance[A].Asset.Effect;
			if (Type == "Asset") return C.Appearance[A].Asset;
			if (Type == "Full") return C.Appearance[A];
			if (Type == "Zoom") return ((C.Appearance[A].Asset.ZoomModifier == null) || (C.Appearance[A].Asset.ZoomModifier > 1) || (C.Appearance[A].Asset.ZoomModifier < 0.9)) ? 1 : C.Appearance[A].Asset.ZoomModifier;
		}
	return "None";

}

/**
 * Repositions the character horizonally to centre them, since shorter characters will shrink towards the left
 * @param C - The character to reposition
 * @param HeightRatio - The character's height ratio
 * @returns The amount to move the character along the X co-ordinate
 */
function CharacterAppearanceXOffset(C: Character, HeightRatio: number): number {
	return 500 * (1 - HeightRatio) / 2;
}

/**
 * Checks if the appearance is locked for the current player
 * @param C - The character to validate
 * @param GroupName - The group name to validate, can be "ALL" to check all groups
 * @returns Return TRUE if the appearance group isn't blocked
 */
function AppearanceGroupAllowed(C: Character, GroupName: string): boolean {
	return true;
}

/**
 * Sets an item in the character appearance
 * @param C - The character whose appearance should be changed
 * @param Group - The name of the corresponding groupr for the item
 * @param ItemAsset - The asset collection of the item to be changed
 * @param NewColor - The new color (as "#xxyyzz" hex value) for that item
 * @param DifficultyFactor - The difficulty, on top of the base asset difficulty, that should be assigned
 * to the item
 * @param ItemMemberNumber- The member number of the player adding the item - defaults to -1
 * @param Refresh - Determines, wether the character should be redrawn after the item change
 */
function CharacterAppearanceSetItem(C: Character, Group: string, ItemAsset: any, NewColor: string | string[], DifficultyFactor: number = 0, ItemMemberNumber: number = -1, Refresh: boolean = true): void {}


/**
 * Serialises a character's appearance into an abbreviated string for backup purposes
 * @param C - The character whose appearance should be serialised
 * @returns A serialised version of the character's current appearance
 */
function CharacterAppearanceStringify(C: Character): string {
	return AppearanceItemStringify(C.Appearance);
}

function AppearanceItemStringify(Item: any[]): string {
	for (let r of Item) {
		if (r.Model?.Filters) r.Filters = r.Model.Filters;
	}
	return JSON.stringify(Item, (key, value) => {
		if (key === "Asset") {
			return value.Group.Family + "/" + value.Group.Name + "/" + value.Name;
		}
		if (key === "Model") {
			return value.Name;
		}
		return value;
	});
}

/**
 * Restores a character's appearance from a serialised string generated by CharacterAppearanceStringify
 * @param C - The character whose appearance should be restored
 * @param backup - The serialised appearance to restore
 */
function CharacterAppearanceRestore(C: Character, backup: string): void {
	C.Appearance = AppearanceItemParse(backup);
}

function AppearanceItemParse(stringified: string): any[] {
	let ret = JSON.parse(stringified, (key, value) => {
		if (key === "Model") {
			return JSON.parse(JSON.stringify(ModelDefs[value]));
		}
		return value;
	});
	for (let r of ret) {
		if (r.Filters && r.Model) r.Model.Filters = r.Filters;
	}
	return ret;
}
