"use strict";
;
;
;
;
var PosePriConditions;
(function (PosePriConditions) {
    PosePriConditions[PosePriConditions["rotation"] = 0] = "rotation";
    PosePriConditions[PosePriConditions["offset_x"] = 1] = "offset_x";
    PosePriConditions[PosePriConditions["offset_y"] = 2] = "offset_y";
    PosePriConditions[PosePriConditions["offset_either"] = 3] = "offset_either";
})(PosePriConditions || (PosePriConditions = {}));
;
let StandalonePatched = true;
let ArcadeDeviousChallenge = false;
let ChatRoomChatLog = [];
let ChatRoomCharacter = null;
let DialogText = "";
let DialogTextDefault = "";
let DialogTextDefaultTimer = -1;
let StruggleProgress = -1;
let DialogColor = null;
let DialogExpressionColor = null;
let DialogColorSelect = null;
let DialogPreviousCharacterData = {};
let DialogInventory = [];
let DialogInventoryOffset = 0;
let DialogFocusItem = null;
let DialogFocusSourceItem = null;
let DialogFocusItemColorizationRedrawTimer = null;
let DialogMenuButton = [];
let DialogItemToLock = null;
let DialogAllowBlush = false;
let DialogAllowEyebrows = false;
let DialogAllowFluids = false;
let DialogFacialExpressions = [];
let DialogFacialExpressionsSelected = -1;
let DialogFacialExpressionsSelectedBlindnessLevel = 2;
let DialogSavedExpressionPreviews = [];
let DialogActivePoses = [];
let DialogItemPermissionMode = false;
let DialogExtendedMessage = "";
let DialogActivityMode = false;
let DialogSortOrder = {
    Enabled: 1,
    Equipped: 2,
    BothFavoriteUsable: 3,
    TargetFavoriteUsable: 4,
    PlayerFavoriteUsable: 5,
    Usable: 6,
    TargetFavoriteUnusable: 7,
    PlayerFavoriteUnusable: 8,
    Unusable: 9,
    Blocked: 10
};
let DialogSelfMenuSelected = null;
let DialogLeaveDueToItem = false;
let DialogLockMenu = false;
let DialogLentLockpicks = false;
let DialogGamingPreviousRoom = "";
let DialogGamingPreviousModule = "";
let DialogButtonDisabledTester = /Disabled(For\w+)?$/u;
let PlayerDialog = new Map();
let DialogFavoriteStateDetails = [];
let MiniGameReturnFunction = "ArcadeKinkyDungeonEnd";
function DialogCanUnlock() {
    return true;
}
function CheatFactor() {
    return 1;
}
function WardrobeGetExpression(C) {
    let characterExpression = {};
    ServerAppearanceBundle(C.Appearance).filter(item => item.Property != null && item.Property.Expression != null).forEach(item => characterExpression[item.Group] = item.Property.Expression);
    return characterExpression;
}
function ServerAppearanceBundle(Appearance) {
    let Bundle = [];
    for (let A = 0; A < Appearance.length; A++) {
        let N = {};
        N.Group = Appearance[A].Asset.Group.Name;
        N.Name = Appearance[A].Asset.Name;
        if ((Appearance[A].Color != null) && (Appearance[A].Color != "Default"))
            N.Color = Appearance[A].Color;
        if ((Appearance[A].Difficulty != null) && (Appearance[A].Difficulty != 0))
            N.Difficulty = Appearance[A].Difficulty;
        if (Appearance[A].Property != null)
            N.Property = Appearance[A].Property;
        Bundle.push(N);
    }
    return Bundle;
}
function OnlineGameDrawCharacter(C, X, Y, Zoom) {
}
function DialogGetMenuButtonColor(ButtonName) {
    if (DialogIsMenuButtonDisabled(ButtonName)) {
        return "#808080";
    }
    else if (ButtonName === "ColorPick") {
        return DialogColorSelect || "#fff";
    }
    else {
        return "#fff";
    }
}
function DialogIsMenuButtonDisabled(ButtonName) {
    return DialogButtonDisabledTester.test(ButtonName);
}
function DialogMenuButtonBuild(C) {
}
function DialogCanColor(C, Item) {
    const ItemColorable = !Item || (Item && Item.Asset && Item.Asset.ColorableLayerCount > 0);
    return ItemColorable;
}
function DialogInventorySort() {
    DialogInventory.sort((a, b) => a.SortOrder.localeCompare(b.SortOrder, undefined, { numeric: true, sensitivity: 'base' }));
}
function DialogInventoryStringified(C) {
    return (C.FocusGroup ? C.FocusGroup.Name : "") + (DialogInventory ? JSON.stringify(DialogInventory.map(I => I.Asset.Name).sort()) : "");
}
function DialogInventoryAdd(C, item, isWorn, sortOrder) {
}
function DialogFindPlayer(KeyWord) {
    const res = PlayerDialog.get(KeyWord);
    return res !== undefined ? res : `MISSING PLAYER DIALOG: ${KeyWord}`;
}
function DialogInventoryBuild(C, Offset, redrawPreviews = false) {
}
function ReputationGet(RepType) {
    return 0;
}
function DialogSetReputation(a, b) {
}
function remap(src) {
    return src;
}
function ChatRoomCharacterUpdate(C) {
}
const TypedItemDataLookup = {};
const ModularItemDataLookup = {};
function TypedItemSetOption(C, item, options, option, push = false) { }
function TypedItemSetOptionByName(a, b, c, d) { }
function ModularItemMergeModuleValues({ asset, modules }, moduleValues) { }
function ExtendedItemSetType(C, Options, Option) { }
function ExtendedItemExit() { }
let MiniGameVictory = true;
let CharacterRefresh = (...args) => { };
function InventoryRemove(C, AssetGroup, Refresh = false) { }
function InventoryGetLock(Lock) { }
function InventoryAllow(C, asset, prerequisites = asset.Prerequisite, setDialog = true) { return true; }
function InventoryWear(C, AssetName, AssetGroup, ItemColor, Difficulty, MemberNumber, Craft, Refresh = true) { }
function InventoryLock(C, Item, Lock, MemberNumber, Update = true) { }
function InventoryUnlock(C, Item) { }
let KDPatched = true;
let ServerURL = "http://localhost:4288";
function ServerSend(Message, Data) { }
function ServerPlayerIsInChatRoom() { return false; }
function suppressCanvasUpdate(f) {
    return f();
}
let Player;
let KeyPress = "";
let CurrentModule;
let CurrentScreen;
let CurrentCharacter = null;
let CurrentOnlinePlayers = 0;
let CurrentDarkFactor = 1.0;
let CommonIsMobile = false;
let CommonCSVCache = {};
let CutsceneStage = 0;
let CommonPhotoMode = false;
let GameVersion = "R0";
const GameVersionFormat = /^R([0-9]+)(?:(Alpha|Beta)([0-9]+)?)?$/;
let CommonVersionUpdated = false;
let CommonTouchList = null;
const CommonChatTags = {
    SOURCE_CHAR: "SourceCharacter",
    DEST_CHAR: "DestinationCharacter",
    DEST_CHAR_NAME: "DestinationCharacterName",
    TARGET_CHAR: "TargetCharacter",
    TARGET_CHAR_NAME: "TargetCharacterName",
    ASSET_NAME: "AssetName",
};
String.prototype.replaceAt = function (index, character) {
    return this.substr(0, index) + character + this.substr(index + character.length);
};
const CommonFontStacks = {
    Arial: [["Arial"], "sans-serif"],
    TimesNewRoman: [["Times New Roman", "Times"], "serif"],
    Papyrus: [["Papyrus", "Ink Free", "Segoe Script", "Gabriola"], "fantasy"],
    ComicSans: [["Comic Sans MS", "Comic Sans", "Brush Script MT", "Segoe Print"], "cursive"],
    Impact: [["Impact", "Arial Black", "Franklin Gothic", "Arial"], "sans-serif"],
    HelveticaNeue: [["Helvetica Neue", "Helvetica", "Arial"], "sans-serif"],
    Verdana: [["Verdana", "Helvetica Neue", "Arial"], "sans-serif"],
    CenturyGothic: [["Century Gothic", "Apple Gothic", "AppleGothic", "Futura"], "sans-serif"],
    Georgia: [["Georgia", "Times"], "serif"],
    CourierNew: [["Courier New", "Courier"], "monospace"],
    Copperplate: [["Copperplate", "Copperplate Gothic Light"], "fantasy"],
};
function CommonIsNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function CommonGetFormatDate() {
    let d = new Date();
    let yyyy = d.getFullYear();
    let mm = d.getMonth() < 9 ? "0" + (d.getMonth() + 1) : (d.getMonth() + 1);
    let dd = d.getDate() < 10 ? "0" + d.getDate() : d.getDate();
    let hh = d.getHours() < 10 ? "0" + d.getHours() : d.getHours();
    let min = d.getMinutes() < 10 ? "0" + d.getMinutes() : d.getMinutes();
    let ss = d.getSeconds() < 10 ? "0" + d.getSeconds() : d.getSeconds();
    return `${yyyy}-${mm}-${dd} ${hh}:${min}:${ss}`;
}
function CommonDetectMobile() {
    let mobile = ['iphone', 'ipad', 'android', 'blackberry', 'nokia', 'opera mini', 'windows mobile', 'windows phone', 'iemobile', 'mobile/', 'webos', 'kindle'];
    for (let i in mobile)
        if (navigator.userAgent.toLowerCase().indexOf(mobile[i].toLowerCase()) > 0)
            return true;
    if (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform))
        return true;
    if (sessionStorage.desktop)
        return false;
    else if (localStorage.mobile)
        return true;
    return false;
}
function CommonGetBrowser() {
    let ua = navigator.userAgent, tem, M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(M[1])) {
        tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
        return { Name: "IE", Version: (tem[1] || "N/A") };
    }
    if (M[1] === 'Chrome') {
        tem = ua.match(/\bOPR|Edge\/(\d+)/);
        if (tem != null)
            return { Name: "Opera", Version: tem[1] || "N/A" };
    }
    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
    if ((tem = ua.match(/version\/(\d+)/i)) != null)
        M.splice(1, 1, tem[1]);
    return { Name: M[0] || "N/A", Version: M[1] || "N/A" };
}
function CommonParseCSV(str) {
    let arr = [];
    let quote = false;
    let c;
    let col;
    str = str.replace(/\r\n/g, '\n').trim();
    for (let row = col = c = 0; c < str.length; c++) {
        let cc = str[c], nc = str[c + 1];
        arr[row] = arr[row] || [];
        arr[row][col] = arr[row][col] || '';
        if (cc == '"' && quote && nc == '"') {
            arr[row][col] += cc;
            ++c;
            continue;
        }
        if (cc == '"') {
            quote = !quote;
            continue;
        }
        if (cc == ',' && !quote) {
            ++col;
            continue;
        }
        if (cc == '\n' && !quote) {
            ++row;
            col = 0;
            continue;
        }
        arr[row][col] += cc;
    }
    return arr;
}
function CommonReadCSV(Array, Path, Screen, File) {
    let FullPath = "Screens/" + Path + "/" + Screen + "/" + File + ".csv";
    if (CommonCSVCache[FullPath]) {
        window[Array] = CommonCSVCache[FullPath];
        return;
    }
    CommonGet(FullPath, function () {
        if (this.status == 200) {
            CommonCSVCache[FullPath] = CommonParseCSV(this.responseText);
            window[Array] = CommonCSVCache[FullPath];
        }
    });
    let TranslationPath = FullPath.replace(".csv", "_" + TranslationLanguage + ".txt");
    if (TranslationAvailable(TranslationPath))
        CommonGet(TranslationPath, function () {
            if (this.status == 200)
                TranslationCache[TranslationPath] = TranslationParseTXT(this.responseText);
        });
}
function CommonGet(Path, Callback, RetriesLeft = 10) {
    let xhr = new XMLHttpRequest();
    xhr.open("GET", Path);
    xhr.onloadend = function () {
        if (this.status < 400)
            Callback.bind(this)(xhr);
        else
            CommonGetRetry(Path, Callback, RetriesLeft);
    };
    xhr.onerror = function () { CommonGetRetry(Path, Callback, RetriesLeft); };
    xhr.send(null);
}
function CommonGetRetry(Path, Callback, RetriesLeft = 10) {
    if (RetriesLeft <= 0) {
        console.error(`GET request to ${Path} failed - no more retries`);
    }
    else {
        const retrySeconds = Math.min(Math.pow(2, Math.max(0, 10 - RetriesLeft)), 60);
        console.warn(`GET request to ${Path} failed - retrying in ${retrySeconds} second${retrySeconds === 1 ? "" : "s"}...`);
        setTimeout(() => CommonGet(Path, Callback, RetriesLeft - 1), retrySeconds * 1000);
    }
}
function CommonClick(event) {
    KinkyDungeonClick();
}
function CommonTouchActive(X, Y, W, H, TL) {
    if (!CommonIsMobile)
        return false;
    if (TL == null)
        TL = CommonTouchList;
    if (TL != null)
        for (let Touch of TL) {
            let TouchX = Math.round((Touch.pageX - PIXICanvas.offsetLeft) * 2000 / PIXICanvas.clientWidth);
            let TouchY = Math.round((Touch.pageY - PIXICanvas.offsetTop) * 1000 / PIXICanvas.clientHeight);
            if ((TouchX >= X) && (TouchX <= X + W) && (TouchY >= Y) && (TouchY <= Y + H))
                return true;
        }
    return false;
}
function CommonKeyDown(event) {
    KinkyDungeonKeyDown();
}
function CommonDynamicFunction(FunctionName) {
    if (typeof window[FunctionName.substr(0, FunctionName.indexOf("("))] === "function")
        window[FunctionName.replace("()", "")]();
    else
        console.log("Trying to launch invalid function: " + FunctionName);
}
function CommonDynamicFunctionParams(FunctionName) {
    let Reverse = false;
    if (FunctionName.substring(0, 1) == "!")
        Reverse = true;
    FunctionName = FunctionName.replace("!", "");
    let ParamCount = 1;
    if (FunctionName.indexOf("()") >= 0)
        ParamCount = 0;
    else
        ParamCount = FunctionName.split(",").length;
    let openParenthesisIndex = FunctionName.indexOf("(");
    let closedParenthesisIndex = FunctionName.indexOf(")", openParenthesisIndex);
    let Params = FunctionName.substring(openParenthesisIndex + 1, closedParenthesisIndex).split(",");
    for (let P = 0; P < Params.length; P++)
        Params[P] = Params[P].trim().replace('"', '').replace('"', '');
    FunctionName = FunctionName.substring(0, openParenthesisIndex);
    if ((FunctionName.indexOf("Dialog") != 0) && (FunctionName.indexOf("Inventory") != 0) && (FunctionName.indexOf(CurrentScreen) != 0))
        FunctionName = CurrentScreen + FunctionName;
    if (typeof window[FunctionName] === "function") {
        let Result = true;
        if (ParamCount == 0)
            Result = window[FunctionName]();
        if (ParamCount == 1)
            Result = window[FunctionName](Params[0]);
        if (ParamCount == 2)
            Result = window[FunctionName](Params[0], Params[1]);
        if (ParamCount == 3)
            Result = window[FunctionName](Params[0], Params[1], Params[2]);
        if (Reverse)
            return !Result;
        else
            return Result;
    }
    else {
        console.log("Trying to launch invalid function: " + FunctionName);
        return false;
    }
}
function CommonCallFunctionByName(FunctionName, ...args) {
    let Function = window[FunctionName];
    if (typeof Function === "function") {
        let args = Array.prototype.slice.call(arguments, 1);
        return Function.apply(null, args);
    }
}
function CommonCallFunctionByNameWarn(FunctionName, ...args) {
    let Function = window[FunctionName];
    if (typeof Function === "function") {
        let args = Array.prototype.slice.call(arguments, 1);
        return Function.apply(null, args);
    }
    else {
        console.warn(`Attempted to call invalid function "${FunctionName}"`);
    }
}
function CommonSetScreen(NewModule, NewScreen) {
    CurrentModule = NewModule;
    CurrentScreen = NewScreen;
    CurrentDarkFactor = 1.0;
    CommonGetFont.clearCache();
    CommonGetFontName.clearCache();
    TextLoad();
}
function CommonTime() {
    return Date.now();
}
function CommonIsColor(Value) {
    if ((Value == null) || (Value.length < 3))
        return false;
    if (/^#[0-9A-F]{3}$/i.test(Value))
        Value = "#" + Value[1] + Value[1] + Value[2] + Value[2] + Value[3] + Value[3];
    return /^#[0-9A-F]{6}$/i.test(Value);
}
function CommonColorIsValid(Color) {
    if (Color == null || typeof Color === "string")
        return true;
    if (Array.isArray(Color))
        return Color.every(C => C == null || typeof C === "string");
    return false;
}
function CommonRandomItemFromList(ItemPrevious, ItemList) {
    let NewItem = ItemPrevious;
    while (NewItem == ItemPrevious)
        NewItem = ItemList[Math.floor(Math.random() * ItemList.length)];
    return NewItem;
}
function CommonColorsEqual(C1, C2) {
    if (Array.isArray(C1) && Array.isArray(C2)) {
        return CommonArraysEqual(C1, C2);
    }
    return C1 === C2;
}
function CommonArraysEqual(a1, a2) {
    return a1.length === a2.length && a1.every((item, i) => item === a2[i]);
}
function CommonMemoize(func) {
    let memo = {};
    let memoized = function () {
        let index = [];
        for (let i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] === "object") {
                index.push(JSON.stringify(arguments[i]));
            }
            else {
                index.push(String(arguments[i]));
            }
        }
        if (!(index in memo)) {
            memo[index] = func.apply(this, arguments);
        }
        return memo[index];
    };
    memoized.clearCache = function () {
        memo = {};
    };
    return memoized;
}
const CommonGetFont = CommonMemoize((size) => {
    return `${size}px ${CommonGetFontName()}`;
});
const CommonGetFontName = CommonMemoize(() => {
    const pref = Player && Player.GraphicsSettings && Player.GraphicsSettings.Font;
    const fontStack = CommonFontStacks[pref] || CommonFontStacks.Arial;
    const font = fontStack[0].map(fontName => `"${fontName}"`).join(", ");
    return `${font}, ${fontStack[1]}`;
});
function CommonPackItemArray(arr) {
    const res = {};
    for (const I of arr) {
        let G = res[I.Group];
        if (G === undefined) {
            G = res[I.Group] = {};
        }
        let A = G[I.Name];
        if (A === undefined) {
            A = G[I.Name] = [];
        }
        const T = I.Type || "";
        if (!A.includes(T)) {
            A.push(T);
        }
    }
    return res;
}
function CommonUnpackItemArray(arr) {
    const res = [];
    for (const G of Object.keys(arr)) {
        for (const A of Object.keys(arr[G])) {
            for (const T of arr[G][A]) {
                res.push({ Group: G, Name: A, Type: T ? T : undefined });
            }
        }
    }
    return res;
}
function CommonDeepEqual(obj1, obj2) {
    if (obj1 === obj2) {
        return true;
    }
    if (obj1 && obj2 && typeof obj1 === "object" && typeof obj2 === "object") {
        if (Object.getPrototypeOf(obj1) !== Object.getPrototypeOf(obj2)) {
            return false;
        }
        const keys1 = Object.keys(obj1);
        const keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false;
        }
        keys1.sort();
        keys2.sort();
        return keys1.every((key, i) => {
            if (key !== keys2[i]) {
                return false;
            }
            return CommonDeepEqual(obj1[key], obj2[key]);
        });
    }
    return false;
}
function CommonArrayConcatDedupe(dest, src) {
    if (Array.isArray(src) && Array.isArray(dest)) {
        for (const item of src) {
            if (!dest.includes(item))
                dest.push(item);
        }
    }
    return dest;
}
function CommonNoop() {
}
function CommonGetServer() {
    if ((location.href.indexOf("bondageprojects") < 0) && (location.href.indexOf("bondage-europe") < 0))
        return "https://bc-server-test.herokuapp.com/";
    if (location.protocol !== 'https:')
        location.replace(`https:${location.href.substring(location.protocol.length)}`);
    return "https://bondage-club-server.herokuapp.com/";
}
let MouseX = 0;
let MouseY = 0;
function MouseIn(Left, Top, Width, Height) {
    return MouseXIn(Left, Width) && MouseYIn(Top, Height);
}
function MouseXIn(Left, Width) {
    return (MouseX >= Left) && (MouseX <= Left + Width);
}
function MouseYIn(Top, Height) {
    return (MouseY >= Top) && (MouseY <= Top + Height);
}
function MouseHovering(Left, Top, Width, Height) {
    return MouseIn(Left, Top, Width, Height) && !CommonIsMobile;
}
let MainCanvas;
let TempCanvas;
let ColorCanvas;
let CharacterCanvas;
let BlindFlash = false;
let DrawingBlindFlashTimer = 0;
const DrawCacheImage = new Map();
let DrawCacheLoadedImages = 0;
let DrawCacheTotalImages = 0;
let DrawLastDarkFactor = 0;
let DrawLastCharacters = [];
let DrawHoverElements = [];
function DrawHexToRGB(color) {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    color = color.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : {
        r: 0,
        g: 0,
        b: 0
    };
}
function DrawRGBToHex(color) {
    const rgb = color[2] | (color[1] << 8) | (color[0] << 16);
    return '#' + (0x1000000 + rgb).toString(16).slice(1).toUpperCase();
}
let PIXIApp = null;
let PIXICanvas = null;
function DrawLoad() {
    PIXIApp = new PIXI.Application({
        view: PIXICanvas,
        background: '#1099bb'
    });
    PIXICanvas = document.getElementById("MainCanvas");
}
function DrawGetImage(Source) {
    let Img = DrawCacheImage.get(Source);
    if (!Img) {
        Img = new Image;
        DrawCacheImage.set(Source, Img);
        const IsAsset = (Source.indexOf("Assets") >= 0);
        if (IsAsset) {
            ++DrawCacheTotalImages;
            Img.addEventListener("load", function () {
                DrawGetImageOnLoad();
            });
        }
        Img.addEventListener("error", function () {
            DrawGetImageOnError(Img, IsAsset);
        });
        Img.src = KDModFiles[Source] || Source;
    }
    return Img;
}
function DrawGetImageOnLoad() {
    ++DrawCacheLoadedImages;
    if (DrawCacheLoadedImages == DrawCacheTotalImages)
        CharacterLoadCanvasAll();
}
function DrawGetImageOnError(Img, IsAsset) {
    if (Img.errorcount == null)
        Img.errorcount = 0;
    Img.errorcount += 1;
    if (Img.errorcount < 3) {
        Img.src = Img.src;
    }
    else {
        console.log("Error loading image " + Img.src);
        if (IsAsset)
            DrawGetImageOnLoad();
    }
}
function DrawCircle(CenterX, CenterY, Radius, LineWidth, LineColor, FillColor = null, Canvas = null) {
    if (!Canvas)
        Canvas = MainCanvas;
    Canvas.beginPath();
    Canvas.arc(CenterX, CenterY, Radius, 0, 2 * Math.PI, false);
    if (FillColor) {
        Canvas.fillStyle = FillColor;
        Canvas.fill();
    }
    Canvas.lineWidth = LineWidth;
    Canvas.strokeStyle = LineColor;
    Canvas.stroke();
}
function DrawProgressBar(x, y, w, h, value, foreground = "#66FF66", background = "red") {
    if (value < 0)
        value = 0;
    if (value > 100)
        value = 100;
    DrawRectKD(kdcanvas, kdpixisprites, `progbar,${x}_${y}_${w}_${h}_${value}`, {
        Left: x,
        Top: y,
        Width: w,
        Height: h,
        Color: "#ffffff",
        LineWidth: 1,
        zIndex: 100,
    });
    DrawRectKD(kdcanvas, kdpixisprites, `progbar2,${x}_${y}_${w}_${h}_${value}`, {
        Left: x + 2,
        Top: y + 2,
        Width: Math.floor((w - 4) * value / 100),
        Height: h - 4,
        Color: foreground,
        LineWidth: 1,
        zIndex: 100,
    });
    DrawRectKD(kdcanvas, kdpixisprites, `progbar3,${x}_${y}_${w}_${h}_${value}`, {
        Left: Math.floor(x + 2 + (w - 4) * value / 100),
        Top: y + 2,
        Width: Math.floor((w - 4) * (100 - value) / 100),
        Height: h - 4,
        Color: background,
        LineWidth: 1,
        zIndex: 100,
    });
}
function DrawProcess(time) {
    DrawLastCharacters = [];
    KinkyDungeonRun();
    DrawProcessHoverElements();
}
function DrawProcessHoverElements() {
    for (let E = 0; E < DrawHoverElements.length; E++)
        if (typeof DrawHoverElements[0] === "function")
            (DrawHoverElements.shift())();
}
let Character = [];
let CharacterNextId = 1;
const CharacterDeafLevels = new Map([
    ["DeafTotal", 4],
    ["DeafHeavy", 3],
    ["DeafNormal", 2],
    ["DeafLight", 1],
]);
const CharacterBlurLevels = new Map([
    ["BlurTotal", 50],
    ["BlurHeavy", 20],
    ["BlurNormal", 8],
    ["BlurLight", 3],
]);
let CharacterType = {
    ONLINE: "online",
    NPC: "npc",
    SIMPLE: "simple",
};
function CharacterReset(CharacterID, CharacterAssetFamily, Type = CharacterType.ONLINE) {
    let NewCharacter = {
        ID: CharacterID,
        Name: "",
        Type,
        AssetFamily: CharacterAssetFamily,
        AccountName: "",
        Owner: "",
        Lover: "",
        Money: 0,
        Inventory: [],
        Appearance: [],
        Stage: "0",
        CurrentDialog: "",
        Dialog: [],
        Reputation: [],
        Skill: [],
        Pose: [],
        Effect: [],
        Tints: [],
        FocusGroup: null,
        Canvas: null,
        CanvasBlink: null,
        MustDraw: false,
        BlinkFactor: Math.round(Math.random() * 10) + 10,
        AllowItem: true,
        BlockItems: [],
        LimitedItems: [],
        BlackList: [],
        IsKneeling: function () {
            throw new Error("Function not implemented.");
        },
        FavoriteItems: [],
        WhiteList: [],
        HeightModifier: 0,
        IsEnclose: () => false,
    };
    let CharacterIndex = Character.findIndex(c => c.ID == CharacterID);
    if (CharacterIndex == -1)
        Character.push(NewCharacter);
    else
        Character[CharacterIndex] = NewCharacter;
    if (CharacterID == 0) {
        Player = NewCharacter;
        CharacterAppearanceSetDefault(NewCharacter);
    }
    CharacterLoadCanvas(NewCharacter);
    return NewCharacter;
}
function CharacterLoadCSVDialog(C, Override = null) {
    let FullPath = ((C.ID == 0) ? "Screens/Character/Player/Dialog_Player" : ((Override == null) ? "Screens/" + CurrentModule + "/" + CurrentScreen + "/Dialog_" + C.AccountName : Override)) + ".csv";
    if (CommonCSVCache[FullPath]) {
        CharacterBuildDialog(C, CommonCSVCache[FullPath]);
        return;
    }
    CommonGet(FullPath, function () {
        if (this.status == 200) {
            CommonCSVCache[FullPath] = CommonParseCSV(this.responseText);
            CharacterBuildDialog(C, CommonCSVCache[FullPath]);
        }
    });
}
function CharacterBuildDialog(C, CSV) {
    const OnlinePlayer = C.AccountName.indexOf("Online-") >= 0;
    C.Dialog = [];
    for (let L = 0; L < CSV.length; L++)
        if ((CSV[L][0] != null) && (CSV[L][0] != "")) {
            const D = {};
            D.Stage = CSV[L][0];
            if ((CSV[L][1] != null) && (CSV[L][1].trim() != ""))
                D.NextStage = CSV[L][1];
            if ((CSV[L][2] != null) && (CSV[L][2].trim() != ""))
                D.Option = CSV[L][2].replace("DialogCharacterName", C.Name).replace("DialogPlayerName", CharacterNickname(Player));
            if ((CSV[L][3] != null) && (CSV[L][3].trim() != ""))
                D.Result = CSV[L][3].replace("DialogCharacterName", C.Name).replace("DialogPlayerName", CharacterNickname(Player));
            if ((CSV[L][4] != null) && (CSV[L][4].trim() != ""))
                D.Function = ((CSV[L][4].trim().substring(0, 6) == "Dialog") ? "" : OnlinePlayer ? "ChatRoom" : CurrentScreen) + CSV[L][4];
            if ((CSV[L][5] != null) && (CSV[L][5].trim() != ""))
                D.Prerequisite = CSV[L][5];
            if ((CSV[L][6] != null) && (CSV[L][6].trim() != ""))
                D.Group = CSV[L][6];
            if ((CSV[L][7] != null) && (CSV[L][7].trim() != ""))
                D.Trait = CSV[L][7];
            C.Dialog.push(D);
        }
    TranslationDialog(C);
    if (C === Player) {
        for (const D of C.Dialog) {
            if (typeof D.Result === "string")
                PlayerDialog.set(D.Stage, D.Result);
        }
    }
}
function CharacterRandomName(C) {
    let NewName = CharacterName[Math.floor(Math.random() * CharacterName.length)];
    C.Name = NewName;
    for (let CN = 0; CN < Character.length; CN++)
        if ((Character[CN].Name == NewName) && (Character[CN].ID != C.ID)) {
            CharacterRandomName(C);
            return;
        }
}
function CharacterLoadSimple(AccName) {
    for (let C = 0; C < Character.length; C++)
        if (Character[C].AccountName === AccName)
            return Character[C];
    const CNew = CharacterReset(CharacterNextId++, "Female3DCG", CharacterType.SIMPLE);
    CNew.AccountName = AccName;
    return CNew;
}
function CharacterDelete(NPCType) {
    for (let C = 0; C < Character.length; C++)
        if (Character[C].AccountName == NPCType) {
            Character.splice(C, 1);
            return;
        }
}
function CharacterAddPose(C, NewPose) {
    for (let E = 0; E < NewPose.length; E++)
        if (C.Pose.indexOf(NewPose[E]) < 0)
            C.Pose.push(NewPose[E]);
}
function CharacterItemsHavePoseAvailable(C, Type, Pose) {
    return true;
}
function CharacterDoItemsSetPose(C, pose, excludeClothes = false) {
    return false;
}
function CharacterLoadCanvas(C) {
}
function CharacterLoadCanvasAll() {
}
function CharacterNaked(C) {
    CharacterAppearanceNaked(C);
}
function CharacterSetActivePose(C, NewPose, ForceChange = false) { }
function CharacterSetFacialExpression(C, AssetGroup, Expression, Timer = null, Color = null) {
    if (StandalonePatched) {
        return;
    }
}
function CharacterResetFacialExpression(C) {
    if (StandalonePatched) {
        return;
    }
}
function CharacterGetCurrent() {
    return Player;
}
function CharacterNickname(C) {
    return "";
}
function CharacterLoadNPC(NPCType) {
    for (let C = 0; C < Character.length; C++)
        if (Character[C].AccountName == NPCType)
            return Character[C];
    CharacterReset(CharacterNextId++, "Female3DCG", CharacterType.NPC);
    const CNew = Character[Character.length - 1];
    CNew.AccountName = NPCType;
    CharacterRandomName(CNew);
    return CNew;
}
function CharacterReleaseTotal(C) {
    var _a;
    for (let E = C.Appearance.length - 1; E >= 0; E--) {
        if (!(((_a = C.Appearance[E].Model) === null || _a === void 0 ? void 0 : _a.Restraint) == undefined)) {
            C.Appearance.splice(E, 1);
        }
    }
}
const CharacterName = [
    "Emma",
    "Olivia",
    "Ava",
    "Isabella",
    "Sophia",
    "Mia",
    "Charlotte",
    "Amelia",
    "Evelyn",
    "Abigail",
    "Harper",
    "Emily",
    "Elizabeth",
    "Avery",
    "Sofia",
    "Ella",
    "Madison",
    "Scarlett",
    "Victoria",
    "Aria",
    "Grace",
    "Chloe",
    "Camila",
    "Penelope",
    "Riley",
    "Layla",
    "Lillian",
    "Nora",
    "Zoey",
    "Mila",
    "Aubrey",
    "Hannah",
    "Lily",
    "Addison",
    "Eleanor",
    "Natalie",
    "Luna",
    "Savannah",
    "Brooklyn",
    "Leah",
    "Zoe",
    "Stella",
    "Hazel",
    "Ellie",
    "Paisley",
    "Audrey",
    "Skylar",
    "Violet",
    "Claire",
    "Bella",
    "Aurora",
    "Lucy",
    "Anna",
    "Samantha",
    "Caroline",
    "Genesis",
    "Aaliyah",
    "Kennedy",
    "Kinsley",
    "Allison",
    "Maya",
    "Madelyn",
    "Adeline",
    "Alexa",
    "Ariana",
    "Elena",
    "Gabriella",
    "Naomi",
    "Alice",
    "Sadie",
    "Hailey",
    "Eva",
    "Emilia",
    "Autumn",
    "Quinn",
    "Nevaeh",
    "Piper",
    "Ruby",
    "Serenity",
    "Willow",
    "Everly",
    "Cora",
    "Kaylee",
    "Lydia",
    "Aubree",
    "Arianna",
    "Eliana",
    "Peyton",
    "Melanie",
    "Gianna",
    "Isabelle",
    "Valentina",
    "Nova",
    "Clara",
    "Vivian",
    "Reagan",
    "Mackenzie",
    "Madeline",
    "Brielle",
    "Delilah",
    "Isla",
    "Rylee",
    "Katherine",
    "Josephine",
    "Ivy",
    "Liliana",
    "Jade",
    "Maria",
    "Taylor",
    "Hadley",
    "Kylie",
    "Emery",
    "Adalynn",
    "Natalia",
    "Annabelle",
    "Faith",
    "Alexandra",
    "Ximena",
    "Ashley",
    "Brianna",
    "Raelynn",
    "Bailey",
    "Mary",
    "Athena",
    "Andrea",
    "Leilani",
    "Jasmine",
    "Lyla",
    "Margaret",
    "Alyssa",
    "Adalyn",
    "Arya",
    "Norah",
    "Khloe",
    "Kayla",
    "Eden",
    "Eliza",
    "Rose",
    "Ariel",
    "Melody",
    "Alexis",
    "Isabel",
    "Sydney",
    "Juliana",
    "Lauren",
    "Iris",
    "Emerson",
    "London",
    "Morgan",
    "Lilly",
    "Charlie",
    "Aliyah",
    "Valeria",
    "Arabella",
    "Sara",
    "Finley",
    "Trinity",
    "Ryleigh",
    "Jordyn",
    "Jocelyn",
    "Kimberly",
    "Esther",
    "Molly",
    "Valerie",
    "Cecilia",
    "Anastasia",
    "Daisy",
    "Reese",
    "Laila",
    "Mya",
    "Amy",
    "Teagan",
    "Amaya",
    "Elise",
    "Harmony",
    "Paige",
    "Adaline",
    "Fiona",
    "Alaina",
    "Nicole",
    "Genevieve",
    "Lucia",
    "Alina",
    "Mckenzie",
    "Callie",
    "Payton",
    "Eloise",
    "Brooke",
    "Londyn",
    "Mariah",
    "Julianna",
    "Rachel",
    "Daniela",
    "Gracie",
    "Catherine",
    "Angelina",
    "Presley",
    "Josie",
    "Harley",
    "Adelyn",
    "Vanessa",
    "Makayla",
    "Parker",
    "Juliette",
    "Amara",
    "Marley",
    "Lila",
    "Ana",
    "Rowan",
    "Alana",
    "Michelle",
    "Malia",
    "Rebecca",
    "Brooklynn",
    "Brynlee",
    "Summer",
    "Sloane",
    "Leila",
    "Sienna",
    "Adriana",
    "Sawyer",
    "Kendall",
    "Juliet",
    "Destiny",
    "Alayna",
    "Elliana",
    "Diana",
    "Hayden",
    "Ayla",
    "Dakota",
    "Angela",
    "Noelle",
    "Rosalie",
    "Joanna",
    "Jayla",
    "Alivia",
    "Lola",
    "Emersyn",
    "Georgia",
    "Selena",
    "June",
    "Daleyza",
    "Tessa",
    "Maggie",
    "Jessica",
    "Remi",
    "Delaney",
    "Camille",
    "Vivienne",
    "Hope",
    "Mckenna",
    "Gemma",
    "Olive",
    "Alexandria",
    "Blakely",
    "Izabella",
    "Catalina",
    "Raegan",
    "Journee",
    "Gabrielle",
    "Lucille",
    "Ruth",
    "Amiyah",
    "Evangeline",
    "Blake",
    "Thea",
    "Amina",
    "Giselle",
    "Lilah",
    "Melissa",
    "River",
    "Kate",
    "Adelaide",
    "Charlee",
    "Vera",
    "Leia",
    "Gabriela",
    "Zara",
    "Jane",
    "Journey",
    "Elaina",
    "Miriam",
    "Briella",
    "Stephanie",
    "Cali",
    "Ember",
    "Lilliana",
    "Aniyah",
    "Logan",
    "Kamila",
    "Brynn",
    "Ariella",
    "Makenzie",
    "Annie",
    "Mariana",
    "Kali",
    "Haven",
    "Elsie",
    "Nyla",
    "Paris",
    "Lena",
    "Freya",
    "Adelynn",
    "Lyric",
    "Camilla",
    "Sage",
    "Paislee",
    "Talia",
    "Alessandra",
    "Juniper",
    "Fatima",
    "Raelyn",
    "Amira",
    "Arielle",
    "Phoebe",
    "Kinley",
    "Ada",
    "Nina",
    "Ariah",
    "Samara",
    "Myla",
    "Brinley",
    "Cassidy",
    "Maci",
    "Aspen",
    "Allie",
    "Keira",
    "Kaia",
    "Makenna",
    "Heaven",
    "Joy",
    "Lia",
    "Madilyn",
    "Gracelyn",
    "Laura",
    "Evelynn",
    "Lexi",
    "Haley",
    "Miranda",
    "Kaitlyn",
    "Daniella",
    "Felicity",
    "Jacqueline",
    "Evie",
    "Angel",
    "Danielle",
    "Ainsley",
    "Dylan",
    "Kiara",
    "Millie",
    "Jordan",
    "Maddison",
    "Rylie",
    "Alicia",
    "Maeve",
    "Margot",
    "Kylee",
    "Phoenix",
    "Heidi",
    "Zuri",
    "Alondra",
    "Lana",
    "Madeleine",
    "Gracelynn",
    "Kenzie",
    "Miracle",
    "Shelby",
    "Elle",
    "Adrianna",
    "Bianca",
    "Addilyn",
    "Kira",
    "Veronica",
    "Gwendolyn",
    "Esmeralda",
    "Chelsea",
    "Alison",
    "Skyler",
    "Magnolia",
    "Daphne",
    "Jenna",
    "Everleigh",
    "Kyla",
    "Braelynn",
    "Harlow",
    "Annalise",
    "Mikayla",
    "Dahlia",
    "Maliyah",
    "Averie",
    "Scarlet",
    "Kayleigh",
    "Luciana",
    "Kelsey",
    "Nadia",
    "Amber",
    "Gia",
    "Kamryn",
    "Yaretzi",
    "Carmen",
    "Jimena",
    "Erin",
    "Christina",
    "Katie",
    "Ryan",
    "Viviana",
    "Alexia",
    "Anaya",
    "Serena",
    "Katelyn",
    "Ophelia",
    "Regina",
    "Helen",
    "Remington",
    "Camryn",
    "Cadence",
    "Royalty",
    "Amari",
    "Kathryn",
    "Skye",
    "Emely",
    "Jada",
    "Ariyah",
    "Aylin",
    "Saylor",
    "Kendra",
    "Cheyenne",
    "Fernanda",
    "Sabrina",
    "Francesca",
    "Eve",
    "Mckinley",
    "Frances",
    "Sarai",
    "Carolina",
    "Kennedi",
    "Nylah",
    "Tatum",
    "Alani",
    "Lennon",
    "Raven",
    "Zariah",
    "Leslie",
    "Winter",
    "Abby",
    "Mabel",
    "Sierra",
    "April",
    "Willa",
    "Carly",
    "Jolene",
    "Rosemary",
    "Aviana",
    "Madelynn",
    "Selah",
    "Renata",
    "Lorelei",
    "Briana",
    "Celeste",
    "Wren",
    "Charleigh",
    "Leighton",
    "Annabella",
    "Jayleen",
    "Braelyn",
    "Ashlyn",
    "Jazlyn",
    "Mira",
    "Oakley",
    "Malaysia",
    "Edith",
    "Avianna",
    "Maryam",
    "Emmalyn",
    "Hattie",
    "Kensley",
    "Macie",
    "Bristol",
    "Marlee",
    "Demi",
    "Cataleya",
    "Maia",
    "Sylvia",
    "Itzel",
    "Allyson",
    "Lilith",
    "Melany",
    "Kaydence",
    "Holly",
    "Nayeli",
    "Meredith",
    "Nia",
    "Liana",
    "Megan",
    "Justice",
    "Bethany",
    "Alejandra",
    "Janelle",
    "Elisa",
    "Adelina",
    "Ashlynn",
    "Elianna",
    "Aleah",
    "Myra",
    "Lainey",
    "Blair",
    "Kassidy",
    "Charley",
    "Virginia",
    "Kara",
    "Helena",
    "Sasha",
    "Julie",
    "Michaela",
    "Carter",
    "Matilda",
    "Kehlani",
    "Henley",
    "Maisie",
    "Hallie",
    "Jazmin",
    "Priscilla",
    "Marilyn",
    "Cecelia",
    "Danna",
    "Colette",
    "Baylee",
    "Elliott",
    "Ivanna",
    "Cameron",
    "Celine",
    "Alayah",
    "Hanna",
    "Imani",
    "Angelica",
    "Emelia",
    "Kalani",
    "Alanna",
    "Lorelai",
    "Macy",
    "Karina",
    "Addyson",
    "Aleena",
    "Aisha",
    "Johanna",
    "Mallory",
    "Leona",
    "Mariam",
    "Kynlee",
    "Madilynn",
    "Karen",
    "Karla",
    "Skyla",
    "Beatrice",
    "Dayana",
    "Gloria",
    "Milani",
    "Savanna",
    "Karsyn",
    "Rory",
    "Giuliana",
    "Lauryn",
    "Liberty",
    "Galilea",
    "Aubrie",
    "Charli",
    "Kyleigh",
    "Brylee",
    "Jillian",
    "Anne",
    "Haylee",
    "Dallas",
    "Azalea",
    "Jayda",
    "Tiffany",
    "Avah",
    "Shiloh",
    "Bailee",
    "Jazmine",
    "Esme",
    "Coraline",
    "Madisyn",
    "Elaine",
    "Lilian",
    "Kyra",
    "Kaliyah",
    "Kora",
    "Octavia",
    "Irene",
    "Kelly",
    "Lacey",
    "Laurel",
    "Adley",
    "Anika",
    "Janiyah",
    "Dorothy",
    "Sutton",
    "Julieta",
    "Kimber",
    "Remy",
    "Cassandra",
    "Rebekah",
    "Collins",
    "Elliot",
    "Emmy",
    "Sloan",
    "Hayley",
    "Amalia",
    "Jemma",
    "Jamie",
    "Melina",
    "Leyla",
    "Jaylah",
    "Anahi",
    "Jaliyah",
    "Kailani",
    "Harlee",
    "Wynter",
    "Saige",
    "Alessia",
    "Monica",
    "Anya",
    "Antonella",
    "Emberly",
    "Khaleesi",
    "Ivory",
    "Greta",
    "Maren",
    "Alena",
    "Emory",
    "Alaia",
    "Cynthia",
    "Addisyn",
    "Alia",
    "Lylah",
    "Angie",
    "Ariya",
    "Alma",
    "Crystal",
    "Jayde",
    "Aileen",
    "Kinslee",
    "Siena",
    "Zelda",
    "Katalina",
    "Marie",
    "Pearl",
    "Reyna",
    "Mae",
    "Zahra",
    "Kailey",
    "Jessie",
    "Tiana",
    "Amirah",
    "Madalyn",
    "Alaya",
    "Lilyana",
    "Julissa",
    "Armani",
    "Lennox",
    "Lillie",
    "Jolie",
    "Laney",
    "Roselyn",
    "Mara",
    "Joelle",
    "Rosa",
    "Kaylani",
    "Bridget",
    "Liv",
    "Oaklyn",
    "Aurelia",
    "Clarissa",
    "Elyse",
    "Marissa",
    "Monroe",
    "Kori",
    "Elsa",
    "Rosie",
    "Amelie",
    "Aitana",
    "Aliza",
    "Eileen",
    "Poppy",
    "Emmie",
    "Braylee",
    "Milana",
    "Addilynn",
    "Royal",
    "Chaya",
    "Frida",
    "Bonnie",
    "Amora",
    "Stevie",
    "Tatiana",
    "Malaya",
    "Mina",
    "Emerie",
    "Reign",
    "Zaylee",
    "Annika",
    "Kenia",
    "Linda",
    "Kenna",
    "Faye",
    "Reina",
    "Brittany",
    "Marina",
    "Astrid",
    "Kadence",
    "Mikaela",
    "Jaelyn",
    "Briar",
    "Kaylie",
    "Teresa",
    "Bria",
    "Hadassah",
    "Lilianna",
    "Guadalupe",
    "Rayna",
    "Chanel",
    "Lyra",
    "Noa",
    "Zariyah",
    "Laylah",
    "Aubrielle",
    "Aniya",
    "Livia",
    "Ellen",
    "Meadow",
    "Amiya",
    "Ellis",
    "Elora",
    "Milan",
    "Hunter",
    "Princess",
    "Leanna",
    "Nathalie",
    "Clementine",
    "Nola",
    "Tenley",
    "Simone",
    "Lina",
    "Marianna",
    "Martha",
    "Sariah",
    "Louisa",
    "Noemi",
    "Emmeline",
    "Kenley",
    "Belen",
    "Erika",
    "Myah",
    "Lara",
    "Amani",
    "Ansley",
    "Everlee",
    "Maleah",
    "Salma",
    "Jaelynn",
    "Kiera",
    "Dulce",
    "Nala",
    "Natasha",
    "Averi",
    "Mercy",
    "Penny",
    "Ariadne",
    "Deborah",
    "Elisabeth",
    "Zaria",
    "Hana",
    "Kairi",
    "Yareli",
    "Raina",
    "Ryann",
    "Lexie",
    "Thalia",
    "Karter",
    "Annabel",
    "Christine",
    "Estella",
    "Keyla",
    "Adele",
    "Aya",
    "Estelle",
    "Landry",
    "Tori",
    "Perla",
    "Lailah",
    "Miah",
    "Rylan",
    "Angelique",
    "Avalynn",
    "Romina",
    "Ari",
    "Jaycee",
    "Jaylene",
    "Kai",
    "Louise",
    "Mavis",
    "Scarlette",
    "Belle",
    "Lea",
    "Nalani",
    "Rivka",
    "Ayleen",
    "Calliope",
    "Dalary",
    "Zaniyah",
    "Kaelyn",
    "Sky",
    "Jewel",
    "Joselyn",
    "Madalynn",
    "Paola",
    "Giovanna",
    "Isabela",
    "Karlee",
    "Aubriella",
    "Azariah",
    "Tinley",
    "Dream",
    "Claudia",
    "Corinne",
    "Erica",
    "Milena",
    "Aliana",
    "Kallie",
    "Alyson",
    "Joyce",
    "Tinsley",
    "Whitney",
    "Emilee",
    "Paisleigh",
    "Carolyn",
    "Jaylee",
    "Zoie",
    "Frankie",
    "Andi",
    "Judith",
    "Paula",
    "Xiomara",
    "Aiyana",
    "Amia",
    "Analia",
    "Audrina",
    "Hadlee",
    "Rayne",
    "Amayah",
    "Cara",
    "Celia",
    "Lyanna",
    "Opal",
    "Amaris",
    "Clare",
    "Gwen",
    "Giana",
    "Veda",
    "Alisha",
    "Davina",
    "Rhea",
    "Sariyah",
    "Noor",
    "Danica",
    "Kathleen",
    "Lillianna",
    "Lindsey",
    "Maxine",
    "Paulina",
    "Hailee",
    "Harleigh",
    "Nancy",
    "Jessa",
    "Raquel",
    "Raylee",
    "Zainab",
    "Chana",
    "Lisa",
    "Heavenly",
    "Oaklynn",
    "Aminah",
    "Emmalynn",
    "Patricia",
    "India",
    "Janessa",
    "Paloma",
    "Ramona",
    "Sandra",
    "Abril",
    "Emmaline",
    "Itzayana",
    "Kassandra",
    "Vienna",
    "Marleigh",
    "Kailyn",
    "Novalee",
    "Rosalyn",
    "Hadleigh",
    "Luella",
    "Taliyah",
    "Avalyn",
    "Barbara",
    "Iliana",
    "Jana",
    "Meilani",
    "Aadhya",
    "Alannah",
    "Blaire",
    "Brenda",
    "Casey",
    "Selene",
    "Lizbeth",
    "Adrienne",
    "Annalee",
    "Malani",
    "Aliya",
    "Miley",
    "Nataly",
    "Bexley",
    "Joslyn",
    "Maliah",
    "Zion",
    "Breanna",
    "Melania",
    "Estrella",
    "Ingrid",
    "Jayden",
    "Kaya",
    "Kaylin",
    "Harmoni",
    "Arely",
    "Jazlynn",
    "Kiana",
    "Dana",
    "Mylah",
    "Oaklee",
    "Ailani",
    "Kailee",
    "Marjorie",
    "Paityn",
    "Courtney",
    "Ellianna",
    "Jurnee",
    "Karlie",
    "Evalyn",
    "Kenya",
    "Magdalena",
    "Carla",
    "Halle",
    "Aryanna",
    "Kaiya",
    "Kimora",
    "Naya",
    "Saoirse",
    "Susan",
    "Desiree",
    "Ensley",
    "Renee",
    "Esperanza",
    "Caylee",
    "Ellison",
    "Kristina",
    "Adilynn",
    "Anabelle",
    "Spencer",
    "Tegan",
    "Aranza",
    "Vada",
    "Emerald",
    "Florence",
    "Marlowe",
    "Micah",
    "Sonia",
    "Sunny",
    "Tara",
    "Riya",
    "Yara",
    "Alisa",
    "Nathalia",
    "Yamileth",
    "Saanvi",
    "Samira",
    "Sylvie",
    "Brenna",
    "Carlee",
    "Jenny",
    "Miya",
    "Monserrat",
    "Zendaya",
    "Alora"
];
let TextScreenCache = null;
const TextAllScreenCache = new Map();
function TextGet(TextTag) {
    return TextScreenCache ? TextScreenCache.get(TextTag) : "";
}
function TextLoad(TextGroup = null) {
    if ((TextGroup == null) || (TextGroup == ""))
        TextGroup = CurrentScreen;
    const FullPath = "Screens/MiniGame/KinkyDungeon/Text_KinkyDungeon.csv";
    TextScreenCache = TextAllScreenCache.get(FullPath);
    if (!TextScreenCache) {
        TextScreenCache = new TextCache(FullPath, "");
        TextAllScreenCache.set(FullPath, TextScreenCache);
    }
}
function TextPrefetch(Module, TextGroup) {
    const FullPath = "Screens/" + Module + "/" + TextGroup + "/Text_" + TextGroup + ".csv";
    if (TextAllScreenCache.has(FullPath)) {
        TextAllScreenCache.set(FullPath, new TextCache(FullPath, "MISSING VALUE FOR TAG: "));
    }
}
class TextCache {
    constructor(path, warn = "") {
        this.path = path;
        this.warn = warn;
        this.language = TranslationLanguage;
        this.cache = {};
        this.rebuildListeners = [];
        this.loaded = false;
        this.buildCache();
    }
    get(key) {
        if (!this.loaded)
            return "";
        if (TranslationLanguage !== this.language) {
            this.buildCache();
        }
        const value = this.cache[key];
        return (value != null) ? value : (this.warn + key);
    }
    onRebuild(callback, immediate = true) {
        if (typeof callback === "function") {
            this.rebuildListeners.push(callback);
            if (immediate) {
                callback();
            }
            return () => {
                this.rebuildListeners = this.rebuildListeners.filter((listener) => listener !== callback);
            };
        }
        return CommonNoop;
    }
    buildCache() {
        if (!this.path)
            return;
        this.fetchCsv()
            .then((lines) => {
            return this.translate(lines);
        })
            .then((lines) => {
            return this.cacheLines(lines);
        })
            .then(() => {
            this.rebuildListeners.forEach((listener) => listener(this));
        });
    }
    fetchCsv() {
        if (CommonCSVCache[this.path])
            return Promise.resolve(CommonCSVCache[this.path]);
        return new Promise((resolve) => {
            CommonGet(this.path, (xhr) => {
                if (xhr.status === 200) {
                    CommonCSVCache[this.path] = CommonParseCSV(xhr.responseText);
                    return resolve(CommonCSVCache[this.path]);
                }
                return Promise.resolve([]);
            });
        });
    }
    cacheLines(lines) {
        lines.forEach((line) => (this.cache[line[0]] = line[1]));
        this.loaded = true;
    }
    translate(lines) {
        this.language = TranslationLanguage;
        const lang = (TranslationLanguage || "").trim().toUpperCase();
        if (!lang || lang === "EN")
            return Promise.resolve(lines);
        const translationPath = this.path.replace(/\/([^/]+)\.csv$/, `/$1_${lang}.txt`);
        if (!TranslationAvailable(translationPath)) {
            return Promise.resolve(lines);
        }
        if (TranslationCache[translationPath]) {
            return Promise.resolve(this.buildTranslations(lines, TranslationCache[translationPath]));
        }
        else {
            return new Promise((resolve) => {
                CommonGet(translationPath, (xhr) => {
                    if (xhr.status === 200) {
                        TranslationCache[translationPath] = TranslationParseTXT(xhr.responseText);
                        return resolve(this.buildTranslations(lines, TranslationCache[translationPath]));
                    }
                    return resolve(lines);
                });
            });
        }
    }
    buildTranslations(lines, translations) {
        let [translationsStringLineCache, translationsLineStringCache] = TranslationStringCachePreBuild(translations, "");
        return lines.map(line => ([line[0], TranslationStringCache(line[1], translationsStringLineCache, translationsLineStringCache)]));
    }
}
function InventoryGet(C, AssetGroup) {
    for (let A = 0; A < C.Appearance.length; A++)
        if ((C.Appearance[A].Asset != null) && (C.Appearance[A].Asset.Group.Family == C.AssetFamily) && (C.Appearance[A].Asset.Group.Name == AssetGroup))
            return C.Appearance[A];
    return null;
}
let KDTextBoxStyle = {
    backgroundColor: "#000000a0",
    fontFamily: "'Arial', sans-serif",
    fontSize: "16px",
    color: "#ffffff",
    lineHeight: 1.6,
};
function ElementValue(ID, Value = null) {
    const e = document.getElementById(ID);
    if (!e) {
        console.error("ElementValue called on a missing element: " + ID.toString);
        return "";
    }
    if (Value == null)
        return e.value.trim();
    e.value = Value;
    return "";
}
function ElementContent(ID, Content = null) {
    const e = document.getElementById(ID);
    if (!e) {
        console.error("ElementContent called on a missing element: " + ID.toString());
        return "";
    }
    if (Content == null)
        return e.innerHTML;
    e.innerHTML = Content;
    return "";
}
function ElementCreateTextArea(ID) {
    if (document.getElementById(ID) == null) {
        var TextArea = document.createElement("TextArea");
        TextArea.setAttribute("ID", ID);
        TextArea.setAttribute("screen-generated", CurrentScreen);
        TextArea.setAttribute("name", ID);
        TextArea.addEventListener("keydown", KeyDown);
        TextArea.className = "HideOnPopup";
        Object.assign(TextArea.style, KDTextBoxStyle);
        document.body.appendChild(TextArea);
    }
}
function ElementCreateInput(ID, Type, Value, MaxLength = null) {
    if (document.getElementById(ID) == null) {
        var Input = document.createElement("input");
        Input.setAttribute("ID", ID);
        Input.setAttribute("name", ID);
        Input.setAttribute("type", Type);
        Input.setAttribute("value", Value);
        Input.setAttribute("screen-generated", CurrentScreen);
        Input.setAttribute("maxlength", MaxLength);
        Input.setAttribute("onfocus", "this.removeAttribute('readonly');");
        Input.addEventListener("keydown", KeyDown);
        Input.className = "HideOnPopup";
        document.body.appendChild(Input);
        Object.assign(Input.style, KDTextBoxStyle);
        return Input;
    }
}
function ElementCreateRangeInput(id, value, min, max, step, thumbIcon = null, vertical = false) {
    if (document.getElementById(id) == null) {
        const input = (document.createElement("input"));
        input.setAttribute("id", id);
        input.setAttribute("name", id);
        input.setAttribute("type", "range");
        input.removeAttribute("readonly");
        input.setAttribute("min", min);
        input.setAttribute("max", max);
        input.setAttribute("step", step);
        input.value = String(value);
        if (thumbIcon)
            input.setAttribute("data-thumb", thumbIcon);
        input.setAttribute("onfocus", "this.removeAttribute('readonly');");
        input.addEventListener("keydown", KeyDown);
        input.classList.add("HideOnPopup");
        if (vertical)
            input.classList.add("Vertical");
        document.body.appendChild(input);
        Object.assign(input.style, KDTextBoxStyle);
        return input;
    }
}
function ElementCreateDropdown(ID, Options, ClickEventListener = null) {
    if (document.getElementById(ID) == null) {
        var CustomSelect = document.createElement("DIV");
        CustomSelect.setAttribute("class", "custom-select");
        CustomSelect.setAttribute("ID", ID);
        var Select = document.createElement("select");
        Select.setAttribute("Name", ID + "-select");
        Select.setAttribute("ID", ID + "-select");
        var DivOptions = document.createElement("DIV");
        DivOptions.setAttribute("class", "select-items select-hide");
        for (let i = 0; i < Options.length; i++) {
            var Option = document.createElement("option");
            var InnerDiv = document.createElement("DIV");
            Option.setAttribute("value", Options[i]);
            Option.innerHTML = Options[i];
            InnerDiv.innerHTML = Options[i];
            InnerDiv.addEventListener("click", function () {
                var s = this.parentElement.parentElement.getElementsByTagName("select")[0];
                var h = this.parentElement.previousElementSibling;
                for (let j = 0; j < s.length; j++) {
                    if (s.options[j].innerHTML == this.innerHTML) {
                        s.selectedIndex = j;
                        h.innerHTML = this.innerHTML;
                        var y = this.parentElement.getElementsByClassName("same-as-selected");
                        for (let k = 0; k < y.length; k++) {
                            y[k].removeAttribute("class");
                        }
                        this.setAttribute("class", "same-as-selected");
                        break;
                    }
                }
                h.click();
                s.dispatchEvent(new Event("change"));
            });
            Select.appendChild(Option);
            DivOptions.appendChild(InnerDiv);
        }
        var SelectedItem = document.createElement("DIV");
        SelectedItem.setAttribute("class", "select-selected");
        SelectedItem.innerHTML = Select.options[0].innerHTML;
        SelectedItem.addEventListener("click", function (e) {
            e.stopPropagation();
            ElementCloseAllSelect(this);
            this.nextElementSibling.classList.toggle("select-hide");
        });
        if (ClickEventListener != null)
            Select.addEventListener("change", ClickEventListener);
        CustomSelect.appendChild(Select);
        CustomSelect.appendChild(SelectedItem);
        CustomSelect.appendChild(DivOptions);
        document.body.appendChild(CustomSelect);
        document.addEventListener("click", ElementCloseAllSelect);
    }
}
function ElementCloseAllSelect(elmnt) {
    var arrNo = [];
    var y = document.getElementsByClassName("select-selected");
    for (let i = 0; i < y.length; i++) {
        if (elmnt == y[i])
            arrNo.push(i);
    }
    var x = document.getElementsByClassName("select-items");
    for (let i = 0; i < x.length; i++) {
        if (arrNo.indexOf(i))
            x[i].classList.add("select-hide");
    }
}
function ElementCreateDiv(ID) {
    if (document.getElementById(ID) == null) {
        var Div = document.createElement("div");
        Div.setAttribute("ID", ID);
        Div.setAttribute("name", ID);
        Div.setAttribute("screen-generated", CurrentScreen);
        Div.addEventListener("keydown", KeyDown);
        Div.className = "HideOnPopup";
        document.body.appendChild(Div);
    }
}
function ElementRemove(ID) {
    if (document.getElementById(ID) != null)
        document.getElementById(ID).parentNode.removeChild(document.getElementById(ID));
}
function ElementPosition(ElementID, X, Y, W, H = null) {
    var E = document.getElementById(ElementID);
    if (!E) {
        console.warn("A call to ElementPosition was made on non-existent element with ID '" + ElementID + "'");
        return;
    }
    if (E.tagName.toLowerCase() === "input" && E.getAttribute("type") === "range" && E.classList.contains("Vertical")) {
        var tmp = W;
        W = H;
        H = tmp;
    }
    const HRatio = PIXICanvas.clientHeight / 1000;
    const WRatio = PIXICanvas.clientWidth / 2000;
    const Font = PIXICanvas.clientWidth <= PIXICanvas.clientHeight * 2 ? PIXICanvas.clientWidth / 50 : PIXICanvas.clientHeight / 25;
    const Height = H ? H * HRatio : Font * 1.15;
    const Width = W * WRatio - 18;
    const Top = PIXICanvas.offsetTop + Y * HRatio - Height / 2;
    const Left = PIXICanvas.offsetLeft + (X - W / 2) * WRatio;
    Object.assign(E.style, {
        fontSize: Font + "px",
        fontFamily: CommonGetFontName(),
        position: "fixed",
        left: Left + "px",
        top: Top + "px",
        width: Width + "px",
        height: Height + "px",
        display: "inline"
    });
}
function ElementPositionFix(ElementID, Font, X, Y, W, H) {
    var E = document.getElementById(ElementID);
    if (!E) {
        console.warn("A call to ElementPositionFix was made on non-existent element with ID '" + ElementID + "'");
        return;
    }
    const HRatio = PIXICanvas.clientHeight / 1000;
    const WRatio = PIXICanvas.clientWidth / 2000;
    Font *= Math.max(HRatio, WRatio);
    const Top = PIXICanvas.offsetTop + Y * HRatio;
    const Height = H * HRatio;
    const Left = PIXICanvas.offsetLeft + X * WRatio;
    const Width = W * WRatio;
    Object.assign(E.style, {
        fontSize: Font + "px",
        fontFamily: CommonGetFontName(),
        position: "fixed",
        left: Left + "px",
        top: Top + "px",
        width: Width + "px",
        height: Height + "px",
        display: "inline"
    });
}
function ElementSetDataAttribute(ID, Name, Value) {
    var element = document.getElementById(ID);
    if (element != null) {
        element.setAttribute(("data-" + Name).toLowerCase(), Value.toString().toLowerCase());
    }
}
function ElementSetAttribute(ID, Name, Value) {
    var element = document.getElementById(ID);
    if (element != null) {
        element.setAttribute(Name, Value);
    }
}
function ElementScrollToEnd(ID) {
    var element = document.getElementById(ID);
    if (element != null)
        element.scrollTop = element.scrollHeight;
}
function ElementGetScrollPercentage(ID) {
    var element = document.getElementById(ID);
    if (element != null)
        return (element.scrollTop + element.clientHeight) / element.scrollHeight;
    return null;
}
function ElementIsScrolledToEnd(ID) {
    var element = document.getElementById(ID);
    return element != null && element.scrollHeight - element.scrollTop - element.clientHeight < 1;
}
function ElementFocus(ID) {
    if ((document.getElementById(ID) != null) && !CommonIsMobile)
        document.getElementById(ID).focus();
}
function ElementToggleGeneratedElements(Screen, ShouldDisplay) {
    const generatedElements = Array.from(document.querySelectorAll(`[screen-generated="${Screen}"]`));
    generatedElements.forEach((element) => element.style.display = ShouldDisplay ? '' : 'none');
}
let TranslationLanguage = "EN";
let TranslationCache = {};
let TranslationDictionary = [
    {
        LanguageCode: "EN",
        LanguageName: "English",
        EnglishName: "English",
        Files: []
    },
    {
        LanguageCode: "DE",
        LanguageName: "Deutsch",
        EnglishName: "German",
        Files: [
            "Assets/Female3DCG/Female3DCG_DE.txt",
        ]
    },
    {
        LanguageCode: "FR",
        LanguageName: "Français",
        EnglishName: "French",
        Files: [
            "Assets/Female3DCG/ColorGroups_FR.txt",
            "Assets/Female3DCG/Female3DCG_FR.txt",
            "Assets/Female3DCG/LayerNames_FR.txt",
        ]
    },
    {
        LanguageCode: "RU",
        LanguageName: "Русский",
        EnglishName: "Russian",
        Files: [
            "Assets/Female3DCG/Female3DCG_RU.txt",
            "Assets/Female3DCG/ColorGroups_RU.txt",
            "Assets/Female3DCG/LayerNames_RU.txt",
        ]
    },
    {
        LanguageCode: "CN",
        LanguageName: "中文",
        EnglishName: "Chinese",
        Files: [
            "Assets/Female3DCG/ColorGroups_CN.txt",
            "Assets/Female3DCG/Female3DCG_CN.txt",
            "Assets/Female3DCG/LayerNames_CN.txt",
            "Screens/Character/Appearance/Text_Appearance_CN.txt",
            "Screens/Character/BackgroundSelection/Text_BackgroundSelection_CN.txt",
            "Screens/MiniGame/KinkyDungeon/Text_KinkyDungeon_CN.txt",
        ]
    },
    {
        LanguageCode: "KR",
        LanguageName: "한국어",
        EnglishName: "Korean",
        Files: [
            "Screens/MiniGame/KinkyDungeon/Text_KinkyDungeon_KR.txt",
        ]
    },
    {
        LanguageCode: "JP",
        LanguageName: "Japanese",
        EnglishName: "Japanese",
        Files: [
            "Screens/MiniGame/KinkyDungeon/Text_KinkyDungeon_JP.txt",
        ]
    },
    {
        LanguageCode: "ES",
        LanguageName: "Espanol",
        EnglishName: "Spanish",
        Files: [
            "Screens/MiniGame/KinkyDungeon/Text_KinkyDungeon_ES.txt",
        ]
    },
];
function TranslationAvailable(FullPath) {
    let FileName = FullPath.trim().toUpperCase();
    for (let L = 0; L < TranslationDictionary.length; L++)
        if (TranslationDictionary[L].LanguageCode == TranslationLanguage)
            for (let F = 0; F < TranslationDictionary[L].Files.length; F++)
                if (TranslationDictionary[L].Files[F].trim().toUpperCase() == FileName)
                    return true;
    return false;
}
function TranslationParseTXT(str) {
    const arr = [];
    let c;
    str = str.replace(/\r\n/g, '\n').trim();
    for (let row = c = 0; c < str.length; c++) {
        let cc = str[c];
        arr[row] = arr[row] || "";
        if (cc == '\n') {
            ++row;
            continue;
        }
        arr[row] += cc;
    }
    for (let row = arr.length - 1; row >= 0; row--)
        if (arr[row].indexOf("###") == 0) {
            arr.splice(row, 1);
        }
    for (let row = 0; row < arr.length; row++)
        arr[row] = arr[row].trim();
    return arr;
}
function TranslationString(S, T, CharacterName) {
    if ((S != null) && (S.trim() !== "")) {
        S = S.trim();
        for (let P = 0; P < T.length - 1; P++)
            if (S === T[P].replace("DialogCharacterName", CharacterName).replace("DialogPlayerName", CharacterNickname(Player)))
                return T[P + 1].replace("DialogCharacterName", CharacterName).replace("DialogPlayerName", CharacterNickname(Player));
    }
    return S;
}
function TranslationStringCachePreBuild(translations, CharacterName) {
    let translationsStringLineCache = new Map();
    let translationsLineStringCache = new Map();
    translations.forEach((T, i) => {
        let S = T.replace("DialogCharacterName", CharacterName).replace("DialogPlayerName", CharacterNickname(Player));
        translationsStringLineCache.set(S, i);
        translationsLineStringCache.set(i, S);
    });
    return [translationsStringLineCache, translationsLineStringCache];
}
function TranslationStringCache(S, translationsStringLineCache, translationsLineStringCache) {
    if (S != null) {
        let S1 = S.trim();
        if (S1 !== "") {
            try {
                let l = translationsStringLineCache.get(S1);
                if (l) {
                    let s = translationsLineStringCache.get(l + 1);
                    if (s) {
                        return s;
                    }
                    console.warn('TranslationStringCache lost translationsLineStringCache:', S, l);
                }
                return S;
            }
            catch (e) {
                console.warn('TranslationStringCache catch:', S, translationsStringLineCache.get(S1), e);
            }
        }
    }
    return S;
}
function TranslationDialogArray(C, T) {
    for (let D = 0; D < C.Dialog.length; D++) {
        C.Dialog[D].Option = TranslationString(C.Dialog[D].Option, T, C.Name);
        C.Dialog[D].Result = TranslationString(C.Dialog[D].Result, T, C.Name);
    }
}
function TranslationTextArray(S, T) {
    for (let P = 0; P < S.length; P++)
        S[P].Value = TranslationString(S[P].Value, T, "");
}
function TranslationDialog(C) {
    if ((TranslationLanguage != null) && (TranslationLanguage.trim() != "") && (TranslationLanguage.trim().toUpperCase() != "EN")) {
        let OnlinePlayer = C.AccountName.indexOf("Online-") >= 0;
        let FullPath = (OnlinePlayer ? "Screens/Online/ChatRoom/Dialog_Online" : (C.ID == 0) ? "Screens/Character/Player/Dialog_Player" : "Screens/" + CurrentModule + "/" + CurrentScreen + "/Dialog_" + C.AccountName) + "_" + TranslationLanguage + ".txt";
        if (TranslationCache[FullPath]) {
            TranslationDialogArray(C, TranslationCache[FullPath]);
            return;
        }
        if (TranslationAvailable(FullPath))
            CommonGet(FullPath, function () {
                if (this.status == 200) {
                    TranslationCache[FullPath] = TranslationParseTXT(this.responseText);
                    TranslationDialogArray(C, TranslationCache[FullPath]);
                }
            });
    }
}
function TranslationText(Text) {
    if ((TranslationLanguage != null) && (TranslationLanguage.trim() != "") && (TranslationLanguage.trim().toUpperCase() != "EN")) {
        let FullPath = "Screens/" + CurrentModule + "/" + CurrentScreen + "/Text_" + CurrentScreen + "_" + TranslationLanguage + ".txt";
        if (TranslationCache[FullPath]) {
            TranslationTextArray(Text, TranslationCache[FullPath]);
            return;
        }
        if (TranslationAvailable(FullPath))
            CommonGet(FullPath, function () {
                if (this.status == 200) {
                    TranslationCache[FullPath] = TranslationParseTXT(this.responseText);
                    TranslationTextArray(Text, TranslationCache[FullPath]);
                }
            });
    }
}
function TranslationNextLanguage() {
    for (let L = 0; L < TranslationDictionary.length; L++)
        if (TranslationDictionary[L].LanguageCode == TranslationLanguage) {
            if (L != TranslationDictionary.length - 1)
                TranslationLanguage = TranslationDictionary[L + 1].LanguageCode;
            else
                TranslationLanguage = TranslationDictionary[0].LanguageCode;
            localStorage.setItem("BondageClubLanguage", TranslationLanguage);
            return;
        }
}
function TranslationLoad() {
    let L = localStorage.getItem("BondageClubLanguage");
    if (L != null)
        TranslationLanguage = L;
}
let CharacterAppearancePreviousEmoticon = null;
function CharacterAppearanceSetDefault(C) {
    C.Appearance = [];
    C.Pose = [];
}
function CharacterAppearanceNaked(C) {
    var _a;
    for (let A = C.Appearance.length - 1; A >= 0; A--)
        if (!((_a = C.Appearance[A].Model) === null || _a === void 0 ? void 0 : _a.Protected))
            C.Appearance.splice(A, 1);
}
function CharacterAppearanceBuildCanvas(C) { }
function CharacterAppearanceGetCurrentValue(C, Group, Type) {
    for (let A = 0; A < C.Appearance.length; A++)
        if ((C.Appearance[A].Asset.Group.Family == C.AssetFamily) && (C.Appearance[A].Asset.Group.Name == Group)) {
            if (Type == "Name")
                return C.Appearance[A].Asset.Name;
            if (Type == "Description")
                return C.Appearance[A].Asset.Description;
            if (Type == "Color")
                return CommonColorsEqual(C.Appearance[A].Color, C.Appearance[A].Asset.DefaultColor) ? "Default" : C.Appearance[A].Color;
            if (Type == "ID")
                return A;
            if (Type == "Effect")
                return C.Appearance[A].Asset.Effect;
            if (Type == "Asset")
                return C.Appearance[A].Asset;
            if (Type == "Full")
                return C.Appearance[A];
            if (Type == "Zoom")
                return ((C.Appearance[A].Asset.ZoomModifier == null) || (C.Appearance[A].Asset.ZoomModifier > 1) || (C.Appearance[A].Asset.ZoomModifier < 0.9)) ? 1 : C.Appearance[A].Asset.ZoomModifier;
        }
    return "None";
}
function CharacterAppearanceXOffset(C, HeightRatio) {
    return 500 * (1 - HeightRatio) / 2;
}
function AppearanceGroupAllowed(C, GroupName) {
    return true;
}
function CharacterAppearanceSetItem(C, Group, ItemAsset, NewColor, DifficultyFactor = 0, ItemMemberNumber = -1, Refresh = true) { }
function CharacterAppearanceStringify(C) {
    return AppearanceItemStringify(C.Appearance);
}
function AppearanceItemStringify(Item) {
    var _a;
    for (let r of Item) {
        if ((_a = r.Model) === null || _a === void 0 ? void 0 : _a.Filters)
            r.Filters = r.Model.Filters;
    }
    return JSON.stringify(Item, (key, value) => {
        if (key === "Asset") {
            return value.Group.Family + "/" + value.Group.Name + "/" + value.Name;
        }
        if (key === "Model") {
            return value.Name;
        }
        return value;
    });
}
function CharacterAppearanceRestore(C, backup) {
    C.Appearance = AppearanceItemParse(backup);
}
function AppearanceItemParse(stringified) {
    let ret = JSON.parse(stringified, (key, value) => {
        if (key === "Model") {
            return JSON.parse(JSON.stringify(ModelDefs[value]));
        }
        return value;
    });
    for (let r of ret) {
        if (r.Filters && r.Model)
            r.Model.Filters = r.Filters;
    }
    return ret;
}
function addTextKey(Name, Text) {
    let ct = 0;
    for (let screen of TextAllScreenCache.entries()) {
        if (screen[0].includes("KinkyDungeon")) {
            screen[1].cache[Name] = Text;
        }
        else
            console.log("ERROR LOADING TEXT!!!");
    }
    if (ct == 0)
        KDLoadingTextKeys[Name] = Text;
}
const cloneDeep = (obj) => JSON.parse(JSON.stringify(obj));
const defaultRestraint = {
    inventory: true,
    power: 0,
    weight: 0,
    minLevel: 0,
    allFloors: true,
    escapeChance: {
        "Struggle": 10,
        "Cut": 10,
        "Remove": 10
    },
    events: [],
    enemyTags: [],
    playerTags: [],
    shrine: [],
};
function KinkyDungeonCreateRestraint(props, displayName, flavorText, functionText) {
    if (!props.name || !props.Group || !props.Asset) {
        throw new Error('name, Group and Asset props must be provided.');
    }
    const restraint = (Object.assign(Object.assign({}, cloneDeep(defaultRestraint)), props));
    KinkyDungeonRestraints.push(restraint);
    if (displayName) {
        KinkyDungeonAddRestraintText(props.name, displayName, flavorText, functionText);
    }
    return restraint;
}
let KDCursedVariantsCreated = {};
function KinkyDungeonAddCursedVariants(Restraint, Variants) {
    for (let v of Variants) {
        if (KDCursedVars[v]) {
            KinkyDungeonCloneRestraint(Restraint.name, Restraint.name + v, KDCursedVars[v].variant(Restraint, Restraint.name + v));
            if (!KDCursedVariantsCreated[Restraint.name])
                KDCursedVariantsCreated[Restraint.name] = {};
            KDCursedVariantsCreated[Restraint.name][v] = KDCursedVars[v].level;
        }
    }
}
function KinkyDungeonGetCurses(Restraint, includeOrig, minLevel, maxLevel) {
    if (KDCursedVariantsCreated[Restraint]) {
        let keys = Object.keys(KDCursedVariantsCreated[Restraint]).filter((key) => {
            return (!minLevel || KDCursedVariantsCreated[Restraint][key] >= minLevel)
                && (!maxLevel || KDCursedVariantsCreated[Restraint][key] < maxLevel);
        }).map((element) => { return Restraint + element; });
        if (includeOrig)
            keys.push(Restraint);
        return keys;
    }
    return [];
}
function KinkyDungeonCloneRestraint(clonedName, newName, props) {
    const existingRestraint = KinkyDungeonRestraints.find(restraint => restraint.name === clonedName);
    if (!existingRestraint) {
        throw new Error(`No restraint named ${clonedName}.`);
    }
    const newRestraint = (Object.assign(Object.assign({}, cloneDeep(existingRestraint)), { name: newName }));
    Object.assign(newRestraint, props);
    KinkyDungeonRestraints.push(newRestraint);
    return newRestraint;
}
function KinkyDungeonAddRestraintText(name, displayName, flavorText, functionText) {
    const baseKey = `Restraint${name}`;
    addTextKey(baseKey, displayName);
    addTextKey(`${baseKey}Desc`, flavorText);
    addTextKey(`${baseKey}Desc2`, functionText);
}
function KinkyDungeonDupeRestraintText(restraint, newRestraint) {
    const oldKey = `Restraint${restraint}`;
    const baseKey = `Restraint${newRestraint}`;
    addTextKey(baseKey, TextGetKD(oldKey));
    addTextKey(`${baseKey}Desc`, TextGetKD(`${oldKey}Desc`));
    addTextKey(`${baseKey}Desc2`, TextGetKD(`${oldKey}Desc2`));
}
let KDAutoStruggleData = {
    lastTick: 0,
    lastActionQueue: [],
    decidedAction: "",
    possibleActions: [],
    totalDespair: {},
    currentFocusGroup: "",
    currentFocusIndex: 0,
    currentFocusDespair: 0,
    currentFocusDespairTarget: 0,
    overallDespair: 0,
    lastDelay: 0,
    wigglePoint: null,
    wiggleDist: 2.99,
};
let KDAutoStruggleActions = {
    "Struggle": {
        itemweight: (player, item) => {
            if (KDGetCurse(item) || KDRestraint(item).good)
                return 0;
            return 10 / Math.max(1, KDRestraint(item).power);
        },
        action: (player) => {
            let action = "Struggle";
            let result = KDSendInput("struggle", { group: KDAutoStruggleData.currentFocusGroup, index: KDAutoStruggleData.currentFocusIndex, type: action });
            let favor = KDAS_SwitchFavor(result);
            let delay = KDAS_SwitchDelay(result);
            return {
                action: action,
                favorability: favor,
                delay: delay,
                id: KDAutoWaitIndexID(player, KDAutoStruggleData.currentFocusGroup, KDAutoStruggleData.currentFocusIndex, action),
                result: result,
            };
        },
    },
    "Remove": {
        itemweight: (player, item) => {
            if (item.lock)
                return 0;
            if (KDGetCurse(item) || KDRestraint(item).good)
                return 0;
            if (!KDRestraint(item).alwaysStruggleable && KDGroupBlocked(KDRestraint(item).Group))
                return 0;
            return 10 / Math.max(1, KDRestraint(item).power);
        },
        action: (player) => {
            let action = "Remove";
            let result = KDSendInput("struggle", { group: KDAutoStruggleData.currentFocusGroup, index: KDAutoStruggleData.currentFocusIndex, type: action });
            let favor = KDAS_SwitchFavor(result);
            let delay = KDAS_SwitchDelay(result);
            return {
                action: action,
                favorability: favor,
                delay: delay,
                id: KDAutoWaitIndexID(player, KDAutoStruggleData.currentFocusGroup, KDAutoStruggleData.currentFocusIndex, action),
                result: result,
            };
        },
    },
    "Cut": {
        itemweight: (player, item) => {
            if (!KDAS_InWigglePoint(player) && !KinkyDungeonWallCrackAndKnife(false))
                return 0;
            if (KDGetCurse(item) || KDRestraint(item).good)
                return 0;
            if (!KDRestraint(item).alwaysStruggleable && KDGroupBlocked(KDRestraint(item).Group))
                return 0;
            if (!((KinkyDungeonAllWeapon().some((inv) => { return KDWeapon(inv).light && KDWeapon(inv).cutBonus != undefined; }) || KinkyDungeonGetAffinity(false, "Sharp"))
                && !(KDRestraint(item) && KDRestraint(item).escapeChance && KDRestraint(item).escapeChance.Cut == undefined)))
                return 0;
            return 10 / Math.max(1, KDRestraint(item).power);
        },
        action: (player) => {
            let action = "Cut";
            let result = KDSendInput("struggle", { group: KDAutoStruggleData.currentFocusGroup, index: KDAutoStruggleData.currentFocusIndex, type: action });
            let favor = KDAS_SwitchFavor(result);
            let delay = KDAS_SwitchDelay(result);
            if (result == "Drop")
                KDAS_UpdateWigglePoint(player, true);
            return {
                action: action,
                favorability: favor,
                delay: delay,
                id: KDAutoWaitIndexID(player, KDAutoStruggleData.currentFocusGroup, KDAutoStruggleData.currentFocusIndex, action),
                result: result,
            };
        },
    },
    "Wait": {
        playerweight: (player) => {
            return 20 * Math.max(0, -KinkyDungeonStatStamina - KinkyDungeonStatStaminaCostStruggle * 2);
        },
        action: (player) => {
            KDSendInput("move", { dir: { x: 0, y: 0, delta: 0 }, delta: 1, AllowInteract: true, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: KinkyDungeonSuppressSprint }, false, true);
            return { action: "wait", id: "", result: "fail", delay: 0, favorability: KinkyDungeonStatStamina > (Math.max(KinkyDungeonStatStaminaCostStruggle * 2, KinkyDungeonStatStaminaMax * 0.7)) ? -10
                    : (KinkyDungeonStatStamina > KinkyDungeonStatStaminaCostStruggle * 2 ? -4 : -1) };
        },
    },
    "Wiggle": {
        playerweight: (player) => {
            return KDAutoStruggleData.lastActionQueue.some((action) => { return action.result == "Drop" || action.result == "NeedEdge"; }) ?
                ((KDAffinityList.some((affinity) => { return KinkyDungeonGetAffinity(false, affinity); })) ? 5 : 50)
                : ((KDAffinityList.some((affinity) => { return KinkyDungeonGetAffinity(false, affinity); })) ? 0.5 : (2 + Math.min(8, KDAutoStruggleData.overallDespair / 10)));
        },
        action: (player) => {
            let wigglePoints = KDAS_GetMovableWigglePoint(player, Math.random() < 0.5);
            let point = wigglePoints[Math.floor(Math.random() * wigglePoints.length)] || { x: 0, y: 0 };
            KDSendInput("move", { dir: { x: point.x - player.x, y: point.y - player.y, delta: 0 }, delta: 1, AllowInteract: true, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: KinkyDungeonSuppressSprint }, false, true);
            KinkyDungeonSendActionMessage(6, TextGet("KDWiggle"), "#aaaaaa", 1);
            if (KDAffinityList.some((affinity) => { return KinkyDungeonGetAffinity(false, affinity); })) {
                KDAutoStruggleData.decidedAction = "";
            }
            return { action: "wiggle", id: "", result: "fail", delay: 1, favorability: KinkyDungeonStatStamina > (Math.max(KinkyDungeonStatStaminaCostStruggle * 2, KinkyDungeonStatStaminaMax * 0.7)) ? -3
                    : (KinkyDungeonStatStamina > KinkyDungeonStatStaminaCostStruggle * 2 ? -2 : -1) };
        },
    },
};
function KDInitAutoStruggle() {
    KDAutoStruggleData.possibleActions = [];
    KDAutoStruggleData.lastActionQueue = [];
    KDAutoStruggleData.decidedAction = "";
    KDAutoStruggleData.currentFocusGroup = "";
    KDAutoStruggleData.currentFocusIndex = 0;
    KDAutoStruggleData.currentFocusDespair = 0;
    KDAutoStruggleData.currentFocusDespairTarget = 0;
    KDAutoStruggleData.overallDespair = 0;
    KDAutoStruggleData.totalDespair = {};
    KDAutoStruggleData.wigglePoint = null;
    KDAutoStruggleData.lastTick = KinkyDungeonCurrentTick;
}
function KDAS_UpdateWigglePoint(player, force) {
    var _a, _b;
    let wpx = (_a = KDAutoStruggleData.wigglePoint) === null || _a === void 0 ? void 0 : _a.x;
    let wpy = (_b = KDAutoStruggleData.wigglePoint) === null || _b === void 0 ? void 0 : _b.y;
    if (force || (!KDAutoStruggleData.wigglePoint || KDistChebyshev(player.x - wpx, player.y - wpy) > 1.5)) {
        KDAutoStruggleData.wigglePoint = { x: player.x, y: player.y };
    }
}
function KDAS_InWigglePoint(player) {
    KDAS_UpdateWigglePoint(player);
    return (player.x == KDAutoStruggleData.wigglePoint.x && player.y == KDAutoStruggleData.wigglePoint.y);
}
function KDAS_GetMovableWigglePoint(player, goCloser) {
    KDAS_UpdateWigglePoint(player);
    let list = [];
    let dist = KDAutoStruggleData.wiggleDist;
    let wpx = KDAutoStruggleData.wigglePoint.x;
    let wpy = KDAutoStruggleData.wigglePoint.y;
    let currentPdist = KDistEuclidean(player.x - wpx, player.y - wpy);
    for (let XX = Math.floor(player.x - dist); XX <= Math.ceil(player.x + dist); XX++) {
        for (let YY = Math.floor(player.y - dist); YY <= Math.ceil(player.y + dist); YY++) {
            let pdist = KDistEuclidean(XX - wpx, YY - wpy);
            if (KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(XX, YY))
                && pdist <= dist
                && (!goCloser || pdist < currentPdist)
                && KDistChebyshev(player.x - XX, player.y - YY) < 1.5) {
                list.push({ x: XX, y: YY });
            }
        }
    }
    return list;
}
function KDAS_SwitchFavor(result) {
    switch (result) {
        case "Success": return 5;
        case "Fail": return -1;
        case "Impossible": return -10;
        case "NeedEdge": return -5;
        case "Drop": return -10;
        case "Limit": return -6;
        case "Strict": return -6;
    }
    return -1;
}
function KDAS_SwitchDelay(result) {
    switch (result) {
        case "Success": return 12;
        case "Fail": return 1;
        case "Impossible": return 4;
        case "NeedEdge": return 3;
        case "Drop": return 9;
        case "Limit": return 6;
        case "Strict": return 3;
    }
    return -1;
}
function KDHandleAutoStruggle(player) {
    if (KinkyDungeonCurrentTick > KDAutoStruggleData.lastTick + 10) {
        KDInitAutoStruggle();
    }
    KDAutoStruggleData.lastTick = KinkyDungeonCurrentTick;
    KDAutoStruggleEvaluate(player);
    KDAutoStruggleMakeDecision(player);
    let result = KDAutoStruggleRunDecision(player);
    console.log(result);
}
function KDAutoStruggleEvaluate(player) {
    KDAutoStruggleData.possibleActions = [];
    for (let inv of KinkyDungeonAllRestraint()) {
        let items = KDDynamicLinkListSurface(inv);
        let link = items[0];
        let index = 0;
        let group = KDRestraint(inv).Group;
        while (link) {
            for (let action of Object.entries(KDAutoStruggleActions)) {
                if (action[1].itemweight) {
                    KDAutoStruggleData.possibleActions.push({
                        action: {
                            action: action[0],
                            group: group,
                            index: index,
                            id: KDAutoWaitIndexID(player, group, index, action[0]),
                        },
                        weight: action[1].itemweight(player, link),
                    });
                }
            }
            index += 1;
            link = items[index];
        }
    }
    for (let action of Object.entries(KDAutoStruggleActions)) {
        if (action[1].playerweight) {
            KDAutoStruggleData.possibleActions.push({
                action: {
                    action: action[0],
                    group: "",
                    index: 0,
                    id: KDAutoWaitIndexID(player, "", 0, action[0]),
                },
                weight: action[1].playerweight(player),
            });
        }
    }
}
function KDAutoStruggleMakeDecision(player) {
    if (KDAutoStruggleData.decidedAction && KDAutoStruggleData.currentFocusDespair < KDAutoStruggleData.currentFocusDespairTarget
        && (!KDAutoStruggleData.currentFocusGroup || (KinkyDungeonGetRestraintItem(KDAutoStruggleData.currentFocusGroup, KDAutoStruggleData.currentFocusIndex)))) {
    }
    else {
        let totalWeight = 0;
        let currentWeights = [];
        for (let action of KDAutoStruggleData.possibleActions) {
            totalWeight += action.weight * (1 / (1 + 0.01 * (KDAutoStruggleData.totalDespair[action.action.id] || 0)));
            currentWeights.push({ action: action.action, weight: totalWeight });
        }
        let selection = Math.random() * totalWeight;
        for (let action of currentWeights) {
            if (action.weight > selection) {
                KDAutoStruggleData.decidedAction = action.action.action;
                KDAutoStruggleData.currentFocusGroup = action.action.group;
                KDAutoStruggleData.currentFocusindex = action.action.index;
                KDAutoStruggleData.currentFocusDespair = 0;
                KDAutoStruggleData.currentFocusDespairTarget = 10;
                break;
            }
        }
    }
}
function KDAutoStruggleRunDecision(player) {
    let result = null;
    if (KDAutoStruggleActions[KDAutoStruggleData.decidedAction]) {
        result = KDAutoStruggleActions[KDAutoStruggleData.decidedAction].action(player);
        KDAutoStruggleData.currentFocusDespair = Math.max(0, (KDAutoStruggleData.currentFocusDespair || 0) - result.favorability);
        KDAutoStruggleData.totalDespair[result.id] = Math.max(0, (KDAutoStruggleData.totalDespair[result.id] || 0) - result.favorability);
        KDAutoStruggleData.overallDespair += Math.max(0, -result.favorability);
        KDAutoStruggleData.lastDelay = Math.max(0, result.delay);
    }
    else {
        KDSendInput("move", { dir: { x: 0, y: 0, delta: 0 }, delta: 1, AllowInteract: true, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: KinkyDungeonSuppressSprint }, false, true);
        result = { action: "wait", id: "", result: "fail", favorability: -1, delay: 0 };
    }
    if (result)
        KDAutoStruggleData.lastActionQueue.unshift(result);
    KDAutoStruggleData.lastActionQueue = KDAutoStruggleData.lastActionQueue.slice(0, 15);
    return result;
}
function KDAutoWaitIndexID(player, group, index, action) {
    var _a;
    return `${group}_${(_a = KinkyDungeonGetRestraintItem(group)) === null || _a === void 0 ? void 0 : _a.name}_${index}_${action}`;
}
let KDClassReqs = {
    "Trainee": () => { return KinkyDungeonSexyMode; }
};
let KDClassStart = {
    "Fighter": () => {
        KinkyDungeonInventoryAddWeapon("Knife");
        KinkyDungeonInventoryAddWeapon("Sword");
        if (!KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("Breastplate"), 0, true, ""))
            KinkyDungeonInventoryAddLoose("Breastplate");
        KDGameData.PreviousWeapon = "Knife";
        KDSetWeapon("Sword");
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("CommandWord"));
        KinkyDungeonSpellChoices.push(KinkyDungeonSpells.length - 1);
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("WPUp1"));
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("WPUp1"));
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("IronWill"));
        KinkyDungeonSpellPoints = 3;
        KinkyDungeonRedKeys = 1;
        KinkyDungeonLockpicks = 1;
        KinkyDungeonGold = 100;
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionStamina, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionFrigid, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionWill, 2);
    },
    "Rogue": () => {
        KinkyDungeonInventoryAddWeapon("Rope");
        KinkyDungeonInventoryAddWeapon("Dirk");
        if (!KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("LeatherBoots"), 0, true, ""))
            KinkyDungeonInventoryAddLoose("LeatherBoots");
        KDGameData.PreviousWeapon = "Rope";
        KDSetWeapon("Dirk");
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("CommandWord"));
        KinkyDungeonSpellChoices.push(KinkyDungeonSpells.length - 1);
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("SPUp1"));
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("SPUp1"));
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("Sneaky"));
        KinkyDungeonSpellPoints = 3;
        KinkyDungeonLockpicks = 2;
        KinkyDungeonGold = 100;
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionStamina, 2);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionFrigid, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionWill, 1);
    },
    "Mage": () => {
        KinkyDungeonInventoryAddWeapon("Knife");
        KinkyDungeonInventoryAddWeapon("ArcaneCrystal");
        KDGameData.PreviousWeapon = "Knife";
        KDSetWeapon("ArcaneCrystal");
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("CommandWord"));
        KinkyDungeonSpellChoices.push(KinkyDungeonSpells.length - 1);
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("Analyze"));
        KinkyDungeonSpellChoices.push(KinkyDungeonSpells.length - 1);
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("MPUp1"));
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("MPUp1"));
        KinkyDungeonSpellPoints = 3;
        KinkyDungeonRedKeys = 1;
        KinkyDungeonGold = 100;
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 3);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionFrigid, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionWill, 1);
    },
    "Peasant": () => {
        KinkyDungeonSpellChoices = [];
        KinkyDungeonSpellPoints = 3;
    },
    "Trainee": () => {
        KinkyDungeonSpellChoices = [];
        KinkyDungeonSpellPoints = 3;
        KinkyDungeonGold = 100;
        KinkyDungeonSpellChoices = [];
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("DistractionCast"));
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("MPUp1"));
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("APUp1"));
        KinkyDungeonInventoryAddWeapon("Knife");
        KDSetWeapon("Knife");
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 3);
        KinkyDungeonChangeFactionRep("Apprentice", .2);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug2"), 100, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), 100, true, "Gold");
    },
};
let KDParticles = new Map();
let KDParticleid = 0;
function KDAddParticle(x, y, img, type, data) {
    if (KDParticles.size > 1000)
        return;
    let tex = KDTex(img);
    if (tex && data) {
        let info = Object.assign({}, data);
        Object.assign(info, {
            time: 0,
            lifetime: (data.lifetime || 0) + (data.lifetime_spread ? (Math.random() * data.lifetime_spread - data.lifetime_spread * 0.5) : 0),
            zIndex: data.zIndex || 100,
            vy: data.vy + (data.vy_spread ? (Math.random() * data.vy_spread - data.vy_spread * 0.5) : 0),
            vx: data.vx + (data.vx_spread ? (Math.random() * data.vx_spread - data.vx_spread * 0.5) : 0),
            sin_y: data.sin_y + (data.sin_y_spread ? (Math.random() * data.sin_y_spread - data.sin_y_spread * 0.5) : 0),
            sin_x: data.sin_x + (data.sin_x_spread ? (Math.random() * data.sin_x_spread - data.sin_x_spread * 0.5) : 0),
            sin_period: data.sin_period + (data.sin_period_spread ? (Math.random() * data.sin_period_spread - data.sin_period_spread * 0.5) : 0),
            phase: data.phase || 0,
        });
        let sprite = PIXI.Sprite.from(tex);
        sprite.position.x = x;
        sprite.position.y = y;
        sprite.zIndex = info.zIndex;
        if (info.fadeEase) {
            switch (info.fadeEase) {
                case "invcos": {
                    sprite.alpha = Math.min(1, Math.max(0, 1 - Math.cos(2 * Math.PI * info.time / info.lifetime)));
                }
            }
        }
        KDParticles.set(KDParticleid, { info: info, sprite: sprite });
        kdparticles.addChild(sprite);
        KDParticleid += 1;
        if (KDParticleid > 4000000000)
            KDParticleid = 0;
    }
}
function KDUpdateParticles(delta) {
    let id = 0;
    let info = null;
    let sprite = null;
    for (let particle of KDParticles.entries()) {
        id = particle[0];
        info = particle[1].info;
        sprite = particle[1].sprite;
        sprite.anchor.set(0.5);
        if (info.rotation && !sprite.rotation)
            sprite.rotation = info.rotation;
        if (info.vy) {
            sprite.position.y += info.vy * delta;
        }
        if (info.vx) {
            sprite.position.x += info.vx * delta;
        }
        if (info.sin_x && info.sin_period) {
            sprite.position.x += info.sin_x * Math.sin(info.phase + info.sin_period * info.time / info.lifetime) * delta;
        }
        if (info.sin_y && info.sin_period) {
            sprite.position.y += info.sin_y * Math.sin(info.phase + info.sin_period * info.time / info.lifetime) * delta;
        }
        if (info.fadeEase) {
            switch (info.fadeEase) {
                case "invcos": {
                    sprite.alpha = Math.min(1, Math.max(0, 1 - Math.cos(2 * Math.PI * info.time / info.lifetime)));
                }
            }
        }
        info.time += delta;
        if (!info.lifetime || info.time > info.lifetime) {
            KDRemoveParticle(id);
        }
    }
}
function KDRemoveParticle(id) {
    if (KDParticles.has(id)) {
        kdparticles.removeChild(KDParticles.get(id).sprite);
        KDParticles.get(id).sprite.destroy();
        KDParticles.delete(id);
    }
}
let lastArousalParticle = 0;
let lastVibeParticle = 0;
function KDDrawArousalParticles(pinkChance, density, purpleChance) {
    if (density == 0)
        return;
    let arousalRate = 100 / density;
    if (CommonTime() > lastArousalParticle + arousalRate) {
        KDCreateArousalParticle(pinkChance, purpleChance);
        lastArousalParticle = CommonTime();
    }
}
function KDDrawVibeParticles(density) {
    let arousalRate = 100 / density;
    if (StandalonePatched)
        arousalRate *= 2;
    if (KinkyDungeonVibeLevel > 0 && CommonTime() > lastVibeParticle + 0.03 * arousalRate * (2 / (2 + KinkyDungeonVibeLevel))) {
        KDCreateVibeParticle();
        lastVibeParticle = CommonTime();
    }
}
function KDCreateVibeParticle() {
    var _a, _b;
    let lifetime = 500 + Math.random() * 250;
    let x = 250 - (StandalonePatched ? 5 : 0);
    let Hogtied = StandalonePatched ? (_a = KDCurrentModels.get(KinkyDungeonPlayer)) === null || _a === void 0 ? void 0 : _a.Poses.Hogtie : KinkyDungeonPlayer.Pose.includes("Hogtied");
    let Kneeling = StandalonePatched ? (_b = KDCurrentModels.get(KinkyDungeonPlayer)) === null || _b === void 0 ? void 0 : _b.Poses.Kneel : KinkyDungeonPlayer.IsKneeling();
    let y = 520 + (Hogtied ? 165 : (Kneeling ? 78 : 0));
    let locations = KDSumVibeLocations();
    let vx = ((Math.random() > 0.5) ? -1 : 1) * 0.25;
    let vy = -.15 + Math.random() * .3;
    let breast = locations.includes("ItemBreast") || locations.includes("ItemNipples");
    let cli = (locations.includes("ItemVulvaPiercings") || locations.includes("ItemPelvis"));
    if (breast || cli) {
        if (cli && (locations.length == 1 || Math.random() < 0.25)) {
            vy = 0.25 + Math.random() * 0.1;
            vx = -.05 + Math.random() * .1;
        }
        else if (breast && !KinkyDungeonPlayer.Pose.includes("Hogtied") && (locations.length == 1 || Math.random() < 0.5))
            y -= 155;
    }
    if (KinkyDungeonPlayer.HeightRatio)
        y += (100) * (1 - KinkyDungeonPlayer.HeightRatio);
    if (KinkyDungeonPlayer.HeightModifier)
        y -= KinkyDungeonPlayer.HeightModifier;
    KDAddParticle(x, y, KinkyDungeonRootDirectory + `Particles/VibeHeart.png`, undefined, {
        time: 0,
        lifetime: lifetime,
        vx: vx,
        vy: vy,
        zIndex: 60,
        sin_x: .04,
        sin_x_spread: .01,
        sin_period: 1.4,
        phase: 6 * Math.random(),
        fadeEase: "invcos",
        rotation: Math.atan2(vy, vx),
    });
}
function KDCreateArousalParticle(pinkChance, purpleChance) {
    let lifetime = 2000 + Math.random() * 1000;
    let y = 200 + Math.random() * 700;
    let xval = Math.random() < 0.5 ? 0.3 * Math.random() : (1 - 0.3 * Math.random());
    let x = xval * 500;
    let vy = -0.3 * Math.min(500, y) / lifetime;
    KDAddParticle(x, y, KinkyDungeonRootDirectory + `Particles/${Math.random() < purpleChance ? "HeartPurple" :
        (Math.random() < pinkChance ? "HeartPink" : "Heart")}.png`, undefined, {
        time: 0,
        lifetime: lifetime,
        vy: vy,
        zIndex: -1,
        sin_x: .04,
        sin_x_spread: .01,
        sin_period: 1.4,
        phase: 6 * Math.random(),
        fadeEase: "invcos",
    });
}
let KinkyDungeonPlayerEntity = null;
let KDSleepWillFraction = 0.5;
let KDSleepWillFractionJail = 0.5;
function KDGetSleepWillFraction() {
    if (KDGameData.PrisonerState == 'jail')
        return KDSleepWillFractionJail;
    return KDSleepWillFraction;
}
let KDMaxStat = 40;
let KDMaxStatStart = 10;
let KDMaxStatStartPool = 40;
let KDStamDamageThresh = 0.3;
let KDStamDamageThreshBonus = 0.05;
let KDSleepRegenWill = KDSleepWillFractionJail * KDMaxStatStart / 40;
let KinkyDungeonStatDistractionMax = KDMaxStatStart;
let KinkyDungeonStatDistractionLower = 0;
let KinkyDungeonStatDistractionLowerCap = 0.9;
let KinkyDungeonStatArousalLowerRegenSleep = 0;
let KinkyDungeonDistractionUnlockSuccessMod = 0.5;
let KinkyDungeonStatDistraction = 0;
let KinkyDungeonCrotchRopeDistraction = 0.4;
let KinkyDungeonStatDistractionRegen = -1.0;
let KinkyDungeonStatDistractionRegenPerUpgrade = KinkyDungeonStatDistractionRegen * 0.5;
let KDNoUnchasteBraMult = 0.9;
let KDNoUnchasteMult = 0.8;
let KDDistractionDecayMultDistractionMode = 0.25;
let KDDistractedAmount = 0.15;
let KinkyDungeonStatDistractionMiscastChance = 0.7;
let KinkyDungeonMiscastChance = 0;
let KinkyDungeonVibeLevel = 0;
let KinkyDungeonTeaseLevel = 0;
let KinkyDungeonTeaseLevelBypass = 0;
let KinkyDungeonOrgasmVibeLevel = 0;
let KinkyDungeonDistractionPerVibe = 0.05;
let KinkyDungeonDistractionPerPlug = 0.1;
let KinkyDungeonVibeCostPerIntensity = 0.15;
let KinkyDungeonStatWillpowerExhaustion = 0;
let KinkyDungeonSleepTurnsMax = 41;
let KinkyDungeonSlowMoveTurns = 0;
let KinkyDungeonStatStaminaMax = KDMaxStatStart;
let KinkyDungeonStatStamina = KinkyDungeonStatStaminaMax;
let KinkyDungeonStatStaminaRegen = 0.5;
let KinkyDungeonStatStaminaRegenPerUpgrade = 0.0;
let KinkyDungeonStatStaminaRegenPerUpgradeWill = 0.1;
let KDNarcolepticRegen = -0.06;
let KinkyDungeonStatStaminaRegenJail = 0.125;
let KinkyDungeonStatStaminaRegenSleep = KinkyDungeonStatStaminaMax / 40;
let KinkyDungeonStatStaminaRegenSleepBedMultiplier = 1.5;
let KinkyDungeonStatStaminaRegenWait = 0;
let KinkyDungeoNStatStaminaLow = 4;
let KDSprintCostBase = 1;
let KDSprintCostSlowLevel = [0.5, 1.0, 1.5, 2.0];
let KinkyDungeonStatWillMax = KDMaxStatStart;
let KinkyDungeonStatWill = KinkyDungeonStatWillMax;
let KinkyDungeonStatWillRate = 0;
let KinkyDungeonStatManaMax = KDMaxStatStart;
let KinkyDungeonStatMana = KinkyDungeonStatManaMax;
let KinkyDungeonStatManaPool = KinkyDungeonStatManaMax;
let KinkyDungeonStatManaPoolMax = KDMaxStatStartPool;
let KDManaPoolRatio = 1.0;
let KinkyDungeonStatManaRate = 0;
let KinkyDungeonStatManaRegen = 0;
let KinkyDungeonStatManaLowRegen = 0;
let KDMeditationRegen = 0.1;
let KinkyDungeonStatManaRegenLowThreshold = 5;
let KinkyDungeonStatManaPoolRegen = 0.01;
let KinkyDungeonStatStaminaRegenPerSlowLevel = -0.03;
let KinkyDungeonStatStaminaCostStruggle = -3.0;
let KinkyDungeonStatStaminaCostRemove = -0.5;
let KinkyDungeonStatStaminaCostTool = -0.2;
let KinkyDungeonStatStaminaCostPick = -0.1;
let KinkyDungeonStatWillCostStruggle = 0;
let KinkyDungeonStatWillCostRemove = 0;
let KinkyDungeonStatWillCostTool = 0;
let KinkyDungeonStatWillCostPick = 0;
let KinkyDungeonStatWillCostUnlock = 0;
let KinkyDungeonStatWillCostEscape = -0.2;
let KinkyDungeonStatWillBonusEscape = 0.2;
let KinkyDungeonStaminaRate = KinkyDungeonStatStaminaRegen;
let KinkyDungeonStatBeltLevel = 0;
let KinkyDungeonStatPlugLevel = 0;
let KinkyDungeonPlugCount = 0;
let KinkyDungeonStatVibeLevel = 0;
let KinkyDungeonStatEdged = false;
let KinkyDungeonStatDistractionGainChaste = -0.1;
let KinkyDungeonSlowLevel = 0;
let KinkyDungeonMovePoints = 0;
let KinkyDungeonBlindLevelBase = 0;
let KinkyDungeonBlindLevel = 0;
let KinkyDungeonStatBlind = 0;
let KinkyDungeonStatFreeze = 0;
let KinkyDungeonStatBind = 0;
let KinkyDungeonDeaf = false;
let KinkyDungeonSleepiness = 0;
let KinkyDungeonSleepinessMax = 10;
let KinkyDungeonGold = 0;
let KinkyDungeonLockpicks = 0;
let KinkyDungeonRedKeys = 0;
let KinkyDungeonBlueKeys = 0;
let KinkyDungeonHasCrotchRope = false;
let KinkyDungeonTorsoGrabChance = 0.4;
let KinkyDungeonTorsoGrabChanceBonus = 0.2;
let KinkyDungeonWeaponGrabChance = 1.0;
let KinkyDungeonInventory = new Map();
function KDInitInventory() {
    KinkyDungeonInventory = new Map();
    for (const c of [Consumable, Restraint, LooseRestraint, Weapon, Outfit]) {
        KinkyDungeonInventory.set(c, new Map());
    }
}
let KinkyDungeonPlayerTags = new Map();
let KinkyDungeonCurrentDress = "Default";
let KinkyDungeonUndress = 0;
let KinkyDungeonSpells = [];
let KinkyDungeonPlayerBuffs = {};
let KinkyDungeonPlayers = [];
let KinkyDungeonDifficulty = 0;
let KinkyDungeonSubmissiveMult = 0;
let KinkyDungeonSpellPoints = 3;
function KinkyDungeonDefaultStats(Load) {
    KinkyDungeonPenanceCosts = {};
    KinkyDungeonLostItems = [];
    KinkyDungeonFastMove = true;
    KinkyDungeonResetEventVariables();
    KinkyDungeonSetDress("Default", "Default");
    KDGameData.KinkyDungeonSpawnJailers = 0;
    KDGameData.KinkyDungeonSpawnJailersMax = 0;
    KinkyDungeonGold = 0;
    KinkyDungeonLockpicks = 0;
    KinkyDungeonRedKeys = 0;
    KinkyDungeonBlueKeys = 0;
    KinkyDungeonHasCrotchRope = false;
    KinkyDungeonSubmissiveMult = 0;
    KDGameData.HeartTaken = false;
    KDSetWeapon(null);
    KinkyDungeonSpellPoints = 0;
    KinkyDungeonStatDistractionMax = KDMaxStatStart;
    KinkyDungeonStatStaminaMax = KDMaxStatStart;
    KinkyDungeonStatManaMax = KDMaxStatStart;
    KinkyDungeonStatWillMax = KDMaxStatStart;
    KinkyDungeonStaminaRate = KinkyDungeonStatStaminaRegen;
    KinkyDungeonStatBlind = 0;
    KinkyDungeonSlowMoveTurns = 0;
    KDGameData.SleepTurns = 0;
    KinkyDungeonStatBind = 0;
    KinkyDungeonStatFreeze = 0;
    KinkyDungeonPlayerBuffs = {};
    KinkyDungeonMovePoints = 0;
    KDInitInventory();
    KinkyDungeonInventoryAdd({ name: "Default", type: Outfit, id: KinkyDungeonGetItemID() });
    KinkyDungeonInventoryAddWeapon("Unarmed");
    KDSetWeapon("Unarmed");
    KinkyDungeonPlayerTags = new Map();
    KinkyDungeonPlayerDamage = KinkyDungeonPlayerDamageDefault;
    KinkyDungeonResetMagic();
    KinkyDungeonInitializeDresses();
    KinkyDungeonShrineInit();
    if (KDClassStart[KinkyDungeonClassMode])
        KDClassStart[KinkyDungeonClassMode]();
    KinkyDungeonSetMaxStats();
    KinkyDungeonStatDistraction = 0;
    KinkyDungeonStatDistractionLower = 0;
    KinkyDungeonStatStamina = KinkyDungeonStatStaminaMax;
    KinkyDungeonStatMana = KinkyDungeonStatManaMax;
    KinkyDungeonStatManaPool = KinkyDungeonStatManaPoolMax;
    KinkyDungeonStatWill = KinkyDungeonStatWillMax;
    KDOrigStamina = KinkyDungeonStatStaminaMax * 10;
    KDOrigMana = KinkyDungeonStatManaMax * 10;
    KDOrigWill = KinkyDungeonStatWillMax * 10;
    KDOrigDistraction = 0;
    if (param_test == 'godmode') {
        KinkyDungeonSeeAll = true;
        KinkyDungeonSpellPoints = 9001;
    }
    if (!Load) {
        let magicHands = KinkyDungeonStatsChoice.has("MagicHands");
        if (!magicHands) {
            KinkyDungeonStatsChoice.set("MagicHands", true);
        }
        for (let perk of [...KinkyDungeonStatsChoice.keys()].filter((e) => { return KDPerkStart[e] != undefined; })
            .sort((a, b) => {
            return ((KinkyDungeonStatsPresets[a] && KinkyDungeonStatsPresets[a].startPriority) || -1) - ((KinkyDungeonStatsPresets[b] && KinkyDungeonStatsPresets[b].startPriority) || -1);
        })) {
            if (KinkyDungeonStatsChoice.get(perk) && KDPerkStart[perk]) {
                KDPerkStart[perk](Load);
                console.log("started with perk " + perk);
            }
        }
        if (!magicHands)
            KinkyDungeonStatsChoice.delete("MagicHands");
    }
    KinkyDungeonDressPlayer();
    CharacterRefresh(KinkyDungeonPlayer);
}
let KDMaxVisionDist = 8;
function KinkyDungeonGetVisionRadius() {
    let data = {
        brightness: KinkyDungeonMapBrightness,
        blindlevel: KinkyDungeonBlindLevel,
        noperipheral: KinkyDungeonDeaf || KinkyDungeonStatBlind > 0,
        blindMult: (KinkyDungeonStatsChoice.get("Blackout") || KinkyDungeonStatsChoice.get("TotalBlackout")) ? 2 : 1,
    };
    KinkyDungeonSendEvent("calcVision", data);
    return (KDGameData.SleepTurns > 2) ? 1 : (Math.max((data.noperipheral) ? 1 : 2, Math.round(KDMaxVisionDist - data.blindlevel * data.blindMult)));
}
function KDIsAutoAction() {
    return KinkyDungeonAutoWait || KinkyDungeonAutoWaitStruggle;
}
function KDDisableAutoWait() {
    KinkyDungeonAutoWait = false;
    KinkyDungeonAutoWaitStruggle = false;
}
function KinkyDungeonInterruptSleep() {
    KDGameData.SleepTurns = 0;
    KDGameData.PlaySelfTurns = 0;
    if (KinkyDungeonTempWait && !KDGameData.KinkyDungeonLeashedPlayer && !KinkyDungeonGetRestraintItem("ItemDevices"))
        KinkyDungeonAutoWait = false;
    if (KinkyDungeonInDanger())
        KinkyDungeonAutoWaitStruggle = false;
}
let KDBaseDamageTypes = {
    arouseTypes: ["grope", "charm", "happygas"],
    bypassTeaseTypes: ["charm", "happygas"],
    distractionTypesWeakNeg: ["pain", "acid"],
    distractionTypesWeak: ["soul"],
    distractionTypesStrong: ["tickle", "grope", "charm", "souldrain", "happygas"],
    teaseTypes: ["grope", "charm"],
    staminaTypesWeak: ["drain", "stun", "fire", "glue", "chain", "tickle", "electric", "shock"],
    staminaTypesStrong: ["ice", "frost", "poison", "crush", "souldrain"],
    manaTypesWeak: ["electric", "drain"],
    manaTypesStrong: [],
    willTypesVeryWeak: ["tickle", "souldrain"],
    willTypesWeak: ["ice", "frost", "poison", "stun", "electric", "acid", "grope", "pierce", "slash", "crush", "unarmed", "glue", "chain"],
    willTypesStrong: ["cold", "fire", "charm", "soul", "pain", "shock"],
};
function KDGetStamDamageThresh() {
    let data = {
        thresh: KDStamDamageThresh,
        bonus: 0,
    };
    for (let s of KinkyDungeonSpells) {
        if (s.name == "APUp1") {
            data.bonus += KDStamDamageThreshBonus;
        }
    }
    KinkyDungeonSendEvent("calcStamDamageThresh", data);
    data.thresh += data.bonus;
    return data.thresh;
}
function KinkyDungeonDealDamage(Damage, bullet, noAlreadyHit, noInterrupt) {
    if (bullet && !noAlreadyHit) {
        if (!bullet.alreadyHit)
            bullet.alreadyHit = [];
        if (bullet.alreadyHit.includes("player"))
            return { happened: 0, string: "" };
        bullet.alreadyHit.push("player");
    }
    let data = {
        dmg: Damage.damage,
        type: Damage.type,
        flags: Damage.flags,
        time: Damage.time,
        armor: KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Armor"),
        armorbreak: KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "ArmorBreak"),
        spellResist: KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SpellResist"),
        buffresist: KDBuffResist(KinkyDungeonPlayerBuffs, Damage.type),
        arouseAmount: 0,
        arouseMod: 1,
        arouseTypes: Object.assign([], KDBaseDamageTypes.arouseTypes),
        bypassTeaseTypes: Object.assign([], KDBaseDamageTypes.bypassTeaseTypes),
        distractionTypesWeakNeg: Object.assign([], KDBaseDamageTypes.distractionTypesWeakNeg),
        teaseTypes: Object.assign([], KDBaseDamageTypes.teaseTypes),
        distractionTypesWeak: Object.assign([], KDBaseDamageTypes.distractionTypesWeak),
        distractionTypesStrong: Object.assign([], KDBaseDamageTypes.distractionTypesStrong),
        staminaTypesWeak: Object.assign([], KDBaseDamageTypes.staminaTypesWeak),
        staminaTypesStrong: Object.assign([], KDBaseDamageTypes.staminaTypesStrong),
        manaTypesWeak: Object.assign([], KDBaseDamageTypes.manaTypesWeak),
        manaTypesStrong: Object.assign([], KDBaseDamageTypes.manaTypesStrong),
        willTypesVeryWeak: Object.assign([], KDBaseDamageTypes.willTypesVeryWeak),
        willTypesWeak: Object.assign([], KDBaseDamageTypes.willTypesWeak),
        willTypesStrong: Object.assign([], KDBaseDamageTypes.willTypesStrong),
        stats: [],
        newstats: [],
        damaged: false,
    };
    if (KinkyDungeonStatsChoice.get("Masochist")) {
        let types = ["pain", "electric", "slash", "pierce", "crush", "fire", "ice", "frost", "acid"];
        data.distractionTypesStrong.push(...types);
        data.arouseMod = Math.max(data.arouseMod, 2.0);
        data.arouseTypes.push(...types);
        if (data.distractionTypesWeakNeg.includes("pain"))
            data.distractionTypesWeakNeg = data.distractionTypesWeakNeg.splice(data.distractionTypesWeakNeg.indexOf("pain"), 1);
        if (data.distractionTypesWeakNeg.includes("acid"))
            data.distractionTypesWeakNeg = data.distractionTypesWeakNeg.splice(data.distractionTypesWeakNeg.indexOf("acid"), 1);
    }
    if (data.arouseTypes.includes(data.type) && !data.arouseAmount) {
        data.arouseAmount = 0.2;
    }
    if (data.arouseAmount < 0)
        data.arouseAmount = 0;
    KinkyDungeonSendEvent("beforePlayerDamage", data);
    data.dmg *= data.buffresist;
    if (data.armorbreak > 0)
        data.armor -= Math.min(Math.max(0, data.armor), data.armorbreak);
    if (data.armor && KinkyDungeonMeleeDamageTypes.includes(data.type))
        data.dmg = Math.max(0, data.dmg * KDArmorFormula(data.dmg, data.armor));
    else if (data.spellResist && !KinkyDungeonMeleeDamageTypes.includes(data.type))
        data.dmg = Math.max(0, data.dmg * KDArmorFormula(data.dmg, data.armor));
    if (data.dmg > 0) {
        let buffreduction = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "DamageReduction");
        if (buffreduction && data.dmg > 0) {
            data.dmg = Math.max(data.dmg - buffreduction, 0);
            KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "damageTaken", 1);
            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Shield.ogg");
        }
    }
    let str = "";
    if (data.dmg > 0)
        data.stats = [
            KinkyDungeonStatDistraction,
            KinkyDungeonStatDistractionLower,
            KinkyDungeonStatMana,
            KinkyDungeonStatWill,
            KinkyDungeonStatStamina,
        ];
    if (data.teaseTypes.includes(data.type)) {
        let amt = data.dmg;
        if (data.bypassTeaseTypes.includes(data.type)) {
            KinkyDungeonTeaseLevelBypass += amt;
        }
        else {
            KinkyDungeonTeaseLevel += amt;
        }
    }
    if (data.distractionTypesWeak.includes(data.type)) {
        let amt = data.dmg / 2 * data.arouseMod;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}dp`;
        KinkyDungeonChangeDistraction(amt, true, data.arouseAmount);
    }
    if (data.distractionTypesWeakNeg.includes(data.type)) {
        let amt = -data.dmg / 2 * data.arouseMod;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}dp`;
        KinkyDungeonChangeDistraction(amt, true);
    }
    if (data.distractionTypesStrong.includes(data.type)) {
        let amt = data.dmg * data.arouseMod;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}dp`;
        KinkyDungeonChangeDistraction(amt, true, data.arouseAmount);
    }
    if (data.staminaTypesStrong.includes(data.type)) {
        let amt = -data.dmg;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}sp`;
        KinkyDungeonChangeStamina(amt, false, false, false, KDGetStamDamageThresh());
    }
    else if (data.staminaTypesWeak.includes(data.type)) {
        let amt = -data.dmg / 2;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}sp`;
        KinkyDungeonChangeStamina(amt, false, false, false, KDGetStamDamageThresh());
    }
    if (data.manaTypesStrong.includes(data.type)) {
        let amt = -data.dmg;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}mp`;
        KinkyDungeonChangeMana(amt);
    }
    else if (data.manaTypesWeak.includes(data.type)) {
        let amt = -data.dmg / 2;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}mp`;
        KinkyDungeonChangeMana(amt);
    }
    if (data.willTypesStrong.includes(data.type)) {
        let amt = -data.dmg;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}wp`;
        KinkyDungeonChangeWill(amt, true);
    }
    else if (data.willTypesWeak.includes(data.type)) {
        let amt = -data.dmg / 2;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}wp`;
        KinkyDungeonChangeWill(amt, true);
    }
    else if (data.willTypesVeryWeak.includes(data.type)) {
        let amt = -data.dmg / 4;
        if (str)
            str = str + ", ";
        str = str + `${Math.round(amt * 10)}wp`;
        KinkyDungeonChangeWill(amt, true);
    }
    if (!noInterrupt)
        KinkyDungeonInterruptSleep();
    if (data.dmg > 0 && KinkyDungeonStatsChoice.get("Breathless")) {
        let sleepAmount = data.dmg > 3 ? 6 : (data.dmg > 1 ? 4 : 2);
        if (["chain", "poison", "crush"].includes(data.type))
            KinkyDungeonSleepiness = Math.max(KinkyDungeonSleepiness, KinkyDungeonSleepiness + sleepAmount);
    }
    if (KinkyDungeonStatFreeze > 0 && KinkyDungeonMeleeDamageTypes.includes(data.type)) {
        KinkyDungeonChangeWill(-data.dmg, true);
        KinkyDungeonStatFreeze = 0;
    }
    KDOrigWill = Math.floor(KinkyDungeonStatWill * 10);
    if (data.dmg > 0) {
        data.newstats = [
            KinkyDungeonStatDistraction,
            KinkyDungeonStatDistractionLower,
            KinkyDungeonStatMana,
            KinkyDungeonStatWill,
            KinkyDungeonStatStamina,
        ];
        let changed = false;
        for (let i = 0; i < data.stats.length; i++) {
            if (data.stats[i] != data.newstats[i]) {
                changed = true;
                break;
            }
        }
        if (changed && KinkyDungeonDamageTypes[data.type]) {
            data.damaged = true;
            KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, Math.floor(data.dmg * 10), KinkyDungeonDamageTypes[data.type].color, undefined, undefined, ` ${TextGet("KinkyDungeonDamageType" + KinkyDungeonDamageTypes[data.type].name)} dmg`);
        }
    }
    KinkyDungeonSendEvent("afterPlayerDamage", data);
    return { happened: data.dmg, string: str };
}
function KinkyDungeonUpdateDialogue(entity, delta) {
    if (!KinkyDungeonSlowMoveTurns && !KinkyDungeonStatFreeze && !KDGameData.PlaySelfTurns)
        if (entity.dialogue) {
            if (entity.dialogueDuration > delta) {
                entity.dialogueDuration = Math.max(0, entity.dialogueDuration - delta);
            }
            else {
                entity.dialogue = null;
            }
        }
}
function KinkyDungeonSendDialogue(entity, dialogue, color, duration, priority, force, nooverride) {
    if (!force && !KDEnemyCanTalk(entity)) {
        return;
    }
    if (!entity.dialogue || !entity.dialoguePriority || entity.dialoguePriority <= priority + (nooverride ? 1 : 0)) {
        entity.dialogue = dialogue;
        entity.dialogueColor = color;
        entity.dialogueDuration = duration;
        entity.dialoguePriority = priority;
        if (!entity.player) {
            KinkyDungeonSendTextMessage(0, `${TextGet("Name" + entity.Enemy.name)}: ${dialogue}`, color, 0, true, false, entity);
            KDAllowDialogue = false;
        }
    }
}
let KDOrigStamina = KDMaxStatStart * 10;
let KDOrigMana = KDMaxStatStart * 10;
let KDOrigWill = KDMaxStatStart * 10;
let KDOrigCharge = 1000;
let KDOrigDistraction = 0;
function KinkyDungeonChangeDistraction(Amount, NoFloater, lowerPerc, minimum = 0) {
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let data = {
        Amount: Amount,
        NoFloater: NoFloater,
        lowerPerc: lowerPerc,
        minimum: minimum,
    };
    KinkyDungeonSendEvent("changeDistraction", data);
    Amount = data.Amount;
    lowerPerc = data.lowerPerc;
    minimum = data.minimum;
    NoFloater = data.NoFloater;
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let minLevel = Math.min(KinkyDungeonStatDistractionMax * minimum, KinkyDungeonStatDistraction);
    if (Amount > 0) {
        KDNoRegenFlag = true;
    }
    KinkyDungeonStatDistraction += Amount;
    KinkyDungeonStatDistraction = Math.min(Math.max(minLevel, KinkyDungeonStatDistraction), KinkyDungeonStatDistractionMax);
    if (!KDGameData.DistractionCooldown) {
        KDGameData.DistractionCooldown = 0;
    }
    if (Amount > 0) {
        let cdBonus = KinkyDungeonStatDistraction >= KinkyDungeonStatDistractionMax ? Math.min(4, Math.max(1, Math.ceil(Amount / 1.5))) : 0;
        KDGameData.DistractionCooldown = Math.max(KDGameData.DistractionCooldown, 3 + cdBonus, KinkyDungeonSlowMoveTurns + 1 + cdBonus);
        if (KDToggles.ArousalHearts)
            for (let i = 0; i < Amount * 10 && i < 100; i++) {
                KDCreateArousalParticle(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax, 0);
            }
    }
    if (lowerPerc) {
        KinkyDungeonStatDistractionLower += Amount * lowerPerc;
        KinkyDungeonStatDistractionLower = Math.min(Math.max(0, KinkyDungeonStatDistractionLower), KinkyDungeonStatDistractionMax * KinkyDungeonStatDistractionLowerCap);
    }
    if (!NoFloater && Math.abs(KDOrigDistraction - Math.floor(KinkyDungeonStatDistraction / KinkyDungeonStatDistraction * 100)) >= 0.99) {
        let amount = Math.min(1, Math.max(0, (Math.floor(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax * 100) - KDOrigDistraction) / 100));
        amount *= amount;
        amount = Math.max(amount, amount * 0.5 + 0.5 * KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax * KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax);
        amount = Math.round(10 * amount);
        KinkyDungeonSendDialogue(KinkyDungeonPlayerEntity, TextGet("KinkyDungeonChangeDistraction" + amount), "#ff00ff", 2, 1);
        KDOrigDistraction = Math.max(0, Math.floor(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax * 100));
    }
    if (isNaN(KinkyDungeonStatDistraction)) {
        console.trace();
        KinkyDungeonStatDistraction = 0;
    }
}
function KinkyDungeonChangeStamina(Amount, NoFloater, Pause, NoSlow, minimum = 0, slowFloor = 5) {
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let data = {
        NoFloater: NoFloater,
        Amount: Amount,
        NoSlow: NoSlow,
        minimum: minimum,
        Pause: Pause,
        slowFloor: slowFloor,
    };
    KinkyDungeonSendEvent("changeStamina", data);
    NoFloater = data.NoFloater;
    Amount = data.Amount;
    NoSlow = data.NoSlow;
    minimum = data.minimum;
    slowFloor = data.slowFloor;
    Pause = data.Pause;
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let minLevel = Math.min(KinkyDungeonStatStaminaMax * minimum, KinkyDungeonStatStamina);
    KinkyDungeonStatStamina += Amount;
    KinkyDungeonStatStamina = Math.min(Math.max(minLevel, KinkyDungeonStatStamina), KinkyDungeonStatStaminaMax);
    if (!NoFloater && Math.abs(KDOrigStamina - Math.floor(KinkyDungeonStatStamina * 10)) >= 0.99) {
        KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, Math.floor(KinkyDungeonStatStamina * 10) - KDOrigStamina, "#44ff66", undefined, undefined, " sp");
        KDOrigStamina = Math.floor(KinkyDungeonStatStamina * 10);
    }
    if (Pause) {
        if (!(KDGameData.StaminaPause > Pause))
            KDGameData.StaminaPause = Pause;
        if (!(KDGameData.StaminaSlow > 5) && !NoSlow)
            KDGameData.StaminaSlow = 5;
    }
    if (isNaN(KinkyDungeonStatStamina)) {
        console.trace();
        KinkyDungeonStatDistraction = 0;
    }
}
function KinkyDungeonChangeMana(Amount, NoFloater, PoolAmount, Pause, spill, minimum = 0) {
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let data = {
        NoFloater: NoFloater,
        Amount: Amount,
        PoolAmount: PoolAmount,
        minimum: minimum,
        Pause: Pause,
        spill: spill,
    };
    KinkyDungeonSendEvent("changeMana", data);
    NoFloater = data.NoFloater;
    Amount = data.Amount;
    PoolAmount = data.PoolAmount;
    minimum = data.minimum;
    Pause = data.pause;
    spill = data.spill;
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let minLevel = Math.min(KinkyDungeonStatManaMax * minimum, KinkyDungeonStatMana);
    let manaAmt = KinkyDungeonStatMana;
    KinkyDungeonStatMana += Amount;
    KinkyDungeonStatMana = Math.min(Math.max(minLevel, KinkyDungeonStatMana), KinkyDungeonStatManaMax);
    manaAmt = KinkyDungeonStatMana - manaAmt;
    if (!PoolAmount)
        PoolAmount = 0;
    if (spill && manaAmt != Amount)
        PoolAmount += (Amount - manaAmt) * KDManaPoolRatio;
    if (PoolAmount) {
        KinkyDungeonStatManaPool += PoolAmount;
        KinkyDungeonStatManaPool = Math.min(Math.max(0, KinkyDungeonStatManaPool), KinkyDungeonStatManaPoolMax);
    }
    if (!NoFloater && Math.abs(KDOrigMana - Math.floor(KinkyDungeonStatMana * 10)) >= 0.99) {
        KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, Math.floor(KinkyDungeonStatMana * 10) - KDOrigMana, "#4499ff", undefined, undefined, " mp");
        KDOrigMana = Math.floor(KinkyDungeonStatMana * 10);
    }
    if (Pause) {
        if (!(KDGameData.ManaSlow > 10))
            KDGameData.ManaSlow = 10;
    }
    if (isNaN(KinkyDungeonStatMana)) {
        console.trace();
        KinkyDungeonStatDistraction = 0;
    }
}
function KinkyDungeonChangeWill(Amount, NoFloater, minimum = 0) {
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let data = {
        NoFloater: NoFloater,
        Amount: Amount,
        minimum: minimum,
    };
    KinkyDungeonSendEvent("changeWill", data);
    NoFloater = data.NoFloater;
    Amount = data.Amount;
    minimum = data.minimum;
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    let minLevel = Math.min(KinkyDungeonStatWillMax * minimum, KinkyDungeonStatWill);
    KinkyDungeonStatWill += Amount;
    KinkyDungeonStatWill = Math.min(Math.max(minLevel, KinkyDungeonStatWill), KinkyDungeonStatWillMax);
    if (!NoFloater && Math.abs(KDOrigWill - Math.floor(KinkyDungeonStatWill * 10)) >= 0.99) {
        KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, Math.floor(KinkyDungeonStatWill * 10) - KDOrigWill, "#ff4444", undefined, undefined, " wp");
        KDOrigWill = Math.floor(KinkyDungeonStatWill * 10);
    }
    if (isNaN(KinkyDungeonStatWill)) {
        console.trace();
        KinkyDungeonStatDistraction = 0;
    }
}
function KinkyDungeonChangeCharge(Amount, NoFloater) {
    if (isNaN(Amount)) {
        console.trace();
        Amount = 0;
    }
    if (!KDGameData.AncientEnergyLevel)
        KDGameData.AncientEnergyLevel = 0;
    KDGameData.AncientEnergyLevel = Math.min(1, KDGameData.AncientEnergyLevel + Amount);
    if (!NoFloater && Math.abs(KDOrigCharge - Math.floor(KDGameData.AncientEnergyLevel * 1000)) >= 0.99) {
        KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, Math.floor(KDGameData.AncientEnergyLevel * 1000 * 10) - KDOrigCharge, "#ffff44", undefined, undefined, " charge");
        KDOrigCharge = Math.floor(KDGameData.AncientEnergyLevel * 1000);
    }
    if (isNaN(KDGameData.AncientEnergyLevel)) {
        console.trace();
        KinkyDungeonStatDistraction = 0;
    }
}
function KinkyDungeonHasStamina(Cost, AddRate) {
    let s = KinkyDungeonStatStamina;
    if (AddRate)
        s += KinkyDungeonStaminaRate;
    return s >= Cost;
}
function KinkyDungeonHasWill(Cost, AddRate) {
    let s = KinkyDungeonStatWill;
    if (AddRate)
        s += KinkyDungeonStatWillRate;
    return s >= Cost;
}
function KinkyDungeonHasMana(Cost, AddRate) {
    let s = KinkyDungeonStatMana;
    if (AddRate)
        s += KinkyDungeonStatManaRate;
    return s >= Cost;
}
function KinkyDungeonSetMaxStats(delta) {
    KinkyDungeonStatStaminaMax = KDMaxStatStart;
    KinkyDungeonStatDistractionMax = KDMaxStatStart;
    KinkyDungeonStatManaMax = KDMaxStatStart;
    KinkyDungeonStatManaPoolMax = KDMaxStatStartPool;
    KinkyDungeonStatWillMax = KDMaxStatStart;
    KinkyDungeonSpellChoiceCount = 21;
    KinkyDungeonSummonCount = 2;
    let data = {
        distractionRate: 0,
        staminaRate: KinkyDungeonStatStaminaRegen,
        delta: delta,
    };
    for (let s of KinkyDungeonSpells) {
        if (s.name == "SPUp1") {
            KinkyDungeonStatStaminaMax += 5;
            data.staminaRate += KinkyDungeonStatStaminaRegenPerUpgrade;
        }
        if (s.name == "APUp1") {
            KinkyDungeonStatDistractionMax += 5;
            if (KinkyDungeonVibeLevel == 0 && !(KDGameData.DistractionCooldown > 0))
                data.distractionRate += KinkyDungeonStatDistractionRegenPerUpgrade;
        }
        if (s.name == "WPUp1") {
            KinkyDungeonStatWillMax += 5;
            data.staminaRate += KinkyDungeonStatStaminaRegenPerUpgradeWill;
        }
        if (s.name == "MPUp1")
            KinkyDungeonStatManaMax += 5;
        if (s.name == "SummonUp1" || s.name == "SummonUp2")
            KinkyDungeonSummonCount += 2;
    }
    KinkyDungeonSendEvent("calcMaxStats", data);
    return { distractionRate: data.distractionRate, staminaRate: data.staminaRate };
}
function KinkyDungeonCanUseWeapon(NoOverride, e) {
    let flags = {
        HandsFree: false,
    };
    if (!NoOverride)
        KinkyDungeonSendEvent("getWeapon", { event: e, flags: flags });
    return flags.HandsFree || KinkyDungeonPlayerDamage.noHands || (!KinkyDungeonIsHandsBound(false, true) && (!KinkyDungeonStatsChoice.get("WeakGrip") || !KinkyDungeonIsArmsBound(false, true)));
}
let KDBlindnessCap = 0;
let KDBoundPowerLevel = 0;
let KDNoRegenFlag = false;
function KDGetDistractionRate(delta) {
    let mult = KDNoRegenFlag ? 0 : 1;
    KDNoRegenFlag = false;
    let distractionRate = (KinkyDungeonVibeLevel == 0 && KDGameData.OrgasmNextStageTimer < 4 && !(KDGameData.DistractionCooldown > 0)) ? (!KinkyDungeonStatsChoice.get("arousalMode") ? KinkyDungeonStatDistractionRegen * KDDistractionDecayMultDistractionMode * mult : (KDGameData.PlaySelfTurns < 1 ? mult * KinkyDungeonStatDistractionRegen * ((KinkyDungeonChastityMult() > 0.9 ? KDNoUnchasteMult : (KinkyDungeonChastityMult() > 0 ? KDNoUnchasteBraMult : 1.0))) : 0)) : (KinkyDungeonDistractionPerVibe * KinkyDungeonVibeLevel);
    if (KDGameData.OrgasmStamina > 0 && delta > 0) {
        let amount = (KDGameData.OrgasmStamina || 0) / 24;
        KDGameData.OrgasmStamina = Math.max(0, KDGameData.OrgasmStamina * 0.98 - delta / 70);
        distractionRate += -amount;
    }
    let distractionBonus = KinkyDungeonSetMaxStats(delta).distractionRate;
    if (KDGameData.PlaySelfTurns < 1)
        distractionRate += distractionBonus;
    if (!KDGameData.DistractionCooldown)
        KDGameData.DistractionCooldown = 0;
    if (KDGameData.DistractionCooldown > 0)
        KDGameData.DistractionCooldown = Math.max(0, KDGameData.DistractionCooldown - delta);
    return distractionRate;
}
function KinkyDungeonUpdateStats(delta) {
    KDBoundPowerLevel = 0;
    KDBoundPowerLevel += 0.1 * Math.max(0, Math.min(1, KinkyDungeonBlindLevel / 3));
    if (KinkyDungeonIsArmsBound(false, false))
        KDBoundPowerLevel += 0.2;
    if (KinkyDungeonIsHandsBound(false, false, 0.65))
        KDBoundPowerLevel += 0.1;
    if (KinkyDungeonIsHandsBound(false, false, 0.99))
        KDBoundPowerLevel += 0.1;
    KDBoundPowerLevel += 0.1 * KinkyDungeonChastityMult();
    KDBoundPowerLevel += 0.2 * KinkyDungeonGagTotal();
    KDBoundPowerLevel += 0.2 * Math.max(0, Math.min(1, KinkyDungeonSlowLevel / 2));
    if (KDBoundPowerLevel > 1)
        KDBoundPowerLevel = 1;
    if (KinkyDungeonStatsChoice.get("BoundPower")) {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "BoundPower",
            type: "Evasion",
            duration: 1,
            power: KDBoundPowerLevel * KDBoundPowerMult,
        });
    }
    KinkyDungeonPlayers = [KinkyDungeonPlayerEntity];
    KDBlindnessCap = 7;
    KinkyDungeonSendEvent("calcStats", {});
    KinkyDungeonCalculateVibeLevel(delta);
    if (KinkyDungeonVibeLevel > 0 && KinkyDungeonCanPlayWithSelf() && KDGameData.SleepTurns > 0 && KDGameData.SleepTurns < 5) {
    }
    KinkyDungeonDifficulty = KinkyDungeonNewGame * 20;
    if (KinkyDungeonStatsChoice.get("hardMode"))
        KinkyDungeonDifficulty += 10;
    KinkyDungeonTeaseLevel = Math.max(KinkyDungeonTeaseLevel * (1 - KinkyDungeonChastityMult()) + (delta > 0 ? KinkyDungeonTeaseLevelBypass : 0), 0);
    if (KinkyDungeonVibeLevel > 0 || KinkyDungeonTeaseLevel > 0) {
        KDGameData.OrgasmNextStageTimer = Math.min(KDOrgasmStageTimerMax, KDGameData.OrgasmNextStageTimer + delta);
        let Chance = (KDGameData.OrgasmStage >= KinkyDungeonMaxOrgasmStage) ? 1.0 : (KDOrgasmStageTimerMaxChance + (1 - KinkyDungeonStatWill / KinkyDungeonStatWillMax) * KinkyDungeonStatDistractionLower / KinkyDungeonStatDistractionMax);
        if ((KinkyDungeonTeaseLevel > 0 || KDGameData.OrgasmNextStageTimer >= KDOrgasmStageTimerMax) && (KDRandom() < Chance && KinkyDungeonControlsEnabled())) {
            if (KDGameData.OrgasmStage < KinkyDungeonMaxOrgasmStage) {
                if (KinkyDungeonCanPlayWithSelf() && KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > KinkyDungeonDistractionPlaySelfThreshold && !KinkyDungeonInDanger()) {
                    KinkyDungeonDoPlayWithSelf(KinkyDungeonTeaseLevel);
                    KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonPlaySelfAutomatic" + (KinkyDungeonIsArmsBound() ? "Bound" : "")), "#FF5BE9", 5);
                }
                else {
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonPlaySelfTease"), "#FF5BE9", 2);
                }
                KDGameData.OrgasmStage += 1;
                KDGameData.OrgasmNextStageTimer = 1;
            }
            else {
                if (KinkyDungeonCanOrgasm() && KDGameData.OrgasmStamina < 0.5 && KDGameData.PlaySelfTurns < 1) {
                    KinkyDungeonDoTryOrgasm(KinkyDungeonTeaseLevel);
                    KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonOrgasmAutomatic"), "#FF5BE9", KinkyDungeonOrgasmStunTime + 1, true);
                    KDGameData.OrgasmNextStageTimer = 1;
                }
            }
        }
    }
    else if (KDGameData.OrgasmNextStageTimer > 0) {
        KDGameData.OrgasmNextStageTimer = Math.max(0, KDGameData.OrgasmNextStageTimer - delta);
    }
    let distractionRate = KDGetDistractionRate(delta);
    if (delta > 0 && KinkyDungeonVibeLevel > 0) {
        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonVibing" + Math.max(0, Math.min(5, Math.round(KinkyDungeonVibeLevel)))), "#ff88ff", 2, true, true);
    }
    let arousalPercent = distractionRate > 0 ? 0.04 : 0;
    if (KDGameData.OrgasmStage > 0 && !KinkyDungeonFlags.get("orgasmStageTimer") && KinkyDungeonStatDistraction < KinkyDungeonStatDistractionMax * 0.75) {
        KDGameData.OrgasmStage = Math.max(0, KDGameData.OrgasmStage - delta);
        KinkyDungeonSetFlag("orgasmStageTimer", 20 + Math.round(KDRandom() * 20));
    }
    if (KinkyDungeonStatDistraction >= KinkyDungeonStatDistractionMax * 0.99)
        KDGameData.OrgasmTurns = Math.min(KDGameData.OrgasmTurns + delta, KinkyDungeonOrgasmTurnsMax);
    else
        KDGameData.OrgasmTurns = Math.max(KDGameData.OrgasmTurns - delta, 0);
    let sleepRegen = KinkyDungeonStatStaminaRegenSleep * KinkyDungeonStatStaminaMax / KDMaxStatStart;
    let sleepRegenDistraction = KinkyDungeonStatArousalLowerRegenSleep * KinkyDungeonStatDistractionMax / KDMaxStatStart;
    if (KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y) == 'B')
        sleepRegen *= 2;
    let stamMult = KDGameData.StaminaSlow > 0 ? Math.max(0.5, (!KinkyDungeonCanStand() ? 0.5 : 1.0) - 0.1 * KDGameData.StaminaSlow) : 1.0;
    let stamRegen = KDGameData.StaminaPause > 0 ? 0 : KinkyDungeonSetMaxStats().staminaRate * stamMult;
    if (delta > 0 && KDGameData.StaminaPause > 0)
        KDGameData.StaminaPause -= delta;
    if (delta > 0 && KDGameData.StaminaSlow > 0)
        KDGameData.StaminaSlow -= delta;
    if (delta > 0 && KDGameData.KneelTurns > 0)
        KDGameData.KneelTurns -= delta;
    KinkyDungeonStaminaRate = KDGameData.SleepTurns > 0 && KDGameData.SleepTurns < KinkyDungeonSleepTurnsMax - 1 ? sleepRegen : stamRegen;
    let statData = {
        manaPoolRegen: KinkyDungeonStatManaPoolRegen,
        player: KinkyDungeonPlayerEntity,
    };
    KinkyDungeonSendEvent("calcManaPool", statData);
    KinkyDungeonStatManaRate = (KinkyDungeonStatMana < KinkyDungeonStatManaRegenLowThreshold && KinkyDungeonStatsChoice.get("Meditation")) ?
        Math.max(KinkyDungeonStatManaPool > 0 ? (statData.manaPoolRegen * KinkyDungeonStatManaMax) : 0, KDMeditationRegen)
        : 0;
    let ManaPoolDrain = 0;
    if (KinkyDungeonStatManaRate == 0 && KinkyDungeonStatManaPool > 0) {
        KinkyDungeonStatManaRate = KinkyDungeonStatManaPool - Math.max(0, KinkyDungeonStatManaPool - statData.manaPoolRegen * KinkyDungeonStatManaMax);
        if (KDGameData.ManaSlow > 0) {
            KinkyDungeonStatManaRate *= Math.max(0.1, 1 - 0.1 * KDGameData.ManaSlow);
        }
        KinkyDungeonStatManaRate = Math.min(KinkyDungeonStatManaRate, KinkyDungeonStatManaMax - KinkyDungeonStatMana);
        ManaPoolDrain = KinkyDungeonStatManaRate * KDManaPoolRatio;
    }
    KinkyDungeonPlayerTags = KinkyDungeonUpdateRestraints(delta);
    let blind = Math.max(KinkyDungeonBlindLevelBase, KinkyDungeonGetBlindLevel());
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Blindness"))
        blind = Math.max(0, blind + KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Blindness"));
    KinkyDungeonBlindLevel = Math.min(KDBlindnessCap, blind);
    if (KinkyDungeonBlindLevel > 0 && KinkyDungeonStatsChoice.has("Unmasked"))
        KinkyDungeonBlindLevel += 1;
    if (KinkyDungeonStatBlind > 0)
        KinkyDungeonBlindLevel = Math.max(KinkyDungeonBlindLevel, 6);
    KinkyDungeonDeaf = false;
    KinkyDungeonPlayerDamage = KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
    KinkyDungeonUpdateStruggleGroups();
    KinkyDungeonCalculateSlowLevel();
    let sleepRate = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sleepiness");
    if ((sleepRate && sleepRate > 0) || KinkyDungeonSleepiness > 0) {
        KinkyDungeonSleepiness = Math.min(KinkyDungeonSleepinessMax, KinkyDungeonSleepiness + sleepRate * delta);
        if (KinkyDungeonSleepiness > 2.99) {
            KinkyDungeonSlowLevel = Math.max(KinkyDungeonSlowLevel, 2);
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Sleepy", aura: "#222222", type: "AttackStamina", duration: 3, power: -1, player: true, enemies: false, tags: ["attack", "stamina"] });
        }
        if (KinkyDungeonSleepiness > 0) {
            KinkyDungeonBlindLevel = Math.max(KinkyDungeonBlindLevel + Math.floor(KinkyDungeonSleepiness * 0.5), Math.min(Math.round(KinkyDungeonSleepiness * 0.7), 6));
        }
        if (KinkyDungeonSleepiness > 0) {
            KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonSleepy"), "#ff0000", 1, true);
        }
    }
    if ((!sleepRate || sleepRate <= 0) && KinkyDungeonSleepiness > 0)
        KinkyDungeonSleepiness = Math.max(0, KinkyDungeonSleepiness - delta);
    KinkyDungeonChangeDistraction(distractionRate * delta, true, distractionRate > 0 ? arousalPercent : 0);
    if (sleepRegenDistraction > 0 && KDGameData.SleepTurns > 0) {
        KinkyDungeonStatDistractionLower -= sleepRegenDistraction * delta;
    }
    else {
    }
    KinkyDungeonChangeStamina(KinkyDungeonStaminaRate * delta, true, undefined, true);
    KinkyDungeonStatMana += KinkyDungeonStatManaRate;
    KinkyDungeonStatManaPool -= ManaPoolDrain;
    if (KDGameData.OrgasmTurns > KinkyDungeonOrgasmTurnsCrave && !(KDGameData.OrgasmStamina > 0)) {
        let EdgeDrainAmount = KinkyDungeonStatDistractionLower < KinkyDungeonStatDistractionLowerCap ? KinkyDungeonOrgasmExhaustionAmountWillful : KinkyDungeonOrgasmExhaustionAmount;
        KinkyDungeonChangeWill(EdgeDrainAmount);
        let vibe = KinkyDungeonVibeLevel > 0 ? "Vibe" : "";
        let suff = KDGameData.OrgasmStage < KinkyDungeonMaxOrgasmStage ? (KDGameData.OrgasmStage < KinkyDungeonMaxOrgasmStage / 2 ? "0" : "1") : "2";
        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonOrgasmExhaustion" + vibe + suff), "#ff0000", 2, true);
    }
    KinkyDungeonStatBlind = Math.max(0, KinkyDungeonStatBlind - delta);
    KinkyDungeonStatFreeze = Math.max(0, KinkyDungeonStatFreeze - delta);
    KinkyDungeonStatBind = Math.max(0, KinkyDungeonStatBind - delta);
    KinkyDungeonCapStats();
    KDOrigDistraction = Math.floor(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax * 100);
    KDOrigStamina = Math.floor(KinkyDungeonStatStamina * 10);
    KDOrigMana = Math.floor(KinkyDungeonStatMana * 10);
    KinkyDungeonCalculateMiscastChance();
    KinkyDungeonHasCrotchRope = false;
    let drains = [];
    for (let item of KinkyDungeonFullInventory()) {
        if (item.type == Restraint) {
            if (KDRestraint(item).difficultyBonus) {
                KinkyDungeonDifficulty += KDRestraint(item).difficultyBonus;
            }
            if (KDRestraint(item).crotchrope)
                KinkyDungeonHasCrotchRope = true;
            if (KDRestraint(item).enchantedDrain) {
                if (KDGameData.AncientEnergyLevel > 0) {
                    drains.push(KDRestraint(item).enchantedDrain);
                }
            }
        }
    }
    if (drains.length > 0 && delta > 0) {
        drains = drains.sort().reverse();
        for (let i = 0; i < drains.length; i++) {
            KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - (drains[i] / (i + 1)) * delta);
        }
    }
    KinkyDungeonSubmissiveMult = KinkyDungeonCalculateSubmissiveMult();
    if (!KDGameData.TimeSinceLastVibeEnd)
        KDGameData.TimeSinceLastVibeEnd = {};
    if (!KDGameData.TimeSinceLastVibeStart)
        KDGameData.TimeSinceLastVibeStart = {};
    for (let type of Object.entries(KDGameData.TimeSinceLastVibeStart)) {
        if (!KDGameData.TimeSinceLastVibeStart[type[0]])
            KDGameData.TimeSinceLastVibeStart[type[0]] = 1;
        else
            KDGameData.TimeSinceLastVibeStart[type[0]] += delta;
    }
    for (let type of Object.entries(KDGameData.TimeSinceLastVibeEnd)) {
        if (!KDGameData.TimeSinceLastVibeEnd[type[0]])
            KDGameData.TimeSinceLastVibeEnd[type[0]] = 1;
        else
            KDGameData.TimeSinceLastVibeEnd[type[0]] += delta;
    }
    KDUpdatePerksBonus();
    if (delta > 0) {
        KinkyDungeonTeaseLevel = 0;
        KinkyDungeonTeaseLevelBypass = 0;
    }
    if (KinkyDungeonSlowLevel > 9)
        KDGameData.CagedTime = (KDGameData.CagedTime || 0) + delta;
    else
        KDGameData.CagedTime = 0;
}
let KDDamageAmpPerks = 0;
let KDDamageAmpPerksMelee = 0;
let KDDamageAmpPerksMagic = 0;
let KDDamageAmpPerksSpell = 0;
let KDDamageAmpEnvironmental = 0;
let KDExtraEnemyTags = {};
function KDGetEnvironmentalDmg() {
    return KinkyDungeonMultiplicativeStat(-KDDamageAmpEnvironmental);
}
function KDUpdatePerksBonus() {
    KDDamageAmpPerks = 0;
    KDDamageAmpPerksMagic = 0;
    KDDamageAmpPerksMelee = 0;
    KDDamageAmpPerksSpell = 0;
    KDDamageAmpEnvironmental = 0;
    KDExtraEnemyTags = {};
    for (let perk of KinkyDungeonStatsChoice.keys()) {
        if (KDPerkUpdateStats[perk])
            KDPerkUpdateStats[perk]();
    }
    KinkyDungeonSendEvent("perksBonus", {});
}
function KinkyDungeonCalculateMiscastChance() {
    let flags = {
        miscastChance: Math.max(0, KinkyDungeonStatDistractionMiscastChance * Math.min(1, KinkyDungeonStatDistraction / (KinkyDungeonStatDistractionMax || 1))),
    };
    if (KinkyDungeonStatsChoice.has("AbsoluteFocus")) {
        flags.miscastChance = Math.min(flags.miscastChance * 2, 1);
    }
    if (KinkyDungeonStatsChoice.get("Distracted"))
        flags.miscastChance += KDDistractedAmount;
    KinkyDungeonSendEvent("calcMiscast", flags);
    KinkyDungeonMiscastChance = Math.max(0, flags.miscastChance || 0);
}
function KinkyDungeonGetBlindLevel() {
    let blindness = 0;
    for (let inv2 of KinkyDungeonAllRestraintDynamic()) {
        let inv = inv2.item;
        if (KDRestraint(inv).blindfold)
            blindness = Math.max(Math.min(5, blindness + 1), KDRestraint(inv).blindfold);
    }
    let data = {
        player: KinkyDungeonPlayerEntity,
        blindness: blindness ? blindness : 0,
    };
    KinkyDungeonSendEvent("calcBlind", data);
    return data.blindness;
}
function KinkyDungeonCapStats() {
    KinkyDungeonStatDistractionLower = Math.max(0, Math.min(KinkyDungeonStatDistractionLower, KinkyDungeonStatDistractionMax * KinkyDungeonStatDistractionLowerCap));
    KinkyDungeonStatDistraction = Math.max(KinkyDungeonStatDistractionLower, Math.min(KinkyDungeonStatDistraction, KinkyDungeonStatDistractionMax));
    KinkyDungeonStatStamina = Math.max(0, Math.min(KinkyDungeonStatStamina, KinkyDungeonStatStaminaMax));
    KinkyDungeonStatMana = Math.max(0, Math.min(KinkyDungeonStatMana, KinkyDungeonStatManaMax));
    KinkyDungeonStatManaPool = Math.max(0, Math.min(KinkyDungeonStatManaPool, KinkyDungeonStatManaPoolMax));
    if (KinkyDungeonStatMana > KinkyDungeonStatManaMax - 0.001)
        KinkyDungeonStatMana = KinkyDungeonStatManaMax;
    if (KinkyDungeonStatWill > KinkyDungeonStatWillMax - 0.001)
        KinkyDungeonStatWill = KinkyDungeonStatWillMax;
}
function KinkyDungeonLegsBlocked() {
    if (KinkyDungeonPlayer.Pose.includes("Hogtie"))
        return true;
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv) && KDRestraint(inv).blockfeet)
            return true;
    }
    return false;
}
function KinkyDungeonCanStand() {
    return !KinkyDungeonPlayer.Pose.includes("Kneel") && !(KDGameData.KneelTurns > 0);
}
function KinkyDungeonCanKneel() {
    return true;
}
function KinkyDungeonCalculateSlowLevel(delta) {
    KinkyDungeonSlowLevel = 0;
    if (KinkyDungeonAllRestraint().some((r) => { return KDRestraint(r).immobile; })) {
        KinkyDungeonSlowLevel += 100;
        KinkyDungeonMovePoints = -1;
    }
    else {
        for (let inv of KinkyDungeonAllRestraint()) {
            if ((KDRestraint(inv).blockfeet || KDRestraint(inv).hobble))
                KinkyDungeonSlowLevel = Math.min(3, KinkyDungeonSlowLevel + 1);
        }
        for (let inv of KinkyDungeonAllRestraint()) {
            if (KDRestraint(inv).blockfeet) {
                KinkyDungeonSlowLevel = Math.max(KinkyDungeonSlowLevel, 2);
                break;
            }
        }
        if (!KinkyDungeonCanStand())
            KinkyDungeonSlowLevel = Math.max(3, KinkyDungeonSlowLevel + 1);
        if (KinkyDungeonPlayer.Pose.includes("Hogtied"))
            KinkyDungeonSlowLevel = Math.max(4, KinkyDungeonSlowLevel + 1);
        for (let inv of KinkyDungeonAllRestraint()) {
            if (KDRestraint(inv).freeze)
                KinkyDungeonSlowLevel = Math.max(2, KinkyDungeonSlowLevel);
        }
        if (!KinkyDungeonHasStamina(0.01))
            KinkyDungeonSlowLevel = Math.max(1, KinkyDungeonSlowLevel);
    }
    let origSlowLevel = KinkyDungeonSlowLevel;
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowLevel"))
        KinkyDungeonSlowLevel += KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowLevel");
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "MoveSpeed"))
        KinkyDungeonSlowLevel = Math.max(0, KinkyDungeonSlowLevel - KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "MoveSpeed"));
    KinkyDungeonSlowLevel = Math.max(0, KinkyDungeonSlowLevel);
    if (delta > 0 && KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowLevelEnergyDrain"))
        KDGameData.AncientEnergyLevel =
            Math.max(0, KDGameData.AncientEnergyLevel - Math.max(0, origSlowLevel - KinkyDungeonSlowLevel) * KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowLevelEnergyDrain"));
}
function KinkyDungeonGagTotal(AllowFlags) {
    let total = 0;
    let allow = false;
    let prevent = false;
    for (let rest of KinkyDungeonAllRestraintDynamic()) {
        let inv = rest.item;
        if (KDRestraint(inv).gag)
            total += KDRestraint(inv).gag;
        if (KDRestraint(inv).allowPotions)
            allow = true;
    }
    if (AllowFlags) {
        if (prevent)
            return 1.00;
        else if (allow)
            return 0.0;
    }
    return total;
}
function KinkyDungeonCanTalk(Loose) {
    for (let inv of KinkyDungeonAllRestraint()) {
        if ((Loose ? KinkyDungeonGagTotal() >= 0.99 : KDRestraint(inv).gag))
            return false;
    }
    return true;
}
function KinkyDungeonCalculateSubmissiveMult() {
    let base = 0;
    for (let item of KinkyDungeonAllRestraint()) {
        if (item.type == Restraint) {
            let power = Math.sqrt(Math.max(0, KinkyDungeonGetLockMult(item.lock) * KDRestraint(item).power));
            base = Math.max(power, base + power / 5);
        }
    }
    base *= 0.28;
    let mult = Math.max(0, 0.2 + 0.8 * (KinkyDungeonGoddessRep.Ghost + 50) / 100);
    let amount = Math.max(0, base * mult);
    return amount;
}
function KinkyDungeonCanPlayWithSelf() {
    if (!KinkyDungeonStatsChoice.get("arousalMode"))
        return false;
    return KinkyDungeonStatDistraction > KinkyDungeonDistractionSleepDeprivationThreshold * KinkyDungeonStatDistractionMax && KinkyDungeonHasStamina(-KDGetOrgasmCost());
}
function KinkyDungeonCanTryOrgasm() {
    if (!KinkyDungeonStatsChoice.get("arousalMode"))
        return false;
    let data = {
        player: KinkyDungeonPlayerEntity,
        threshold: KinkyDungeonStatDistractionMax - 0.01,
    };
    KinkyDungeonSendEvent("calcOrgThresh", data);
    return KinkyDungeonStatDistraction >= data.threshold && (KinkyDungeonHasStamina(-KDGetOrgasmCost()) || KDGameData.OrgasmStage > 3) && KDGameData.OrgasmStamina < 1;
}
function KDGetOrgasmCost() {
    return Math.max(KinkyDungeonOrgasmCost, -KinkyDungeonOrgasmCostPercent * KinkyDungeonStatStamina);
}
function KDGetPlaySelfPower(tease) {
    let OrigAmount = Math.max(tease ? Math.min(KinkyDungeonPlayWithSelfPowerMax, tease) : 0, KinkyDungeonPlayWithSelfPowerMin + (KinkyDungeonPlayWithSelfPowerMax - KinkyDungeonPlayWithSelfPowerMin) * KDRandom());
    let amount = Math.max(0, OrigAmount - KinkyDungeonChastityMult() * KinkyDungeonPlayWithSelfChastityPenalty);
    return { orig: OrigAmount, final: amount };
}
function KinkyDungeonDoPlayWithSelf(tease) {
    let affinity = KinkyDungeonGetAffinity(false, "Edge");
    let power = KDGetPlaySelfPower(tease);
    let OrigAmount = power.orig;
    let amount = power.final;
    let bound = KinkyDungeonIsArmsBound();
    if (bound && !affinity)
        amount = Math.max(0, Math.min(amount, OrigAmount - KinkyDungeonPlayWithSelfBoundPenalty));
    if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.playSelfBonus)
        amount += KinkyDungeonPlayerDamage.playSelfBonus;
    let data = {
        player: KinkyDungeonPlayerEntity,
        amount: amount,
        cost: KinkyDungeonPlayCost,
        bound: bound,
        playTime: 3,
        playSound: true,
        playMsg: true,
        affinity: affinity,
        OrigAmount: OrigAmount,
        power: power,
        alertRadius: 3,
        distractionCooldown: Math.max(KDGameData.DistractionCooldown, 13),
    };
    KinkyDungeonSendEvent("playSelf", data);
    KinkyDungeonAlert = Math.max(KinkyDungeonAlert || 0, data.alertRadius);
    KinkyDungeonChangeDistraction(0.5 + Math.sqrt(Math.max(0, data.amount * KinkyDungeonPlayWithSelfMult)) * KinkyDungeonStatDistractionMax / KDMaxStatStart, false, 0.05);
    KinkyDungeonChangeStamina(data.cost, true, 3);
    if (data.playSound) {
        if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.playSelfSound)
            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + KinkyDungeonPlayerDamage.playSelfSound + ".ogg");
    }
    if (data.playMsg) {
        if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.playSelfMsg) {
            KinkyDungeonSendActionMessage(10, TextGet(KinkyDungeonPlayerDamage.playSelfMsg), "#FF5BE9", 4);
        }
        else if (KinkyDungeonIsArmsBound()) {
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonPlaySelfBound"), "#FF5BE9", 4);
        }
        else if (KinkyDungeonChastityMult() > 0.9) {
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonChastityDeny"), "#FF5BE9", 4);
        }
        else
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonPlaySelf"), "#FF5BE9", 4);
        if (affinity)
            KinkyDungeonSendTextMessage(8, TextGet("KinkyDungeonPlayCorner"), "#88FF00", 4);
    }
    KDGameData.PlaySelfTurns = data.playTime;
    KDGameData.DistractionCooldown = data.distractionCooldown;
    return amount;
}
let KinkyDungeonOrgasmVibeLevelPlayPowerMult = 1.0;
let KinkyDungeonOrgasmChanceBase = -0.1;
let KinkyDungeonOrgasmChanceScaling = 1.1;
let KinkyDungeonMaxOrgasmStage = 7;
let KinkyDungeonOrgasmStageVariation = 4;
let KinkyDungeonDistractionSleepDeprivationThreshold = 0.001;
let KinkyDungeonDistractionPlaySelfThreshold = 0.3;
let KinkyDungeonPlaySelfOrgasmThreshold = 3;
let KinkyDungeonOrgasmTurnsMax = 10;
let KinkyDungeonOrgasmTurnsCrave = 8;
let KinkyDungeonPlayWithSelfPowerMin = 3;
let KinkyDungeonPlayWithSelfPowerMax = 6;
let KinkyDungeonPlayWithSelfPowerVibeWand = 5;
let KinkyDungeonPlayWithSelfChastityPenalty = 4.5;
let KinkyDungeonPlayWithSelfBoundPenalty = 2.0;
let KinkyDungeonOrgasmExhaustionAmount = -0.02;
let KinkyDungeonOrgasmExhaustionAmountWillful = -0.005;
let KDOrgasmStageTimerMax = 10;
let KDOrgasmStageTimerMaxChance = 0.1;
let KDWillpowerMultiplier = 0.5;
let KinkyDungeonOrgasmCost = -8;
let KinkyDungeonOrgasmCostPercent = 0.7;
let KinkyDungeonOrgasmWillpowerCost = -2;
let KinkyDungeonEdgeCost = -1;
let KinkyDungeonPlayCost = -0.1;
let KinkyDungeonOrgasmStunTime = 4;
let KinkyDungeonPlayWithSelfMult = 0.25;
function KinkyDungeonDoTryOrgasm(Bonus) {
    let chance = KinkyDungeonOrgasmChanceBase + KinkyDungeonOrgasmChanceScaling * (KDGameData.OrgasmTurns / KinkyDungeonOrgasmTurnsMax);
    let denied = KinkyDungeonVibratorsDeny(chance);
    let amount = denied ? 0 : KinkyDungeonOrgasmVibeLevel * KinkyDungeonOrgasmVibeLevelPlayPowerMult;
    let playSelfAmount = Bonus != undefined ? Bonus : KinkyDungeonDoPlayWithSelf();
    amount += playSelfAmount;
    let msg = "KinkyDungeonOrgasm";
    let msgTime = KinkyDungeonOrgasmStunTime + 3;
    let data = {
        player: KinkyDungeonPlayerEntity,
        amount: amount,
        chance: chance,
        denied: denied,
        Bonus: Bonus,
        edgespcost: KinkyDungeonEdgeCost,
        edgewpcost: 0,
        spcost: KDGetOrgasmCost(),
        wpcost: KinkyDungeonOrgasmWillpowerCost,
        stunTime: KinkyDungeonOrgasmStunTime,
        playSound: true,
        playMsg: true,
        alertRadius: 7,
        satisfaction: KinkyDungeonStatDistraction,
        distractionCooldown: Math.max(KDGameData.DistractionCooldown, 13),
        cancelOrgasm: false,
        lowerFloorTo: 0,
    };
    KinkyDungeonSendEvent("tryOrgasm", data);
    if (data.cancelOrgasm)
        return;
    if (data.amount > KinkyDungeonPlaySelfOrgasmThreshold && KDRandom() < data.chance) {
        KinkyDungeonStatBlind = data.stunTime + 2;
        KinkyDungeonSetFlag("OrgSuccess", 3);
        KinkyDungeonSetFlag("PlayerOrgasm", data.stunTime);
        KinkyDungeonSetFlag("PlayerOrgasmFilter", data.stunTime + 1);
        KDGameData.OrgasmStamina = data.satisfaction;
        KinkyDungeonChangeStamina(data.spCost);
        KinkyDungeonChangeWill(data.wpCost);
        KinkyDungeonStatDistractionLower = data.lowerFloorTo;
        KinkyDungeonAlert = Math.max(KinkyDungeonAlert || 0, data.alertRadius);
        KDGameData.PlaySelfTurns = data.stunTime;
        KinkyDungeonSendEvent("orgasm", data);
    }
    else {
        KinkyDungeonChangeStamina(data.edgespCost);
        KinkyDungeonChangeWill(data.edgewpCost);
        KDGameData.OrgasmTurns = Math.min(KDGameData.OrgasmTurns + amount, KinkyDungeonOrgasmTurnsMax);
        KDGameData.OrgasmStage = Math.min(KinkyDungeonMaxOrgasmStage, KDGameData.OrgasmStage + 1);
        if (KDGameData.CurrentVibration) {
            if (KDGameData.CurrentVibration.denialsLeft > 0 || KDGameData.CurrentVibration.denialsLeft == undefined) {
                KDGameData.CurrentVibration.denyTimeLeft = KDGameData.CurrentVibration.denyTime;
                if (KDGameData.CurrentVibration.denialsLeft > 0)
                    KDGameData.CurrentVibration.denialsLeft -= 1;
            }
        }
        if (denied && KinkyDungeonVibeLevel > 0) {
            msg = "KinkyDungeonDeny";
            KinkyDungeonSetFlag("OrgDenied", 3);
            KinkyDungeonSendEvent("deny", data);
        }
        else {
            msg = "KinkyDungeonEdge";
            KinkyDungeonSetFlag("OrgEdged", 3);
            KinkyDungeonSendEvent("edge", data);
        }
    }
    if (data.playMsg) {
        let msgIndex = Math.min(KinkyDungeonMaxOrgasmStage, KDGameData.OrgasmStage) + Math.floor(Math.random() * KinkyDungeonOrgasmStageVariation);
        KinkyDungeonSendActionMessage(10, TextGet(msg + ("" + msgIndex)), "#FF5BE9", msgTime);
    }
}
function KinkyDungeonIsChaste(Breast) {
    for (let inv of KinkyDungeonAllRestraint()) {
        if ((!Breast && KDRestraint(inv).chastity) || (Breast && KDRestraint(inv).chastitybra))
            return true;
    }
}
function KinkyDungeonChastityMult() {
    let chaste = 0.0;
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv).chastity)
            chaste += 1;
        else if (KDRestraint(inv).chastitybra)
            chaste += 0.2;
    }
    return chaste;
}
function KDBuffResist(buffs, type) {
    if (KDDamageEquivalencies[type])
        type = KDDamageEquivalencies[type];
    return KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(buffs, type + "DamageResist"))
        * (KinkyDungeonMeleeDamageTypes.includes(type) ?
            KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(buffs, "meleeDamageResist"))
            : KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(buffs, "magicDamageResist")));
}
let KDMapTilesList = { "HallCross": { "name": "HallCross", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1110111\n1110111\n0000000\n1110111\n1110111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.75 }], "Keyring": [], "Jail": [], "Tiles": {}, "effectTiles": { "5,3": { "TorchUnlit": { "x": 5, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,3": { "TorchUnlit": { "x": 1, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "T_Left_Thinvert": { "name": "T_Left_Thinvert", "w": 1, "h": 1, "primInd": "udr", "index": { "1,1": "udr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n111d111\n1110L00\n1110000\n11100L0\n111d111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [], "Tiles": { "3,1": { "Type": "Door" }, "3,5": { "Type": "Door" }, "4,2": { "Type": "Barrel" }, "5,4": { "Type": "Barrel" } }, "effectTiles": { "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban"], "forbidTags": ["silverchest"], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "deadend_d": { "name": "deadend_d", "w": 1, "h": 1, "primInd": "d", "index": { "1,1": "d" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n11RRL11\n1L00001\n10000L1\n1000001\n1000001\n111d111\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["urban"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": { "3,6": { "Type": "Door" }, "5,3": { "Type": "Barrel" }, "4,1": { "Type": "Barrel" }, "1,2": { "Type": "Barrel" }, "2,1": { "Type": "Rubble" }, "3,1": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "deadend_u": { "name": "deadend_u", "w": 1, "h": 1, "primInd": "u", "index": { "1,1": "u" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111d111\n10L0001\n1000001\n1000001\n10000R1\n110LL11\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["urban"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": { "3,0": { "Type": "Door" }, "2,1": { "Type": "Barrel" }, "4,5": { "Type": "Barrel" }, "3,5": { "Type": "Barrel" }, "5,4": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "deadend_l": { "name": "deadend_l", "w": 1, "h": 1, "primInd": "l", "index": { "1,1": "l" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1LL00,1\n1L00001\nd000001\n10000R1\n1LL0011\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["urban"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": { "0,3": { "Type": "Door" }, "1,5": { "Type": "Barrel" }, "2,5": { "Type": "Barrel" }, "1,1": { "Type": "Barrel" }, "1,2": { "Type": "Barrel" }, "2,1": { "Type": "Barrel" }, "5,4": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "deadend_r": { "name": "deadend_r", "w": 1, "h": 1, "primInd": "r", "index": { "1,1": "r" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n11LL001\n1R00001\n100000d\n1L00001\n11L0001\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["urban"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": { "6,3": { "Type": "Door" }, "3,1": { "Type": "Barrel" }, "2,5": { "Type": "Barrel" }, "1,4": { "Type": "Barrel" }, "2,1": { "Type": "Barrel" }, "1,2": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "narrow_noleft": { "name": "narrow_noleft", "w": 1, "h": 1, "primInd": "udr", "index": { "1,1": "udr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1110111\n1100001\n1100000\n1100001\n1110111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.75 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": [], "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_noright": { "name": "narrow_noright", "w": 1, "h": 1, "primInd": "udl", "index": { "1,1": "udl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1110111\n1000011\n0000011\n1000011\n1110111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.75 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": [], "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_noup": { "name": "narrow_noup", "w": 1, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1100001\n1100001\n0000000\n1100001\n1100001\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.75 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": [], "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_nodown": { "name": "narrow_nodown", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "temple", "weight": 50, "grid": "1111111\n1X1X1X1\n0000000\n2222222\n0000000\n1X1X1X1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 3, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 3, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": [], "effectTiles": { "4,2": { "Torch": { "x": 4, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,2": { "Torch": { "x": 2, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "narrow_upright": { "name": "narrow_upright", "w": 1, "h": 1, "primInd": "ur", "index": { "1,1": "ur" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1110111\n1100111\n1100000\n1100011\n1111111\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": [], "effectTiles": { "4,3": { "TorchUnlit": { "x": 4, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_upleft": { "name": "narrow_upleft", "w": 1, "h": 1, "primInd": "ul", "index": { "1,1": "ul" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1110111\n1110011\n0000011\n1100011\n1111111\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": [], "effectTiles": { "2,3": { "TorchUnlit": { "x": 2, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_downleft": { "name": "narrow_downleft", "w": 1, "h": 1, "primInd": "dl", "index": { "1,1": "dl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n,100011\n0000011\n1110011\n1110111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": [], "effectTiles": { "2,2": { "TorchUnlit": { "x": 2, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_downright": { "name": "narrow_downright", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n1100011\n1100000\n1100111\n1110111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": [], "effectTiles": { "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_vert": { "name": "narrow_vert", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1100111\n1100111\n11R0111\n1100111\n1100111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "2,3": { "Type": "Rubble" } }, "effectTiles": { "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_horiz": { "name": "narrow_horiz", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n100R001\n0000000\n1111111\n1111111\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,2": { "Type": "Rubble" } }, "effectTiles": { "2,2": { "TorchUnlit": { "x": 2, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "VertChest": { "name": "VertChest", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111D111\n1120211\n1120211\n112C211\n1120211\n1120211\n111D111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,0": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "3,6": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" } }, "effectTiles": { "4,1": { "Torch": { "x": 4, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["ignite", "hot"] } }, "2,1": { "Torch": { "x": 2, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["ignite", "hot"] } } }, "Skin": [], "inaccessible": [{ "indX1": 1, "indY1": 1, "indX2": 1, "indY2": 1, "dir1": "u", "dir2": "d" }, { "indX1": 1, "indY1": 1, "indX2": 1, "indY2": 1, "dir1": "d", "dir2": "u" }], "tags": ["door", "locked", "chest", "wide"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "wide_horiz": { "name": "wide_horiz", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n0L0L0L0\n0000000\n00L0L00\n1111111\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "1,2": { "Type": "Barrel" }, "2,4": { "Type": "Barrel" }, "3,2": { "Type": "Barrel" }, "4,4": { "Type": "Barrel" }, "5,2": { "Type": "Barrel" } }, "effectTiles": { "2,2": { "TorchUnlit": { "x": 2, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": ["silverchest"], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_vert": { "name": "wide_vert", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100011\n11L0011\n1100L11\n11L0011\n1100L11\n11L0011\n1100011\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "2,3": { "Type": "Barrel" }, "4,2": { "Type": "Barrel" }, "2,1": { "Type": "Barrel" }, "4,4": { "Type": "Barrel" }, "2,5": { "Type": "Barrel" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": ["silverchest"], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "HallCrossWide": { "name": "HallCrossWide", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100011\n1100011\n0000000\n0000000\n0000000\n1100011\n1100011\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [], "Tiles": [], "effectTiles": { "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "HallCrossWideDoors": { "name": "HallCrossWideDoors", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111d111\n1100011\n1000001\nd00000d\n1000001\n1100011\n111d111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [], "Tiles": { "6,3": { "Type": "Door" }, "3,0": { "Type": "Door" }, "3,6": { "Type": "Door" }, "0,3": { "Type": "Door" } }, "effectTiles": { "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "HallCrossWideRoom": { "name": "HallCrossWideRoom", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 15, "grid": "1100011\n1000001\n0010100\n000G000\n0010100\n1000001\n1100011\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" } }, "effectTiles": { "4,3": { "TorchUnlit": { "x": 4, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,5": { "TorchUnlit": { "x": 4, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,5": { "TorchUnlit": { "x": 2, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,3": { "TorchUnlit": { "x": 2, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": ["start"], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "wide_upleft": { "name": "wide_upleft", "w": 1, "h": 1, "primInd": "ul", "index": { "1,1": "ul" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100R11\n1,0R011\n000/R11\n000LL11\n00RLL11\n1111111\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "Barrel" }, "4,4": { "Type": "Barrel" }, "4,3": { "Type": "Barrel" }, "3,4": { "Type": "Barrel" }, "4,2": { "Type": "Rubble" }, "2,4": { "Type": "Rubble" }, "3,1": { "Type": "Rubble" }, "4,0": { "Type": "Rubble" }, "3,2": { "Type": "Debris", "Always": true } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": ["silverchest"], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_upright": { "name": "wide_upright", "w": 1, "h": 1, "primInd": "ur", "index": { "1,1": "ur" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100011\n1100011\n11RR000\n11LLR00\n11LL/00\n1111111\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "4,4": { "Type": "Debris" }, "3,3": { "Type": "Barrel" }, "2,3": { "Type": "Barrel" }, "2,4": { "Type": "Barrel" }, "3,4": { "Type": "Barrel" }, "2,2": { "Type": "Rubble" }, "3,2": { "Type": "Rubble" }, "4,3": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_downleft": { "name": "wide_downleft", "w": 1, "h": 1, "primInd": "dl", "index": { "1,1": "dl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n0RLLL11\n00RL/11\n000LL11\n1100R11\n1100011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "4,2": { "Type": "Barrel" }, "3,2": { "Type": "Barrel" }, "2,2": { "Type": "Barrel" }, "3,3": { "Type": "Barrel" }, "3,4": { "Type": "Barrel" }, "4,4": { "Type": "Barrel" }, "1,2": { "Type": "Rubble" }, "2,3": { "Type": "Rubble" }, "4,5": { "Type": "Rubble" }, "4,3": { "Type": "Debris" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_downright": { "name": "wide_downright", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n11/LLR0\n11RLR00\n110R0L0\n11L0011\n1100011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "4,2": { "Type": "Barrel" }, "3,2": { "Type": "Barrel" }, "3,3": { "Type": "Barrel" }, "5,4": { "Type": "Barrel" }, "2,5": { "Type": "Barrel" }, "5,2": { "Type": "Rubble" }, "4,3": { "Type": "Rubble" }, "3,4": { "Type": "Rubble" }, "2,3": { "Type": "Rubble" }, "2,2": { "Type": "Debris" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_RoomNoLeft": { "name": "wide_RoomNoLeft", "w": 1, "h": 1, "primInd": "udr", "index": { "1,1": "udr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111d111\n1000001\n10+0001\n10OG00d\n10+0001\n1000001\n111d111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "6,3": { "Type": "Door" }, "3,0": { "Type": "Door" }, "3,6": { "Type": "Door" }, "2,2": { "Type": "Charger" }, "2,4": { "Type": "Charger" }, "2,3": { "Type": "ChestOrShrine" }, "3,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" } }, "effectTiles": { "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_RoomNoRight": { "name": "wide_RoomNoRight", "w": 1, "h": 1, "primInd": "udl", "index": { "1,1": "udl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111d111\n1000001\n1000+01\nd00GO01\n1000+01\n1000001\n111d111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,0": { "Type": "Door" }, "3,6": { "Type": "Door" }, "0,3": { "Type": "Door" }, "4,3": { "Type": "ChestOrShrine" }, "4,2": { "Type": "Charger" }, "4,4": { "Type": "Charger" }, "3,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" } }, "effectTiles": { "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_RoomNoDown": { "name": "wide_RoomNoDown", "w": 1, "h": 1, "primInd": "ulr", "index": { "1,1": "ulr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111d111\n1000001\n1000001\nd00G00d\n10+O+01\n1000001\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,0": { "Type": "Door" }, "0,3": { "Type": "Door" }, "6,3": { "Type": "Door" }, "2,4": { "Type": "Charger" }, "4,4": { "Type": "Charger" }, "3,4": { "Type": "ChestOrShrine" }, "3,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" } }, "effectTiles": { "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_RoomNoUp": { "name": "wide_RoomNoUp", "w": 1, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1000001\n10+O+01\nd00G00d\n1000001\n1000001\n111d111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "0,3": { "Type": "Door" }, "6,3": { "Type": "Door" }, "3,6": { "Type": "Door" }, "3,2": { "Type": "ChestOrShrine" }, "2,2": { "Type": "Charger" }, "4,2": { "Type": "Charger" }, "3,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" } }, "effectTiles": { "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "T_Right_Thinvert": { "name": "T_Right_Thinvert", "w": 1, "h": 1, "primInd": "udl", "index": { "1,1": "udl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n111d111\n00L0111\n0000111\n0LL0111\n111d111\n1110111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [], "Tiles": { "3,5": { "Type": "Door" }, "3,1": { "Type": "Door" }, "2,2": { "Type": "Barrel" }, "2,4": { "Type": "Barrel" }, "1,4": { "Type": "Barrel" } }, "effectTiles": { "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "wide_horizDoors": { "name": "wide_horizDoors", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n1000001\nd00000d\n1000001\n1111111\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "6,3": { "Type": "Door" }, "0,3": { "Type": "Door" } }, "effectTiles": { "2,2": { "TorchUnlit": { "x": 2, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "wide_vertDoors": { "name": "wide_vertDoors", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111d111\n1100011\n1100011\n1100011\n1100011\n1100011\n111d111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,0": { "Type": "Door" }, "3,6": { "Type": "Door" } }, "effectTiles": { "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "narrow_noleft_room": { "name": "narrow_noleft_room", "w": 1, "h": 1, "primInd": "udr", "index": { "1,1": "udr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110011\n1111011\n1+01d11\n1O00000\n1+01d11\n1111011\n1110011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "4,4": { "Type": "Door" }, "4,2": { "Type": "Door" }, "1,3": { "Type": "ChestOrShrine" }, "1,2": { "Type": "Charger" }, "1,4": { "Type": "Charger" } }, "effectTiles": { "5,3": { "TorchUnlit": { "x": 5, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "3,3": { "TorchUnlit": { "x": 3, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_noright_room": { "name": "narrow_noright_room", "w": 1, "h": 1, "primInd": "udl", "index": { "1,1": "udl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100111\n1101111\n11d10+1\n00000O1\n11d10+1\n1101111\n1100111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "2,2": { "Type": "Door" }, "2,4": { "Type": "Door" }, "5,3": { "Type": "ChestOrShrine" }, "5,2": { "Type": "Charger" }, "5,4": { "Type": "Charger" } }, "effectTiles": { "3,3": { "TorchUnlit": { "x": 3, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,3": { "TorchUnlit": { "x": 1, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_noup_room": { "name": "narrow_noup_room", "w": 1, "h": 1, "primInd": "udl", "index": { "1,1": "udl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100111\n1101111\n11d10+1\n00000O1\n11d10+1\n1101111\n1100111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "2,2": { "Type": "Door" }, "2,4": { "Type": "Door" }, "5,3": { "Type": "ChestOrShrine" }, "5,2": { "Type": "Charger" }, "5,4": { "Type": "Charger" } }, "effectTiles": { "3,3": { "TorchUnlit": { "x": 3, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,3": { "TorchUnlit": { "x": 1, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_noup_silver": { "name": "narrow_noup_silver", "w": 1, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n11oCo11\n1100011\n0100010\n0d000d0\n111d111\n1110111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,1": { "Type": "Chest", "Loot": "silver", "Priority": true }, "5,4": { "Type": "Door" }, "1,4": { "Type": "Door" }, "3,5": { "Type": "Door" } }, "effectTiles": { "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow", "silverchest"], "forbidTags": ["silverchest"], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [1, 1], "notTags": ["", ""] }, "wide_horiz_chestshrine": { "name": "wide_horiz_chestshrine", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n002O200\n002G200\n0000000\n1111111\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,2": { "Type": "ChestOrShrine" }, "3,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" } }, "effectTiles": { "2,2": { "TorchUnlit": { "x": 2, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "narrow_vert_spawn": { "name": "narrow_vert_spawn", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1X222X1\n1G000G1\n1X2O2X1\n1G000G1\n1X222X1\n1110111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "ChestOrShrine" }, "5,2": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "1,2": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "1,4": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "5,4": { "Type": "Spawn", "required": [], "AI": "looseguard" } }, "effectTiles": { "4,1": { "Torch": { "x": 4, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,1": { "Torch": { "x": 2, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_horiz_spawn": { "name": "narrow_horiz_spawn", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1X222X1\n1G000G1\nd02O00d\n1G000G1\n1X222X1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "ChestOrShrine" }, "6,3": { "Type": "Door" }, "0,3": { "Type": "Door" }, "5,2": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "5,4": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "1,4": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "1,2": { "Type": "Spawn", "required": [], "AI": "looseguard" } }, "effectTiles": { "4,1": { "Torch": { "x": 4, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,1": { "Torch": { "x": 2, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": ["start"], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_uprightOpen": { "name": "narrow_uprightOpen", "w": 1, "h": 1, "primInd": "ur", "index": { "1,1": "ur" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1110111\n1100111\n1?0000d\n1000001\n1XLX111\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 2, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": { "6,3": { "Type": "Door" }, "2,5": { "Type": "Cage", "Furniture": "Cage" } }, "effectTiles": { "4,3": { "TorchUnlit": { "x": 4, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,2": { "TorchUnlit": { "x": 2, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_upleftOpen": { "name": "narrow_upleftOpen", "w": 1, "h": 1, "primInd": "ul", "index": { "1,1": "ul" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n111d111\n1110LL1\n0d00La1\n1120LL1\n1111111\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "5,2": { "Type": "Barrel" }, "5,4": { "Type": "Barrel" }, "4,4": { "Type": "Barrel" }, "4,3": { "Type": "Barrel" }, "4,2": { "Type": "Barrel" }, "1,3": { "Type": "Door" }, "3,1": { "Type": "Door" } }, "effectTiles": { "2,3": { "TorchUnlit": { "x": 2, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_downleftOpen": { "name": "narrow_downleftOpen", "w": 1, "h": 1, "primInd": "dl", "index": { "1,1": "dl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n112B211\n1120211\n0d00011\n112?211\n1120211\n111d111\n", "POI": [], "Keyring": [{ "x": 3, "y": 2 }], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "1,3": { "Type": "Door" }, "3,6": { "Type": "Door" } }, "effectTiles": { "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_downrightOpen": { "name": "narrow_downrightOpen", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1R1LLL1\n1L1g1d1\n1000100\n10L0111\n1000111\n1110111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 2, "y": 4, "type": "furniture", "radius": 1 }], "Tiles": { "2,4": { "Type": "Cage", "Furniture": "Cage" }, "1,2": { "Type": "Barrel", "Always": true }, "5,2": { "Type": "Door" }, "3,1": { "Type": "Barrel" }, "4,1": { "Type": "Barrel" }, "5,1": { "Type": "Barrel" }, "1,1": { "Type": "Rubble" } }, "effectTiles": { "2,3": { "TorchUnlit": { "x": 2, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_vert_dorm": { "name": "narrow_vert_dorm", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111d111\n1C10CB1\n10D00B1\n1010GB1\n1Rb00B1\n1L10RB1\n111d111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "1,1": { "Priority": true }, "2,2": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "4,3": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "1,4": { "Type": "Rubble" }, "1,5": { "Type": "Barrel", "Always": true }, "4,5": { "Type": "Rubble" }, "3,0": { "Type": "Door" }, "3,6": { "Type": "Door" }, "4,1": { "Type": "Chest", "Loot": "storage" } }, "effectTiles": { "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "narrow_horiz_cells": { "name": "narrow_horiz_cells", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1BR0GB1\n11bDb11\n0000000\n1R000L1\n1111111\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,2": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "5,4": { "Type": "Barrel" }, "1,4": { "Type": "Rubble" }, "4,1": { "Type": "Prisoner" }, "2,1": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "1x2_Cells": { "name": "1x2_Cells", "w": 1, "h": 2, "primInd": "dlr", "index": { "1,1": "dlr", "1,2": "ulr" }, "scale": 7, "category": "urban", "weight": 35, "grid": "111,111\n1000001\n10X0L01\nd0G000d\n1021b11\n102bGB1\n102DGB1\n10210B1\n102bGB1\n1021b11\nd00000d\n10L0G01\n1000CB1\n1110111\n", "POI": [], "Keyring": [{ "x": 4, "y": 11 }], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 4, "y": 2, "type": "furniture", "radius": 1 }, { "x": 2, "y": 11, "type": "furniture", "radius": 1 }], "Tiles": { "4,5": { "Type": "Prisoner" }, "4,6": { "Type": "Prisoner" }, "4,8": { "Type": "Prisoner" }, "3,6": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "4,12": { "Type": "Chest" }, "4,2": { "Type": "Cage", "Furniture": "Cage" }, "2,11": { "Type": "Cage", "Furniture": "Cage" }, "6,3": { "Type": "Door" }, "0,3": { "Type": "Door" }, "0,10": { "Type": "Door" }, "6,10": { "Type": "Door" }, "4,11": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" }, "2,3": { "Type": "Spawn", "required": [], "AI": "looseguard" } }, "effectTiles": { "5,5": { "TorchUnlit": { "x": 5, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,1": { "TorchUnlit": { "x": 2, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,10": { "Torch": { "x": 5, "y": 10, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "cells"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 5], "multTags": [1, 1], "notTags": ["", ""] }, "narrow_horizwide": { "name": "narrow_horizwide", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n1111111\n0002000\n000G000\n11g1111\n11000C1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "5,5": { "Type": "Chest" }, "3,3": { "Type": "Spawn", "required": [], "AI": "guard" } }, "effectTiles": { "5,5": { "Torch": { "x": 5, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "3,2": { "TorchUnlit": { "x": 3, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "2wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow", "2wide"], "maxTags": [-1, -1, -1], "bonusTags": [0, 0, 0], "multTags": [0, 2, 2], "notTags": ["", "", ""] }, "narrow_vertWide": { "name": "narrow_vertWide", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100111\n1X00g01\n1100101\n1AGG1/1\n1100101\n1X00g01\n1100111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "2,3": { "Type": "Spawn", "required": [], "AI": "guard" }, "3,3": { "Type": "Spawn", "required": [], "AI": "guard" }, "5,3": { "Type": "Debris" }, "1,3": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": { "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "2wide"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow", "2wide"], "maxTags": [-1, -1, -1], "bonusTags": [0, 0, 0], "multTags": [0, 2, 1], "notTags": ["", "", ""] }, "deadend_dChest": { "name": "deadend_dChest", "w": 1, "h": 1, "primInd": "d", "index": { "1,1": "d" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n11XCX11\n12G2G21\n12X2X21\n1202021\n1102011\n111d111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,6": { "Type": "Door" }, "3,1": { "Type": "Chest" }, "4,2": { "Type": "Spawn", "required": [], "AI": "guard" }, "2,2": { "Type": "Spawn", "required": [], "AI": "guard" } }, "effectTiles": { "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "deadend_uChest": { "name": "deadend_uChest", "w": 1, "h": 1, "primInd": "u", "index": { "1,1": "u" }, "scale": 7, "category": "urban", "weight": 10, "grid": "111D111\n1100011\n120G021\n12XCX21\n1200021\n11+A+11\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,0": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "2,5": { "Type": "Charger" }, "4,5": { "Type": "Charger" }, "3,2": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" }, "3,3": { "Priority": true }, "3,5": { "Type": "Shrine", "Name": "Will", "Priority": true } }, "effectTiles": { "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "open_upright_OpR": { "name": "open_upright_OpR", "w": 1, "h": 1, "primInd": "ur", "index": { "1,1": "ur" }, "scale": 7, "category": "dungeon", "weight": 10, "grid": "1110111\n1100011\n1100000\n1000000\n1RLL000\n1111/00\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "2,4": { "Type": "Barrel" }, "3,4": { "Type": "Barrel" }, "1,4": { "Type": "Rubble" }, "4,5": { "Type": "Debris" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["dungeon", "open"], "forbidTags": [], "requireTags": [], "indexTags": ["R_open"], "maxTags": [-1], "bonusTags": [0], "multTags": [10], "notTags": [""] }, "open_upleft_OpL": { "name": "open_upleft_OpL", "w": 1, "h": 1, "primInd": "ul", "index": { "1,1": "ul" }, "scale": 7, "category": "dungeon", "weight": 10, "grid": "1110111\n1000111\n0000011\n0X0XGO1\n0000021\n1000111\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "5,3": { "Type": "ChestOrShrine" }, "4,3": { "Type": "Spawn", "required": [], "AI": "looseguard" } }, "effectTiles": { "2,1": { "Torch": { "x": 2, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["dungeon", "open"], "forbidTags": [], "requireTags": [], "indexTags": ["L_open"], "maxTags": [-1], "bonusTags": [0], "multTags": [10], "notTags": [""] }, "3x1_corridor": { "name": "3x1_corridor", "w": 3, "h": 1, "primInd": "lr", "index": { "1,1": "lr", "2,1": "lr", "3,1": "lr" }, "scale": 7, "category": "urban", "weight": 70, "grid": "111R11111111111111111\n1+101a11000T000100011\n101b1001g11111g10X011\n0000000021XOX12000000\n101b100X210001200X011\n1+1010002G0G0G2000011\n111R11111111111111111\n", "POI": [], "Keyring": [{ "x": 11, "y": 5 }], "Jail": [{ "x": 3, "y": 34, "type": "furniture", "radius": 1 }, { "x": 31, "y": 5, "type": "furniture", "radius": 1 }, { "x": 25, "y": 25, "type": "jail", "radius": 1 }, { "x": 30, "y": 4, "type": "furniture", "radius": 1 }], "Tiles": { "11,1": { "Type": "Trap", "Always": true }, "9,5": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "13,5": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "11,5": { "Type": "Spawn", "required": [], "AI": "guard" }, "3,6": { "Type": "Rubble" }, "3,0": { "Type": "Rubble" }, "1,5": { "Type": "Charger" }, "1,1": { "Type": "Charger" }, "11,3": { "Type": "ChestOrShrine" } }, "effectTiles": { "15,3": { "TorchUnlit": { "x": 15, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "7,3": { "TorchUnlit": { "x": 7, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "13,5": { "TorchUnlit": { "x": 13, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "9,5": { "TorchUnlit": { "x": 9, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban"], "forbidTags": [], "requireTags": [], "indexTags": ["narrow"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "3x1_splitChamber": { "name": "3x1_splitChamber", "w": 3, "h": 1, "primInd": "lr", "index": { "1,1": "lr", "2,1": "udlr", "3,1": "lr" }, "scale": 7, "category": "urban", "weight": 70, "grid": "11,1111411D1111114,11\n11000200T222T00R00011\n1G000000X2A2X000020G1\nd0L000G0T2C2T0G200L0d\n1G002000X2A2X000020G1\n110000R0T222T02200011\n1111141111D1114111111\n", "POI": [], "Keyring": [{ "x": 6, "y": 3 }, { "x": 14, "y": 3 }], "Jail": [{ "x": 3, "y": 34, "type": "furniture", "radius": 1 }, { "x": 31, "y": 5, "type": "furniture", "radius": 1 }, { "x": 25, "y": 25, "type": "jail", "radius": 1 }, { "x": 30, "y": 4, "type": "furniture", "radius": 1 }, { "x": 18, "y": 3, "type": "furniture", "radius": 1 }, { "x": 2, "y": 3, "type": "furniture", "radius": 1 }], "Tiles": { "10,0": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "10,6": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "20,3": { "Type": "Door" }, "0,3": { "Type": "Door" }, "15,1": { "Type": "Rubble" }, "6,5": { "Type": "Rubble" }, "10,3": { "Type": "Chest", "Loot": "silver", "Priority": true }, "10,2": { "Type": "Shrine", "Name": "Metal" }, "10,4": { "Type": "Shrine", "Name": "Metal" }, "18,3": { "Type": "Cage", "Furniture": "Cage" }, "2,3": { "Type": "Cage", "Furniture": "Cage" }, "8,3": { "Type": "Trap", "Always": true }, "12,3": { "Type": "Trap", "Always": true }, "12,1": { "Type": "Trap", "Always": true }, "12,5": { "Type": "Trap", "Always": true }, "8,5": { "Type": "Trap", "Always": true }, "8,1": { "Type": "Trap", "Always": true }, "6,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" }, "14,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" }, "1,2": { "Type": "Spawn", "required": [], "AI": "guard" }, "1,4": { "Type": "Spawn", "required": [], "AI": "guard" }, "19,2": { "Type": "Spawn", "required": [], "AI": "guard" }, "19,4": { "Type": "Spawn", "required": [], "AI": "guard" } }, "effectTiles": { "11,1": { "Torch": { "x": 11, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "9,1": { "Torch": { "x": 9, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,2": { "Torch": { "x": 1, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "19,2": { "Torch": { "x": 19, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "silverchest"], "forbidTags": [], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [4], "notTags": [""] }, "GuardedChest": { "name": "GuardedChest", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 15, "grid": "1X000X1\nX22222X\n0200020\n020C020\n0200020\nX22222X\n1X000X1\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "GuardedChest" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "chest"], "forbidTags": ["maxchest", "start"], "requireTags": [], "indexTags": ["wide"], "maxTags": [-1], "bonusTags": [0], "multTags": [3], "notTags": [""] }, "SoulCrystal": { "name": "SoulCrystal", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "temple", "weight": 5, "grid": "1000001\n0000000\n00+2+00\n0023200\n00+2+00\n0000000\n1000001\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "Spawn", "required": ["soul", "active"], "tags": ["soul"], "Label": "SoulC_A" }, "2,2": { "Type": "Charger" }, "2,4": { "Type": "Charger" }, "4,4": { "Type": "Charger" }, "4,2": { "Type": "Charger" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["temple"], "forbidTags": ["start"], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Banquet": { "name": "Banquet", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1100LL1\n10000R1\n10F2F01\n00F1F00\n10F2F01\n1000001\n1100011\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,3": { "Type": "Table", "Food": "Plate" }, "5,1": { "Type": "Rubble" }, "5,0": { "Type": "Barrel" }, "4,0": { "Type": "Barrel" }, "2,2": { "Type": "Table", "Food": "Plate" }, "2,4": { "Type": "Table", "Food": "Plate" }, "2,3": { "Type": "Table", "Food": "Plate" }, "4,2": { "Type": "Table", "Food": "Plate" }, "4,4": { "Type": "Table", "Food": "Plate" } }, "effectTiles": { "3,4": { "TorchUnlit": { "x": 3, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "food", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["U_wide", "D_wide"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, 2], "notTags": ["", ""] }, "narrow_vertObst": { "name": "narrow_vertObst", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n10G0001\n1001131\n1G01F01\n1000001\n10000R1\n1110111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "1,3": { "Type": "Spawn", "required": [], "AI": "guard" }, "2,1": { "Type": "Spawn", "required": [], "AI": "guard" }, "4,3": { "Type": "Table", "Food": "Plate" }, "5,5": { "Type": "Rubble" }, "5,2": { "Type": "ForceSpawn", "required": ["obstacledoor"], "tags": ["obstacletile"], "Label": "Door" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "narrow"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [0, 2], "notTags": ["", ""] }, "HallCrossRubble": { "name": "HallCrossRubble", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1110111\n1110111\n1110111\n00000R0\n1110111\n1110111\n1110111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "5,3": { "Type": "Rubble" } }, "effectTiles": { "1,3": { "TorchUnlit": { "x": 1, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "DR_Closet": { "name": "DR_Closet", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n11R0C11\n111D111\n1000000\n1000000\n1100011\n1110111\n", "POI": [], "Keyring": [{ "x": 3, "y": 1 }], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,2": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "4,1": { "Type": "Chest", "Loot": "storage" }, "2,1": { "Type": "Rubble" } }, "effectTiles": { "2,3": { "TorchUnlit": { "x": 2, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,3": { "TorchUnlit": { "x": 4, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban"], "forbidTags": [], "requireTags": [], "indexTags": ["narrow"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "DL_Closet": { "name": "DL_Closet", "w": 1, "h": 1, "primInd": "dl", "index": { "1,1": "dl" }, "scale": 7, "category": "urban", "weight": 10, "grid": "1111111\n11R0C11\n111D111\n0000001\n0000001\n1100011\n1110111\n", "POI": [], "Keyring": [{ "x": 3, "y": 1 }], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }], "Tiles": { "3,2": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "4,1": { "Type": "Chest", "Loot": "storage" }, "2,1": { "Type": "Rubble" } }, "effectTiles": { "2,3": { "TorchUnlit": { "x": 2, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,3": { "TorchUnlit": { "x": 4, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban"], "forbidTags": [], "requireTags": [], "indexTags": ["narrow"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Corridor_Up_1x2": { "name": "Corridor_Up_1x2", "w": 1, "h": 2, "primInd": "dlr", "index": { "1,1": "dlr", "1,2": "ud" }, "scale": 7, "category": "urban", "weight": 60, "grid": "1100111\n1100111\n0000000\n000A000\n1100011\n1120111\n1102111\n1102111\n1100111\n1100111\n1120011\n1120111\n1100111\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": { "4,10": { "TorchUnlit": { "x": 4, "y": 10, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "2wide"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Corridor_UD_1x2": { "name": "Corridor_UD_1x2", "w": 1, "h": 2, "primInd": "ud", "index": { "1,1": "ud", "1,2": "ud" }, "scale": 7, "category": "urban", "weight": 40, "grid": "1100111\n1100111\n1102111\n1100111\n1100011\n1120111\n1102111\n1102111\n1100111\n1100111\n1120011\n1120111\n1100111\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": [], "effectTiles": { "4,4": { "TorchUnlit": { "x": 4, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,10": { "TorchUnlit": { "x": 4, "y": 10, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "2wide"], "forbidTags": [], "requireTags": [], "indexTags": ["U_2wide", "D_2wid"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [5, 5], "notTags": ["", ""] }, "Corridor_LR_1x2": { "name": "Corridor_LR_1x2", "w": 2, "h": 1, "primInd": "lr", "index": { "1,1": "lr", "2,1": "lr" }, "scale": 7, "category": "urban", "weight": 50, "grid": "11111111111111\n11111111111111\n00000000000000\n00000000000000\n111A111111+111\n11111111111111\n11111111111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "10,4": { "Type": "Charger" }, "3,4": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": { "10,2": { "TorchUnlit": { "x": 10, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "3,2": { "TorchUnlit": { "x": 3, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "2wide"], "forbidTags": [], "requireTags": [], "indexTags": ["L_2wide", "R_2wid"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [4, 4], "notTags": ["", ""] }, "HallCrossThicc": { "name": "HallCrossThicc", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 30, "grid": "1100111\n1100111\n0000000\n0000000\n1100111\n1100111\n1100111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["urban"], "used": false, "chance": 0.25 }], "Keyring": [], "Jail": [], "Tiles": [], "effectTiles": { "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "2wide"], "forbidTags": [], "requireTags": [], "indexTags": ["L_2wide", "R_2wide", "U_2wid", "D_2wid"], "maxTags": [-1, -1, -1, -1], "bonusTags": [0, 0, 0, 0], "multTags": [3, 3, 3, 3], "notTags": ["", "", "", ""] }, "jng1": { "name": "jng1", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "0000011\n01000R1\n000X130\n0000100\nX000,10\n1X00010\n1000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "5,1": { "Type": "Rubble" }, "5,2": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" } }, "effectTiles": { "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng2": { "name": "jng2", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "010000X\n000R10X\n0000R00\n0000000\n0000000\n0100100\nX100000\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["jungle"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,1": { "Type": "Rubble" }, "4,2": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng3": { "name": "jng3", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "XX00000\nX0R0010\n0000000\n00X1000\n0000000\n000-100\n0000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "2,1": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_ud_1": { "name": "jng_ud_1", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "0000011\n01000R1\n000X130\n0000100\nX000110\n1X00010\n1000000\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["jungle"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "5,1": { "Type": "Rubble" }, "5,2": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" } }, "effectTiles": { "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_lr_1": { "name": "jng_lr_1", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "XXX0X0X\nX0X0X30\n0000000\n0000000\n0300030\nX3000XX\nX0XX0X0\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["jungle"], "used": false, "chance": 0.5 }], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "5,1": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "1,4": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "1,5": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "5,4": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_ul_1": { "name": "jng_ul_1", "w": 1, "h": 1, "primInd": "ul", "index": { "1,1": "ul" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "0000000\n0000000\n00000L0\n0000LL1\n0000111\n00LL111\n0111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["jungle"], "used": false, "chance": 0.5 }], "Keyring": [{ "x": 3, "y": 4 }], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "5,3": { "Type": "Barrel" }, "5,2": { "Type": "Barrel" }, "4,3": { "Type": "Barrel" }, "3,5": { "Type": "Barrel" }, "2,5": { "Type": "Barrel" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_ur_1": { "name": "jng_ur_1", "w": 1, "h": 1, "primInd": "ur", "index": { "1,1": "ur" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "0000000\n0000000\n0303000\nX0X0000\nXX3XX00\n1XX3000\n11XXXX0\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "2,4": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "3,5": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "1,2": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "3,2": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_dl_1": { "name": "jng_dl_1", "w": 1, "h": 1, "primInd": "dl", "index": { "1,1": "dl" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "0001111\n0001C01\n0001101\n00001g1\n0000000\n0000000\n0000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "4,1": { "Type": "Chest", "Loot": "silver", "Priority": true } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_dr_1": { "name": "jng_dr_1", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "1111100\n11X0300\n11X0X00\n1130000\n1X03000\n1000000\n0000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "4,1": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "2,3": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "3,4": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_noR_1": { "name": "jng_noR_1", "w": 1, "h": 1, "primInd": "udl", "index": { "1,1": "udl" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "0000001\n00000X1\n000Xo01\n0X00001\n0000XA1\n00X0XX1\n0000011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "5,4": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_noL_1": { "name": "jng_noL_1", "w": 1, "h": 1, "primInd": "udr", "index": { "1,1": "udr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "1000000\n1X0X000\nXR00000\n1XX0000\n4XXX000\n1RX0000\n1100000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "1,5": { "Type": "Rubble" }, "1,2": { "Type": "Rubble" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_noU_1": { "name": "jng_noU_1", "w": 1, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "1111111\n111111X\n031X100\n00XR130\n0030000\n0000000\n0000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "Rubble" }, "1,2": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "5,3": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" }, "2,4": { "Type": "Spawn", "required": ["mushroom", "scenery"], "tags": ["mushroom"], "Label": "Mushroom" } }, "effectTiles": {}, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng_noD_1": { "name": "jng_noD_1", "w": 1, "h": 1, "primInd": "ulr", "index": { "1,1": "ulr" }, "scale": 7, "category": "jungle", "weight": 10, "grid": "0000000\n0000000\n0000000\n011G110\n0100010\n01RCR11\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "ForceSpawn", "required": ["obstacledoor"], "tags": ["obstacletile"], "Label": "Door" }, "3,5": { "Priority": true }, "4,5": { "Type": "Rubble" }, "2,5": { "Type": "Rubble" } }, "effectTiles": { "4,4": { "TorchUnlit": { "x": 4, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,4": { "TorchUnlit": { "x": 2, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "HallCrossDisplay": { "name": "HallCrossDisplay", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "urban", "weight": 25, "grid": "1110111\n1100011\n1000001\n000L000\n1000001\n1100011\n1110111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 3, "y": 3, "type": "furniture", "radius": 1 }], "Tiles": { "3,3": { "Type": "DisplayStand", "Furniture": "DisplayStand" } }, "effectTiles": { "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": [], "inaccessible": [], "tags": ["urban", "narrow"], "forbidTags": [], "requireTags": [], "indexTags": ["egyptian"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": [""] }, "wide_tombH": { "name": "wide_tombH", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "temple", "weight": 100, "grid": "1111111\n1L1X1L1\n0000000\n2222222\n0000000\n1X1L1X1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 3, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 3, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "3,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "4,2": { "Torch": { "x": 4, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,2": { "Torch": { "x": 2, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombV": { "name": "wide_tombV", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "temple", "weight": 100, "grid": "1102011\n1L020X1\n1102011\n1X020L1\n1102011\n1L020X1\n1102011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }, { "x": 5, "y": 3, "type": "furniture", "radius": 1 }, { "x": 1, "y": 3, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "1,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,3": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "1,3": { "Torch": { "x": 1, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,3": { "Torch": { "x": 5, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,1": { "Torch": { "x": 5, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,1": { "Torch": { "x": 1, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,5": { "Torch": { "x": 1, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,5": { "Torch": { "x": 5, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombX": { "name": "wide_tombX", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "temple", "weight": 250, "grid": "1102011\n1X020L1\n0002000\n2222222\n0002000\n1L020X1\n1102011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": { "5,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "1,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "5,1": { "Torch": { "x": 5, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,1": { "Torch": { "x": 1, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombXFull": { "name": "wide_tombXFull", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "temple", "weight": 100, "grid": "1102011\n1X020X1\n0002000\n2222222\n0002000\n1X020X1\n1102011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": [], "effectTiles": { "5,1": { "Torch": { "x": 5, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,1": { "Torch": { "x": 1, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombXEmpty": { "name": "wide_tombXEmpty", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "scale": 7, "category": "temple", "weight": 50, "grid": "1102011\n1L020L1\n0002000\n2222222\n0002000\n1L020L1\n1102011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "1,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "5,1": { "Torch": { "x": 5, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,1": { "Torch": { "x": 1, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombVMost": { "name": "wide_tombVMost", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "temple", "weight": 100, "grid": "1102011\n1L020X1\n1102011\n1X020X1\n1102011\n1X020X1\n1102011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }, { "x": 5, "y": 3, "type": "furniture", "radius": 1 }, { "x": 1, "y": 3, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "1,3": { "Torch": { "x": 1, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,3": { "Torch": { "x": 5, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,1": { "Torch": { "x": 5, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,1": { "Torch": { "x": 1, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,5": { "Torch": { "x": 1, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,5": { "Torch": { "x": 5, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombVEmpty": { "name": "wide_tombVEmpty", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "temple", "weight": 50, "grid": "1102011\n1L020L1\n1102011\n1L020L1\n1102011\n1L020L1\n1102011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }, { "x": 5, "y": 3, "type": "furniture", "radius": 1 }, { "x": 1, "y": 3, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "1,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,3": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "1,3": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "1,3": { "Torch": { "x": 1, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,3": { "Torch": { "x": 5, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,1": { "Torch": { "x": 5, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,1": { "Torch": { "x": 1, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,5": { "Torch": { "x": 1, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,5": { "Torch": { "x": 5, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombVFull": { "name": "wide_tombVFull", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "scale": 7, "category": "temple", "weight": 50, "grid": "1102011\n1X020X1\n1102011\n1X020X1\n1102011\n1X020X1\n1102011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }, { "x": 5, "y": 3, "type": "furniture", "radius": 1 }, { "x": 1, "y": 3, "type": "furniture", "radius": 1 }], "Tiles": [], "effectTiles": { "1,3": { "Torch": { "x": 1, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,3": { "Torch": { "x": 5, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,1": { "Torch": { "x": 5, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,1": { "Torch": { "x": 1, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,5": { "Torch": { "x": 1, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,5": { "Torch": { "x": 5, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombHEmpty": { "name": "wide_tombHEmpty", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "temple", "weight": 50, "grid": "1111111\n1L1L1L1\n0000000\n2222222\n0000000\n1L1L1L1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 3, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 3, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "3,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "5,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "3,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" }, "1,5": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "4,2": { "Torch": { "x": 4, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,2": { "Torch": { "x": 2, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombHMost": { "name": "wide_tombHMost", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "temple", "weight": 100, "grid": "1111111\n1L1X1X1\n0000000\n2222222\n0000000\n1X1X1X1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 3, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 3, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "Furniture", "Furniture": "DisplayEgyptian" } }, "effectTiles": { "4,2": { "Torch": { "x": 4, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,2": { "Torch": { "x": 2, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "wide_tombHFull": { "name": "wide_tombHFull", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "temple", "weight": 50, "grid": "1111111\n1X1X1X1\n0000000\n2222222\n0000000\n1X1X1X1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 3, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 3, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": [], "effectTiles": { "4,2": { "Torch": { "x": 4, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,2": { "Torch": { "x": 2, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "test": { "name": "test", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "scale": 7, "category": "temple", "weight": 50, "grid": "1111111\n1X1X1X1\n0000000\n2222222\n0000000\n1X1X1X1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 13, "y": 32, "type": "jail", "radius": 1 }, { "x": 1, "y": 1, "type": "furniture", "radius": 1 }, { "x": 3, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 1, "type": "furniture", "radius": 1 }, { "x": 5, "y": 5, "type": "furniture", "radius": 1 }, { "x": 3, "y": 5, "type": "furniture", "radius": 1 }, { "x": 1, "y": 5, "type": "furniture", "radius": 1 }], "Tiles": [], "effectTiles": { "4,2": { "Torch": { "x": 4, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,2": { "Torch": { "x": 2, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": [], "inaccessible": [], "tags": ["temple", "wide", "egyptian"], "forbidTags": [], "requireTags": [], "indexTags": ["wide", "egyptian"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [2, -1], "notTags": ["", "1"] }, "Market": { "name": "Market", "w": 2, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "2,1": "udlr", "2,2": "udlr" }, "flexEdge": { "2,2": "y", "1,2": "y", "1,1": "y", "2,1": "y" }, "flexEdgeSuper": { "1,1": "y", "2,1": "y", "2,2": "y", "1,2": "y" }, "scale": 7, "category": "urban", "weight": 500, "grid": "00000000000000\n01101100111010\n01F0F10010L010\n000G000000G000\n01F0F100100F10\n01101100100110\n00000000000000\n0000000G000000\n01F0FF00FFF0F0\n01L00F00F00010\n01LG0000003L10\n01FGF000F00F10\n011111001F0110\n00000000000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 2, "y": 10, "type": "furniture", "radius": 1 }, { "x": 2, "y": 9, "type": "furniture", "radius": 1 }, { "x": 10, "y": 2, "type": "furniture", "radius": 1 }, { "x": 11, "y": 10, "type": "furniture", "radius": 1 }], "Tiles": { "8,8": { "Type": "Table" }, "9,8": { "Type": "Table" }, "10,8": { "Type": "Table" }, "12,8": { "Type": "Table" }, "8,11": { "Type": "Table" }, "8,9": { "Type": "Table" }, "9,12": { "Type": "Table" }, "11,11": { "Type": "Table", "Food": "Plate" }, "11,10": { "Type": "DisplayStand", "Furniture": "DisplayStand" }, "2,11": { "Type": "Table", "Food": "Plate" }, "3,11": { "Type": "Prisoner" }, "2,8": { "Type": "Table" }, "2,9": { "Type": "Cage", "Furniture": "Cage" }, "2,10": { "Type": "Cage", "Furniture": "Cage" }, "4,8": { "Type": "Table" }, "5,8": { "Type": "Table" }, "5,9": { "Type": "Table" }, "4,2": { "Type": "Table", "Food": "Plate" }, "2,2": { "Type": "Table", "Food": "Plate" }, "2,4": { "Type": "Table", "Food": "Plate" }, "4,4": { "Type": "Table", "Food": "Plate" }, "10,2": { "Type": "DisplayStand", "Furniture": "DisplayStand" }, "11,4": { "Type": "Table" }, "4,11": { "Type": "Table", "Food": "Plate" }, "3,10": { "Type": "Spawn", "required": [] }, "3,3": { "Type": "Spawn", "required": [] }, "10,3": { "Type": "Spawn", "required": [] }, "7,7": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" }, "10,10": { "Type": "Spawn", "required": ["dressmaker"], "Label": "dressmaker", "tags": ["dressmaker"], "Chance": 1, "AI": "guard", "force": "true" } }, "effectTiles": { "8,6": { "Torch": { "x": 8, "y": 6, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "12,6": { "Torch": { "x": 12, "y": 6, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,6": { "Torch": { "x": 1, "y": 6, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,6": { "Torch": { "x": 5, "y": 6, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,3": { "Torch": { "x": 5, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "12,3": { "Torch": { "x": 12, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,13": { "Torch": { "x": 5, "y": 13, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "8,13": { "Torch": { "x": 8, "y": 13, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "12,13": { "Torch": { "x": 12, "y": 13, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,13": { "Torch": { "x": 1, "y": 13, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "1,3": { "Torch": { "x": 1, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["urban", "market"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": [""] }, "Shoppe": { "name": "Shoppe", "w": 2, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr", "2,1": "udlr" }, "flexEdge": { "2,1": "y", "1,1": "y" }, "flexEdgeSuper": { "2,1": "y", "1,1": "y" }, "scale": 7, "category": "urban", "weight": 30, "grid": "00000000000000\n0LL11110L11110\n0111FGD00D0L10\n0d00F01D110L10\n01100G10B1LC10\n0L111111111110\n00000000000000\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,3": { "Type": "Table" }, "4,2": { "Type": "Table" }, "7,3": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "6,2": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "9,2": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "11,4": { "Type": "Chest", "Lock": "Red" }, "10,4": { "Type": "Barrel", "OffLimits": true }, "11,3": { "Type": "Barrel", "OffLimits": true }, "11,2": { "Type": "Barrel", "OffLimits": true }, "5,2": { "Type": "Spawn", "required": [] }, "5,4": { "Type": "Spawn", "required": [] }, "1,3": { "Type": "Door" }, "8,1": { "Type": "Barrel" }, "7,4": { "OffLimits": true }, "10,2": { "OffLimits": true }, "10,3": { "OffLimits": true }, "2,1": { "Type": "Barrel" }, "1,1": { "Type": "Barrel" }, "1,5": { "Type": "Barrel" } }, "effectTiles": { "4,2": { "Torch": { "x": 4, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "8,4": { "Torch": { "x": 8, "y": 4, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["urban"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Prison": { "name": "Prison", "w": 2, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "2,1": "udlr", "2,2": "udlr" }, "flexEdge": { "2,2": "y", "2,1": "y", "1,1": "y", "1,2": "y" }, "flexEdgeSuper": { "2,2": "y", "2,1": "y", "1,1": "y", "1,2": "y" }, "scale": 7, "category": "urban", "weight": 900, "grid": "00000000000000\n01111b11111110\n01B0D01B01CC10\n01G0b01FG10010\n011b1G11d1bD10\n01B0D0d00000G0\n01G0b0111d1110\n011b1d1FL0LF10\n01CL001G0G0G10\n0100001FFFFF10\n01GF00D0000010\n01111110000010\n0000001b1d1b10\n00000000000000\n", "POI": [], "Keyring": [{ "x": 10, "y": 8 }], "Jail": [], "Tiles": { "9,12": { "Type": "Door" }, "6,10": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "7,9": { "Type": "Table" }, "8,9": { "Type": "Table" }, "9,9": { "Type": "Table" }, "10,9": { "Type": "Table" }, "11,9": { "Type": "Table" }, "6,5": { "Type": "Door" }, "11,4": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Purple", "OffLimits": true }, "9,6": { "Type": "Door", "OffLimits": true }, "8,4": { "Type": "Door", "OffLimits": true }, "3,10": { "Type": "Table" }, "7,7": { "Type": "Table", "Food": "Plate" }, "11,7": { "Type": "Table", "Food": "Plate" }, "7,3": { "Type": "Table", "Food": "Plate" }, "4,5": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red", "OffLimits": true }, "4,2": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red", "OffLimits": true }, "2,6": { "Type": "Prisoner", "OffLimits": true }, "2,3": { "Type": "Prisoner" }, "2,8": { "Type": "Chest" }, "11,2": { "Type": "Chest", "Lock": "Blue" }, "7,8": { "Type": "Spawn", "required": [], "OffLimits": true }, "11,8": { "Type": "Spawn", "required": [], "OffLimits": true }, "9,8": { "Type": "Spawn", "required": [], "OffLimits": true }, "8,3": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard", "OffLimits": true }, "5,4": { "Type": "Spawn", "required": [], "OffLimits": true }, "3,8": { "Type": "Barrel" }, "8,7": { "Type": "Barrel", "OffLimits": true }, "10,7": { "Type": "Barrel", "OffLimits": true }, "5,7": { "Type": "Door", "OffLimits": true }, "2,10": { "Type": "Spawn", "required": [], "OffLimits": true }, "7,10": { "OffLimits": false }, "7,11": { "OffLimits": false }, "5,10": { "OffLimits": true }, "5,8": { "OffLimits": true }, "5,9": { "OffLimits": true }, "4,8": { "OffLimits": true }, "4,9": { "OffLimits": true }, "4,10": { "OffLimits": true }, "3,9": { "OffLimits": true }, "2,9": { "OffLimits": true }, "3,6": { "OffLimits": true }, "3,5": { "OffLimits": true }, "5,6": { "OffLimits": true }, "5,5": { "OffLimits": true }, "3,2": { "OffLimits": true }, "3,3": { "OffLimits": true }, "5,2": { "OffLimits": true }, "5,3": { "OffLimits": true }, "7,5": { "OffLimits": true }, "8,5": { "OffLimits": true }, "9,5": { "OffLimits": true }, "4,4": { "OffLimits": false }, "10,5": { "OffLimits": true }, "11,5": { "OffLimits": true }, "8,2": { "OffLimits": true }, "10,3": { "OffLimits": true }, "11,3": { "OffLimits": true }, "7,2": { "OffLimits": true }, "2,2": { "OffLimits": true }, "2,5": { "OffLimits": true }, "9,7": { "OffLimits": true }, "8,8": { "OffLimits": true }, "10,8": { "OffLimits": true }, "4,3": { "OffLimits": false }, "10,2": { "Priority": true }, "12,5": { "Type": "ForceSpawn", "required": ["obstacledoor"], "tags": ["obstacletile"], "Label": "Door" } }, "effectTiles": { "8,7": { "Torch": { "x": 8, "y": 7, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "10,7": { "Torch": { "x": 10, "y": 7, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "9,5": { "Torch": { "x": 9, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "8,2": { "Torch": { "x": 8, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "11,2": { "Torch": { "x": 11, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "3,2": { "Torch": { "x": 3, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "3,5": { "Torch": { "x": 3, "y": 5, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "4,8": { "Torch": { "x": 4, "y": 8, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "8,13": { "Torch": { "x": 8, "y": 13, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "10,13": { "Torch": { "x": 10, "y": 13, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["urban", "prison"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "cyb_WolfCampS": { "name": "cyb_WolfCampS", "w": 3, "h": 3, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "1,3": "udlr", "2,1": "udlr", "2,2": "udlr", "2,3": "udlr", "3,1": "udlr", "3,2": "udlr", "3,3": "udlr" }, "flexEdge": { "1,3": "y", "2,3": "y", "3,3": "y", "3,2": "y", "3,1": "y", "2,1": "y", "1,1": "y", "1,2": "y" }, "flexEdgeSuper": { "1,3": "y", "2,3": "y", "3,3": "y", "3,2": "y", "3,1": "y", "2,1": "y", "1,1": "y", "1,2": "y" }, "scale": 7, "category": "urban", "weight": 500, "grid": "000000000000000000000\n011111111111111111110\n010TTTTTD000LG01L0B10\n01CTTTTT10F000F1B0010\n010TTTTT10GF0FG100B10\n01111111100G0G0d0G010\n01B0B000d000000100B10\n0100000L10?00?01B0010\n01B0B00G1L0000L1L0B10\n01111d11111d111111110\n0b00G0G0b0020000L0L10\n0b000000b0G2G00000010\n0b000000d222000000010\n0b000000b0G2GL0L0L010\n0b000000b002000000010\n0b000000b002000000010\n01bbbbbb1bbDbb1bbbb10\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 1, "y": 7, "type": "furniture", "radius": 1 }, { "x": 16, "y": 10, "type": "furniture", "radius": 1 }, { "x": 18, "y": 10, "type": "furniture", "radius": 1 }, { "x": 12, "y": 2, "type": "furniture", "radius": 1 }], "Tiles": { "11,16": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "8,12": { "Type": "Door" }, "8,2": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Purple" }, "8,6": { "Type": "Door" }, "4,2": { "Type": "Trap", "OffLimits": true }, "5,2": { "Type": "Trap", "OffLimits": true }, "7,2": { "Type": "Trap", "OffLimits": true }, "5,3": { "Type": "Trap", "OffLimits": true }, "6,3": { "Type": "Trap", "OffLimits": true }, "7,3": { "Type": "Trap", "OffLimits": true }, "7,7": { "Type": "Barrel" }, "15,5": { "Type": "Door" }, "11,9": { "Type": "Door" }, "14,3": { "Type": "Table", "Food": "Plate" }, "13,4": { "Type": "Table", "Food": "Plate" }, "11,4": { "Type": "Table", "Food": "Plate" }, "10,3": { "Type": "Table", "Food": "Plate" }, "5,9": { "Type": "Door" }, "9,8": { "Type": "Barrel" }, "14,8": { "Type": "Barrel" }, "16,8": { "Type": "Barrel" }, "16,2": { "Type": "Barrel" }, "16,10": { "Type": "Cage", "Furniture": "Cage" }, "18,10": { "Type": "Cage", "Furniture": "Cage" }, "13,13": { "Type": "Barrel" }, "15,13": { "Type": "Barrel" }, "17,13": { "Type": "Barrel" }, "2,3": { "Type": "Chest", "Lock": "Blue", "OffLimits": true }, "4,4": { "Type": "Trap", "OffLimits": true }, "6,4": { "Type": "Trap", "OffLimits": true }, "7,4": { "Type": "Trap", "OffLimits": true }, "3,4": { "Type": "Trap", "OffLimits": true }, "10,11": { "Type": "Spawn", "required": [], "AI": "guard" }, "12,11": { "Type": "Spawn", "required": [], "AI": "guard" }, "12,13": { "Type": "Spawn", "required": [], "AI": "guard" }, "10,13": { "Type": "Spawn", "required": [], "AI": "guard" }, "14,4": { "Type": "Spawn", "required": [], "AI": "guard" }, "13,5": { "Type": "Spawn", "required": [], "AI": "guard" }, "11,5": { "Type": "Spawn", "required": [], "AI": "guard" }, "10,4": { "Type": "Spawn", "required": [], "AI": "guard" }, "13,2": { "Type": "Prisoner" }, "12,2": { "Type": "DisplayStand", "Furniture": "DisplayStand" }, "17,5": { "Type": "Spawn", "required": ["miniboss"], "AI": "guard" }, "7,8": { "Type": "Prisoner" }, "4,10": { "Type": "Prisoner" }, "6,10": { "Type": "Prisoner" }, "3,2": { "Type": "Trap", "OffLimits": true }, "4,3": { "Type": "Trap", "OffLimits": true }, "3,3": { "Type": "Trap", "OffLimits": true }, "6,2": { "Type": "Trap", "OffLimits": true }, "5,4": { "Type": "Trap", "OffLimits": true }, "2,2": { "OffLimits": true }, "2,4": { "OffLimits": true } }, "effectTiles": { "14,17": { "Torch": { "x": 14, "y": 17, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "8,17": { "Torch": { "x": 8, "y": 17, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "17,2": { "Torch": { "x": 17, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "14,2": { "Torch": { "x": 14, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "9,2": { "Torch": { "x": 9, "y": 2, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "10,10": { "Torch": { "x": 10, "y": 10, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "12,10": { "Torch": { "x": 12, "y": 10, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "7,10": { "Torch": { "x": 7, "y": 10, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,10": { "Torch": { "x": 2, "y": 10, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "5,6": { "Torch": { "x": 5, "y": 6, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "17,10": { "Torch": { "x": 17, "y": 10, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["urban", "wolfgirl"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "cyb_PetTrack": { "name": "cyb_PetTrack", "w": 3, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "2,1": "udlr", "2,2": "udlr", "3,1": "udlr", "3,2": "udlr" }, "flexEdge": { "1,1": "y", "1,2": "y", "2,2": "y", "3,2": "y", "3,1": "y", "2,1": "y" }, "flexEdgeSuper": { "1,2": "y", "1,1": "y", "2,2": "y", "3,2": "y", "3,1": "y", "2,1": "y" }, "scale": 7, "category": "urban", "weight": 250, "grid": "100000000000000000001\n100000000000000000001\n1001bbbbbbdbbbbbb1001\n000b2222222222222b000\n100b2222222222222b001\n100b22001bdb10022b001\n100b2200bG0Gb0022b001\n100b22G0b00Gb0G22b001\n100b22001bdb10022b001\n100b2222222222222b001\n000b2222222222222b000\n1001bbbbbbdbbbbbb1001\n100000000000000000001\n100000000000000000001\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "10,8": { "Type": "Door" }, "10,11": { "Type": "Door" }, "10,2": { "Type": "Door" }, "10,5": { "Type": "Door" }, "14,7": { "Type": "Spawn", "required": [] }, "6,7": { "Type": "Spawn", "required": [] }, "11,7": { "Type": "Spawn", "required": [] }, "9,6": { "Type": "Prisoner" }, "11,6": { "Type": "Prisoner" } }, "effectTiles": { "12,9": { "Torch": { "x": 12, "y": 9, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "8,9": { "Torch": { "x": 8, "y": 9, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "8,3": { "Torch": { "x": 8, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "12,3": { "Torch": { "x": 12, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "16,3": { "Torch": { "x": 16, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "4,3": { "Torch": { "x": 4, "y": 3, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["urban", "pet"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "pyro_ruinedHall": { "name": "pyro_ruinedHall", "w": 4, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr", "2,1": "udlr", "3,1": "udlr", "4,1": "udlr" }, "flexEdge": { "4,1": "y", "1,1": "y", "3,1": "y", "2,1": "y" }, "flexEdgeSuper": { "4,1": "y", "3,1": "y", "2,1": "y", "1,1": "y" }, "scale": 7, "category": "temple", "weight": 4000, "grid": "1100011110001111000111100011\n100004bb40001bb40001bb400004\n00X00-CL-TG0-LG+TR0+LL-T0X00\n00000T0GT0/GTR0T000TRGT00000\n0L000+0/+T0T-0/-00L-0T+T0000\n1000014410004114000114100001\n1100011110001111000111100011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 20, "y": 2, "type": "furniture", "radius": 1 }, { "x": 21, "y": 2, "type": "furniture", "radius": 1 }], "Tiles": { "20,3": { "Type": "Rubble" }, "7,4": { "Type": "Debris" }, "10,3": { "Type": "Debris" }, "15,2": { "Type": "Charger" }, "8,4": { "Type": "Charger" }, "5,4": { "Type": "Charger" }, "19,2": { "Type": "Charger" }, "22,4": { "Type": "Charger" }, "13,2": { "Type": "Barrel" }, "18,4": { "Type": "Barrel" }, "14,4": { "Type": "Debris", "Always": true }, "13,3": { "Type": "Rubble" }, "17,2": { "Type": "Rubble" }, "9,2": { "Type": "Trap" }, "23,2": { "Type": "Trap" }, "23,4": { "Type": "Trap" }, "16,2": { "Type": "Trap" }, "11,4": { "Type": "Trap" }, "9,4": { "Type": "Trap" }, "5,3": { "Type": "Trap" }, "8,3": { "Type": "Trap" }, "12,3": { "Type": "Trap" }, "15,3": { "Type": "Trap" }, "22,3": { "Type": "Trap" }, "19,3": { "Type": "Trap" }, "11,3": { "Type": "Spawn", "required": [] }, "10,2": { "Type": "Spawn", "required": [] }, "6,2": { "Type": "Chest" }, "7,3": { "Type": "Spawn", "required": [] }, "21,3": { "Type": "Spawn", "required": [], "AI": "guard" }, "14,2": { "Type": "Spawn", "required": [] }, "1,4": { "Type": "Barrel" }, "7,2": { "Type": "Barrel" }, "21,4": { "Type": "Trap" }, "20,2": { "Type": "Cage", "Furniture": "Cage" }, "21,2": { "Type": "Cage", "Furniture": "Cage" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "long", "hall"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": ["1"] }, "TempleHall_1x2": { "name": "TempleHall_1x2", "w": 1, "h": 2, "primInd": "ud", "index": { "1,1": "ud", "1,2": "ud" }, "flexEdge": {}, "scale": 7, "category": "temple", "weight": 200, "grid": "4b101b1\nLL+0+0L\nRL0000L\nLR00111\n/000141\n11401A1\n11100TL\n1A1000L\n0T00111\n00L0411\nL0001A1\nR0000T0\n/R+0+00\n1b101b4\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "4,1": { "Type": "Charger" }, "2,1": { "Type": "Charger" }, "2,12": { "Type": "Charger" }, "4,12": { "Type": "Charger" }, "5,10": { "Type": "Shrine", "Name": "Metal" }, "1,7": { "Type": "Shrine", "Name": "Metal" }, "5,5": { "Type": "Shrine", "Name": "Metal" }, "5,11": { "Type": "Trap" }, "5,6": { "Type": "Trap" }, "1,8": { "Type": "Trap" }, "1,12": { "Type": "Rubble" }, "0,11": { "Type": "Rubble" }, "0,12": { "Type": "Debris" }, "0,10": { "Type": "Barrel" }, "2,9": { "Type": "Barrel" }, "0,1": { "Type": "Barrel" }, "1,1": { "Type": "Barrel" }, "1,2": { "Type": "Barrel" }, "0,2": { "Type": "Rubble" }, "0,3": { "Type": "Barrel" }, "1,3": { "Type": "Rubble" }, "0,4": { "Type": "Debris" }, "6,6": { "Type": "Barrel" }, "6,7": { "Type": "Barrel" }, "6,2": { "Type": "Barrel" }, "6,1": { "Type": "Barrel" } }, "effectTiles": { "4,6": { "TorchUnlit": { "x": 4, "y": 6, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,11": { "TorchUnlit": { "x": 4, "y": 11, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,8": { "TorchUnlit": { "x": 2, "y": 8, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": ["1"] }, "TempleHall_2x1": { "name": "TempleHall_2x1", "w": 2, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr", "2,1": "dlr" }, "flexEdge": { "1,1": "y", "2,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "temple", "weight": 200, "grid": "11111111111111\n1R1111C=1111R1\n001A102201A100\n0032G0220G2300\n00021111112000\n1000Xo00oX0001\n11000000000011\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "10,2": { "Type": "Shrine", "Name": "Metal" }, "3,2": { "Type": "Shrine", "Name": "Metal" }, "6,1": { "Type": "Chest", "Loot": "silver", "Priority": true }, "2,3": { "Type": "Spawn", "required": ["statue"], "Label": "Statue" }, "11,3": { "Type": "Spawn", "required": ["statue"], "Label": "Statue" }, "9,3": { "Type": "ForceSpawn", "required": ["obstacledoor"], "tags": ["obstacletile"], "Label": "Door", "OffLimits": true }, "4,3": { "Type": "ForceSpawn", "required": ["obstacledoor"], "tags": ["obstacletile"], "Label": "Door", "OffLimits": true }, "7,1": { "Type": "Charger", "NoRemove": false }, "12,1": { "Type": "Rubble" }, "1,1": { "Type": "Rubble" }, "5,3": { "OffLimits": true }, "5,2": { "OffLimits": true }, "6,2": { "OffLimits": true }, "7,2": { "OffLimits": true }, "8,2": { "OffLimits": true }, "8,3": { "OffLimits": true }, "7,3": { "OffLimits": true }, "6,3": { "OffLimits": true } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "TempleHall_End": { "name": "TempleHall_End", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 70, "grid": "X2X2X2X\n2000002\nX01b10X\n201C102\nX01310X\n2000002\nX2X2X2X\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Priority": true }, "3,4": { "Type": "Spawn", "required": ["statue"], "Label": "Statue" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide", "chest"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "TempleHall_Hub": { "name": "TempleHall_Hub", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 70, "grid": "X01d10X\n0222220\n1200021\nd20+02d\n1200021\n0222220\nX01d10X\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "0,3": { "Type": "Door" }, "3,0": { "Type": "Door" }, "3,6": { "Type": "Door" }, "6,3": { "Type": "Door" }, "3,3": { "Type": "Charger" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "TempleHall_Field": { "name": "TempleHall_Field", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 70, "grid": "0202020\n2X2X2X2\n0202020\n2X232X2\n0202020\n2X2X2X2\n0202000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "Spawn", "required": ["soul"], "Label": "soul", "tags": ["soul"], "Chance": 0.4, "AI": "guard", "force": "true" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide", "open"], "forbidTags": ["start"], "requireTags": [], "indexTags": ["temple", "open"], "maxTags": [-1, -1], "bonusTags": [0, 0], "multTags": [1, 0], "notTags": ["1", "1"] }, "TempleHall_UR": { "name": "TempleHall_UR", "w": 1, "h": 1, "primInd": "ur", "index": { "1,1": "ur" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 35, "grid": "111d111\n1222221\n1200021\n120A02d\n1200021\n1222221\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,0": { "Type": "Door" }, "6,3": { "Type": "Door" }, "3,3": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "TempleHall_UL": { "name": "TempleHall_UL", "w": 1, "h": 1, "primInd": "ul", "index": { "1,1": "ul" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 35, "grid": "111d111\n1222221\n1200021\nd20A021\n1200021\n1222221\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,0": { "Type": "Door" }, "3,3": { "Type": "Shrine", "Name": "Metal" }, "0,3": { "Type": "Door" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "TempleHall_DL": { "name": "TempleHall_DL", "w": 1, "h": 1, "primInd": "dl", "index": { "1,1": "dl" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 35, "grid": "1111111\n1222221\n1200021\nd20A021\n1200021\n1222221\n111d111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "Shrine", "Name": "Metal" }, "0,3": { "Type": "Door" }, "3,6": { "Type": "Door" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "TempleHall_DR": { "name": "TempleHall_DR", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 35, "grid": "1111111\n1222221\n1200021\n120A02d\n1200021\n1222221\n111d111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,3": { "Type": "Shrine", "Name": "Metal" }, "3,6": { "Type": "Door" }, "6,3": { "Type": "Door" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "TempleHall_MultiShrine": { "name": "TempleHall_MultiShrine", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "temple", "weight": 20, "grid": "X01d10X\n0222220\n12A0A21\nd20002d\n12A0A21\n0222220\nX01d10X\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "0,3": { "Type": "Door" }, "3,0": { "Type": "Door" }, "3,6": { "Type": "Door" }, "6,3": { "Type": "Door" }, "2,2": { "Type": "Shrine", "Name": "Metal" }, "4,2": { "Type": "Shrine", "Name": "Metal" }, "4,4": { "Type": "Shrine", "Name": "Metal" }, "2,4": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": ["1"] }, "jng4": { "name": "jng4", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "jungle", "weight": 15, "grid": "0000000\n01TAT10\n00TFT00\n00TTT00\n0000000\n00R0000\n0000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "3,2": { "Type": "Table", "Food": "Plate" }, "3,1": { "Type": "Shrine", "Name": "Metal" }, "2,1": { "Type": "Trap" }, "2,2": { "Type": "Trap" }, "2,3": { "Type": "Trap" }, "3,3": { "Type": "Trap" }, "4,3": { "Type": "Trap" }, "4,2": { "Type": "Trap" }, "4,1": { "Type": "Trap" }, "2,5": { "Type": "Rubble" } }, "effectTiles": { "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "jng5": { "name": "jng5", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "jungle", "weight": 7, "grid": "0000000\n0111100\n01C0100\n0100D00\n01B0100\n011g100\n0000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 24, "y": 41, "type": "furniture", "radius": 1 }, { "x": 47, "y": 10, "type": "furniture", "radius": 1 }, { "x": 45, "y": 19, "type": "furniture", "radius": 1 }, { "x": 3, "y": 33, "type": "furniture", "radius": 1 }, { "x": 39, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "2,2": { "Priority": true, "OffLimits": true }, "4,3": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "3,2": { "OffLimits": true }, "3,3": { "OffLimits": true }, "3,4": { "OffLimits": true }, "2,4": { "OffLimits": true }, "2,3": { "OffLimits": true } }, "effectTiles": { "3,2": { "TorchUnlit": { "x": 3, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["jungle"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "TempleSanctum": { "name": "TempleSanctum", "w": 2, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "2,1": "udlr", "2,2": "udlr" }, "flexEdge": { "1,2": "y", "2,2": "y", "2,1": "y", "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "temple", "weight": 1000, "grid": "11000141100011\n1m000222200Rm4\n00000100400000\n0R0X142211X000\n00011A22A11000\n1211A2222A1121\n4202220C222021\n120222G0222021\n1211A2222A1421\n00014A22A11000\n000X112241XR00\n000/0100400000\n1m0002222000m1\n11000141100041\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "5,4": { "Type": "Shrine", "Name": "Metal" }, "4,5": { "Type": "Shrine", "Name": "Metal" }, "8,4": { "Type": "Shrine", "Name": "Metal" }, "9,5": { "Type": "Shrine", "Name": "Metal" }, "8,9": { "Type": "Shrine", "Name": "Metal" }, "4,8": { "Type": "Shrine", "Name": "Metal" }, "5,9": { "Type": "Shrine", "Name": "Metal" }, "6,7": { "Type": "Spawn", "required": ["boss"], "AI": "guard" }, "9,8": { "Type": "Shrine", "Name": "Metal" }, "11,1": { "Type": "Rubble" }, "1,3": { "Type": "Rubble" }, "11,10": { "Type": "Rubble" }, "3,11": { "Type": "Debris" }, "7,6": { "Priority": true } }, "effectTiles": { "11,6": { "TorchUnlit": { "x": 11, "y": 6, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,6": { "TorchUnlit": { "x": 2, "y": 6, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,9": { "TorchUnlit": { "x": 2, "y": 9, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "11,9": { "TorchUnlit": { "x": 11, "y": 9, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "8,12": { "TorchUnlit": { "x": 8, "y": 12, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,12": { "TorchUnlit": { "x": 5, "y": 12, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "8,1": { "TorchUnlit": { "x": 8, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": ["1"] }, "TempleSanctumGuarded": { "name": "TempleSanctumGuarded", "w": 2, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "2,1": "udlr", "2,2": "udlr" }, "flexEdge": { "1,2": "y", "2,2": "y", "1,1": "y", "2,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "temple", "weight": 1000, "grid": "11000141100011\n1m0002222000m4\n0000L100400000\n000X142211X000\n00011a22A11R00\n1211AG00Ga1121\n420220G0022021\n12022000022021\n1211oG00GC11D1\n00-14+22C11C04\n000X1122410000\n0000R1004L00,0\n1m000222g0G0G0\n11000141400000\n", "POI": [], "Keyring": [{ "x": 10, "y": 10 }], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "4,5": { "Type": "Shrine", "Name": "Metal" }, "8,4": { "Type": "Shrine", "Name": "Metal" }, "8,9": { "Priority": true }, "5,9": { "Type": "Charger" }, "9,8": { "Type": "Chest", "Lock": "Blue" }, "11,9": { "Type": "Chest", "Loot": "storage" }, "9,11": { "Type": "Barrel" }, "4,2": { "Type": "Barrel" }, "11,4": { "Type": "Rubble" }, "4,11": { "Type": "Rubble" }, "10,12": { "Type": "Spawn", "required": [], "AI": "guard" }, "5,5": { "Type": "Spawn", "required": [] }, "5,8": { "Type": "Spawn", "required": [] }, "8,8": { "Type": "Spawn", "required": [] }, "8,5": { "Type": "Spawn", "required": [] }, "6,6": { "Type": "Spawn", "required": [], "AI": "guard" }, "12,12": { "Type": "Prisoner" }, "12,8": { "Type": "Door", "Priority": true, "AlwaysClose": true } }, "effectTiles": { "2,6": { "TorchUnlit": { "x": 2, "y": 6, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "11,6": { "TorchUnlit": { "x": 11, "y": 6, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,12": { "TorchUnlit": { "x": 5, "y": 12, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "8,12": { "TorchUnlit": { "x": 8, "y": 12, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "8,1": { "TorchUnlit": { "x": 8, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "10,10": { "Torch": { "x": 10, "y": 10, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "wide"], "forbidTags": [], "requireTags": [], "indexTags": ["temple"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": ["1"] }, "TempleChamber": { "name": "TempleChamber", "w": 1, "h": 2, "primInd": "ud", "index": { "1,1": "ud", "1,2": "ud" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "temple", "weight": 400, "grid": "111D111\n1110111\n1100011\n1100011\n1000001\n1300031\n+00+00+\n+00+00+\n1300031\n1000001\n1100011\n1100011\n1110111\n111D111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 28, "y": 10, "type": "furniture", "radius": 1 }, { "x": 29, "y": 10, "type": "furniture", "radius": 1 }, { "x": 17, "y": 5, "type": "furniture", "radius": 1 }, { "x": 18, "y": 25, "type": "jail", "radius": 1 }], "Tiles": { "1,5": { "Type": "Spawn", "required": ["statue"], "Label": "Statue" }, "5,5": { "Type": "Spawn", "required": ["statue"], "Label": "Statue" }, "5,8": { "Type": "Spawn", "required": ["statue"], "Label": "Statue" }, "1,8": { "Type": "Spawn", "required": ["statue"], "Label": "Statue" }, "6,6": { "Type": "Charger" }, "6,7": { "Type": "Charger" }, "0,6": { "Type": "Charger" }, "0,7": { "Type": "Charger" }, "3,6": { "Type": "Charger" }, "3,7": { "Type": "Charger" }, "3,0": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "3,13": { "Type": "Door", "Priority": true, "AlwaysClose": true } }, "effectTiles": { "5,4": { "TorchUnlit": { "x": 5, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "6,6": { "TorchUnlit": { "x": 6, "y": 6, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,2": { "TorchUnlit": { "x": 4, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,2": { "TorchUnlit": { "x": 2, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,4": { "TorchUnlit": { "x": 1, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["temple", "hall", "narrow"], "forbidTags": [], "requireTags": ["orrery"], "indexTags": ["orrery"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": ["1"] }, "ShopStart": { "name": "ShopStart", "w": 2, "h": 1, "primInd": "r", "index": { "1,1": "r", "2,1": "l" }, "flexEdge": { "2,1": "y", "1,1": "y" }, "flexEdgeSuper": { "2,1": "y", "1,1": "y" }, "scale": 7, "category": "unavailable", "weight": 10, "grid": "1111111LL,1111\n1L0m001LL/1000\n1L0000D000D000\n1L00F01D111000\n0000F010BL1000\n1LL0FL10001000\n11111111111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 9, "y": 4, "type": "furniture", "radius": 1 }], "Tiles": { "4,3": { "Type": "Table" }, "7,3": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "6,2": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "8,1": { "Type": "Barrel" }, "4,4": { "Type": "Table" }, "4,5": { "Type": "Table" }, "5,5": { "Type": "Barrel" }, "7,1": { "Type": "Barrel" }, "7,0": { "Type": "Barrel" }, "8,0": { "Type": "Barrel" }, "10,2": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "9,1": { "Type": "Debris", "Always": true }, "9,4": { "Type": "Cage", "Furniture": "Cage" }, "2,5": { "Type": "Barrel" }, "1,5": { "Type": "Barrel" }, "1,1": { "Type": "Barrel" }, "1,2": { "Type": "Barrel" }, "1,3": { "Type": "Barrel" } }, "effectTiles": { "8,4": { "Torch": { "x": 8, "y": 4, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "2,1": { "Torch": { "x": 2, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "4,1": { "Torch": { "x": 4, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } }, "12,1": { "Torch": { "x": 12, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["unavailable"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Conveyor_+": { "name": "Conveyor_+", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 50, "grid": "1111111\n1tVVVVu\n1122211\nd00000d\n1122211\nuVVVVt1\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "6,3": { "Type": "Door" }, "0,3": { "Type": "Door" }, "1,1": { "Type": "DollTerminal" }, "5,5": { "Type": "DollTerminal" }, "0,5": { "Type": "DollSupply" }, "6,1": { "Type": "DollSupply" }, "2,1": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "3,1": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "4,1": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "5,1": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "1,5": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "2,5": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "3,5": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "4,5": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 } }, "effectTiles": { "1,3": { "TorchUnlit": { "x": 1, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,3": { "TorchUnlit": { "x": 5, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": [], "requireTags": [], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": ["1"] }, "Conveyor_+2": { "name": "Conveyor_+2", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 50, "grid": "1111111\nuVVVVt1\n1122211\nd00000d\n1122211\n1tVVVVu\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "6,3": { "Type": "Door" }, "0,3": { "Type": "Door" }, "0,1": { "Type": "DollSupply" }, "6,5": { "Type": "DollSupply" }, "1,5": { "Type": "DollTerminal" }, "5,1": { "Type": "DollTerminal" }, "1,1": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "2,1": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "3,1": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "4,1": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "5,5": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "4,5": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "3,5": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "2,5": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 } }, "effectTiles": { "5,3": { "TorchUnlit": { "x": 5, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,3": { "TorchUnlit": { "x": 1, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": [], "requireTags": [], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [0], "notTags": ["1"] }, "Conveyor_LongLatex": { "name": "Conveyor_LongLatex", "w": 2, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr", "2,1": "udlr" }, "flexEdge": { "2,1": "y", "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 400, "grid": "11001111110011\n10000000000001\n00uVVNVV110000\n0005000N110000\n0000000VVNVVVV\n1000000000000t\n11001111110011\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "11,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "2,2": { "Type": "DollSupply" }, "3,2": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "4,2": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "6,2": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "9,4": { "Type": "BondageMachine", "Binding": "Latex" }, "10,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "8,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "7,2": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "7,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "5,2": { "Type": "BondageMachine", "Binding": "Latex" }, "7,3": { "Type": "BondageMachine", "Binding": "Latex" }, "13,5": { "Type": "DollTerminal" }, "12,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "13,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,3": { "Type": "DollDropoff", "Sprite": "Floor", "Overlay": "DollDropoff" } }, "effectTiles": { "8,4": { "TorchUnlit": { "x": 8, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": [""] }, "Conveyor_LongLatex2": { "name": "Conveyor_LongLatex2", "w": 2, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr", "2,1": "udlr" }, "flexEdge": { "2,1": "y", "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 400, "grid": "11001111110011\n10005000000001\n00VVVu1tVVVV00\n00V11111111V00\n00VVVNVNVNVV00\n10000000000000\n11001111110011\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "7,4": { "Type": "BondageMachine", "Binding": "Latex" }, "5,4": { "Type": "BondageMachine", "Binding": "Latex" }, "9,4": { "Type": "BondageMachine", "Binding": "Latex" }, "10,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "11,4": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "11,3": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "11,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "10,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "9,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "8,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "5,2": { "Type": "DollSupply" }, "7,2": { "Type": "DollTerminal" }, "8,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "6,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "4,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "3,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "2,4": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "2,3": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,2": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "4,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "3,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "4,1": { "Type": "DollDropoff", "Sprite": "Floor", "Overlay": "DollDropoffD", "direction": { "x": 0, "y": 1 } } }, "effectTiles": { "3,4": { "TorchUnlit": { "x": 3, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "10,4": { "TorchUnlit": { "x": 10, "y": 4, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": [""] }, "Conveyor_LongMetal": { "name": "Conveyor_LongMetal", "w": 1, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr" }, "flexEdge": { "1,2": "y", "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 500, "grid": "1110111\n1100011\n1000001\n0022200\n10VVu01\n10V11g1\n10N1C01\n10V1C01\n10V11g1\n10VVt01\n0022200\n1000001\n1100011\n1110111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,6": { "Type": "Chest", "Loot": "storage" }, "4,7": { "Type": "Chest", "Loot": "storage" }, "2,7": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,8": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,9": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "3,9": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "2,5": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,6": { "Type": "BondageMachine", "Binding": "Metal" }, "2,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,4": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "4,4": { "Type": "DollSupply" }, "4,9": { "Type": "DollTerminal" } }, "effectTiles": { "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "3,9": { "TorchUnlit": { "x": 3, "y": 9, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": [""] }, "Conveyor_LongChastity": { "name": "Conveyor_LongChastity", "w": 1, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "ulr" }, "flexEdge": { "1,2": "y", "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 600, "grid": "1110111\n1100011\n1000001\nd02t20d\n1R0V001\n1R1N101\n1LLV001\n1LRNG01\n1L0V001\n1R1N101\nd02V20d\n105N001\n1uVV001\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,7": { "Type": "Spawn", "required": [], "AI": "guard" }, "2,6": { "Type": "Barrel" }, "2,7": { "Type": "Rubble" }, "1,5": { "Type": "Rubble" }, "1,6": { "Type": "Barrel", "Always": true }, "1,7": { "Type": "Barrel", "Always": true }, "1,8": { "Type": "Barrel" }, "1,4": { "Type": "Rubble" }, "1,9": { "Type": "Rubble" }, "3,6": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,7": { "Type": "BondageMachine", "Binding": "Plug" }, "3,8": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,9": { "Type": "BondageMachine", "Binding": "Metal" }, "3,10": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,3": { "Type": "DollTerminal" }, "3,5": { "Type": "BondageMachine", "Binding": "Chastity" }, "3,4": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,11": { "Type": "BondageMachine", "Binding": "Metal" }, "6,10": { "Type": "Door" }, "0,10": { "Type": "Door" }, "0,3": { "Type": "Door" }, "6,3": { "Type": "Door" }, "1,12": { "Type": "DollSupply" }, "2,12": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "3,12": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "2,11": { "Type": "DollDropoff", "Sprite": "Floor", "Overlay": "DollDropoffD", "direction": { "x": 0, "y": 1 } } }, "effectTiles": { "5,2": { "TorchUnlit": { "x": 5, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,2": { "TorchUnlit": { "x": 1, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,6": { "Torch": { "x": 4, "y": 6, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": [], "requireTags": ["factory", "arousalMode"], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": [""] }, "Conveyor_TapeFacility": { "name": "Conveyor_TapeFacility", "w": 2, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "2,1": "udlr", "2,2": "udlr" }, "flexEdge": { "2,2": "y", "2,1": "y", "1,1": "y", "1,2": "y" }, "flexEdgeSuper": { "1,2": "y", "2,1": "y", "1,1": "y", "2,2": "y" }, "scale": 7, "category": "factory", "weight": 500, "grid": "00000000000000\n0220XXuVVVVVu0\n02202200VV5220\n00002200NN0000\n01112200VV01C0\n01Cb2222NN0000\n010b2222VV0000\n010D0000NN0000\n010b0000VV0000\n0111L000NN01C0\n00000000VV0000\n0220tVVNVV0220\n0220tVVNVV0220\n0G000000000000\n", "POI": [], "Keyring": [], "Jail": [{ "x": 4, "y": 9, "type": "furniture", "radius": 1 }], "Tiles": { "4,9": { "Type": "DisplayStand", "Furniture": "DisplayStand" }, "1,13": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "12,4": { "Type": "Chest", "Loot": "storage" }, "12,9": { "Type": "Chest", "Loot": "storage" }, "8,3": { "Type": "BondageMachine", "Binding": "Tape" }, "8,5": { "Type": "BondageMachine", "Binding": "Tape" }, "8,7": { "Type": "BondageMachine", "Binding": "Tape" }, "8,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "8,6": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "9,6": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "9,8": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "8,8": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "8,9": { "Type": "BondageMachine", "Binding": "Tape" }, "9,9": { "Type": "BondageMachine", "Binding": "Tape" }, "9,3": { "Type": "BondageMachine", "Binding": "Tape" }, "8,2": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "9,2": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "8,1": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "7,1": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "6,1": { "Type": "DollSupply" }, "9,5": { "Type": "BondageMachine", "Binding": "Tape" }, "9,7": { "Type": "BondageMachine", "Binding": "Tape" }, "9,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "9,10": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "8,11": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "9,12": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "8,12": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "5,11": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "5,12": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "7,11": { "Type": "BondageMachine", "Binding": "Latex" }, "7,12": { "Type": "BondageMachine", "Binding": "Latex" }, "9,11": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "8,10": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "4,11": { "Type": "DollTerminal" }, "4,12": { "Type": "DollTerminal" }, "6,11": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "6,12": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "3,7": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Purple" }, "2,5": { "Type": "Chest", "Loot": "silver", "Priority": true }, "9,1": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "10,1": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "11,1": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "12,1": { "Type": "DollSupply" }, "10,2": { "Type": "DollDropoff", "Sprite": "Floor", "Overlay": "DollDropoff" } }, "effectTiles": { "11,5": { "TorchUnlit": { "x": 11, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "11,10": { "TorchUnlit": { "x": 11, "y": 10, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,10": { "TorchUnlit": { "x": 2, "y": 10, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "2,5": { "TorchUnlit": { "x": 2, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_Shrine1": { "name": "Bellows_Shrine1", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 60, "grid": "1X000X1\n1000001\n00VVV00\n00VAV00\n00t+u00\n1000001\n1X000X1\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "Shrine", "Name": "Will", "Priority": true }, "4,3": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "2,2": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,3": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "4,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "3,2": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "3,4": { "Type": "Charger" }, "4,4": { "Type": "DollSupply" }, "2,4": { "Type": "DollTerminal" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": ["start"], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_Shrine2": { "name": "Bellows_Shrine2", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "bellows", "weight": 50, "grid": "0000000\n0011110\n0110O10\n0b=0010\n01b1D10\n2X2X222\n0000000\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,2": { "Type": "ChestOrShrine" }, "4,4": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "2,3": { "Type": "Charger", "NoRemove": false } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": ["start"], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_Shrine3": { "name": "Bellows_Shrine3", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "bellows", "weight": 50, "grid": "0000000\n0011000\n0022200\n0422210\n002A240\n04040m0\n0000000\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,4": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": { "3,2": { "TorchUnlit": { "x": 3, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": ["start"], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_T_noU": { "name": "Bellows_T_noU", "w": 1, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "bellows", "weight": 70, "grid": "1X111X1\n12g0RC1\n1211111\n0000000\n0000000\n1000001\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "5,1": { "Type": "Chest" }, "4,1": { "Type": "Rubble" } }, "effectTiles": { "2,3": { "TorchUnlit": { "x": 2, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,3": { "TorchUnlit": { "x": 4, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": ["start"], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_LR": { "name": "Bellows_LR", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 120, "grid": "11,1111\n1CRggR1\n1bb1101\n00L0L00\n2222222\n1111111\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "2,1": { "Type": "Rubble" }, "5,1": { "Type": "Rubble" }, "4,3": { "Type": "Barrel" }, "2,3": { "Type": "Barrel" }, "1,1": { "Type": "Chest" } }, "effectTiles": { "3,3": { "TorchUnlit": { "x": 3, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_LR_pris": { "name": "Bellows_LR_pris", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 12, "grid": "11,1111\n1G0gg01\n1bb1101\n0000000\n2222222\n1111111\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "1,1": { "Type": "Prisoner" } }, "effectTiles": { "3,3": { "TorchUnlit": { "x": 3, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_UR": { "name": "Bellows_UR", "w": 1, "h": 1, "primInd": "ur", "index": { "1,1": "ur" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 100, "grid": "1000001\n10TF000\n1011110\n10R0LT0\n1011110\n10TCL00\n1111111\n", "POI": [], "Keyring": [{ "x": 4, "y": 1 }], "Jail": [], "Tiles": { "2,5": { "Type": "Trap" }, "5,3": { "Type": "Trap" }, "2,1": { "Type": "Trap" }, "3,1": { "Type": "Table" }, "3,5": { "Type": "Chest", "Lock": "Red" }, "4,3": { "Type": "Barrel" }, "4,5": { "Type": "Barrel" }, "2,3": { "Type": "Rubble" } }, "effectTiles": { "6,1": { "TorchUnlit": { "x": 6, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_UD": { "name": "Bellows_UD", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 120, "grid": "1000001\n11100R1\n1?400L1\n10100R1\n10100R1\n1000001\n1000001\n", "POI": [], "Keyring": [], "Jail": [{ "x": 5, "y": 2, "type": "furniture", "radius": 1 }], "Tiles": { "5,1": { "Type": "Rubble" }, "5,4": { "Type": "Rubble" }, "5,3": { "Type": "Rubble" }, "5,2": { "Type": "Cage", "Furniture": "Cage" } }, "effectTiles": { "2,5": { "TorchUnlit": { "x": 2, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_DR": { "name": "Bellows_DR", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 100, "grid": "1111111\n1CL0LR1\n1TRLRR1\n1000000\n1000000\n1L00RR1\n1100111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 4, "y": 1, "type": "furniture", "radius": 1 }], "Tiles": { "4,1": { "Type": "Cage", "Furniture": "Cage" }, "1,1": { "Type": "Chest" }, "2,1": { "Type": "Barrel" }, "3,2": { "Type": "Barrel" }, "1,5": { "Type": "Barrel" }, "5,1": { "Type": "Rubble" }, "5,2": { "Type": "Rubble" }, "4,2": { "Type": "Rubble" }, "5,5": { "Type": "Rubble" }, "4,5": { "Type": "Rubble" }, "2,2": { "Type": "Rubble" }, "1,2": { "Type": "Trap", "Always": true } }, "effectTiles": { "3,1": { "TorchUnlit": { "x": 3, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_UL": { "name": "Bellows_UL", "w": 1, "h": 1, "primInd": "ul", "index": { "1,1": "ul" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 120, "grid": "111d111\n0000bX1\n0+00bX1\n0200bC1\n0200b01\n0000GR1\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,0": { "Type": "Door" }, "5,3": { "Type": "Chest", "Lock": "Blue" }, "4,5": { "Type": "ForceSpawn", "required": ["obstacledoor"], "tags": ["obstacletile"], "Label": "Door" }, "5,5": { "Type": "Rubble" }, "1,2": { "Type": "Charger" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_DL": { "name": "Bellows_DL", "w": 1, "h": 1, "primInd": "dl", "index": { "1,1": "dl" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 80, "grid": "1111111\n1FF00C1\n11b10G1\nd00b001\n1001bD1\n10T0001\n111d111\n", "POI": [], "Keyring": [{ "x": 4, "y": 1 }], "Jail": [], "Tiles": { "2,5": { "Type": "Trap" }, "2,1": { "Type": "Table", "Food": "Plate" }, "1,1": { "Type": "Table" }, "5,4": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "5,2": { "Type": "Spawn", "required": [], "AI": "guard" }, "5,1": { "Type": "Chest" }, "3,6": { "Type": "Door" }, "0,3": { "Type": "Door" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Factory_T_noU": { "name": "Factory_T_noU", "w": 1, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 90, "grid": "1111X11\n1000201\n1222221\n0000000\n0000000\n1100111\n1100111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["factory"], "used": false }], "Keyring": [], "Jail": [], "Tiles": {}, "effectTiles": { "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Factory_T_noD": { "name": "Factory_T_noD", "w": 1, "h": 1, "primInd": "ulr", "index": { "1,1": "ulr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 25, "grid": "1100111\n1000201\n1222X21\n0000200\n0000200\n1000201\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["factory"], "used": false }], "Keyring": [], "Jail": [], "Tiles": {}, "effectTiles": { "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Factory_T_noR": { "name": "Factory_T_noR", "w": 1, "h": 1, "primInd": "udl", "index": { "1,1": "udl" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 10, "grid": "1100111\n1000221\n10G02X1\n0000221\n00G02X1\n1000221\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "2,2": { "Type": "Spawn", "required": [] }, "2,4": { "Type": "Spawn", "required": [] } }, "effectTiles": { "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Factory_T_noL": { "name": "Factory_T_noL", "w": 1, "h": 1, "primInd": "udr", "index": { "1,1": "udr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 10, "grid": "1100,11\n1200201\n12G0201\n120020d\n12G0201\n1200201\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "2,2": { "Type": "Spawn", "required": [] }, "2,4": { "Type": "Spawn", "required": [] }, "6,3": { "Type": "Door" } }, "effectTiles": { "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Conveyor_LongTape": { "name": "Conveyor_LongTape", "w": 1, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr" }, "flexEdge": { "1,2": "y", "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 300, "grid": "1100111\n1000001\n1000t01\n00u0V00\n00V0N00\n10N0V01\n1CV0N11\n11N0VC1\n10V0N01\n10N0V01\nd0V0u0d\n10t0001\n1000001\n111d111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,4": { "Type": "BondageMachine", "Binding": "Tape" }, "4,6": { "Type": "BondageMachine", "Binding": "Tape" }, "2,7": { "Type": "BondageMachine", "Binding": "Tape" }, "2,9": { "Type": "BondageMachine", "Binding": "Tape" }, "4,8": { "Type": "BondageMachine", "Binding": "Tape" }, "4,7": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "4,5": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "4,3": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "2,3": { "Type": "DollSupply" }, "2,5": { "Type": "BondageMachine", "Binding": "Tape" }, "2,6": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,8": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,10": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "4,10": { "Type": "DollSupply" }, "4,9": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "4,2": { "Type": "DollTerminal" }, "2,11": { "Type": "DollTerminal" }, "5,7": { "Type": "Chest" }, "1,6": { "Type": "Chest" }, "6,10": { "Type": "Door" }, "0,10": { "Type": "Door" }, "3,13": { "Type": "Door" } }, "effectTiles": { "1,8": { "TorchUnlit": { "x": 1, "y": 8, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,7": { "TorchUnlit": { "x": 5, "y": 7, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "chest", "conveyor"], "forbidTags": ["start"], "requireTags": ["factory"], "indexTags": ["bellows"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": [""] }, "IndustrialHallV": { "name": "IndustrialHallV", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 80, "grid": "1100111\n11222X1\n1100111\n11222X1\n1100111\n11222X1\n1100111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["industrial"], "used": false }], "Keyring": [], "Jail": [], "Tiles": {}, "effectTiles": { "4,3": { "TorchUnlit": { "x": 4, "y": 3, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,1": { "TorchUnlit": { "x": 4, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "4,5": { "TorchUnlit": { "x": 4, "y": 5, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHallH": { "name": "IndustrialHallH", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 80, "grid": "1111111\n11222X1\n1100201\n0000+00\n0000200\n11222X1\n1100111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["industrial"], "used": false }], "Keyring": [], "Jail": [], "Tiles": { "4,3": { "Type": "Charger" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_U": { "name": "IndustrialHall_U", "w": 1, "h": 1, "primInd": "u", "index": { "1,1": "u" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 30, "grid": "111D111\n1CL0/C1\n1L00001\n1011101\n100R001\n1/11101\n1000R01\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,0": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "5,1": { "Type": "Chest", "Loot": "storage", "Chance": 0.8 }, "1,2": { "Type": "Barrel" }, "1,1": { "Type": "Chest" }, "2,1": { "Type": "Barrel" }, "3,4": { "Type": "Rubble" }, "4,6": { "Type": "Rubble" }, "4,1": { "Type": "Debris" }, "1,5": { "Type": "Debris" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_D": { "name": "IndustrialHall_D", "w": 1, "h": 1, "primInd": "d", "index": { "1,1": "d" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 30, "grid": "1111111\n1uu0RR1\n1000OR1\n10G0001\n1X00O01\n1X00001\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,2": { "Type": "ChestOrShrine" }, "4,4": { "Type": "ChestOrShrine" }, "1,1": { "Type": "DollSupply" }, "2,1": { "Type": "DollSupply" }, "2,3": { "Type": "Spawn", "required": [], "AI": "looseguard" }, "5,1": { "Type": "Rubble" }, "4,1": { "Type": "Rubble" }, "5,2": { "Type": "Rubble" } }, "effectTiles": { "3,1": { "Torch": { "x": 3, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_L": { "name": "IndustrialHall_L", "w": 1, "h": 1, "primInd": "l", "index": { "1,1": "l" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 25, "grid": "1111111\n1RRRRR1\n1000001\n0000L01\n0000LL1\n1X0LLO1\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,5": { "Type": "Barrel" }, "5,4": { "Type": "Barrel" }, "4,4": { "Type": "Barrel" }, "3,5": { "Type": "Barrel" }, "4,3": { "Type": "Barrel" }, "5,5": { "Type": "ChestOrShrine" }, "2,1": { "Type": "Rubble" }, "3,1": { "Type": "Rubble" }, "4,1": { "Type": "Rubble" }, "5,1": { "Type": "Rubble" }, "1,1": { "Type": "Rubble" } }, "effectTiles": { "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_R": { "name": "IndustrialHall_R", "w": 1, "h": 1, "primInd": "r", "index": { "1,1": "r" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 50, "grid": "1111111\n1tRLRR1\n1V00001\n1V00000\n1000001\n1ALRLR1\n1111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 4, "y": 5, "type": "furniture", "radius": 1 }, { "x": 3, "y": 1, "type": "furniture", "radius": 1 }], "Tiles": { "1,1": { "Type": "DollTerminal" }, "4,5": { "Type": "DisplayStand", "Furniture": "DisplayStand" }, "3,1": { "Type": "Cage", "Furniture": "Cage" }, "5,5": { "Type": "Rubble" }, "2,5": { "Type": "Barrel", "Always": true }, "3,5": { "Type": "Rubble" }, "4,1": { "Type": "Rubble" }, "5,1": { "Type": "Rubble" }, "2,1": { "Type": "Rubble" }, "1,2": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "1,3": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "1,5": { "Type": "Shrine", "Name": "Metal" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["industrial", "conveyor", "shrine"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_U_poi": { "name": "IndustrialHall_U_poi", "w": 1, "h": 1, "primInd": "u", "index": { "1,1": "u" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 80, "grid": "111D111\n1000001\n1000001\n1000001\n1000001\n1000001\n1000001\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["industrial"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": { "3,0": { "Type": "Door", "Priority": true, "AlwaysClose": true } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_R_poi": { "name": "IndustrialHall_R_poi", "w": 1, "h": 1, "primInd": "r", "index": { "1,1": "r" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 80, "grid": "1111111\n1000001\n1000001\n1000000\n1000001\n1000001\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["industrial"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": {}, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_L_poi": { "name": "IndustrialHall_L_poi", "w": 1, "h": 1, "primInd": "l", "index": { "1,1": "l" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 80, "grid": "1111111\n1000001\n1000001\n0000L01\n0000LL1\n100LL01\n1111111\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["industrial"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": { "4,5": { "Type": "Barrel" }, "5,4": { "Type": "Barrel" }, "4,4": { "Type": "Barrel" }, "3,5": { "Type": "Barrel" }, "4,3": { "Type": "Barrel" } }, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "IndustrialHall_D_poi": { "name": "IndustrialHall_D_poi", "w": 1, "h": 1, "primInd": "d", "index": { "1,1": "d" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "industrial", "weight": 80, "grid": "1111111\n1000RR1\n1000001\n1000001\n1000001\n1000001\n1100111\n", "POI": [{ "x": 3, "y": 3, "requireTags": ["endpoint"], "favor": ["industrial"], "used": false, "chance": 1 }], "Keyring": [], "Jail": [], "Tiles": { "5,1": { "Type": "Rubble" }, "4,1": { "Type": "Rubble" } }, "effectTiles": { "3,1": { "Torch": { "x": 3, "y": 1, "name": "Torch", "duration": 9999, "priority": 5, "brightness": 6, "lightColor": 16746803, "yoffset": -1, "tags": ["hot"] } } }, "Skin": {}, "inaccessible": [], "tags": ["industrial"], "forbidTags": [], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Factory_+": { "name": "Factory_+", "w": 1, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 35, "grid": "1100111\n1000001\n1222221\n0000000\n0000000\n1000001\n1100111\n", "POI": [{ "x": 3, "y": 3, "requireTags": [], "favor": ["factory"], "used": false, "chance": 0.75 }], "Keyring": [], "Jail": [], "Tiles": {}, "effectTiles": { "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Factory_ButtonTest": { "name": "Factory_ButtonTest", "w": 1, "h": 1, "primInd": "dlr", "index": { "1,1": "dlr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 10, "grid": "1111111\n1C00001\n1uVVt01\n00T@T00\n00TTT00\n1m000m1\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "EffectTile", "Tile": "Wire" }, "2,2": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "3,2": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "4,2": { "Type": "DollTerminal" }, "1,2": { "Type": "DollSupply", "count": 0, "wireType": "increment", "rate": 3 }, "3,4": { "Type": "Trap" }, "4,3": { "Type": "Trap" }, "2,3": { "Type": "Trap" }, "2,4": { "Type": "Trap" }, "4,4": { "Type": "Trap" }, "1,1": { "Type": "Chest" } }, "effectTiles": { "3,3": { "Wire": { "x": 3, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,3": { "Wire": { "x": 2, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,3": { "Wire": { "x": 1, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,2": { "Wire": { "x": 1, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Factory_PPDoor": { "name": "Factory_PPDoor", "w": 1, "h": 1, "primInd": "d", "index": { "1,1": "d" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "factory", "weight": 100, "grid": "1111111\n10CCC01\n1000001\n1bbZbb1\n1000001\n1000001\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "AutoDoor", "wireType": "AutoDoor_HoldOpen", "Label": "HoldOpen" }, "2,1": { "Type": "Chest", "Loot": "storage", "Chance": 0.8 }, "4,1": { "Type": "Chest", "Loot": "storage", "Chance": 0.8 }, "3,1": { "Priority": true } }, "effectTiles": { "5,1": { "TorchUnlit": { "x": 5, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "1,1": { "TorchUnlit": { "x": 1, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "3,3": { "Wire": { "x": 3, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,4": { "PressurePlateHold": { "x": 3, "y": 4, "name": "PressurePlateHold", "duration": 9999, "priority": 50, "tags": ["wire"] } }, "3,2": { "PressurePlateHold": { "x": 3, "y": 2, "name": "PressurePlateHold", "duration": 9999, "priority": 50, "tags": ["wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["factory", "chest", "signal"], "forbidTags": [], "requireTags": ["factory"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "IndustrialPuzzle": { "name": "IndustrialPuzzle", "w": 2, "h": 2, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "2,1": "udlr", "2,2": "udlr" }, "flexEdge": { "1,2": "y", "2,2": "y", "2,1": "y", "1,1": "y" }, "flexEdgeSuper": { "1,2": "y", "2,2": "y", "2,1": "y", "1,1": "y" }, "scale": 7, "category": "industrial", "weight": 1500, "grid": "00000000000000\n000000001111L0\n0uVV0000ZC1LL0\n005N0+001b1110\n0@0V0000D000D0\n0G0N0000100F10\n000V00001LGF10\n000N0+00100010\n000V0000111110\n000V0000000000\n000V000RLRRL/0\n0tVV0?0RLRRL/0\n00000000000000\n00000000000000\n", "POI": [], "Keyring": [{ "x": 11, "y": 7 }], "Jail": [{ "x": 9, "y": 6, "type": "furniture", "radius": 1 }], "Tiles": { "11,5": { "Type": "Table" }, "11,6": { "Type": "Table" }, "10,10": { "Type": "Rubble" }, "9,11": { "Type": "Rubble" }, "9,10": { "Type": "Rubble" }, "10,11": { "Type": "Rubble" }, "11,10": { "Type": "Barrel" }, "8,11": { "Type": "Barrel" }, "8,10": { "Type": "Barrel" }, "11,11": { "Type": "Barrel" }, "12,11": { "Type": "Debris" }, "12,10": { "Type": "Debris" }, "7,11": { "Type": "Rubble" }, "7,10": { "Type": "Rubble" }, "9,2": { "Type": "Chest", "Loot": "silver", "Priority": true }, "11,2": { "Type": "Barrel", "Always": true }, "12,1": { "Type": "Barrel" }, "12,2": { "Type": "Barrel" }, "8,2": { "Type": "AutoDoor", "wireType": "AutoDoor_HoldOpen", "Label": "HoldOpen" }, "1,2": { "Type": "DollSupply", "count": 0, "wireType": "increment", "rate": 3 }, "3,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,6": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,7": { "Type": "BondageMachine", "Binding": "Latex" }, "3,8": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,9": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,10": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,2": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "2,2": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "3,11": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "2,11": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "1,11": { "Type": "DollTerminal" }, "3,5": { "Type": "BondageMachine", "Binding": "Tape" }, "3,3": { "Type": "BondageMachine", "Binding": "Metal" }, "5,7": { "Type": "Charger" }, "5,3": { "Type": "Charger" }, "12,4": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "8,4": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "9,6": { "Type": "Cage", "Furniture": "Cage" }, "10,6": { "Type": "Spawn", "required": [], "AI": "guard" }, "1,5": { "Type": "Spawn", "required": [], "AI": "guard" }, "2,3": { "Type": "DollDropoff", "Sprite": "Floor", "Overlay": "DollDropoff" } }, "effectTiles": { "7,2": { "Wire": { "x": 7, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "8,2": { "Wire": { "x": 8, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,3": { "Wire": { "x": 7, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,4": { "Wire": { "x": 7, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,5": { "Wire": { "x": 7, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,6": { "Wire": { "x": 7, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,7": { "Wire": { "x": 7, "y": 7, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,8": { "Wire": { "x": 7, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,9": { "Wire": { "x": 7, "y": 9, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "6,9": { "Wire": { "x": 6, "y": 9, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,9": { "Wire": { "x": 5, "y": 9, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,9": { "Wire": { "x": 4, "y": 9, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,3": { "Wire": { "x": 1, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,4": { "Wire": { "x": 1, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,9": { "PressurePlateHold": { "x": 3, "y": 9, "name": "PressurePlateHold", "duration": 9999, "priority": 50, "tags": ["wire"] } }, "1,2": { "Wire": { "x": 1, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["industrial", "silverchest", "conveyor", "signal"], "forbidTags": ["silverchest"], "requireTags": ["industrial"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "BellowsDollDispenser": { "name": "BellowsDollDispenser", "w": 2, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr", "2,1": "l" }, "flexEdge": { "1,1": "y" }, "flexEdgeSuper": { "1,1": "y" }, "scale": 7, "category": "bellows", "weight": 500, "grid": "00001111111111\n0@001111111111\n000000000000F1\n0000VVNVNVNVu1\n0C000000000001\n11001111111111\n11001111111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "12,3": { "Type": "DollSupply", "count": 0, "wireType": "increment", "rate": 3 }, "11,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "10,3": { "Type": "BondageMachine", "Binding": "Metal" }, "9,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "6,3": { "Type": "BondageMachine", "Binding": "Chastity" }, "7,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "8,3": { "Type": "BondageMachine", "Binding": "Plug" }, "5,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "4,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "12,2": { "Type": "Table", "Food": "Plate" }, "1,4": { "Type": "Chest" } }, "effectTiles": { "4,5": { "Wire": { "x": 4, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,5": { "Wire": { "x": 5, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "6,5": { "Wire": { "x": 6, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,5": { "Wire": { "x": 7, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,1": { "Wire": { "x": 2, "y": 1, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,1": { "Wire": { "x": 3, "y": 1, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,1": { "Wire": { "x": 4, "y": 1, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,2": { "Wire": { "x": 4, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,3": { "Wire": { "x": 4, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,4": { "Wire": { "x": 4, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,1": { "Wire": { "x": 1, "y": 1, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "8,5": { "Wire": { "x": 8, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "9,5": { "Wire": { "x": 9, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,5": { "Wire": { "x": 10, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "11,5": { "Wire": { "x": 11, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "12,5": { "Wire": { "x": 12, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "12,4": { "Wire": { "x": 12, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "12,3": { "Wire": { "x": 12, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "6,2": { "TorchUnlit": { "x": 6, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "8,2": { "TorchUnlit": { "x": 8, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } }, "10,2": { "TorchUnlit": { "x": 10, "y": 2, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide", "chest", "conveyor", " signal"], "forbidTags": ["start"], "requireTags": ["bellows", "arousalMode"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "BellowsRobotTrap": { "name": "BellowsRobotTrap", "w": 1, "h": 2, "primInd": "d", "index": { "1,1": "d", "1,2": "udlr" }, "flexEdge": { "1,2": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 8000, "grid": "1111111\n111C111\n13Z0Z31\n1110111\n13Z0Z31\n1110111\n13Z0Z31\n1110111\n13Z0Z31\n111D111\n0200200\n0200200\n0+00X00\n0000000\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "1,12": { "Type": "Charger" }, "3,9": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" }, "3,1": { "Type": "Chest", "Loot": "lessergold", "Faction": "AncientRobot", "NoTrap": "true", "Priority": "true" }, "4,2": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,2": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,4": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "4,4": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "4,6": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,6": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,8": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "4,8": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "1,8": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" }, "1,6": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" }, "5,6": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" }, "5,8": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" }, "5,4": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" }, "1,4": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" }, "1,2": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" }, "5,2": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "RoboAtk", "tags": ["robot", "minor"], "Chance": 1, "force": "true", "faction": "Ambush" } }, "effectTiles": { "2,8": { "Wire": { "x": 2, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,8": { "Wire": { "x": 3, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,8": { "Wire": { "x": 4, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,7": { "Wire": { "x": 3, "y": 7, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,6": { "Wire": { "x": 3, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,5": { "Wire": { "x": 3, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,4": { "Wire": { "x": 3, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,3": { "Wire": { "x": 3, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,2": { "Wire": { "x": 2, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,4": { "Wire": { "x": 2, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,4": { "Wire": { "x": 4, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,6": { "Wire": { "x": 4, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,6": { "Wire": { "x": 2, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,2": { "Wire": { "x": 4, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,2": { "PressurePlateOneUse": { "x": 3, "y": 2, "name": "PressurePlateOneUse", "duration": 9999, "priority": 50, "tags": ["wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide", "lessergold"], "forbidTags": ["start", "maxlessergold"], "requireTags": ["bellows"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Bellows_DR2": { "name": "Bellows_DR2", "w": 1, "h": 1, "primInd": "dr", "index": { "1,1": "dr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 100, "grid": "1111111\n1000000\n1L11110\n1LRRRR0\n1L11110\n1LRRRR0\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,5": { "Type": "Rubble" }, "2,5": { "Type": "Rubble" }, "3,5": { "Type": "Rubble" }, "5,5": { "Type": "Rubble" }, "5,3": { "Type": "Rubble" }, "4,3": { "Type": "Rubble" }, "3,3": { "Type": "Rubble" }, "2,3": { "Type": "Rubble" }, "1,2": { "Type": "Barrel" }, "1,3": { "Type": "Barrel" }, "1,4": { "Type": "Barrel" }, "1,5": { "Type": "Barrel" } }, "effectTiles": { "6,1": { "TorchUnlit": { "x": 6, "y": 1, "name": "TorchUnlit", "duration": 9999, "priority": 5, "yoffset": -1, "tags": [] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "BellowsRobotTrap2": { "name": "BellowsRobotTrap2", "w": 2, "h": 1, "primInd": "udlr", "index": { "1,1": "udlr", "2,1": "udlr" }, "flexEdge": { "1,1": "y", "2,1": "y" }, "flexEdgeSuper": { "1,1": "y", "2,1": "y" }, "scale": 7, "category": "bellows", "weight": 300, "grid": "00000000000000\n0X222XX111Z100\n01111111333110\n01C00001Z11110\n0111110000z010\n01X22111111d10\n00000000000000\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "2,3": { "Type": "Chest", "Loot": "lessergold", "Faction": "AncientRobots", "NoTrap": "true", "Priority": "true" }, "8,3": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "11,5": { "Type": "Door" }, "10,4": { "Type": "AutoDoor", "wireType": "AutoDoor_Close", "Label": "Open" }, "10,1": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "8,2": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "Robo", "tags": ["robot", "minor", "elite"], "Chance": 1, "force": "true", "faction": "Ambush" }, "9,2": { "Type": "Spawn", "required": ["robot"], "Label": "Robo", "tags": ["robot", "minor", "elite"], "Chance": 1, "force": "true", "faction": "Ambush" }, "10,2": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "Robo", "tags": ["robot", "minor", "elite"], "Chance": 1, "force": "true", "faction": "Ambush" } }, "effectTiles": { "7,3": { "Wire": { "x": 7, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "6,3": { "Wire": { "x": 6, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,3": { "Wire": { "x": 5, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "8,3": { "Wire": { "x": 8, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,3": { "Wire": { "x": 4, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,3": { "PressurePlateOneUse": { "x": 3, "y": 3, "name": "PressurePlateOneUse", "duration": 9999, "priority": 50, "tags": ["wire"] } }, "9,3": { "Wire": { "x": 9, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,3": { "Wire": { "x": 10, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,4": { "Wire": { "x": 10, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,2": { "Wire": { "x": 10, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,1": { "Wire": { "x": 10, "y": 1, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,4": { "Wire": { "x": 7, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "8,4": { "Wire": { "x": 8, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "9,4": { "Wire": { "x": 9, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "wide", "lessergold"], "forbidTags": ["start", "maxlessergold"], "requireTags": ["bellows"], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Bellows_Silv1": { "name": "Bellows_Silv1", "w": 1, "h": 1, "primInd": "lr", "index": { "1,1": "lr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 600, "grid": "1111111\n13ZCZ31\n1Z101Z1\n001z100\n0000000\n0000000\n1111111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "3,3": { "Type": "AutoDoor", "wireType": "AutoDoor_Close", "Label": "Open" }, "5,2": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "1,2": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "4,1": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,1": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "3,1": { "Type": "Chest", "Loot": "silver", "Priority": true }, "1,1": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "robo", "tags": ["robot", "minor", "elite"], "Chance": 1, "force": "true", "faction": "Ambush" }, "5,1": { "Type": "Spawn", "required": ["robot"], "filterTags": ["turret", "oldrobot"], "Label": "robo", "tags": ["robot", "minor", "elite"], "Chance": 1, "force": "true", "faction": "Ambush" } }, "effectTiles": { "3,3": { "Wire": { "x": 3, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,2": { "Wire": { "x": 1, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,2": { "Wire": { "x": 2, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,2": { "Wire": { "x": 4, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,2": { "Wire": { "x": 5, "y": 2, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,2": { "PressurePlateOneUse": { "x": 3, "y": 2, "name": "PressurePlateOneUse", "duration": 9999, "priority": 50, "tags": ["wire"] } }, "2,1": { "Wire": { "x": 2, "y": 1, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,1": { "Wire": { "x": 4, "y": 1, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "silverchest"], "forbidTags": ["maxsilverchest", " start"], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_Silv2": { "name": "Bellows_Silv2", "w": 1, "h": 1, "primInd": "ud", "index": { "1,1": "ud" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 600, "grid": "1100111\n1000001\n11D1221\n1C0b001\n11Z1X01\n1100001\n1100111\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "1,3": { "Type": "Chest", "Loot": "silver", "Priority": true }, "2,4": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,2": { "Type": "Door", "Priority": true, "AlwaysClose": true, "Lock": "Red" } }, "effectTiles": { "2,4": { "Wire": { "x": 2, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,3": { "PressurePlateOneUse": { "x": 2, "y": 3, "name": "PressurePlateOneUse", "duration": 9999, "priority": 50, "tags": ["wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "silverchest"], "forbidTags": ["maxsilverchest", " start"], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [2], "notTags": [""] }, "Bellows_Gallery": { "name": "Bellows_Gallery", "w": 1, "h": 2, "primInd": "dlr", "index": { "1,1": "dlr", "1,2": "ulr" }, "flexEdge": { "1,2": "y", "1,1": "y" }, "flexEdgeSuper": {}, "scale": 7, "category": "bellows", "weight": 200, "grid": "1LRR2L1\n1000201\n10X2X01\n001D100\n1110111\n11Z0Z11\n13Z0Z31\n13Z0Z31\n13Z0Z31\n1110111\n001D100\n10X2@01\n1020001\n1F200F1\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": { "4,5": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "4,6": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "4,7": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "4,8": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,5": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,6": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,7": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "2,8": { "Type": "AutoDoor", "wireType": "AutoDoor_Open", "Label": "Open" }, "3,3": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "3,10": { "Type": "Door", "Priority": true, "AlwaysClose": true }, "5,13": { "Type": "Table" }, "1,13": { "Type": "Table" }, "5,0": { "Type": "Barrel" }, "1,0": { "Type": "Barrel" }, "2,0": { "Type": "Rubble" }, "3,0": { "Type": "Rubble" }, "5,6": { "Type": "Spawn", "required": ["basicturret", "oldrobot"], "Label": "turret", "tags": ["robot", "minor"], "Chance": 1, "force": "true" }, "1,6": { "Type": "Spawn", "required": ["basicturret", "oldrobot"], "Label": "turret", "tags": ["robot", "minor"], "Chance": 1, "force": "true" }, "1,7": { "Type": "Spawn", "required": ["basicturret", "oldrobot"], "Label": "turret", "tags": ["robot", "minor"], "Chance": 1, "force": "true" }, "5,7": { "Type": "Spawn", "required": ["basicturret", "oldrobot"], "Label": "turret", "tags": ["robot", "minor"], "Chance": 1, "force": "true" }, "5,8": { "Type": "Spawn", "required": ["basicturret", "oldrobot"], "Label": "turret", "tags": ["robot", "minor"], "Chance": 1, "force": "true" }, "1,8": { "Type": "Spawn", "required": ["basicturret", "oldrobot"], "Label": "turret", "tags": ["robot", "minor"], "Chance": 1, "force": "true" } }, "effectTiles": { "4,11": { "Wire": { "x": 4, "y": 11, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,10": { "Wire": { "x": 4, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,9": { "Wire": { "x": 4, "y": 9, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,8": { "Wire": { "x": 4, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,7": { "Wire": { "x": 4, "y": 7, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,5": { "Wire": { "x": 4, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,6": { "Wire": { "x": 4, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,8": { "Wire": { "x": 3, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,8": { "Wire": { "x": 2, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,7": { "Wire": { "x": 2, "y": 7, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,6": { "Wire": { "x": 2, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,5": { "Wire": { "x": 2, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,9": { "Wire": { "x": 3, "y": 9, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,7": { "Wire": { "x": 3, "y": 7, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,6": { "Wire": { "x": 3, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,5": { "Wire": { "x": 3, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["bellows", "signal", "ambush"], "forbidTags": [], "requireTags": ["bellows"], "indexTags": ["factory"], "maxTags": [-1], "bonusTags": [0], "multTags": [1], "notTags": [""] }, "Arena_Dollmaker": { "name": "Arena_Dollmaker", "w": 3, "h": 3, "primInd": "dr", "index": { "1,1": "dr", "1,2": "udlr", "1,3": "ur", "2,1": "dlr", "2,2": "udlr", "2,3": "ulr", "3,1": "dl", "3,2": "udlr", "3,3": "ul" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "boss", "weight": -1, "grid": "111111111111111111111\n111t1110=0u0=0111t111\n110V000000V000000V011\n110N0VVVVVVVVVVV0N011\n110V0V111111111V0V011\n000N0V100000001V0N000\n000V0V10F000F01V0V000\n000N0V13bbbbb31V0N002\n00=V0V02=0@0=20V0V=00\n000V0V020000020V0V000\n000VVV5200L0025VVV000\n000V0V020000020V0V000\n00=V0V02=0@0=20V0V=00\n000N0V0X22222X0V0N000\n000V0V000000000V0V000\n000N0V000000000V0N000\n110V0V000000000V0V011\n110N0VVVVVVVVVVV0N011\n110V000000V000000V011\n111t1110=0u0=0111t111\n111111111111111111111\n", "POI": [], "Keyring": [], "Jail": [{ "x": 10, "y": 10, "type": "furniture", "radius": 1 }], "Tiles": { "8,8": { "Type": "Charger", "Priority": true }, "12,8": { "Type": "Charger", "Priority": true }, "8,19": { "Type": "Charger", "Priority": true }, "12,19": { "Type": "Charger", "Priority": true }, "12,1": { "Type": "Charger", "Priority": true }, "2,12": { "Type": "Charger", "Priority": true }, "2,8": { "Type": "Charger", "Priority": true }, "18,8": { "Type": "Charger", "Priority": true }, "18,12": { "Type": "Charger", "Priority": true }, "8,12": { "Type": "Charger", "Priority": true }, "8,1": { "Type": "Charger", "Priority": true }, "12,12": { "Type": "Charger", "Priority": true }, "3,19": { "Type": "DollTerminal" }, "17,19": { "Type": "DollTerminal" }, "17,1": { "Type": "DollTerminal" }, "3,1": { "Type": "DollTerminal" }, "10,19": { "Type": "DollSupply" }, "10,1": { "Type": "DollSupply" }, "10,18": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "10,2": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "10,3": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0, "wireType": "Conveyor_Switch", "SwitchMode": "Switch" }, "10,17": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0, "wireType": "Conveyor_Switch", "SwitchMode": "Switch" }, "11,17": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "12,17": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "13,17": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "9,17": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "8,17": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "7,17": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "9,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "8,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "7,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "11,3": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "12,3": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "13,3": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "15,3": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "14,3": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "5,3": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "6,3": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "14,17": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "6,17": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "15,17": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,17": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "15,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "15,5": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "15,6": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "15,7": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "15,8": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "5,4": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "5,5": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "5,6": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "5,7": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "5,8": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "5,9": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "15,9": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "15,16": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "15,15": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "15,14": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "15,13": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "15,12": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "15,11": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,15": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,14": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,16": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,13": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,12": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,11": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "5,10": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "15,10": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "16,10": { "Type": "Conveyor", "Sprite": "Conveyor/Right", "DX": 1, "DY": 0 }, "17,9": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "17,6": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "17,7": { "Type": "BondageMachine", "Binding": "Metal" }, "17,8": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "17,5": { "Type": "BondageMachine", "Binding": "Metal" }, "17,3": { "Type": "BondageMachine", "Binding": "Metal" }, "17,2": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "17,11": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "17,13": { "Type": "BondageMachine", "Binding": "Latex" }, "17,14": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "17,15": { "Type": "BondageMachine", "Binding": "Latex" }, "17,16": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "17,17": { "Type": "BondageMachine", "Binding": "Latex" }, "17,18": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "17,10": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1, "wireType": "Conveyor_Switch", "SwitchMode": "Switch" }, "4,10": { "Type": "Conveyor", "Sprite": "Conveyor/Left", "DX": -1, "DY": 0 }, "3,9": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,8": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,7": { "Type": "BondageMachine", "Binding": "Metal" }, "3,6": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,5": { "Type": "BondageMachine", "Binding": "Tape" }, "3,4": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,3": { "Type": "BondageMachine", "Binding": "Latex" }, "3,2": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "3,11": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,12": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,13": { "Type": "BondageMachine", "Binding": "Tape" }, "3,14": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,15": { "Type": "BondageMachine", "Binding": "Tape" }, "3,16": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,17": { "Type": "BondageMachine", "Binding": "Tape" }, "3,18": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "3,10": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1, "wireType": "Conveyor_Switch", "SwitchMode": "Switch" }, "17,12": { "Type": "Conveyor", "Sprite": "Conveyor/Down", "DX": 0, "DY": 1 }, "17,4": { "Type": "Conveyor", "Sprite": "Conveyor/Up", "DX": 0, "DY": -1 }, "13,7": { "Type": "ForceSpawn", "required": ["dolldoor"], "Label": "dolldoor", "tags": ["dolldoor"], "Chance": 1, "force": "true" }, "7,7": { "Type": "ForceSpawn", "required": ["dolldoor"], "Label": "dolldoor", "tags": ["dolldoor"], "Chance": 1, "force": "true" }, "12,6": { "Type": "Table", "Food": "Plate" }, "8,6": { "Type": "Table", "Food": "Plate" }, "10,10": { "Type": "DisplayStand", "Furniture": "DisplayStand" }, "14,10": { "Type": "DollDropoff", "Sprite": "Floor", "Overlay": "DollDropoffR", "direction": { "x": 1, "y": 0 } }, "6,10": { "Type": "DollDropoff", "Sprite": "Floor", "Overlay": "DollDropoffL", "direction": { "x": -1, "y": 0 } } }, "effectTiles": { "10,8": { "Wire": { "x": 10, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,12": { "Wire": { "x": 10, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "13,10": { "Wire": { "x": 13, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "14,10": { "Wire": { "x": 14, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "15,10": { "Wire": { "x": 15, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "17,10": { "Wire": { "x": 17, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "16,10": { "Wire": { "x": 16, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,17": { "Wire": { "x": 10, "y": 17, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,16": { "Wire": { "x": 10, "y": 16, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,15": { "Wire": { "x": 10, "y": 15, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,14": { "Wire": { "x": 10, "y": 14, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,13": { "Wire": { "x": 10, "y": 13, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "8,10": { "Wire": { "x": 8, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,10": { "Wire": { "x": 7, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "6,10": { "Wire": { "x": 6, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,10": { "Wire": { "x": 5, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,10": { "Wire": { "x": 4, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,10": { "Wire": { "x": 3, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,7": { "Wire": { "x": 10, "y": 7, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,6": { "Wire": { "x": 10, "y": 6, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,5": { "Wire": { "x": 10, "y": 5, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,4": { "Wire": { "x": 10, "y": 4, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,3": { "Wire": { "x": 10, "y": 3, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "9,10": { "Wire": { "x": 9, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "10,10": { "Wire": { "x": 10, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "12,10": { "Wire": { "x": 12, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "11,10": { "Wire": { "x": 11, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "9,12": { "Wire": { "x": 9, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "8,12": { "Wire": { "x": 8, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,12": { "Wire": { "x": 7, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "6,12": { "Wire": { "x": 6, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,12": { "Wire": { "x": 5, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,12": { "Wire": { "x": 4, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,12": { "Wire": { "x": 3, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,12": { "Wire": { "x": 2, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,12": { "Wire": { "x": 1, "y": 12, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,11": { "Wire": { "x": 1, "y": 11, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,10": { "Wire": { "x": 1, "y": 10, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,9": { "Wire": { "x": 1, "y": 9, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "1,8": { "Wire": { "x": 1, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "2,8": { "Wire": { "x": 2, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "3,8": { "Wire": { "x": 3, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "4,8": { "Wire": { "x": 4, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "5,8": { "Wire": { "x": 5, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "6,8": { "Wire": { "x": 6, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "7,8": { "Wire": { "x": 7, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "9,8": { "Wire": { "x": 9, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } }, "8,8": { "Wire": { "x": 8, "y": 8, "name": "Wire", "duration": 9999, "priority": 50, "tags": ["hiddenmagic", "wire"] } } }, "Skin": {}, "inaccessible": [], "tags": ["boss"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] }, "Arena_Empty": { "name": "Arena_Empty", "w": 3, "h": 3, "primInd": "udlr", "index": { "1,1": "udlr", "1,2": "udlr", "1,3": "udlr", "2,1": "udlr", "2,2": "udlr", "2,3": "udlr", "3,1": "udlr", "3,2": "udlr", "3,3": "udlr" }, "flexEdge": {}, "flexEdgeSuper": {}, "scale": 7, "category": "urban", "weight": -1, "grid": "000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n000000000000000000000\n", "POI": [], "Keyring": [], "Jail": [], "Tiles": {}, "effectTiles": {}, "Skin": {}, "inaccessible": [], "tags": ["urban"], "forbidTags": [], "requireTags": [], "indexTags": [], "maxTags": [], "bonusTags": [], "multTags": [], "notTags": [] } };
let KDMapTilesListEditor = localStorage.getItem("KDMapTilesListEditor") ? JSON.parse(localStorage.getItem("KDMapTilesListEditor")) : Object.assign({}, KDMapTilesList);
let KDTileToTest = null;
function KDInitTileEditor() {
    KDTE_Create(1, 1);
}
let KDEditorTileIndex = 'lr';
let KDEditorTileFlex = "";
let KDEditorTileFlexSuper = "";
let KDEditorTileIndexQuery = '1,1';
let KDEditorTileIndexStore = {
    "1,1": 'lr',
};
let KDEditorTileFlexStore = {};
let KDEditorTileFlexSuperStore = {};
let KDEditorCurrentMapTileName = 'test';
let KDEditorCurrentMapTile = null;
let KDTileIndices = {
    'udlr': true,
    'u': true,
    'd': true,
    'l': true,
    'r': true,
    'ud': true,
    'lr': true,
    'ul': true,
    'ur': true,
    'dl': true,
    'dr': true,
    'udl': true,
    'udr': true,
    'dlr': true,
    'ulr': true,
};
let KDEditorTileIndexHover = '';
let KDEditorTileNameIndex = 0;
let KDEditorTileBrush = 'Clear';
let KDEditorTileBrushIndex = 0;
let KDEditorTileBrushIndex2 = 0;
let KDTilePalette = {
    'Clear': { type: "clear", tile: '0' },
    'Wall': { type: "tile", tile: '1' },
    '----Spawns----': { type: "none" },
    'Spawn': { type: "tile", tile: 'G', special: { Type: "Spawn", required: [] } },
    'SpawnGuard': { type: "tile", tile: 'G', special: { Type: "Spawn", required: [], AI: "guard" } },
    'Prisoner': { type: "tile", tile: 'G', special: { Type: "Prisoner" } },
    'SpawnLooseGuard': { type: "tile", tile: 'G', special: { Type: "Spawn", required: [], AI: "looseguard" } },
    'SpawnMiniboss': { type: "tile", tile: 'G', special: { Type: "Spawn", required: ["miniboss"], AI: "guard" } },
    'SpawnBoss': { type: "tile", tile: 'G', special: { Type: "Spawn", required: ["boss"], AI: "guard" } },
    '----SpecifcSpawns----': { type: "none" },
    'SpawnStatue': { type: "tile", tile: '3', special: { Type: "Spawn", required: ["statue"], Label: "Statue" } },
    'SpawnObstacleDoor': { type: "tile", tile: 'G', special: { Type: "ForceSpawn", required: ["obstacledoor"], tags: ["obstacletile"], Label: "Door" } },
    'SpawnSoulCrys': { type: "tile", tile: '3', special: { Type: "Spawn", required: ["soul"], tags: ["soul"], Label: "SoulC" } },
    'SpawnSoulCrysActive': { type: "tile", tile: '3', special: { Type: "Spawn", required: ["soul", "active"], tags: ["soul"], Label: "SoulC_A" } },
    'SpawnChaosCrysRare': { type: "tile", tile: '3', special: { Type: "ForceSpawn", required: ["chaos", "inactive"], tags: ["chaos"], Label: "ChaosC", Chance: 0.4 } },
    'SpawnChaosCrys': { type: "tile", tile: '3', special: { Type: "Spawn", required: ["chaos"], tags: ["chaos"], Label: "ChaosC" } },
    'SpawnChaosCrysActive': { type: "tile", tile: '3', special: { Type: "Spawn", required: ["chaos", "active"], tags: ["chaos"], Label: "ChaosC_A" } },
    'SpawnMushroom': { type: "tile", tile: '3', special: { Type: "Spawn", required: ["mushroom", "scenery"], tags: ["mushroom"], Label: "Mushroom" } },
    'SpawnCustom': { type: "tile", tile: '3', special: { Type: "Spawn", required: [], Label: "Custom" }, customfields: {
            required: { type: "array" },
            tags: { type: "array" },
            filterTags: { type: "array" },
            Label: { type: "string" },
            Chance: { type: "number" },
            AI: { type: "string" },
            force: { type: "boolean" },
            faction: { type: "string" },
        } },
    'ForceSpawnCustom': { type: "tile", tile: '3', special: { Type: "ForceSpawn", required: [], Label: "Custom" }, customfields: {
            required: { type: "array" },
            tags: { type: "array" },
            filterTags: { type: "array" },
            Label: { type: "string" },
            Chance: { type: "number" },
            AI: { type: "string" },
            force: { type: "boolean" },
            faction: { type: "string" },
        } },
    '----Tiles----': { type: "none" },
    'Brick': { type: "tile", tile: '2' },
    'Doodad': { type: "tile", tile: 'X' },
    'Grate': { type: "tile", tile: 'g' },
    'Bars': { type: "tile", tile: 'b' },
    'Bed': { type: "tile", tile: 'B' },
    'Crack': { type: "tile", tile: '4' },
    'WallHook': { type: "tile", tile: ',' },
    'CeilingHook': { type: "tile", tile: '?' },
    'InactiveTablet': { type: "tile", tile: 'm' },
    'BrokenShrine': { type: "tile", tile: 'a' },
    'BrokenOrb': { type: "tile", tile: 'o' },
    'BrokenCharger': { type: "tile", tile: '-' },
    '----Doors----': { type: "none" },
    'Door': { type: "tile", tile: 'd', special: { Type: "Door" } },
    'DoorAlways': { type: "tile", tile: 'D', special: { Type: "Door", Priority: true, AlwaysClose: true } },
    'Door_RedLock': { type: "tile", tile: 'D', special: { Type: "Door", Priority: true, AlwaysClose: true, Lock: "Red" } },
    'Door_PurpleLock': { type: "tile", tile: 'D', special: { Type: "Door", Priority: true, AlwaysClose: true, Lock: "Purple" } },
    'Door_BlueLock': { type: "tile", tile: 'D', special: { Type: "Door", Priority: true, AlwaysClose: true, Lock: "Blue" } },
    'AutoDoorToggle': { type: "tile", tile: 'Z', special: { Type: "AutoDoor", wireType: "AutoDoor_Toggle" } },
    'AutoDoorOpenToggle': { type: "tile", tile: 'z', special: { Type: "AutoDoor", wireType: "AutoDoor_Toggle" } },
    'AutoDoorHoldOpen': { type: "tile", tile: 'Z', special: { Type: "AutoDoor", wireType: "AutoDoor_HoldOpen", Label: "HoldOpen" } },
    'AutoDoorHoldClosed': { type: "tile", tile: 'Z', special: { Type: "AutoDoor", wireType: "AutoDoor_HoldClosed", Label: "HoldClosed" } },
    'AutoDoorOpen': { type: "tile", tile: 'Z', special: { Type: "AutoDoor", wireType: "AutoDoor_Open", Label: "Open" } },
    'AutoDoorClose': { type: "tile", tile: 'z', special: { Type: "AutoDoor", wireType: "AutoDoor_Close", Label: "Open" } },
    '----Furniture----': { type: "none" },
    'Table': { type: "tile", tile: 'F', special: { Type: "Table" } },
    'TableFood': { type: "tile", tile: 'F', special: { Type: "Table", Food: "Plate" } },
    'Rubble': { type: "tile", tile: 'R', special: { Type: "Rubble" } },
    'Sharp': { type: "tile", tile: '/', special: { Type: "Debris" } },
    'SharpAlways': { type: "tile", tile: '/', special: { Type: "Debris", Always: true } },
    'Torch': { type: "effect", effectTile: "Torch" },
    'PotentialTorch': { type: "effect", effectTile: "TorchUnlit" },
    'Barrel': { type: "tile", tile: 'L', special: { Type: "Barrel" } },
    'BarrelAlways': { type: "tile", tile: 'L', special: { Type: "Barrel", Always: true } },
    'Cage': { type: "tile", tile: 'L', special: { Type: "Cage", Furniture: "Cage" }, jail: { type: "furniture", radius: 1 } },
    'DisplayStand': { type: "tile", tile: 'L', special: { Type: "DisplayStand", Furniture: "DisplayStand" }, jail: { type: "furniture", radius: 1 } },
    'DisplayEgyptian': { type: "tile", tile: 'L', special: { Type: "Furniture", Furniture: "DisplayEgyptian" }, jail: { type: "furniture", radius: 1 } },
    '----Chests----': { type: "none" },
    'Chest': { type: "tile", tile: 'C', special: { Type: "Chest" } },
    'ChestRed': { type: "tile", tile: 'C', special: { Type: "Chest", Lock: "Red" } },
    'ChestBlue': { type: "tile", tile: 'C', special: { Type: "Chest", Lock: "Blue" } },
    'ChestOrShrine': { type: "tile", tile: 'O', special: { Type: "ChestOrShrine" } },
    'HighPriorityChest': { type: "tile", tile: 'C', special: { Priority: true } },
    'SilverChest': { type: "tile", tile: 'C', special: { Type: "Chest", Loot: "silver", Priority: true } },
    'StorageChest': { type: "tile", tile: 'C', special: { Type: "Chest", Loot: "storage", Chance: 0.8 } },
    'ChestCustom': { type: "tile", tile: 'C', special: { Type: "Chest", Loot: "storage" }, customfields: {
            Loot: { type: "string" },
            Faction: { type: "string" },
            NoTrap: { type: "boolean" },
            lootTrap: { type: "string" },
            Lock: { type: "string" },
            Priority: { type: "boolean" },
        } },
    'GuardedChest': { type: "tile", tile: 'C', special: { Type: "GuardedChest", Label: "Guarded" } },
    'GuardedChestLocked': { type: "tile", tile: 'C', special: { Type: "GuardedChest", Lock: "Red", Label: "Guarded" } },
    '----Shrines----': { type: "none" },
    'Shrine': { type: "tile", tile: 'A', special: { Type: "Shrine", Name: "Metal" } },
    'HighPriorityShrine': { type: "tile", tile: 'A', special: { Type: "Shrine", Name: "Will", Priority: true } },
    '----Chargers----': { type: "none" },
    'PriorityCharger': { type: "tile", tile: '=', special: { Type: "Charger", Priority: true } },
    'Charger': { type: "tile", tile: '+', special: { Type: "Charger" } },
    'UnlockedCharger': { type: "tile", tile: '=', special: { Type: "Charger", NoRemove: false } },
    '----Hazards----': { type: "none" },
    'Trap': { type: "tile", tile: 'T', special: { Type: "Trap", Always: true, } },
    'PotentialTrap': { type: "tile", tile: 'T', special: { Type: "Trap" } },
    '----Conveyors----': { type: "none" },
    'ConveyorUp': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Up", DX: 0, DY: -1, } },
    'ConveyorDown': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Down", DX: 0, DY: 1, } },
    'ConveyorLeft': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Left", DX: -1, DY: 0, } },
    'ConveyorRight': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Right", DX: 1, DY: 0, } },
    'ConveyorUpOn': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Up", DX: 0, DY: -1, wireType: "Conveyor_Toggle", SwitchMode: "On" } },
    'ConveyorDownOn': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Down", DX: 0, DY: 1, wireType: "Conveyor_Toggle", SwitchMode: "On" } },
    'ConveyorLeftOn': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Left", DX: -1, DY: 0, wireType: "Conveyor_Toggle", SwitchMode: "On" } },
    'ConveyorRightOn': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Right", DX: 1, DY: 0, wireType: "Conveyor_Toggle", SwitchMode: "On" } },
    'ConveyorUpOff': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Up", DX: 0, DY: -1, wireType: "Conveyor_Toggle", SwitchMode: "Off" } },
    'ConveyorDownOff': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Down", DX: 0, DY: 1, wireType: "Conveyor_Toggle", SwitchMode: "Off" } },
    'ConveyorLeftOff': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Left", DX: -1, DY: 0, wireType: "Conveyor_Toggle", SwitchMode: "Off" } },
    'ConveyorRightOff': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Right", DX: 1, DY: 0, wireType: "Conveyor_Toggle", SwitchMode: "Off" } },
    'ConveyorUpSwitch': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Up", DX: 0, DY: -1, wireType: "Conveyor_Switch", SwitchMode: "Switch" } },
    'ConveyorDownSwitch': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Down", DX: 0, DY: 1, wireType: "Conveyor_Switch", SwitchMode: "Switch" } },
    'ConveyorLeftSwitch': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Left", DX: -1, DY: 0, wireType: "Conveyor_Switch", SwitchMode: "Switch" } },
    'ConveyorRightSwitch': { type: "tile", tile: 'V', special: { Type: "Conveyor", Sprite: "Conveyor/Right", DX: 1, DY: 0, wireType: "Conveyor_Switch", SwitchMode: "Switch" } },
    '----Machines----': { type: "none" },
    'DollSupply': { type: "tile", tile: 'u', special: { Type: "DollSupply" } },
    'DollSupplyManual': { type: "tile", tile: 'u', special: { Type: "DollSupply", count: 0, wireType: "increment", rate: 3 } },
    'DollTerminal': { type: "tile", tile: 't', special: { Type: "DollTerminal" } },
    'BondageMachineLatex': { type: "tile", tile: 'N', special: { Type: "BondageMachine", Binding: "Latex" } },
    'BondageMachinePlug': { type: "tile", tile: 'N', special: { Type: "BondageMachine", Binding: "Plug" } },
    'BondageMachineChastity': { type: "tile", tile: 'N', special: { Type: "BondageMachine", Binding: "Chastity" } },
    'BondageMachineTape': { type: "tile", tile: 'N', special: { Type: "BondageMachine", Binding: "Tape" } },
    'BondageMachineMetal': { type: "tile", tile: 'N', special: { Type: "BondageMachine", Binding: "Metal" } },
    'DollDropoffU': { type: "tile", tile: '5', special: { Type: "DollDropoff", Sprite: "Floor", Overlay: "DollDropoff", direction: { x: 0, y: -1 } } },
    'DollDropoffD': { type: "tile", tile: '5', special: { Type: "DollDropoff", Sprite: "Floor", Overlay: "DollDropoffD", direction: { x: 0, y: 1 } } },
    'DollDropoffR': { type: "tile", tile: '5', special: { Type: "DollDropoff", Sprite: "Floor", Overlay: "DollDropoffR", direction: { x: 1, y: 0 } } },
    'DollDropoffL': { type: "tile", tile: '5', special: { Type: "DollDropoff", Sprite: "Floor", Overlay: "DollDropoffL", direction: { x: -1, y: 0 } } },
    '----Signals----': { type: "none" },
    'Button': { type: "tile", tile: '@' },
    'Wire': { type: "effect", effectTile: "Wire" },
    'PressurePlate': { type: "effect", effectTile: "PressurePlate" },
    'PressurePlateHold': { type: "effect", effectTile: "PressurePlateHold" },
    'PressurePlateOneUse': { type: "effect", effectTile: "PressurePlateOneUse" },
    '----Misc----': { type: "none" },
    'POI': { type: "POI" },
    'OffLimits': { type: "offlimits" },
    'Jail': { type: "jail" },
    'Keyring': { type: "Keyring" },
};
function KDGetTileIndexImg(index) {
    return {
        u: index.includes('u'),
        d: index.includes('d'),
        l: index.includes('l'),
        r: index.includes('r'),
    };
}
let KDTE_State = "";
function KDDrawTileEditor() {
    if (KinkyDungeonCanvas) {
        KinkyDungeonContext.fillStyle = "rgba(0,0,0.0,1.0)";
        KinkyDungeonContext.fillRect(0, 0, KinkyDungeonCanvas.width, KinkyDungeonCanvas.height);
        KinkyDungeonContext.fill();
        KinkyDungeonCamX = KinkyDungeonPlayerEntity.x - Math.floor(KinkyDungeonGridWidthDisplay / 2);
        KinkyDungeonCamY = KinkyDungeonPlayerEntity.y - Math.floor(KinkyDungeonGridHeightDisplay / 2);
        KDDrawMap(KinkyDungeonCamX, KinkyDungeonCamY, 0, 0, true);
        KDDrawEffectTiles(0, 0, KinkyDungeonCamX, KinkyDungeonCamY);
        KinkyDungeonTargetX = Math.round((MouseX - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetX) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamX;
        KinkyDungeonTargetY = Math.round((MouseY - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetY) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamY;
        if (KinkyDungeonTargetX >= 0 && KinkyDungeonTargetX < KinkyDungeonGridWidth
            && KinkyDungeonTargetY >= 0 && KinkyDungeonTargetY < KinkyDungeonGridHeight) {
            KDDraw(kdgameboard, kdpixisprites, "ui_movereticule", KinkyDungeonRootDirectory + "TargetMove.png", (KinkyDungeonTargetX - KinkyDungeonCamX) * KinkyDungeonGridSizeDisplay, (KinkyDungeonTargetY - KinkyDungeonCamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                zIndex: 100,
            });
        }
        for (let sprite of kdpixisprites.entries()) {
            if (!kdSpritesDrawn.has(sprite[0]) && sprite[1] && sprite[1].parent == kdgameboard) {
                sprite[1].parent.removeChild(sprite[1]);
                if (kdprimitiveparams.has(sprite[0]))
                    kdprimitiveparams.delete(sprite[0]);
                kdpixisprites.delete(sprite[0]);
                sprite[1].destroy();
            }
        }
        if (!StandalonePatched) {
            if (pixirendererKD) {
                pixirendererKD.render(kdgameboard, {
                    clear: false,
                });
            }
            if (!pixirendererKD) {
                if (KinkyDungeonContext && KinkyDungeonCanvas) {
                    pixirendererKD = new PIXI.CanvasRenderer({
                        width: KinkyDungeonCanvas.width,
                        height: KinkyDungeonCanvas.height,
                        view: KinkyDungeonCanvas,
                        antialias: true,
                    });
                }
            }
        }
        if (!StandalonePatched)
            MainCanvas.drawImage(KinkyDungeonCanvas, canvasOffsetX, canvasOffsetY);
        KDTE_UpdateUI(false);
        if (!KDTE_State) {
            DrawButtonKDEx("ToTags", (bdata) => {
                KDTE_State = "Tags";
                return true;
            }, true, 20, 920, 250, 64, 'Edit Tile Tags', "#ffffff");
            KDDrawEditorUI();
        }
        else {
            DrawButtonKDEx("backToBrushes", (bdata) => {
                KDTE_State = "";
                return true;
            }, true, 20, 920, 250, 64, 'Go Back', "#ffffff");
            if (KDTE_State == "Tags")
                KDDrawEditorTagsUI();
        }
    }
    if (KinkyDungeonKeybindingCurrentKey && KinkyDungeonGameKeyDown()) {
        if (KinkyDungeonKeybindingCurrentKey)
            KDLastKeyTime[KinkyDungeonKeybindingCurrentKey] = CommonTime();
        KinkyDungeonKeybindingCurrentKey = '';
    }
}
function KDDrawEditorTagsUI() {
}
let KDEditorTileBrushIndexVisual = 0;
let KDEditorTileBrushIndex2Visual = 0;
let KDEditorTileNameIndexVisual = 0;
function KDDrawEditorUI() {
    if (Math.abs(KDEditorTileBrushIndexVisual - KDEditorTileBrushIndex) > 0.5)
        KDEditorTileBrushIndexVisual = (KDEditorTileBrushIndexVisual * 4 + KDEditorTileBrushIndex) / 5;
    if (Math.abs(KDEditorTileBrushIndex2Visual - KDEditorTileBrushIndex2) > 0.5)
        KDEditorTileBrushIndex2Visual = (KDEditorTileBrushIndex2Visual * 4 + KDEditorTileBrushIndex2) / 5;
    if (Math.abs(KDEditorTileNameIndexVisual - KDEditorTileNameIndex) > 0.5)
        KDEditorTileNameIndexVisual = (KDEditorTileNameIndexVisual * 4 + KDEditorTileNameIndex) / 5;
    let indexX = (1 + Math.floor(Math.max(0, Math.min(KinkyDungeonGridWidth - 1, KinkyDungeonPlayerEntity.x)) / KDTE_Scale));
    let indexY = (1 + Math.floor(Math.max(0, Math.min(KinkyDungeonGridHeight - 1, KinkyDungeonPlayerEntity.y)) / KDTE_Scale));
    let yy = 160;
    let xx = 100;
    let grid = 10;
    DrawTextFitKD("Tile Index", xx + grid * 1.5, yy - 30, 200, "#ffffff");
    KDEditorTileIndexHover = '';
    KDEditorTileIndex = KDEditorTileIndexStore[KDEditorTileIndexQuery];
    KDEditorTileFlex = KDEditorTileFlexStore[KDEditorTileIndexQuery] || "";
    KDEditorTileFlexSuper = KDEditorTileFlexSuperStore[KDEditorTileIndexQuery] || "";
    for (let index of Object.keys(KDTileIndices)) {
        let patt = KDGetTileIndexImg(index);
        if (!patt.u && KDEditorTileIndexStore[(indexX) + "," + (indexY - 1)]) {
            yy += grid * 5;
            continue;
        }
        if (!patt.d && KDEditorTileIndexStore[(indexX) + "," + (indexY + 1)]) {
            yy += grid * 5;
            continue;
        }
        if (!patt.l && KDEditorTileIndexStore[(indexX - 1) + "," + (indexY)]) {
            yy += grid * 5;
            continue;
        }
        if (!patt.r && KDEditorTileIndexStore[(indexX + 1) + "," + (indexY)]) {
            yy += grid * 5;
            continue;
        }
        DrawBoxKD(xx + grid, yy, grid, grid, patt.u ? "#ffffff" : "#000000", patt.u);
        DrawBoxKD(xx + grid, yy + 2 * grid, grid, grid, patt.d ? "#ffffff" : "#000000", patt.d);
        DrawBoxKD(xx, yy + grid, grid, grid, patt.l ? "#ffffff" : "#000000", patt.l);
        DrawBoxKD(xx + 2 * grid, yy + grid, grid, grid, patt.r ? "#ffffff" : "#000000", patt.r);
        if (MouseIn(xx, yy, grid * 3, grid * 3) || KDEditorTileIndex == index) {
            if (KDEditorTileIndex != index)
                KDEditorTileIndexHover = index;
            DrawRectKD(kdcanvas, kdpixisprites, "tileInd" + index, {
                Left: xx - 3,
                Top: yy - 3,
                Width: grid * 3 + 8,
                Height: grid * 3 + 8,
                Color: "#ffffff",
                LineWidth: 2,
                zIndex: 100,
                alpha: 0.5,
            });
        }
        yy += grid * 5;
    }
    DrawButtonKDEx("flextoggle", (bdata) => {
        KDEditorTileFlex = KDEditorTileFlex ? "" : "y";
        if (KDEditorTileFlexStore[KDEditorTileIndexQuery] && !KDEditorTileFlex) {
            delete KDEditorTileFlexStore[KDEditorTileIndexQuery];
        }
        else if (!KDEditorTileFlexStore[KDEditorTileIndexQuery] && KDEditorTileFlex) {
            KDEditorTileFlexStore[KDEditorTileIndexQuery] = KDEditorTileFlex;
        }
        return true;
    }, true, 150, 160, 140, 45, 'Flex', "#ffffff", KDEditorTileFlex ? (KinkyDungeonRootDirectory + "UI/CheckSmall.png") : undefined);
    DrawButtonKDEx("flexsupertoggle", (bdata) => {
        KDEditorTileFlexSuper = KDEditorTileFlexSuper ? "" : "y";
        if (KDEditorTileFlexSuperStore[KDEditorTileIndexQuery] && !KDEditorTileFlexSuper) {
            delete KDEditorTileFlexSuperStore[KDEditorTileIndexQuery];
        }
        else if (!KDEditorTileFlexSuperStore[KDEditorTileIndexQuery] && KDEditorTileFlexSuper) {
            KDEditorTileFlexSuperStore[KDEditorTileIndexQuery] = KDEditorTileFlexSuper;
        }
        return true;
    }, true, 150, 210, 140, 45, 'OpenBorder', "#ffffff", KDEditorTileFlexSuper ? (KinkyDungeonRootDirectory + "UI/CheckSmall.png") : undefined);
    let tileKeys = Object.keys(KDMapTilesListEditor);
    yy = 220;
    xx = 1790;
    grid = 40;
    let width = 200;
    let brushKeys = Object.keys(KDTilePalette);
    DrawButtonKDEx("tilebrushup", (bdata) => {
        if (KDEditorTileBrushIndex == 0)
            KDEditorTileBrushIndex = brushKeys.length - 4;
        else
            KDEditorTileBrushIndex = Math.max(0, KDEditorTileBrushIndex - 14);
        return true;
    }, true, xx, yy, width, grid - 5, '^', KDEditorTileBrushIndex > 0 ? "#ffffff" : "#888888");
    KDTE_CullIndex(tileKeys, brushKeys);
    yy += grid;
    for (let i = 0; i < 670 / grid; i++) {
        let index = i + Math.round(KDEditorTileBrushIndexVisual);
        if (index >= brushKeys.length)
            break;
        DrawButtonKDEx("brush" + i, (bdata) => {
            KDEditorTileBrush = brushKeys[index];
            return true;
        }, true, xx, yy, width, grid - 5, brushKeys[index], brushKeys[index] == KDEditorTileBrush ? "#ffffff" : (brushKeys[index].startsWith('-') ? "#77ff77" : "#888888"));
        yy += grid;
    }
    DrawButtonKDEx("tilebrushdown", (bdata) => {
        if (KDEditorTileBrushIndex >= brushKeys.length - 6)
            KDEditorTileBrushIndex = 0;
        else
            KDEditorTileBrushIndex = Math.min(brushKeys.length - 4, KDEditorTileBrushIndex + 14);
        return true;
    }, true, xx, yy, width, grid - 5, 'v', KDEditorTileBrushIndex < brushKeys.length - 4 ? "#ffffff" : "#888888");
    yy = 220;
    xx = 1590;
    grid = 40;
    DrawButtonKDEx("tilebrushup2", (bdata) => {
        if (KDEditorTileBrushIndex2 == 0)
            KDEditorTileBrushIndex2 = brushKeys.length - 4;
        else
            KDEditorTileBrushIndex2 = Math.max(0, KDEditorTileBrushIndex2 - 8);
        return true;
    }, true, xx, yy, width, grid - 5, '^', KDEditorTileBrushIndex2 > 0 ? "#ffffff" : "#888888");
    KDTE_CullIndex(tileKeys, brushKeys);
    yy += grid;
    for (let i = 0; i < 420 / grid; i++) {
        let index = i + Math.round(KDEditorTileBrushIndex2Visual);
        if (index >= brushKeys.length)
            break;
        DrawButtonKDEx("brush2_" + i, (bdata) => {
            KDEditorTileBrush = brushKeys[index];
            return true;
        }, true, xx, yy, width, grid - 5, brushKeys[index], brushKeys[index] == KDEditorTileBrush ? "#ffffff" : (brushKeys[index].startsWith('-') ? "#77ff77" : "#888888"));
        yy += grid;
    }
    DrawButtonKDEx("tilebrushdown2", (bdata) => {
        if (KDEditorTileBrushIndex2 >= brushKeys.length - 6)
            KDEditorTileBrushIndex2 = 0;
        else
            KDEditorTileBrushIndex2 = Math.min(brushKeys.length - 4, KDEditorTileBrushIndex2 + 8);
        return true;
    }, true, xx, yy, width, grid - 5, 'v', KDEditorTileBrushIndex2 < brushKeys.length - 4 ? "#ffffff" : "#888888");
    yy = 160;
    xx = 300;
    grid = 45;
    width = 200;
    DrawTextFitKD("Tile List", xx + width / 2, yy - 30, width, "#ffffff", undefined, 36);
    DrawButtonKDEx("tilenameup", (bdata) => {
        if (KDEditorTileNameIndex == 0)
            KDEditorTileNameIndex = tileKeys.length - 4;
        else
            KDEditorTileNameIndex = Math.max(0, KDEditorTileNameIndex - 9);
        KDTELoadConfirm = false;
        return true;
    }, true, xx, yy, width, grid - 5, '^', KDEditorTileNameIndex > 0 ? "#ffffff" : "#888888");
    yy += grid;
    KDTE_CullIndex(tileKeys, brushKeys);
    for (let i = 0; i < 700 / grid; i++) {
        let index = i + Math.round(KDEditorTileNameIndexVisual);
        if (index >= tileKeys.length)
            break;
        DrawButtonKDEx("tilename" + i, (bdata) => {
            if (KDEditorCurrentMapTileName != tileKeys[index] || !KDTELoadConfirm) {
                KDEditorCurrentMapTileName = tileKeys[index];
                ElementValue("MapTileTitle", KDEditorCurrentMapTileName);
                KDTELoadConfirm = true;
            }
            else if (KDTELoadConfirm) {
                KDTE_LoadTile(KDEditorCurrentMapTileName);
                KDTELoadConfirm = false;
            }
            return true;
        }, true, xx, yy, width, grid - 5, tileKeys[index], tileKeys[index] == KDEditorCurrentMapTileName ? "#ffffff" : "#888888");
        if (KDTELoadConfirm && tileKeys[index] == KDEditorCurrentMapTileName) {
            DrawTextFitKD("Double click to LOAD", xx + width * 1.65, yy + grid / 2, width, "#ffffff", undefined);
            DrawButtonKDEx("deletetilename" + i, (bdata) => {
                delete KDMapTilesListEditor[KDEditorCurrentMapTileName];
                return true;
            }, true, xx - 160, yy, 150, grid - 5, "Delete!!!", tileKeys[index] == KDEditorCurrentMapTileName ? "#ffffff" : "#888888");
        }
        yy += grid;
    }
    DrawButtonKDEx("tilenamedown", (bdata) => {
        if (KDEditorTileNameIndex >= tileKeys.length - 6)
            KDEditorTileNameIndex = 0;
        else
            KDEditorTileNameIndex = Math.min(tileKeys.length - 4, KDEditorTileNameIndex + 9);
        KDTELoadConfirm = false;
        return true;
    }, true, xx, yy, width, grid - 5, 'v', KDEditorTileNameIndex < tileKeys.length - 4 ? "#ffffff" : "#888888");
    DrawButtonKDEx("tilesave", (bdata) => {
        KDTE_SaveTile(KDEditorCurrentMapTileName);
        return true;
    }, true, 900, 150, 200, 60, 'Save Tile', "#ffffff");
    DrawButtonKDEx("maptileR", (bdata) => {
        KinkyDungeonPlayerEntity.x = Math.max(0, Math.min(KinkyDungeonGridWidth - 1, KinkyDungeonPlayerEntity.x + 3));
        KDTELoadConfirm = false;
        return true;
    }, true, 1000, 900, 50, 50, '>', "#ffffff");
    DrawButtonKDEx("maptileL", (bdata) => {
        KinkyDungeonPlayerEntity.x = Math.max(0, Math.min(KinkyDungeonGridWidth - 1, KinkyDungeonPlayerEntity.x - 3));
        KDTELoadConfirm = false;
        return true;
    }, true, 900, 900, 50, 50, '<', "#ffffff");
    DrawButtonKDEx("maptileD", (bdata) => {
        KinkyDungeonPlayerEntity.y = Math.max(0, Math.min(KinkyDungeonGridHeight - 1, KinkyDungeonPlayerEntity.y + 3));
        KDTELoadConfirm = false;
        return true;
    }, true, 950, 950, 50, 50, 'v', "#ffffff");
    DrawButtonKDEx("maptileU", (bdata) => {
        KinkyDungeonPlayerEntity.y = Math.max(0, Math.min(KinkyDungeonGridHeight - 1, KinkyDungeonPlayerEntity.y - 3));
        KDTELoadConfirm = false;
        return true;
    }, true, 950, 850, 50, 50, '^', "#ffffff");
    KDTE_CullIndex(tileKeys, brushKeys);
    DrawButtonKDEx("TileEditorBack", () => {
        KinkyDungeonState = "Menu";
        KinkyDungeonSeeAll = false;
        KDTE_CloseUI();
        return true;
    }, true, 10, 10, 350, 64, "Back to menu", "#ffffff", "");
    DrawButtonKDEx("TileEditorNew", () => {
        let x = parseInt(ElementValue("MapTileX"));
        let y = parseInt(ElementValue("MapTileY"));
        if (x && y && x > 0 && y > 0 && x <= KDTE_MAXDIM && y <= KDTE_MAXDIM)
            KDTE_Create(x, y);
        return true;
    }, true, 1600, 130, 350, 64, "Resize (Clears all)", "#ffffff", "");
    DrawButtonKDEx("TileTest", () => {
        KDTE_CloseUI();
        KDTileToTest = KDTE_ExportTile();
        KinkyDungeonStartNewGame();
        return true;
    }, true, 1910, 10, 80, 40, "Test Tile", "#ffffff", "");
    DrawButtonKDEx("CopyClip", () => {
        var text = JSON.stringify(KDMapTilesListEditor);
        navigator.clipboard.writeText(text).then(function () {
            console.log('Async: Copying to clipboard was successful!');
            console.log(KDMapTilesListEditor);
        }, function (err) {
            console.error('Async: Could not copy text: ', err);
        });
        return true;
    }, true, 1450, 900, 275, 45, "Copy array to clipboard", "#ffffff", "");
    DrawButtonKDEx("MergeClip", () => {
        let success = false;
        navigator.clipboard.readText()
            .then(text => {
            if (JSON.parse(text)) {
                console.log(JSON.parse(text));
                console.log("Parse successful!!!");
                for (let tile of Object.values(JSON.parse(text))) {
                    if (tile && tile.name) {
                        if (!KDMapTilesListEditor[tile.name]) {
                            KDMapTilesListEditor[tile.name] = tile;
                            console.log(`${tile.name} added successfully`);
                            success = true;
                        }
                        else {
                            console.log(`${tile.name} already present`);
                        }
                    }
                }
                if (success) {
                    localStorage.setItem("KDMapTilesListEditor", JSON.stringify(KDMapTilesListEditor));
                    console.log("Saved new tiles to browser local storage.");
                }
            }
        })
            .catch(err => {
            console.error('Failed to read clipboard contents: ', err);
        });
        return true;
    }, true, 1450, 850, 275, 45, "Merge from clipboard", "#ffffff", "");
    DrawButtonKDEx("DeleteEditorTiles", () => {
        if (KDTE_confirmreset) {
            KDTE_confirmreset = false;
            KDMapTilesListEditor = JSON.parse(JSON.stringify(KDMapTilesList));
        }
        else {
            KDTE_confirmreset = true;
        }
        return true;
    }, true, 1450, 800, 275, 40, "Reset tile database", "#ffffff", "");
    if (KDTE_confirmreset) {
        DrawTextFitKD("This is a DESTRUCTIVE operation. Click the button again to do it. Save a tile to commit fully.", 1400, 470, 1000, "#ffff00", "#ff0000");
    }
    DrawButtonKDEx("PasteTileFromCB", () => {
        let success = false;
        navigator.clipboard.readText()
            .then(text => {
            let tile = JSON.parse(text);
            if (tile && tile.name) {
                console.log(JSON.parse(text));
                console.log("Parse successful!!!");
                KDTE_LoadTile(tile.name, tile);
                if (success) {
                    localStorage.setItem("KDMapTilesListEditor", JSON.stringify(KDMapTilesListEditor));
                    console.log("Saved new tiles to browser local storage.");
                }
            }
        })
            .catch(err => {
            console.error('Failed to read clipboard contents: ', err);
        });
        return true;
    }, true, 1250, 950, 175, 45, "Load tile from Clipboard", "#ffffff", "");
    DrawButtonKDEx("MakeTileCB", () => {
        var text = JSON.stringify(KDTE_ExportTile());
        navigator.clipboard.writeText(text).then(function () {
            console.log('Async: Copying to clipboard was successful!');
        }, function (err) {
            console.error('Async: Could not copy text: ', err);
        });
        return true;
    }, true, 1250, 900, 175, 45, "Copy Tile to Clipboard", "#ffffff", "");
    DrawButtonKDEx("CommitTiles", () => {
        if (KDTE_confirmcommit) {
            KDTE_confirmcommit = false;
            KDMapTilesList = JSON.parse(JSON.stringify(KDMapTilesListEditor));
        }
        else {
            KDTE_confirmcommit = true;
        }
        return true;
    }, true, 1450, 950, 275, 45, "Commit Editor Tiles", "#ffffff", "");
    if (KDTE_confirmcommit) {
        DrawTextFitKD("This will temporarily make the game use your editor's tiles. You are responsible for any crashes.", 1400, 470, 1000, "#ffffff", "#ff00aa");
    }
    KDEditorTileIndexQuery = indexX
        + ","
        + indexY;
    for (let sim_x = 0; sim_x < KinkyDungeonGridWidth - 1; sim_x += KDTE_Scale) {
        for (let sim_y = 0; sim_y < KinkyDungeonGridHeight - 1; sim_y += KDTE_Scale) {
            let indexXX = (Math.floor(Math.max(0, Math.min(KinkyDungeonGridWidth - 1, sim_x)) / KDTE_Scale));
            let indexYY = (Math.floor(Math.max(0, Math.min(KinkyDungeonGridHeight - 1, sim_y)) / KDTE_Scale));
            let patt = KDGetTileIndexImg(KDEditorTileIndexStore[(indexXX + 1) + "," + (indexYY + 1)]);
            if (patt) {
                if (patt.u && indexYY == 0)
                    KDTE_Clear(indexXX * KDTE_Scale + Math.floor(KDTE_Scale / 2), indexYY * KDTE_Scale);
                if (patt.d && indexYY == Math.floor((KinkyDungeonGridHeight - 1) / KDTE_Scale))
                    KDTE_Clear(indexXX * KDTE_Scale + Math.floor(KDTE_Scale / 2), indexYY * KDTE_Scale + KDTE_Scale - 1);
                if (patt.l && indexXX == 0)
                    KDTE_Clear(indexXX * KDTE_Scale, indexYY * KDTE_Scale + Math.floor(KDTE_Scale / 2));
                if (patt.r && indexXX == Math.floor((KinkyDungeonGridWidth - 1) / KDTE_Scale))
                    KDTE_Clear(indexXX * KDTE_Scale + KDTE_Scale - 1, indexYY * KDTE_Scale + Math.floor(KDTE_Scale / 2));
            }
        }
    }
    if (mouseDown && !CommonIsMobile) {
        if (!KDTE_lastMouse)
            KDTE_lastMouse = CommonTime();
        if (CommonTime() > KDTE_lastMouse + KDTEHoldDelay)
            KDHandleTileEditor(true);
    }
    else
        KDTE_lastMouse = 0;
    KDTE_CustomUI();
}
let customfieldsElements = [];
function KDTE_CustomUI() {
    let brush = KDTilePalette[KDEditorTileBrush];
    let names = [];
    if (brush === null || brush === void 0 ? void 0 : brush.customfields) {
        names.push(...Object.keys(brush.customfields));
    }
    for (let element of customfieldsElements) {
        if (!names.includes(element)) {
            ElementRemove("KDTECustomField" + element);
            customfieldsElements.splice(customfieldsElements.indexOf(element), 1);
        }
    }
    let YY = 990 - names.length * 55;
    let XX = 650;
    for (let name of names) {
        if (!customfieldsElements.includes(name)) {
            ElementCreateTextArea("KDTECustomField" + name);
            document.getElementById("KDTECustomField" + name).setAttribute("placeholder", name);
            ElementPosition("KDTECustomField" + name, XX, YY, 300, 45);
            YY += 55;
            customfieldsElements.push(name);
        }
    }
}
let KDTE_lastMouse = 0;
let KDTEHoldDelay = 200;
let KDTEmode = 0;
let KDTE_Scale = 7;
let KDTE_MAXDIM = 4;
let KDTELoadConfirm = false;
function KDTE_Clear(x, y, force = false) {
    if (force || !KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(x, y))) {
        KinkyDungeonMapSetForce(x, y, '0');
        KinkyDungeonTilesDelete(x + "," + y);
        delete KinkyDungeonTilesSkin[x + "," + y];
        for (let jail of KDGameData.JailPoints) {
            if (jail.x == x && jail.y == y)
                KDGameData.JailPoints.splice(KDGameData.JailPoints.indexOf(jail), 1);
        }
    }
}
let KDTE_Brush = {
    "clear": (brush, curr, noSwap) => {
        KDTE_Clear(KinkyDungeonTargetX, KinkyDungeonTargetY, true);
        for (let p of KinkyDungeonPOI) {
            if (p.x == KinkyDungeonTargetX && p.y == KinkyDungeonTargetY) {
                KinkyDungeonPOI.splice(KinkyDungeonPOI.indexOf(p), 1);
                break;
            }
        }
        delete KinkyDungeonEffectTiles[KinkyDungeonTargetX + "," + KinkyDungeonTargetY];
    },
    "tile": (brush, curr, noSwap) => {
        let OL = KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY) ? KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).OffLimits : undefined;
        let Jail = KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY) ? KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).Jail : undefined;
        let tile = (curr == brush.tile && !noSwap) ? '0' : brush.tile;
        if (tile == '0') {
            if (!noSwap) {
                KDTE_Clear(KinkyDungeonTargetX, KinkyDungeonTargetY, true);
                if (OL || Jail)
                    KinkyDungeonTilesSet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY, { OffLimits: OL, Jail: Jail });
            }
        }
        else if (curr != tile) {
            KinkyDungeonMapSetForce(KinkyDungeonTargetX, KinkyDungeonTargetY, tile);
            if (brush.jail) {
                KDGameData.JailPoints.push({ x: KinkyDungeonTargetX, y: KinkyDungeonTargetY, type: brush.jail.type, radius: brush.jail.radius });
            }
            if (brush.special) {
                KinkyDungeonTilesSet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY, Object.assign({}, brush.special));
                if (OL)
                    KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).OffLimits = true;
                if (Jail)
                    KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).Jail = true;
                if (brush.customfields) {
                    for (let field of Object.entries(brush.customfields)) {
                        if (KDTE_GetField(field))
                            KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY)[field[0]] = KDTE_GetField(field);
                    }
                }
            }
            else {
                if (OL)
                    KinkyDungeonTilesSet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY, { OffLimits: true });
                else
                    KinkyDungeonTilesDelete(KinkyDungeonTargetX + "," + KinkyDungeonTargetY);
            }
        }
    },
    'offlimits': (brush, curr, noSwap) => {
        if (KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY)) {
            if (KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).OffLimits) {
                if (!noSwap)
                    KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).OffLimits = false;
            }
            else
                KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).OffLimits = true;
        }
        else {
            KinkyDungeonTilesSet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY, { OffLimits: true });
        }
    },
    'jail': (brush, curr, noSwap) => {
        if (KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY)) {
            if (KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).Jail) {
                if (!noSwap)
                    KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).Jail = false;
            }
            else
                KinkyDungeonTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY).Jail = true;
        }
        else {
            KinkyDungeonTilesSet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY, { Jail: true });
        }
    },
    'Keyring': (brush, curr, noSwap) => {
        let keyringLength = KDGameData.KeyringLocations.length;
        let filtered = KDGameData.KeyringLocations.filter((e) => { return e.x != KinkyDungeonTargetX || e.y != KinkyDungeonTargetY; });
        if (filtered.length != keyringLength) {
            if (!noSwap)
                KDGameData.KeyringLocations = filtered;
        }
        else {
            KDGameData.KeyringLocations.push({ x: KinkyDungeonTargetX, y: KinkyDungeonTargetY });
        }
    },
    "effect": (brush, curr, noSwap) => {
        if ((brush.wall && KinkyDungeonWallTiles.includes(curr))
            || (brush.floor && KinkyDungeonGroundTiles.includes(curr))
            || (!brush.floor && !brush.wall)) {
            if (KinkyDungeonEffectTilesGet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY)) {
                if (!noSwap)
                    delete KinkyDungeonEffectTiles[KinkyDungeonTargetX + "," + KinkyDungeonTargetY];
            }
            else {
                KDCreateEffectTile(KinkyDungeonTargetX, KinkyDungeonTargetY, { name: brush.effectTile }, 0);
            }
        }
    },
    "POI": (brush, curr, noSwap) => {
        let deleted = false;
        for (let p of KinkyDungeonPOI) {
            if (p.x == KinkyDungeonTargetX && p.y == KinkyDungeonTargetY) {
                if (!noSwap) {
                    if (!p.requireTags.includes("endpoint")) {
                        let chanceCycle = [1.0, 0.75, 0.5, 0.25, 0.15, 0.1, 0.05, 0.01];
                        let chanceIndex = chanceCycle.indexOf(p.chance || 1.0);
                        chanceIndex += 1;
                        if (chanceIndex >= chanceCycle.length) {
                            p.requireTags.push("endpoint");
                            p.chance = 1.0;
                        }
                        else {
                            p.chance = chanceCycle[chanceIndex];
                        }
                    }
                    else {
                        KinkyDungeonPOI.splice(KinkyDungeonPOI.indexOf(p), 1);
                    }
                }
                deleted = true;
                break;
            }
        }
        if (!deleted) {
            let tags = [];
            let favor = [];
            if (ElementValue("MapTileCategory"))
                favor.push(ElementValue("MapTileCategory"));
            KinkyDungeonPOI.push({ x: KinkyDungeonTargetX, y: KinkyDungeonTargetY, requireTags: tags, favor: favor, used: false });
        }
    }
};
let KDTE_Inaccessible = false;
let KDTE_confirmreset = false;
let KDTE_confirmcommit = false;
function KDHandleTileEditor(noSwap) {
    if (!noSwap && KDTE_lastMouse && CommonTime() > KDTE_lastMouse + KDTEHoldDelay)
        return;
    KDTE_confirmreset = false;
    KDTE_confirmcommit = false;
    if (KDTE_State)
        return;
    KDTESetIndexToTile(KDEditorCurrentMapTileName);
    KinkyDungeonTargetX = Math.round((MouseX - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetX) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamX;
    KinkyDungeonTargetY = Math.round((MouseY - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetY) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamY;
    if (KinkyDungeonTargetX >= 0 && KinkyDungeonTargetX < KinkyDungeonGridWidth
        && KinkyDungeonTargetY >= 0 && KinkyDungeonTargetY < KinkyDungeonGridHeight) {
        KDTELoadConfirm = false;
        let curr = KinkyDungeonMapGet(KinkyDungeonTargetX, KinkyDungeonTargetY);
        let brush = KDTilePalette[KDEditorTileBrush];
        if (KDTE_Brush[brush.type]) {
            KDTE_Brush[brush.type](brush, curr, noSwap);
        }
        if (ElementValue("MapTileSkin")) {
            KinkyDungeonSkinSet(KinkyDungeonTargetX + "," + KinkyDungeonTargetY, { force: true, skin: ElementValue("MapTileSkin") });
        }
        else {
            KinkyDungeonSkinDelete(KinkyDungeonTargetX + "," + KinkyDungeonTargetY);
        }
        if (!noSwap) {
            KDVisionUpdate = 1;
            KinkyDungeonMakeBrightnessMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, KinkyDungeonMapBrightness, [], KDVisionUpdate);
            KinkyDungeonMakeVisionMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, [], [], KDVisionUpdate, KinkyDungeonMapBrightness);
            KDVisionUpdate = 0;
        }
    }
    if (KDEditorTileIndexHover) {
        KDEditorTileIndexStore[KDEditorTileIndexQuery] = KDEditorTileIndexHover;
    }
    if (!noSwap) {
        let inaccess = KDTEGetInaccessible();
        if (inaccess.length > 0)
            KDTE_Inaccessible = true;
        else
            KDTE_Inaccessible = false;
    }
}
function KDTE_UpdateUI(Load) {
    let tagCount = 17;
    if (Load) {
        ElementCreateTextArea("MapTileTitle");
        ElementValue("MapTileTitle", KDEditorCurrentMapTileName);
        ElementCreateTextArea("MapTileTileset");
        ElementValue("MapTileTileset", ElementValue("MapTileTileset") ? ElementValue("MapTileTileset") : KinkyDungeonMapIndex.grv);
        ElementCreateTextArea("MapTileCategory");
        ElementValue("MapTileCategory", "urban");
        ElementCreateTextArea("MapTileWeight");
        ElementValue("MapTileWeight", "10");
        ElementCreateTextArea("MapTileX");
        ElementValue("MapTileX", "1");
        ElementCreateTextArea("MapTileY");
        ElementValue("MapTileY", "1");
        ElementCreateTextArea("MapTags");
        ElementCreateTextArea("MapRequireTags");
        ElementCreateTextArea("MapForbidTags");
        for (let i = 0; i < tagCount; i++) {
            ElementCreateTextArea("MapCountTag" + i);
            ElementCreateTextArea("MapCountTagMult" + i);
            ElementCreateTextArea("MapCountTagBonus" + i);
            ElementCreateTextArea("MapCountTagMax" + i);
            ElementCreateTextArea("MapCountTagNot" + i);
            ElementValue("MapCountTagMax" + i, "-1");
            ElementValue("MapCountTagBonus" + i, "0");
            ElementValue("MapCountTagMult" + i, "1");
            ElementValue("MapCountTagNot" + i, "");
        }
    }
    if (KDTE_State == "Tags") {
        DrawTextFitKD("Tile Tags", 300, 50, 500, "#ffffff");
        ElementPosition("MapTags", 300, 200, 500, 200);
        DrawTextFitKD("Require Tags", 300, 350, 500, "#ffffff");
        ElementPosition("MapRequireTags", 300, 500, 500, 200);
        DrawTextFitKD("Forbid Tags", 300, 650, 500, "#ffffff");
        ElementPosition("MapForbidTags", 300, 800, 500, 200);
        for (let i = 0; i < tagCount; i++) {
            DrawTextFitKD("Existing Tag", 1450, 150, 400, "#ffffff");
            DrawTextFitKD("Mult", 1720, 150, 400, "#ffffff");
            DrawTextFitKD("Bonus", 1820, 150, 400, "#ffffff");
            DrawTextFitKD("Max", 1920, 150, 400, "#ffffff");
            ElementPosition("MapCountTag" + i, 1450, 200 + 50 * i, 200, 40);
            ElementPosition("MapCountTagMult" + i, 1680, 200 + 50 * i, 150, 40);
            ElementPosition("MapCountTagBonus" + i, 1820, 200 + 50 * i, 110, 40);
            ElementPosition("MapCountTagMax" + i, 1920, 200 + 50 * i, 110, 40);
            DrawTextFitKD("NOT", 1250, 150, 400, "#ffffff");
            ElementPosition("MapCountTagNot" + i, 1250, 200 + 50 * i, 110, 40);
        }
    }
    else {
        ElementPosition("MapTags", 300, -1000, 500, 200);
        ElementPosition("MapRequireTags", 300, -1000, 500, 200);
        ElementPosition("MapForbidTags", 300, -1000, 500, 200);
        for (let i = 0; i < tagCount; i++) {
            ElementPosition("MapCountTag" + i, 1700, -1000, 200, 40);
            ElementPosition("MapCountTagMult" + i, 1900, -1000, 90, 40);
            ElementPosition("MapCountTagBonus" + i, 1900, -1000, 90, 40);
            ElementPosition("MapCountTagMax" + i, 1900, -1000, 90, 40);
            ElementPosition("MapCountTagNot" + i, 1900, -1000, 90, 40);
        }
    }
    DrawTextFitKD("X", 1700, 25, 100, "#ffffff");
    ElementPosition("MapTileX", 1800, 25, 150);
    DrawTextFitKD("Y", 1700, 75, 100, "#ffffff");
    ElementPosition("MapTileY", 1800, 75, 150);
    DrawTextFitKD("Name of Tile", 1000, 25, 200, "#ffffff");
    ElementPosition("MapTileTitle", 1000, 70, 400);
    let propTile = ElementValue("MapTileTitle");
    KDEditorCurrentMapTileName = propTile;
    DrawTextFitKD("Tileset", 1000 - 400, 25, 200, "#ffffff");
    ElementPosition("MapTileTileset", 1000 - 400, 70, 200);
    DrawTextFitKD("Skin", 1000 - 400, 120, 200, "#ffffff");
    KDTextField("MapTileSkin", 1000 - 400 - 100, 150, 200, 60);
    let propTileset = ElementValue("MapTileTileset");
    if (KinkyDungeonMapParams[propTileset]) {
        KinkyDungeonMapIndex.grv = propTileset;
    }
    DrawTextFitKD("Category", 1000 + 350, 25, 200, "#ffffff");
    ElementPosition("MapTileCategory", 1000 + 350, 70, 200);
    DrawTextFitKD("Weight", 1000 + 550, 25, 200, "#ffffff");
    ElementPosition("MapTileWeight", 1000 + 550, 70, 200);
    if (KDTE_Inaccessible)
        DrawTextFitKD("Some entrances are inaccessible. This tile will occur more rarely in worldgen", 1000, 800, 1000, "#ff5555");
}
function KDTESetIndexToTile(propTile) {
    if (KDMapTilesListEditor[propTile]) {
        let tileKeys = Object.keys(KDMapTilesListEditor);
        let brushKeys = Object.keys(KDTilePalette);
        KDEditorTileNameIndex = tileKeys.indexOf(propTile) - 9;
        KDTE_CullIndex(tileKeys, brushKeys);
    }
}
function KDTE_CullIndex(tileKeys, brushKeys) {
    KDEditorTileNameIndex = Math.max(0, Math.min(tileKeys.length - 6, KDEditorTileNameIndex));
    KDEditorTileBrushIndex = Math.max(0, Math.min(brushKeys.length - 6, KDEditorTileBrushIndex));
    KDEditorTileBrushIndex2 = Math.max(0, Math.min(brushKeys.length - 6, KDEditorTileBrushIndex2));
}
function KDTE_CloseUI() {
    ElementRemove("MapTileTitle");
    ElementRemove("MapTileTileset");
    ElementRemove("MapTileCategory");
    ElementRemove("MapTileWeight");
    ElementRemove("MapTileX");
    ElementRemove("MapTileY");
}
function KDTE_Create(w, h, chkpoint = 'grv') {
    MiniGameKinkyDungeonCheckpoint = 'grv';
    KinkyDungeonMapIndex = {
        'grv': chkpoint,
    };
    KinkyDungeonSeeAll = true;
    KinkyDungeonGrid = "";
    KinkyDungeonGridWidth = KDTE_Scale * w;
    KinkyDungeonGridHeight = KDTE_Scale * h;
    for (let y = 0; y < KinkyDungeonGridHeight; y++) {
        for (let x = 0; x < KinkyDungeonGridWidth; x++) {
            KinkyDungeonGrid = KinkyDungeonGrid + "1";
        }
        KinkyDungeonGrid = KinkyDungeonGrid + "\n";
    }
    KinkyDungeonTiles = {};
    KinkyDungeonEffectTiles = {};
    KinkyDungeonTilesSkin = {};
    KinkyDungeonEntities = [];
    KinkyDungeonTilesMemory = {};
    KinkyDungeonPOI = [];
    KDGameData.KeyringLocations = [];
    KDEditorTileIndexStore = {};
    for (let ww = 1; ww <= w; ww++) {
        for (let hh = 1; hh <= h; hh++) {
            KDEditorTileIndexStore[ww + "," + hh] = 'udlr';
        }
    }
    KDEditorTileFlexStore = {};
    KDEditorTileFlexSuperStore = {};
    KinkyDungeonPlayerEntity = {
        x: Math.floor(KinkyDungeonGridWidth / 2),
        y: Math.floor(KinkyDungeonGridHeight / 2),
        player: true,
    };
    KDInitCanvas();
    KDVisionUpdate = 1;
    KinkyDungeonMakeBrightnessMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, KinkyDungeonMapBrightness, [], KDVisionUpdate);
    KinkyDungeonMakeVisionMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, [], [], KDVisionUpdate, KinkyDungeonMapBrightness);
    KDVisionUpdate = 0;
    KDTE_UpdateUI(true);
}
function KDTE_LoadTile(name, loadedTile) {
    let nt = loadedTile || KDMapTilesListEditor[name];
    KDTE_Create(nt.w, nt.h);
    KDEditorTileIndexStore = nt.index;
    KDEditorTileFlexStore = nt.flexEdge || {};
    KDEditorTileFlexSuperStore = nt.flexEdgeSuper || {};
    if (nt.category)
        ElementValue("MapTileCategory", nt.category);
    if (nt.weight)
        ElementValue("MapTileWeight", "" + nt.weight);
    KinkyDungeonGrid = nt.grid;
    KinkyDungeonPOI = [];
    for (let p of nt.POI) {
        KinkyDungeonPOI.push(Object.assign({}, p));
    }
    KDGameData.KeyringLocations = [];
    if (nt.Keyring) {
        for (let k of nt.Keyring) {
            KDGameData.KeyringLocations.push({ x: k.x, y: k.y });
        }
    }
    KinkyDungeonTiles = KDObjFromMapArray(nt.Tiles);
    KinkyDungeonTilesSkin = KDObjFromMapArray(nt.Skin);
    KDGameData.JailPoints = [];
    for (let j of nt.Jail) {
        KDGameData.JailPoints.push(Object.assign({}, j));
    }
    let array = KDObjFromMapArray(nt.effectTiles);
    for (let tile of Object.entries(array)) {
        KinkyDungeonEffectTilesSet(tile[0], KDObjFromMapArray(tile[1]));
    }
    KDVisionUpdate = 1;
    KinkyDungeonMakeBrightnessMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, KinkyDungeonMapBrightness, [], KDVisionUpdate);
    KinkyDungeonMakeVisionMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, [], [], KDVisionUpdate, KinkyDungeonMapBrightness);
    KDVisionUpdate = 0;
    ElementValue("MapTags", nt.tags.toString());
    ElementValue("MapRequireTags", nt.requireTags.toString());
    ElementValue("MapForbidTags", nt.forbidTags.toString());
    KDMapTilesListEditor = JSON.parse(JSON.stringify(KDMapTilesListEditor));
    KDTESetIndexToTile(nt.name);
    let tagCount = 17;
    for (let i = 0; i < tagCount; i++) {
        ElementValue("MapCountTag" + i, nt.indexTags[i] ? nt.indexTags[i] : "");
        ElementValue("MapCountTagBonus" + i, "" + (nt.indexTags[i] ? nt.bonusTags[i] : 0));
        ElementValue("MapCountTagMult" + i, "" + (nt.indexTags[i] ? nt.multTags[i] : 1));
        ElementValue("MapCountTagMax" + i, "" + (nt.indexTags[i] ? nt.maxTags[i] : -1));
        ElementValue("MapCountTagNot" + i, (nt.indexTags[i] && nt.notTags ? nt.notTags[i] : ""));
    }
}
function KDTE_ExportTile() {
    let saveTile = {
        name: KDEditorCurrentMapTileName,
        w: KinkyDungeonGridWidth / KDTE_Scale,
        h: KinkyDungeonGridHeight / KDTE_Scale,
        primInd: KDEditorTileIndexStore["1,1"],
        index: KDEditorTileIndexStore,
        flexEdge: KDEditorTileFlexStore || {},
        flexEdgeSuper: KDEditorTileFlexSuperStore || {},
        scale: KDTE_Scale,
        category: ElementValue("MapTileCategory"),
        weight: parseInt(ElementValue("MapTileWeight")) ? parseInt(ElementValue("MapTileWeight")) : 10,
        grid: KinkyDungeonGrid,
        POI: KinkyDungeonPOI,
        Keyring: KDGameData.KeyringLocations,
        Jail: KDGameData.JailPoints,
        Tiles: KinkyDungeonTiles,
        effectTiles: KinkyDungeonEffectTiles,
        Skin: KinkyDungeonTilesSkin,
        inaccessible: KDTEGetInaccessible(),
        tags: ElementValue("MapTags") ? ElementValue("MapTags").split(',') : [ElementValue("MapTileCategory")],
        forbidTags: ElementValue("MapForbidTags") ? ElementValue("MapForbidTags").split(',') : [],
        requireTags: ElementValue("MapRequireTags") ? ElementValue("MapRequireTags").split(',') : [],
        indexTags: [],
        maxTags: [],
        bonusTags: [],
        multTags: [],
        notTags: [],
    };
    let maxTags = 17;
    for (let i = 0; i < maxTags; i++) {
        if (ElementValue("MapCountTag" + i)) {
            saveTile.indexTags.push(ElementValue("MapCountTag" + i));
            saveTile.bonusTags.push(parseInt(ElementValue("MapCountTagBonus" + i)));
            saveTile.multTags.push(parseInt(ElementValue("MapCountTagMult" + i)));
            saveTile.maxTags.push(parseInt(ElementValue("MapCountTagMax" + i)));
            saveTile.notTags.push(ElementValue("MapCountTagNot" + i));
        }
    }
    return saveTile;
}
function KDTE_SaveTile(tile) {
    let saveTile = KDTE_ExportTile();
    KDMapTilesListEditor[KDEditorCurrentMapTileName] = saveTile;
    KDMapTilesListEditor = JSON.parse(JSON.stringify(KDMapTilesListEditor));
    KDTESetIndexToTile(KDEditorCurrentMapTileName);
    localStorage.setItem("KDMapTilesListEditor", JSON.stringify(KDMapTilesListEditor));
}
function KDTEGetInaccessible() {
    let list = [];
    let listEntrances = [];
    for (let ind of Object.entries(KDEditorTileIndexStore)) {
        let indX = parseInt(ind[0].split(',')[0]);
        let indY = parseInt(ind[0].split(',')[1]);
        if (indX && indY) {
            if (indX == 1 && ind[1].includes('l'))
                listEntrances.push({ indX: indX, indY: indY, dir: 'l' });
            if (indX == 1 + Math.floor((KinkyDungeonGridWidth - 1) / KDTE_Scale) && ind[1].includes('r'))
                listEntrances.push({ indX: indX, indY: indY, dir: 'r' });
            if (indY == 1 && ind[1].includes('u'))
                listEntrances.push({ indX: indX, indY: indY, dir: 'u' });
            if (indY == 1 + Math.floor((KinkyDungeonGridHeight - 1) / KDTE_Scale) && ind[1].includes('d'))
                listEntrances.push({ indX: indX, indY: indY, dir: 'd' });
        }
    }
    let pairsTested = {};
    for (let entrance1 of listEntrances) {
        for (let entrance2 of listEntrances) {
            if (entrance1 == entrance2)
                continue;
            let ID = entrance1.indX + "," + entrance1.indY + "," + entrance1.dir + ","
                + entrance2.indX + "," + entrance2.indY + "," + entrance2.dir;
            if (pairsTested[ID])
                continue;
            pairsTested[ID] = true;
            let x1 = (entrance1.indX - 1) * KDTE_Scale;
            if (entrance1.dir == 'r')
                x1 += KDTE_Scale;
            else if (entrance1.dir == 'u' || entrance1.dir == 'd')
                x1 += Math.floor(KDTE_Scale / 2);
            let x2 = (entrance2.indX - 1) * KDTE_Scale;
            if (entrance2.dir == 'r')
                x2 += KDTE_Scale;
            else if (entrance2.dir == 'u' || entrance2.dir == 'd')
                x2 += Math.floor(KDTE_Scale / 2);
            let y1 = (entrance1.indY - 1) * KDTE_Scale;
            if (entrance1.dir == 'd')
                y1 += KDTE_Scale;
            else if (entrance1.dir == 'l' || entrance1.dir == 'r')
                y1 += Math.floor(KDTE_Scale / 2);
            let y2 = (entrance2.indY - 1) * KDTE_Scale;
            if (entrance2.dir == 'd')
                y2 += KDTE_Scale;
            else if (entrance2.dir == 'l' || entrance2.dir == 'r')
                y2 += Math.floor(KDTE_Scale / 2);
            KDPathCacheIgnoreLocks = new Map();
            KDPathCache = new Map();
            let access = KinkyDungeonFindPath(x1, y1, x2, y2, false, false, false, KinkyDungeonMovableTilesSmartEnemy);
            if (!access) {
                list.push({
                    indX1: entrance1.indX,
                    indY1: entrance1.indY,
                    indX2: entrance2.indX,
                    indY2: entrance2.indY,
                    dir1: entrance1.dir,
                    dir2: entrance2.dir,
                });
            }
        }
    }
    return list;
}
function KDObjFromMapArray(array) {
    if (array.length != undefined) {
        let map = {};
        for (let entry of array) {
            map[entry[0]] = entry[1];
        }
        return map;
    }
    else {
        return array;
    }
}
function KDReloadAllEditorTiles() {
    for (let tile of Object.entries(KDMapTilesList)) {
        KDEditorCurrentMapTileName = tile[0];
        KDTE_LoadTile(tile[0]);
        KDTE_SaveTile();
    }
}
function KDTE_GetField(field) {
    var _a;
    if (!field[1])
        return undefined;
    if (ElementValue("KDTECustomField" + field[0]) == "")
        return undefined;
    if (field[1].type == 'array')
        return (_a = ElementValue("KDTECustomField" + field[0])) === null || _a === void 0 ? void 0 : _a.split(',');
    if (field[1].type == 'number')
        return parseFloat(ElementValue("KDTECustomField" + field[0])) || 0;
    return ElementValue("KDTECustomField" + field[0]);
}
let KD_GENWEIGHTCUTOFF = 100000;
function KDMapTilesPopulate(w, h, indices, data, requiredAccess, maxTagFlags, tagModifiers) {
    let tiles_temp = [];
    for (let t of Object.keys(indices)) {
        tiles_temp.push(t);
    }
    let tileOrder = [];
    while (tiles_temp.length > 0) {
        let ind = Math.floor(KDRandom() * tiles_temp.length);
        tileOrder.push(tiles_temp[ind]);
        tiles_temp.splice(ind, 1);
    }
    let tilesFilled = {};
    let indexFilled = {};
    let tagCounts = {};
    let fails = 0;
    let ii = 0;
    let globalTags = Object.assign({}, data.params.globalTags || {});
    if (KinkyDungeonStatsChoice.get("arousalMode"))
        globalTags.arousalMode = true;
    while (tileOrder.length > 0) {
        let tileOrderInd = Math.floor(KDRandom() * tileOrder.length);
        let tileSpot = tileOrder[tileOrderInd];
        let indX = parseInt(tileSpot.split(',')[0]);
        let indY = parseInt(tileSpot.split(',')[1]);
        if (indX == undefined || indY == undefined) {
            fails += 1;
            if (fails > 100)
                tileOrder = [];
            console.log("Nuclear meltdown. Pls report. Tilespot = " + tileSpot);
            continue;
        }
        if (ii == 0 || ((indices[tileSpot].includes('l') && indexFilled[(indX - 1) + ',' + (indY)])
            || (indices[tileSpot].includes('r') && indexFilled[(indX + 1) + ',' + (indY)])
            || (indices[tileSpot].includes('u') && indexFilled[(indX) + ',' + (indY - 1)])
            || (indices[tileSpot].includes('d') && indexFilled[(indX) + ',' + (indY + 1)]))) {
            let cornerX = (indX - 1) * KDTE_Scale + 1;
            let cornerY = (indY - 1) * KDTE_Scale + 1;
            if (indexFilled[tileSpot]) {
                tileOrder.splice(tileOrderInd, 1);
                continue;
            }
            let index = indices[tileSpot];
            if (!index) {
                fails += 1;
                if (fails > 100)
                    tileOrder = [];
                console.log("Nuclear meltdown. Pls report. Index = " + index + ", Tilespot = " + tileSpot);
                continue;
            }
            let tileName = KD_GetMapTile(index, indX, indY, tilesFilled, indexFilled, tagCounts, requiredAccess, globalTags, indices, tagModifiers);
            let tile = KDMapTilesList[tileName];
            let tags = KD_PasteTile(tile, cornerX, cornerY, data);
            if (tags) {
                for (let t of tags) {
                    if (!tagCounts[t])
                        tagCounts[t] = 1;
                    else
                        tagCounts[t] += 1;
                }
                for (let xx = 1; xx <= tile.w; xx++)
                    for (let yy = 1; yy <= tile.h; yy++) {
                        tilesFilled[(indX + xx - 1) + "," + (indY + yy - 1)] = tile;
                        indexFilled[(indX + xx - 1) + "," + (indY + yy - 1)] = tile.index[xx + ',' + yy];
                    }
            }
            tileOrder.splice(tileOrderInd, 1);
        }
        for (let t of Object.entries(maxTagFlags)) {
            if (tagCounts[t[0]] >= t[1])
                globalTags["max" + t[0]] = true;
        }
        ii += 1;
    }
    console.log(tagCounts);
    console.log(globalTags);
    console.log(tilesFilled);
    console.log(indexFilled);
    return tilesFilled;
}
function KDGetTileWeight(mapTile, tags, tagCounts, tagModifiers) {
    let weight = mapTile.weight;
    if (mapTile.forbidTags) {
        for (let tag of mapTile.forbidTags) {
            if (tags[tag])
                return 0;
        }
    }
    if (mapTile.requireTags) {
        for (let tag of mapTile.requireTags) {
            if (!tags[tag]) {
                return 0;
            }
        }
    }
    for (let i = 0; i < mapTile.indexTags.length; i++) {
        let not = mapTile.notTags && mapTile.notTags[i];
        if ((!not && tags[mapTile.indexTags[i]])
            || (not && !tags[mapTile.indexTags[i]])) {
            if (mapTile.maxTags[i] >= 0) {
                let count = tagCounts[mapTile.maxTags[i]];
                if (count && count >= mapTile.maxTags[i])
                    return 0;
            }
            if (mapTile.bonusTags[i])
                weight += mapTile.bonusTags[i];
            if (mapTile.multTags[i] != undefined)
                weight *= mapTile.multTags[i];
        }
    }
    if (weight > 0 && tagModifiers) {
        for (let tag of mapTile.tags) {
            if (tagModifiers[tag] != undefined)
                weight *= tagModifiers[tag];
            if (weight == 0)
                return 0;
        }
    }
    return weight;
}
function KD_GetMapTile(index, indX, indY, tilesFilled, indexFilled, tagCounts, requiredAccess, globalTags, indices, tagModifiers) {
    let tagList = {
        "1,1": KDAggregateTileTags(indX, indY, 1, 1, tilesFilled, globalTags),
    };
    let tile = null;
    let WeightTotal = 0;
    let Weights = [];
    let maxWeight = 0;
    for (let mapTile of Object.values(KDMapTilesList)) {
        if (mapTile.primInd == index || (mapTile.flexEdge && mapTile.flexEdge['1,1'])) {
            if (!KDCheckMapTileFilling(mapTile, indX, indY, indices, requiredAccess, indexFilled))
                continue;
            if (!KDCheckMapTileAccess(mapTile, indX, indY, indexFilled, requiredAccess))
                continue;
            let tags = tagList[mapTile.w + ',' + mapTile.h];
            if (!tags) {
                tags = KDAggregateTileTags(indX, indY, mapTile.w, mapTile.h, tilesFilled, globalTags);
                tagList[mapTile.w + ',' + mapTile.h] = tags;
            }
            if (requiredAccess[indX + ',' + indY])
                tags.start = true;
            let weight = KDGetTileWeight(mapTile, tags, tagCounts, tagModifiers);
            if (weight > 0 && (maxWeight < KD_GENWEIGHTCUTOFF || weight >= KD_GENWEIGHTCUTOFF)) {
                maxWeight = weight;
                Weights.push({ tile: mapTile, weight: WeightTotal });
                WeightTotal += mapTile.weight;
            }
        }
    }
    if (maxWeight >= KD_GENWEIGHTCUTOFF) {
        for (let L = Weights.length - 1; L >= 0; L--) {
            if (Weights[L].weight < KD_GENWEIGHTCUTOFF) {
                Weights[L].weight = 0;
                break;
            }
        }
    }
    let selection = KDRandom() * WeightTotal;
    for (let L = Weights.length - 1; L >= 0; L--) {
        if (selection > Weights[L].weight) {
            tile = Weights[L].tile.name;
            break;
        }
    }
    if (!tile) {
        console.log("ERROR AT INDEX " + indX + "," + indY);
    }
    return tile;
}
function KDCheckMapTileFilling(mapTile, indX, indY, indices, requiredAccess, indexFilled) {
    let passCount = 0;
    for (let xx = 1; xx <= mapTile.w; xx++)
        for (let yy = 1; yy <= mapTile.h; yy++) {
            let fail = false;
            let ind = mapTile.index[xx + ',' + yy];
            if (!indices[(xx + indX - 1) + ',' + (yy + indY - 1)])
                return false;
            if (ind != indices[(xx + indX - 1) + ',' + (yy + indY - 1)] && KDLooseIndexRankingSuspend(indices[(xx + indX - 1) + ',' + (yy + indY - 1)], ind, mapTile.w, mapTile.h, xx, yy)) {
                if (mapTile.flexEdge && mapTile.flexEdge[xx + ',' + yy] && ((mapTile.flexEdgeSuper && mapTile.flexEdgeSuper[xx + ',' + yy]) || ((yy > 1 || !indices[(xx + indX - 1) + ',' + (yy + indY - 1)].includes('u') || indexFilled[(xx + indX - 1) + ',' + (yy + indY - 1 - 1)])
                    && (yy < mapTile.h || !indices[(xx + indX - 1) + ',' + (yy + indY - 1)].includes('d') || indexFilled[(xx + indX - 1) + ',' + (yy + indY - 1 + 1)])
                    && (xx < mapTile.w || !indices[(xx + indX - 1) + ',' + (yy + indY - 1)].includes('l') || indexFilled[(xx + indX - 1 - 1) + ',' + (yy + indY - 1)])
                    && (xx > 1 || !indices[(xx + indX - 1) + ',' + (yy + indY - 1)].includes('r') || indexFilled[(xx + indX - 1 + 1) + ',' + (yy + indY - 1)]))))
                    fail = true;
                else
                    return false;
            }
            if (indexFilled[(xx + indX - 1) + ',' + (yy + indY - 1)])
                return false;
            if (mapTile.w != 1 || mapTile.h != 1 || (mapTile.inaccessible && mapTile.inaccessible.length > 0)) {
                if (requiredAccess[(xx + indX - 1) + ',' + (yy + indY - 1)])
                    return false;
            }
            if (!fail)
                passCount += 1;
        }
    return passCount > 0;
}
function KDLooseIndexRankingSuspend(indexCheck, indexTile, w, h, xx, yy) {
    if (w == 1 && h == 1)
        return true;
    if (xx > 1 && xx < w && yy > 1 && yy < h)
        return false;
    if (!indexCheck)
        return true;
    if (!indexTile)
        return true;
    if (indexCheck.includes('u') && yy == 1 && !indexTile.includes('u'))
        return true;
    if (indexCheck.includes('d') && yy == h && !indexTile.includes('d'))
        return true;
    if (indexCheck.includes('l') && xx == 1 && !indexTile.includes('l'))
        return true;
    if (indexCheck.includes('r') && xx == w && !indexTile.includes('r'))
        return true;
    return false;
}
function KDCheckMapTileAccess(mapTile, indX, indY, indexFilled, requiredAccess) {
    if (mapTile.inaccessible) {
        for (let access of mapTile.inaccessible) {
            let XX1 = indX + access.indX1 - 1;
            let XX2 = indX + access.indX2 - 1;
            let YY1 = indY + access.indY1 - 1;
            let YY2 = indY + access.indY2 - 1;
            if ((access.dir1 == "l" && !indexFilled[(XX1 - 1) + ',' + (YY1)])
                || (access.dir1 == "r" && !indexFilled[(XX1 + 1) + ',' + (YY1)])
                || (access.dir1 == "u" && !indexFilled[(XX1) + ',' + (YY1 - 1)])
                || (access.dir1 == "d" && !indexFilled[(XX1) + ',' + (YY1 + 1)]))
                return false;
            if ((access.dir2 == "l" && !indexFilled[(XX2 - 1) + ',' + (YY2)])
                || (access.dir2 == "r" && !indexFilled[(XX2 + 1) + ',' + (YY2)])
                || (access.dir2 == "u" && !indexFilled[(XX2) + ',' + (YY2 - 1)])
                || (access.dir2 == "d" && !indexFilled[(XX2) + ',' + (YY2 + 1)]))
                return false;
        }
    }
    return true;
}
function KD_PasteTile(tile, x, y, data) {
    let tileWidth = KDTE_Scale * tile.w;
    let tileHeight = KDTE_Scale * tile.h;
    for (let xx = 0; xx < tileWidth; xx++)
        for (let yy = 0; yy < tileHeight; yy++) {
            let tileTile = tile.grid[xx + yy * (tileWidth + 1)];
            KinkyDungeonMapSetForce(x + xx, y + yy, tileTile);
            if (tileTile == 'B' && !data.notraps && KinkyDungeonStatsChoice.has("Nowhere")) {
                if (KDRandom() < 0.5)
                    KinkyDungeonTilesSet((x + xx) + "," + (y + yy), {
                        Type: "Trap",
                        Trap: "BedTrap",
                    });
            }
        }
    if (tile.Keyring) {
        for (let k of tile.Keyring) {
            KDGameData.KeyringLocations.push({ x: x + k.x, y: y + k.y });
        }
    }
    if (tile.POI)
        for (let origPoi of tile.POI) {
            let poi = Object.assign({}, origPoi);
            KinkyDungeonPOI.push(poi);
            poi.x = x + poi.x;
            poi.y = y + poi.y;
            if (poi.chance && KDRandom() > poi.chance)
                poi.used = true;
        }
    for (let tileLoc of Object.entries(tile.Tiles)) {
        let xx = parseInt(tileLoc[0].split(',')[0]);
        let yy = parseInt(tileLoc[0].split(',')[1]);
        if (xx != undefined && yy != undefined) {
            let gennedTile = KDCreateTile(xx + x, yy + y, Object.assign({}, tileLoc[1]), data);
            if (gennedTile)
                KinkyDungeonTilesSet((xx + x) + "," + (yy + y), gennedTile);
        }
    }
    for (let tileLoc of Object.entries(tile.Skin)) {
        let xx = parseInt(tileLoc[0].split(',')[0]);
        let yy = parseInt(tileLoc[0].split(',')[1]);
        if (xx != undefined && yy != undefined) {
            KinkyDungeonTilesSkin[(xx + x) + "," + (yy + y)] = tileLoc[1];
        }
    }
    for (let tileLoc of Object.entries(tile.effectTiles)) {
        let xx = parseInt(tileLoc[0].split(',')[0]);
        let yy = parseInt(tileLoc[0].split(',')[1]);
        if (xx != undefined && yy != undefined) {
            for (let eTile of Object.entries(tileLoc[1])) {
                KDCreateEffectTileTile(xx + x, yy + y, eTile[1], data);
            }
        }
    }
    return tile.tags;
}
let KDEffectTileGen = {
    "TorchUnlit": (x, y, tile, tileGenerator, data) => {
        let torchlitchance = data.params.torchlitchance || 0.6;
        let torchreplace = data.params.torchreplace;
        let spr = torchreplace ? torchreplace.sprite : "Torch";
        if ((!torchreplace || torchreplace.unlitsprite) && KDRandom() > torchlitchance) {
            spr = torchreplace ? torchreplace.unlitsprite : "TorchUnlit";
        }
        KDCreateEffectTile(x, y, {
            name: spr,
            duration: 9999,
        }, 0);
        return null;
    },
    "Torch": (x, y, tile, tileGenerator, data) => {
        let torchlitchance = 1.0;
        let torchreplace = data.params.torchreplace;
        let spr = torchreplace ? torchreplace.sprite : "Torch";
        if ((!torchreplace || torchreplace.unlitsprite) && KDRandom() > torchlitchance) {
            spr = torchreplace ? torchreplace.unlitsprite : "TorchUnlit";
        }
        KDCreateEffectTile(x, y, {
            name: spr,
            duration: 9999,
        }, 0);
        return null;
    },
    "Wire": (x, y, tile, tileGenerator, data) => {
        KDCreateEffectTile(x, y, {
            name: "Wire",
            duration: 9999,
        }, 0);
        return null;
    },
};
let KDTileGen = {
    "Rubble": (x, y, tile, tileGenerator, data) => {
        let rubblechance = data.params.rubblechance || 0.5;
        if (KDRandom() < rubblechance)
            KinkyDungeonMapSet(x, y, 'R');
        else if (KDRandom() < rubblechance * rubblechance - 0.01)
            KinkyDungeonMapSet(x, y, '/');
        else
            KinkyDungeonMapSet(x, y, 'r');
        return null;
    },
    "Debris": (x, y, tile, tileGenerator, data) => {
        let rubblechance = data.params.rubblechance || 1;
        if (tileGenerator.Always || KDRandom() < rubblechance)
            KinkyDungeonMapSet(x, y, '/');
        else
            KinkyDungeonMapSet(x, y, 'r');
        return null;
    },
    "Barrel": (x, y, tile, tileGenerator, data) => {
        let barrelChance = data.params.barrelChance || 0.25;
        if (tileGenerator.Always || KDRandom() < barrelChance)
            KinkyDungeonMapSet(x, y, 'L');
        else
            KinkyDungeonMapSet(x, y, 'r');
        return null;
    },
    "Spawn": (x, y, tile, tileGenerator, data) => {
        data.spawnpoints.push({ x: x, y: y, required: tileGenerator.required, ftags: tileGenerator.filterTags, tags: tileGenerator.tags, AI: tileGenerator.AI, faction: tileGenerator.faction });
        KinkyDungeonMapSet(x, y, '0');
        return null;
    },
    "ForceSpawn": (x, y, tile, tileGenerator, data) => {
        if (!tileGenerator.Chance || KDRandom() < tileGenerator.Chance) {
            let enemy = KinkyDungeonGetEnemy(tileGenerator.tags, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', tileGenerator.required, tileGenerator.requireHostile, tileGenerator.bonusTags, tileGenerator.filterTags, tileGenerator.requireSingleTag);
            DialogueCreateEnemy(x, y, enemy.name);
        }
        KinkyDungeonMapSet(x, y, '0');
        return null;
    },
    "Prisoner": (x, y, tile, tileGenerator, data) => {
        SetpieceSpawnPrisoner(x, y);
        KinkyDungeonMapSet(x, y, '0');
        return null;
    },
    "Chest": (x, y, tile, tileGenerator, data) => {
        var _a;
        if (tileGenerator.Loot) {
            if (tileGenerator.Priority || KDRandom() < (tileGenerator.Chance || 0.5)) {
                KinkyDungeonMapSet(x, y, 'C');
                KDGameData.ChestsGenerated.push(tileGenerator.Loot);
                return {
                    NoTrap: tileGenerator.NoTrap,
                    Type: tileGenerator.Lock ? "Lock" : undefined, Lock: tileGenerator.Lock == "Red" ? KDRandomizeRedLock() : tileGenerator.Lock,
                    Loot: tileGenerator.Lock == "Blue" ? "blue" : (tileGenerator.Loot ? tileGenerator.Loot : "chest"),
                    Roll: KDRandom(),
                    Special: tileGenerator.Lock == "Blue",
                    RedSpecial: (_a = tileGenerator.Lock) === null || _a === void 0 ? void 0 : _a.includes("Red"),
                    lootTrap: KDGenChestTrap(false, x, y, (tileGenerator.Loot ? tileGenerator.Loot : "chest"), tileGenerator.Lock, tileGenerator.NoTrap),
                };
            }
            else {
                KinkyDungeonMapSet(x, y, 'c');
            }
        }
        else {
            data.chestlist.push(({ x: x, y: y, priority: tileGenerator.Priority, NoTrap: tileGenerator.NoTrap }));
            KinkyDungeonMapSet(x, y, '2');
        }
        return null;
    },
    "GuardedChest": (x, y, tile, tileGenerator, data) => {
        var _a;
        KinkyDungeonMapSet(x, y, 'C');
        let faction = KDPlaceChest(x - 1, y - 1, 3, data.chestlist, data.spawnpoints, true);
        return {
            NoTrap: tileGenerator.NoTrap,
            Type: tileGenerator.Lock ? "Lock" : undefined, Lock: tileGenerator.Lock,
            Loot: tileGenerator.Lock == "Blue" ? "blue" : (tileGenerator.Loot ? tileGenerator.Loot : "chest"),
            Faction: faction,
            Roll: KDRandom(),
            Special: tileGenerator.Lock == "Blue",
            RedSpecial: (_a = tileGenerator.Lock) === null || _a === void 0 ? void 0 : _a.includes("Red"),
            lootTrap: KDGenChestTrap(false, x, y, (tileGenerator.Loot ? tileGenerator.Loot : "chest"), tileGenerator.Lock, tileGenerator.NoTrap),
        };
    },
    "ChestOrShrine": (x, y, tile, tileGenerator, data) => {
        let chestcount = data.params.chestcount || 1;
        let shrinecount = data.params.shrinecount || 1;
        if (KDRandom() < (chestcount) / Math.max(1, chestcount + shrinecount))
            data.chestlist.push(({ x: x, y: y, NoTrap: tileGenerator.NoTrap }));
        else
            data.shrinelist.push(({ x: x, y: y, NoTrap: tileGenerator.NoTrap }));
        KinkyDungeonMapSet(x, y, '2');
        return null;
    },
    "Door": (x, y, tile, tileGenerator, data) => {
        let doorchance = data.params.doorchance;
        let nodoorchance = data.params.nodoorchance || 0;
        if ("Ddg".includes(KinkyDungeonMapGet(x - 1, y))
            || "Ddg".includes(KinkyDungeonMapGet(x + 1, y))
            || "Ddg".includes(KinkyDungeonMapGet(x, y - 1))
            || "Ddg".includes(KinkyDungeonMapGet(x, y + 1)))
            nodoorchance = 1.0;
        else if (!(KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x + 1, y)) && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x - 1, y)))
            && !(KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x, y + 1)) && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x, y - 1)))) {
            nodoorchance = 1.0;
        }
        if (tileGenerator.Priority || KDRandom() > nodoorchance) {
            if (tileGenerator.AlwaysClose || KDRandom() < doorchance) {
                KinkyDungeonMapSet(x, y, 'D');
            }
            else {
                KinkyDungeonMapSet(x, y, 'd');
            }
            return { Type: "Door", Lock: tileGenerator.Lock == "Red" ? KDRandomizeRedLock() : tileGenerator.Lock, OffLimits: tileGenerator.OffLimits };
        }
        else {
            KinkyDungeonMapSet(x, y, '2');
        }
        return null;
    },
    "Shrine": (x, y, tile, tileGenerator, data) => {
        data.shrinelist.push(({ x: x, y: y, priority: tileGenerator.Priority }));
        KinkyDungeonMapSet(x, y, 'a');
        return null;
    },
    "DollDropoff": (x, y, tile, tileGenerator, data) => {
        if (KinkyDungeonStatsChoice.get("NoDoll")) {
            KinkyDungeonMapSet(x, y, '0');
            return null;
        }
        KinkyDungeonMapSet(x, y, '5');
        KDGameData.JailPoints.push({ x: x, y: y, type: "dropoff", direction: tileGenerator.direction || { x: 0, y: -1 }, radius: 1, restrainttags: ["dollstand"] });
        return { Sprite: "Floor", Overlay: tileGenerator.Overlay || "DollDropoff" };
    },
    "Cage": (x, y, tile, tileGenerator, data) => {
        KinkyDungeonMapSet(x, y, 'L');
        KDGameData.JailPoints.push({ x: x, y: y, type: "furniture", radius: 1 });
        return { Furniture: "Cage" };
    },
    "DisplayStand": (x, y, tile, tileGenerator, data) => {
        KinkyDungeonMapSet(x, y, 'L');
        KDGameData.JailPoints.push({ x: x, y: y, type: "furniture", radius: 1 });
        return { Furniture: "DisplayStand" };
    },
    "Furniture": (x, y, tile, tileGenerator, data) => {
        KDGameData.JailPoints.push({ x: x, y: y, type: "furniture", radius: 1 });
        return { Furniture: tileGenerator.Furniture };
    },
    "Table": (x, y, tile, tileGenerator, data) => {
        KinkyDungeonMapSet(x, y, 'F');
        let type = "";
        if (tileGenerator.Food == "Plate") {
            let WeightTotal = 0;
            let Weights = [];
            for (let obj of Object.values(KDFood)) {
                Weights.push({ event: obj, weight: WeightTotal });
                WeightTotal += obj.Weight;
            }
            let selection = KDRandom() * WeightTotal;
            for (let L = Weights.length - 1; L >= 0; L--) {
                if (selection > Weights[L].weight) {
                    type = Weights[L].event.Food;
                    break;
                }
            }
        }
        return { Food: type, Type: "Food" };
    },
    "Trap": (x, y, tile, tileGenerator, data) => {
        let trapchance = data.params.trapchance || 0.1;
        if (tileGenerator.Always || KDRandom() < trapchance)
            data.traps.push(({ x: x, y: y }));
        KinkyDungeonMapSet(x, y, '2');
        return null;
    },
    "Charger": (x, y, tile, tileGenerator, data) => {
        if (tileGenerator.Priority) {
            return { Type: "Charger", NoRemove: KinkyDungeonMapGet(x, y) == '=', lightColor: KDChargerColor, Light: (KinkyDungeonMapGet(x, y) == '=' ? KDChargerLight : undefined) };
        }
        KinkyDungeonMapSet(x, y, '-');
        data.chargerlist.push(({ x: x, y: y }));
        return null;
    },
    "Conveyor": (x, y, tile, tileGenerator, data) => {
        KinkyDungeonMapSet(x, y, 'V');
        return { Type: "Conveyor", DX: tileGenerator.DX, DY: tileGenerator.DY, OffLimits: true, wireType: tileGenerator.wireType, SwitchMode: tileGenerator.SwitchMode };
    },
    "DollSupply": (x, y, tile, tileGenerator, data) => {
        KinkyDungeonMapSet(x, y, 'u');
        return { Type: "DollSupply", index: 0, cd: 0, rate: tileGenerator.rate || 10, count: tileGenerator.count, dollType: tileGenerator.dollType, SwitchMode: tileGenerator.SwitchMode, wireType: tileGenerator.wireType };
    },
    "DollTerminal": (x, y, tile, tileGenerator, data) => {
        KinkyDungeonMapSet(x, y, 't');
        return { Type: "DollTerminal", OffLimits: true };
    },
    "BondageMachine": (x, y, tile, tileGenerator, data) => {
        KinkyDungeonMapSet(x, y, 'N');
        return { Type: "BondageMachine", OffLimits: true, Binding: tileGenerator.Binding };
    },
    "EffectTile": (x, y, tile, tileGenerator, data) => {
        KDCreateEffectTile(x, y, {
            name: tileGenerator.Tile,
        }, 0);
        return null;
    },
    "AutoDoor": (x, y, tile, tileGenerator, data) => {
        return { wireType: tileGenerator.wireType };
    },
};
function KDCreateTile(x, y, tileGenerator, data) {
    let tile = {};
    if (tileGenerator.Type) {
        tile = KDTileGen[tileGenerator.Type](x, y, tile, tileGenerator, data);
    }
    else {
        tile = Object.assign({}, tileGenerator);
        tile.x = x;
        tile.y = y;
    }
    if (tile)
        return tile;
}
function KDCreateEffectTileTile(x, y, tileGenerator, data) {
    let tile = {};
    if (tileGenerator.name && KDEffectTileGen[tileGenerator.name]) {
        tile = KDEffectTileGen[tileGenerator.name](x, y, tile, tileGenerator, data);
    }
    else {
        tile = KDCreateEffectTile(x, y, {
            name: tileGenerator.name,
            duration: tileGenerator.duration,
        }, 0);
    }
    if (tile)
        return tile;
}
function KDAggregateTileTags(x, y, w, h, tilesFilled, globalTags) {
    let tags = Object.assign({}, globalTags);
    for (let indX = x - 1; indX <= x + w; indX++)
        for (let indY = y - 1; indY <= y + h; indY++) {
            let index = indX < x ? "L_" : (indX >= x + w ? "R_" : "");
            index = (indY < y ? "U" : (indY >= y + h ? "D" : "")) + index;
            if (index) {
                let neighbor = tilesFilled[indX + ',' + indY];
                if (neighbor) {
                    for (let t of neighbor.tags) {
                        tags[index + t] = true;
                        tags[t] = true;
                    }
                }
            }
        }
    return tags;
}
function KinkyDungeonSetupCrashHandler() {
    window.addEventListener("error", KinkyDungeonOnUncaughtError);
}
function KinkyDungeonTeardownCrashHandler() {
    window.removeEventListener("error", KinkyDungeonOnUncaughtError);
}
function KinkyDungeonOnUncaughtError(event) {
    const report = KinkyDungeonGenerateErrorReport(event);
    KinkyDungeonShowCrashReportModal(report);
}
function KinkyDungeonGenerateErrorReport(event) {
    return [
        KinkyDungeonCrashReportErrorDetails(event),
        KinkyDungeonCrashReportStateData(),
        KinkyDungeonCrashReportDiagnostics(),
        KinkyDungeonCrashReportDeviceDetails(),
        KinkyDungeonCrashReportSaveData(),
    ].join("\n\n");
}
function KinkyDungeonCrashReportStateData() {
    let version;
    try {
        version = TextGet("KinkyDungeon") || "Version unknown";
    }
    catch (_a) {
        version = "Version unknown";
    }
    let modFiles;
    try {
        modFiles = KDAllModFiles.map(({ filename }) => filename).join(",");
    }
    catch (_b) {
        modFiles = "Failed to parse mod files";
    }
    return [
        "========== Game State Data ==========",
        "",
        `Version: ${version}`,
        `Test mode: ${TestMode}`,
        `Debug mode: ${KDDebugMode}`,
        `Kinky Dungeon state: ${KinkyDungeonState}`,
        `Kinky Dungeon running: ${KinkyDungeonGameRunning}`,
        `Loaded mod files: [${modFiles}]`,
    ].join("\n");
}
function KinkyDungeonCrashReportErrorDetails(event) {
    return [
        "========== Kinky Dungeon Crash Report ==========",
        "",
        `Message: ${event.message}`,
        `Location: ${KinkyDungeonStackSanitize(event.filename)}:${event.lineno}:${event.colno}`,
        "",
        KinkyDungeonStackSanitize(event.error.stack),
    ].join("\n");
}
function KinkyDungeonCrashReportSaveData() {
    let saveData = localStorage.getItem("KinkyDungeonSave");
    if (!saveData) {
        try {
            saveData = KinkyDungeonCompressSave(KinkyDungeonGenerateSaveData());
        }
        catch (error) {
            saveData = "Could not locate or generate save data";
        }
    }
    return [
        "========== Save Data ==========",
        "",
        saveData,
    ].join("\n");
}
function KinkyDungeonCrashReportDiagnostics() {
    return [
        "========== Diagnostics ==========",
        "",
        `Location: ${KinkyDungeonStackSanitize(window.location.href)}`,
        `User agent: ${window.navigator.userAgent}`,
        `Locale: ${window.navigator.language}`,
        `Local time: ${Date.now()}`,
        `Mouse: [${MouseX}, ${MouseY}]`,
        `WebGL supported: ${PIXI.utils.isWebGLSupported()}`,
    ].join("\n");
}
function KinkyDungeonCrashReportDeviceDetails() {
    return [
        "========== Device Detection ==========",
        "",
        JSON.stringify(PIXI.utils.isMobile, null, 2),
    ].join("\n");
}
function KinkyDungeonStackSanitize(stack) {
    return stack.replaceAll(/\/\d{10,}/g, "<beta>");
}
function KinkyDungeonShowCrashReportModal(report) {
    const id = "kinky-dungeon-crash-report";
    if (document.querySelector(`#${id}`)) {
        return;
    }
    const backdrop = document.createElement("div");
    backdrop.id = id;
    Object.assign(backdrop.style, {
        position: "fixed",
        inset: 0,
        backgroundColor: "#000000a0",
        fontFamily: "'Arial', sans-serif",
        fontSize: "1.8vmin",
        lineHeight: 1.6,
    });
    const modal = document.createElement("div");
    Object.assign(modal.style, {
        position: "absolute",
        display: "flex",
        flexFlow: "column nowrap",
        width: "90vw",
        maxWidth: "1440px",
        maxHeight: "90vh",
        overflow: "hidden",
        backgroundColor: "#282828",
        color: "#fafafa",
        left: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)",
        padding: "1rem",
        borderRadius: "2px",
        boxShadow: "1px 1px 40px -8px #ffffff80",
    });
    backdrop.appendChild(modal);
    const heading = document.createElement("h1");
    Object.assign(heading.style, {
        display: "flex",
        flexFlow: "row nowrap",
        alignItems: "center",
        justifyContent: "space-around",
        textAlign: "center",
    });
    heading.appendChild(KinkyDungeonErrorImage("WolfgirlPet"));
    heading.appendChild(KinkyDungeonErrorImage("Wolfgirl"));
    heading.appendChild(KinkyDungeonErrorImage("WolfgirlPet"));
    heading.appendChild(document.createTextNode("Kinky Dungeon Crash Handler"));
    heading.appendChild(KinkyDungeonErrorImage("WolfgirlPet"));
    heading.appendChild(KinkyDungeonErrorImage("Wolfgirl"));
    heading.appendChild(KinkyDungeonErrorImage("WolfgirlPet"));
    modal.appendChild(heading);
    const hr = document.createElement("hr");
    Object.assign(hr.style, {
        border: `1px solid ${KDBorderColor}`,
        margin: "0 0 1.5em",
    });
    modal.appendChild(hr);
    modal.appendChild(KinkyDungeonErrorPreamble([
        "An error has occurred whilst Kinky Dungeon was running. ",
        "You may be able to continue playing, but Kinky Dungeon might not function correctly.",
    ]));
    modal.appendChild(KinkyDungeonErrorPreamble([
        "Please report this error in the Kinky Dungeon Discord so that we can dispatch our team of highly-trained wolfgirls to fix it.",
        "When you make your report, please include the following debug information - the wolfgirls will appreciate it!",
    ]));
    const pre = document.createElement("pre");
    Object.assign(pre.style, {
        flex: 1,
        backgroundColor: "#1a1a1a",
        border: "1px solid #ffffff40",
        fontSize: "1.1em",
        padding: "1em",
        userSelect: "all",
        overflowWrap: "anywhere",
        overflowX: "hidden",
        overflowY: "auto",
        color: KDBorderColor,
    });
    pre.textContent = `\`\`\`\n${report}\n\`\`\``;
    modal.appendChild(pre);
    const buttons = document.createElement("div");
    Object.assign(buttons.style, {
        display: "flex",
        flexFlow: "row wrap",
        justifyContent: "flex-end",
        gap: "1em",
    });
    modal.appendChild(buttons);
    const copyButton = KinkyDungeonErrorModalButton("Copy to clipboard");
    copyButton.addEventListener("click", () => {
        KinkyDungeonErrorCopy(report, pre)
            .then(copied => {
            copyButton.textContent = copied ? "Awoo!" : "Failed";
        })
            .catch(() => void 0);
    });
    buttons.appendChild(copyButton);
    const closeButton = KinkyDungeonErrorModalButton("Close");
    closeButton.addEventListener("click", () => {
        backdrop.remove();
    });
    buttons.appendChild(closeButton);
    document.body.appendChild(backdrop);
}
function KinkyDungeonErrorImage(src) {
    const img = document.createElement("img");
    img.src = `${KinkyDungeonRootDirectory}Enemies/${src}.png`;
    Object.assign(img.style, {
        maxWidth: "10vw",
    });
    return img;
}
function KinkyDungeonErrorPreamble(content) {
    const preamble = document.createElement("p");
    Object.assign(preamble.style, {
        margin: "0 0 0.5em",
        fontSize: "1.25em",
    });
    preamble.innerHTML = content.join(" ");
    return preamble;
}
function KinkyDungeonErrorModalButton(text) {
    const button = document.createElement("button");
    button.textContent = text;
    Object.assign(button.style, {
        fontSize: "1.25em",
        padding: "0.5em 1em",
        backgroundColor: KDButtonColor,
        border: `2px solid ${KDBorderColor}`,
        color: "#ffffff",
        cursor: "pointer",
    });
    return button;
}
function KinkyDungeonErrorCopy(report, reportElement) {
    return navigator.clipboard.writeText(report)
        .then(() => true)
        .catch(() => {
        var _a, _b;
        if (reportElement) {
            const range = document.createRange();
            range.selectNode(reportElement);
            (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
            (_b = window.getSelection()) === null || _b === void 0 ? void 0 : _b.addRange(range);
            return document.execCommand("copy");
        }
        return false;
    });
}
PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;
let CanvasWidth = 2000;
let CanvasHeight = 1000;
let KDBigLanguages = ["CN", "KR", "JP"];
let KDBigLanguages2 = ["Chinese", "Korean", "Japanese"];
let KDLanguages = ["", "CN", "KR", "JP", "ES"];
let KinkyDungeonPlayerNeedsRefresh = false;
let KinkyDungeonNextRefreshCheck = 0;
const pp = new URLSearchParams(window.location.search);
let param_branch = pp.has('branch') ? pp.get('branch') : "";
let param_test = pp.has('test') ? pp.get('test') : "";
let param_localhost = pp.has('localhost') ? pp.get('localhost') : "";
let TestMode = param_test || param_branch || param_localhost || ServerURL == 'https://bc-server-test.herokuapp.com/';
let KDDebugMode = false;
let KDDebug = false;
let KDDebugPerks = false;
let KDDebugGold = false;
let KDAllModFiles = [];
let KDModFiles = {};
let KinkyDungeonPerksConfig = "1";
let KDUnlockedPerks = [];
let KinkyDungeonBackground = "BrickWall";
let KinkyDungeonPlayer = null;
let KinkyDungeonState = "Consent";
let KinkyDungeonRep = 0;
function KDSetDefaultKeybindings() {
    KinkyDungeonKeybindingsTemp = Object.assign({}, KDDefaultKB);
}
let KinkyDungeonKeybindings = null;
let KinkyDungeonKeybindingsTemp = null;
let KinkyDungeonKeybindingCurrentKey = "";
let KinkyDungeonKeybindingCurrentKeyRelease = "";
let KinkyDungeonNewGame = 0;
let KinkyDungeonGameRunning = false;
let KDLose = false;
let KDLoadingFinished = false;
let KDLoadingDone = 1;
let KDLoadingMax = 1;
let KinkyDungeonKey = ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyZ', 'KeyC'];
let KinkyDungeonKeySpell = ['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7'];
let KinkyDungeonKeyWait = ['KeyX'];
let KinkyDungeonKeySkip = ['Space'];
let KinkyDungeonKeyEnter = ['Enter'];
let KinkyDungeonKeySprint = ['ShiftLeft'];
let KinkyDungeonKeyWeapon = ['KeyF'];
let KinkyDungeonKeyUpcast = ['KeyR', 'ControlLeft'];
let KinkyDungeonKeyMenu = ['KeyT', 'KeyI', 'KeyG', 'KeyM', 'KeyL'];
let KinkyDungeonKeyToggle = ['Backquote', 'KeyB', 'KeyV', 'KeyN', 'Comma', 'Slash'];
let KinkyDungeonKeySpellPage = ['Backquote'];
let KinkyDungeonKeySwitchWeapon = ['ControlRight'];
let KDLoadingTextKeys = {};
let KinkyDungeonGraphicsQuality = true;
let KDToggles = {
    VibeSounds: true,
    Music: true,
    Sound: true,
    Drool: true,
    DrawArmor: true,
    TurnCounter: true,
    ShowNPCStatuses: true,
    StunFlash: true,
    ArousalHearts: true,
    VibeHearts: true,
    FancyWalls: true,
};
let KDDefaultKB = {
    Down: KinkyDungeonKey[2],
    DownLeft: KinkyDungeonKey[6],
    DownRight: KinkyDungeonKey[7],
    Left: KinkyDungeonKey[1],
    Right: KinkyDungeonKey[3],
    Up: KinkyDungeonKey[0],
    UpLeft: KinkyDungeonKey[4],
    UpRight: KinkyDungeonKey[5],
    Spell1: KinkyDungeonKeySpell[0],
    Spell2: KinkyDungeonKeySpell[1],
    Spell3: KinkyDungeonKeySpell[2],
    Spell4: KinkyDungeonKeySpell[3],
    Spell5: KinkyDungeonKeySpell[4],
    Spell6: KinkyDungeonKeySpell[5],
    Spell7: KinkyDungeonKeySpell[6],
    SpellWeapon: KinkyDungeonKeyWeapon[0],
    Wait: KinkyDungeonKeyWait[0],
    Skip: KinkyDungeonKeySkip[0],
    Enter: KinkyDungeonKeyEnter[0],
    Sprint: KinkyDungeonKeySprint[0],
    SpellPage: KinkyDungeonKeySpellPage[0],
    SwitchWeapon: KinkyDungeonKeySwitchWeapon[0],
    QInventory: KinkyDungeonKeyMenu[0],
    Inventory: KinkyDungeonKeyMenu[1],
    Reputation: KinkyDungeonKeyMenu[2],
    Magic: KinkyDungeonKeyMenu[3],
    Log: KinkyDungeonKeyMenu[4],
    Upcast: KinkyDungeonKeyUpcast[0],
    UpcastCancel: KinkyDungeonKeyUpcast[1],
    MsgLog: KinkyDungeonKeyToggle[0],
    Pass: KinkyDungeonKeyToggle[1],
    Door: KinkyDungeonKeyToggle[2],
    AStruggle: KinkyDungeonKeyToggle[3],
    APathfind: KinkyDungeonKeyToggle[4],
    AInspect: KinkyDungeonKeyToggle[5],
};
let KinkyDungeonRootDirectory = "Screens/MiniGame/KinkyDungeon/";
let KinkyDungeonPlayerCharacter = null;
let KinkyDungeonGameData = null;
let KinkyDungeonGameDataNullTimer = 4000;
let KinkyDungeonGameDataNullTimerTime = 0;
let KinkyDungeonStreamingPlayers = [];
let KinkyDungeonInitTime = 0;
let KinkyDungeonSleepTime = 0;
let KinkyDungeonFreezeTime = 1000;
let KinkyDungeonPlaySelfTime = 300;
let KinkyDungeonOrgasmTime = 1000;
let KinkyDungeonAutoWait = false;
let KinkyDungeonAutoWaitStruggle = false;
let KinkyDungeonConfigAppearance = false;
const Consumable = "consumable";
const Restraint = "restraint";
const LooseRestraint = "looserestraint";
const Outfit = "outfit";
const Accessory = "accessory";
const Weapon = "weapon";
const Misc = "misc";
let KinkyDungeonStatsChoice = new Map();
let KDJourney = "";
let KDOptOut = false;
let KDGameDataBase = {
    CollectedOrbs: 0,
    CollectedHearts: 0,
    DollRoomCount: 0,
    ChestsGenerated: [],
    MainPath: 'grv',
    ShortcutPath: 'grv',
    DollCount: 0,
    CagedTime: 0,
    HiddenItems: {},
    KeyringLocations: [],
    HiddenSpellPages: {},
    PriorJailbreaks: 0,
    PriorJailbreaksDecay: 0,
    MapFaction: "",
    KeysNeeded: false,
    RoomType: "",
    MapMod: "",
    Quests: [],
    HunterTimer: 0,
    Hunters: [],
    AlertTimer: 0,
    OrgasmNextStageTimer: 0,
    DistractionCooldown: 0,
    PoolUses: 0,
    PoolUsesGrace: 3,
    JailRemoveRestraintsTimer: 0,
    KinkyDungeonSpawnJailers: 0,
    KinkyDungeonSpawnJailersMax: 5,
    KinkyDungeonLeashedPlayer: 0,
    KinkyDungeonLeashingEnemy: 0,
    KinkyDungeonJailGuard: 0,
    KinkyDungeonGuardTimer: 0,
    KinkyDungeonGuardTimerMax: 28,
    KinkyDungeonGuardSpawnTimer: 0,
    KinkyDungeonGuardSpawnTimerMax: 80,
    KinkyDungeonGuardSpawnTimerMin: 50,
    KinkyDungeonMaxPrisonReduction: 10,
    KinkyDungeonPrisonReduction: 0,
    KinkyDungeonPrisonExtraGhostRep: 0,
    PrisonGoodBehaviorFromLeash: 0,
    KinkyDungeonJailTourTimer: 0,
    KinkyDungeonJailTourTimerMin: 20,
    KinkyDungeonJailTourTimerMax: 40,
    KinkyDungeonPenanceCostCurrent: 100,
    KinkyDungeonAngel: 0,
    KDPenanceStage: 0,
    KDPenanceStageEnd: 0,
    AngelCurrentRep: "",
    KDPenanceMode: "",
    OrgasmStage: 0,
    OrgasmTurns: 0,
    OrgasmStamina: 0,
    KinkyDungeonPenance: false,
    RescueFlag: false,
    SleepTurns: 0,
    PlaySelfTurns: 0,
    GuardApplyTime: 0,
    AncientEnergyLevel: 0,
    OrigEnergyLevel: 0,
    LastAP: 0,
    LastSP: KDMaxStatStart,
    LastMP: KDMaxStatStart,
    LastWP: KDMaxStatStart,
    Outfit: "Default",
    Champion: "",
    ChampionCurrent: 0,
    JailPoints: [],
    WarningLevel: 0,
    LastMapSeed: "",
    AlreadyOpened: [],
    Journey: "",
    CheckpointIndices: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
    TempFlagFloorTicks: {},
    PrisonerState: "",
    TimesJailed: 0,
    JailTurns: 0,
    JailKey: false,
    CurrentDialog: "",
    CurrentDialogStage: "",
    CurrentDialogMsg: "",
    CurrentDialogMsgSpeaker: "",
    CurrentDialogMsgPersonality: "",
    CurrentDialogMsgData: {},
    CurrentDialogMsgValue: {},
    CurrentDialogMsgID: -1,
    ConfirmAttack: false,
    RespawnQueue: [],
    HeartTaken: false,
    CurrentVibration: null,
    Edged: false,
    TimeSinceLastVibeStart: {},
    TimeSinceLastVibeEnd: {},
    OfferFatigue: 0,
    Favors: {},
    PreviousWeapon: null,
    StaminaPause: 0,
    StaminaSlow: 0,
    ManaSlow: 0,
    KneelTurns: 0,
    ShopItems: [],
    DelayedActions: [],
    JailFaction: [],
    GuardFaction: [],
    OfferCount: 0,
    ItemID: 0,
    ShopkeeperFee: 0,
    otherPlaying: 0,
};
let KDGameData = Object.assign({}, KDGameDataBase);
let KDLeashingEnemy = null;
function KinkyDungeonLeashingEnemy() {
    if (KDGameData.KinkyDungeonLeashingEnemy) {
        if (!KDLeashingEnemy) {
            KDLeashingEnemy = KinkyDungeonFindID(KDGameData.KinkyDungeonLeashingEnemy);
        }
    }
    else if (!KDIsPlayerTethered(KinkyDungeonPlayerEntity)) {
        KDLeashingEnemy = null;
    }
    return KDLeashingEnemy;
}
let KDJailGuard = null;
function KinkyDungeonJailGuard() {
    if (KDGameData.KinkyDungeonJailGuard) {
        if (!KDJailGuard) {
            KDJailGuard = KinkyDungeonFindID(KDGameData.KinkyDungeonJailGuard);
        }
    }
    else {
        KDJailGuard = null;
    }
    return KDJailGuard;
}
let KDAngel = null;
function KinkyDungeonAngel() {
    if (KDGameData.KinkyDungeonAngel) {
        if (!KDAngel) {
            KDAngel = KinkyDungeonFindID(KDGameData.KinkyDungeonAngel);
        }
    }
    else {
        KDAngel = null;
    }
    return KDAngel;
}
function KDUnlockPerk(Perk) {
    if (Perk && !KDUnlockedPerks.includes(Perk))
        KDUnlockedPerks.push(Perk);
    KDLoadPerks();
    localStorage.setItem("KDUnlockedPerks", JSON.stringify(KDUnlockedPerks));
}
function KDLoadPerks(Perk) {
    if (localStorage.getItem("KDUnlockedPerks")) {
        let perks = JSON.parse(localStorage.getItem("KDUnlockedPerks"));
        if (perks) {
            for (let p of perks) {
                if (!KDUnlockedPerks.includes(p)) {
                    KDUnlockedPerks.push(p);
                }
            }
        }
    }
}
function KDMapInit(list) {
    let map = {};
    for (let l of list) {
        map[l] = true;
    }
    return map;
}
function KDistEuclidean(x, y) {
    return Math.sqrt(x * x + y * y);
}
function KDistChebyshev(x, y) {
    return Math.max(Math.abs(x), Math.abs(y));
}
function KDLoadToggles() {
    let loaded = localStorage.getItem("KDToggles") ? JSON.parse(localStorage.getItem("KDToggles")) : {};
    for (let t of Object.keys(KDToggles)) {
        if (loaded[t] != undefined)
            KDToggles[t] = loaded[t];
    }
    if (!Player.GraphicsSettings) {
        Player.GraphicsSettings = { AnimationQuality: 0 };
    }
}
function KDSaveToggles() {
    localStorage.setItem("KDToggles", JSON.stringify(KDToggles));
}
function KinkyDungeonLoad() {
    console.log(ModelDefs);
    KinkyDungeonSetupCrashHandler();
    for (let entry of Object.entries(KDLoadingTextKeys)) {
        addTextKey(entry[0], entry[1]);
    }
    KDCategories = Object.assign([], KDCategoriesStart);
    for (let c of KDCategories) {
        c.buffs = [];
        c.debuffs = [];
    }
    for (let stat of Object.entries(KinkyDungeonStatsPresets)) {
        for (let c of KDCategories) {
            if (stat[1].category == c.name) {
                if (!stat[1].buff && (stat[1].debuff || KDGetPerkCost(stat[1]) < 0))
                    c.debuffs.push(stat);
                else
                    c.buffs.push(stat);
            }
        }
    }
    KDLoadPerks();
    CurrentDarkFactor = 0;
    KinkyDungeonPlayerNeedsRefresh = false;
    KinkyDungeonInitTime = CommonTime();
    KinkyDungeonGameKey.load();
    if (!KinkyDungeonIsPlayer())
        KinkyDungeonGameRunning = false;
    if (ServerURL != 'foobar' && KinkyDungeonState == 'Consent')
        KinkyDungeonState = "Menu";
    if (!KinkyDungeonGameRunning) {
        if (!KinkyDungeonPlayer) {
            KDrandomizeSeed(false);
            if (KDPatched) {
                KinkyDungeonPlayer = suppressCanvasUpdate(() => CharacterLoadNPC("NPC_Avatar"));
            }
            else {
                KinkyDungeonPlayer = CharacterLoadNPC("NPC_Avatar");
            }
            KinkyDungeonPlayer.Type = "simple";
            KinkyDungeonPlayer.OnlineSharedSettings = { BlockBodyCosplay: true, };
            KDLoadToggles();
            KinkyDungeonBones = localStorage.getItem("KinkyDungeonBones") != undefined ? localStorage.getItem("KinkyDungeonBones") : KinkyDungeonBones;
            if (localStorage.getItem("KDVibeVolume")) {
                let parsed = parseInt(localStorage.getItem("KDVibeVolume"));
                if (parsed != undefined) {
                    KDVibeVolumeListIndex = parsed;
                    KDVibeVolume = KDVibeVolumeList[KDVibeVolumeListIndex];
                }
            }
            if (localStorage.getItem("KDMusicVolume")) {
                let parsed = parseInt(localStorage.getItem("KDMusicVolume"));
                if (parsed != undefined) {
                    KDMusicVolumeListIndex = parsed;
                    KDMusicVolume = KDMusicVolumeList[KDMusicVolumeListIndex];
                }
            }
            if (localStorage.getItem("KDAnimSpeed")) {
                let parsed = parseInt(localStorage.getItem("KDAnimSpeed"));
                if (parsed != undefined) {
                    KDAnimSpeedListIndex = parsed;
                    KDAnimSpeed = KDAnimSpeedList[KDAnimSpeedListIndex] || 0;
                }
            }
            KinkyDungeonSexyMode = localStorage.getItem("KinkyDungeonSexyMode") != undefined ? localStorage.getItem("KinkyDungeonSexyMode") == "True" : true;
            KinkyDungeonClassMode = localStorage.getItem("KinkyDungeonClassMode") != undefined ? localStorage.getItem("KinkyDungeonClassMode") : "Mage";
            KinkyDungeonSexyPiercing = localStorage.getItem("KinkyDungeonSexyPiercing") != undefined ? localStorage.getItem("KinkyDungeonSexyPiercing") == "True" : false;
            KinkyDungeonSexyPlug = localStorage.getItem("KinkyDungeonSexyPlug") != undefined ? localStorage.getItem("KinkyDungeonSexyPlug") == "True" : false;
            KinkyDungeonSaveMode = localStorage.getItem("KinkyDungeonSaveMode") != undefined ? localStorage.getItem("KinkyDungeonSaveMode") == "True" : false;
            KinkyDungeonRandomMode = localStorage.getItem("KinkyDungeonRandomMode") != undefined ? localStorage.getItem("KinkyDungeonRandomMode") == "True" : false;
            KinkyDungeonEasyMode = localStorage.getItem("KinkyDungeonEasyMode") != undefined ? parseInt(localStorage.getItem("KinkyDungeonEasyMode")) || 0 : 0;
            KinkyDungeonNewDress = true;
            KDCurrentOutfit = parseInt(localStorage.getItem("kdcurrentoutfit") || 0);
            let appearance = LZString.decompressFromBase64(localStorage.getItem("kinkydungeonappearance" + KDCurrentOutfit));
            if (!appearance) {
                KinkyDungeonNewDress = false;
                appearance = CharacterAppearanceStringify(KinkyDungeonPlayerCharacter ? KinkyDungeonPlayerCharacter : Player);
            }
            CharacterAppearanceRestore(KinkyDungeonPlayer, appearance);
            if (KDPatched)
                suppressCanvasUpdate(() => CharacterReleaseTotal(KinkyDungeonPlayer));
            else
                CharacterReleaseTotal(KinkyDungeonPlayer);
            CharacterRefresh(KinkyDungeonPlayer);
            KinkyDungeonInitializeDresses();
            KinkyDungeonDressSet();
            if (KDPatched)
                suppressCanvasUpdate(() => CharacterNaked(KinkyDungeonPlayer));
            else
                CharacterNaked(KinkyDungeonPlayer);
            KinkyDungeonCheckClothesLoss = true;
            KinkyDungeonDressPlayer();
            KDInitProtectedGroups();
        }
        if (localStorage.getItem("KinkyDungeonKeybindings") && JSON.parse(localStorage.getItem("KinkyDungeonKeybindings"))) {
            KinkyDungeonKeybindings = JSON.parse(localStorage.getItem("KinkyDungeonKeybindings"));
            KinkyDungeonKeybindingsTemp = {};
            Object.assign(KinkyDungeonKeybindingsTemp, KinkyDungeonKeybindings);
            console.log(KinkyDungeonKeybindings);
        }
        else
            console.log("Failed to load keybindings");
        if (KinkyDungeonIsPlayer()) {
            if (ServerURL != 'foobar' && KinkyDungeonState == "Consent")
                KinkyDungeonState = "Menu";
            KinkyDungeonGameData = null;
            CharacterAppearancePreviousEmoticon = WardrobeGetExpression(Player).Emoticon;
            ServerSend("ChatRoomCharacterExpressionUpdate", { Name: "Gaming", Group: "Emoticon", Appearance: ServerAppearanceBundle(Player.Appearance) });
        }
        else {
            KinkyDungeonState = "Game";
            if (!KinkyDungeonGameData) {
                MiniGameKinkyDungeonLevel = 1;
                KinkyDungeonInitialize(1);
            }
        }
        for (const group of KinkyDungeonStruggleGroupsBase) {
            if (group == "ItemM") {
                if (InventoryGet(Player, "ItemMouth"))
                    KinkyDungeonRestraintsLocked.push("ItemMouth");
                if (InventoryGet(Player, "ItemMouth2"))
                    KinkyDungeonRestraintsLocked.push("ItemMouth2");
                if (InventoryGet(Player, "ItemMouth3"))
                    KinkyDungeonRestraintsLocked.push("ItemMouth3");
            }
            if (group == "ItemH") {
                if (InventoryGet(Player, "ItemHood"))
                    KinkyDungeonRestraintsLocked.push("ItemHood");
                if (InventoryGet(Player, "ItemHead"))
                    KinkyDungeonRestraintsLocked.push("ItemHead");
            }
            if (InventoryGet(Player, group))
                KinkyDungeonRestraintsLocked.push(group);
        }
    }
}
function KinkyDungeonDeviousDungeonAvailable() {
    return KinkyDungeonIsPlayer() && (DialogGamingPreviousRoom == "Arcade" || MiniGameReturnFunction == "ArcadeKinkyDungeonEnd") && ServerURL != 'foobar';
}
function KinkyDungeonIsPlayer() {
    return (!KinkyDungeonPlayerCharacter || KinkyDungeonPlayerCharacter == Player);
}
let KinkyDungeonCreditsPos = 0;
let KDMaxPatronPerPage = 4;
let KDMaxPatron = 5;
let KinkyDungeonPatronPos = 0;
let KinkyDungeonFastWait = true;
let KinkyDungeonTempWait = false;
let KinkyDungeonSexyMode = false;
let KinkyDungeonClassMode = "Mage";
let KinkyDungeonRandomMode = false;
let KinkyDungeonEasyMode = 0;
let KinkyDungeonSaveMode = false;
let KinkyDungeonSexyPiercing = false;
let KinkyDungeonSexyPlug = false;
let KDOldValue = "";
let KDOriginalValue = "";
let KDRestart = false;
let fpscounter = 0;
let lastfps = 0;
let dispfps = 60;
async function sleep(msec) {
    return new Promise(resolve => setTimeout(resolve, msec));
}
let KDMarkAsCache = [];
function KinkyDungeonRun() {
    var _a;
    if (KDCurrentModels)
        for (let MC of KDCurrentModels.values()) {
            for (let Container of MC.Containers.entries()) {
                if (!MC.ContainersDrawn.has(Container[0]) && Container[1]) {
                    Container[1].Container.parent.removeChild(Container[1]);
                    MC.Containers.delete(Container[0]);
                    Container[1].Container.destroy();
                }
            }
            MC.ContainersDrawn.clear();
        }
    if (!CommonIsMobile)
        document.addEventListener('contextmenu', event => {
            var _a;
            if (CommonIsMobile || ((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.id) != "MainCanvas") {
            }
            else {
                event.preventDefault();
                let code = KinkyDungeonKeySkip[0];
                if (!KinkyDungeonKeybindingCurrentKey) {
                    KinkyDungeonKeybindingCurrentKey = code;
                    KDLastKeyTime[KinkyDungeonKeybindingCurrentKey] = CommonTime() + 100;
                    (async function () {
                        KinkyDungeonGameKey.keyPressed[9] = true;
                        await sleep(100);
                        KinkyDungeonGameKey.keyPressed[9] = false;
                    })();
                }
            }
        });
    kdSpritesDrawn = new Map();
    KDLastButtonsCache = KDButtonsCache;
    KDButtonsCache = {};
    KDUpdateVibeSounds();
    KDUpdateMusic();
    if (ServerURL != "foobar")
        DrawButtonVis(1885, 25, 90, 90, "", "#ffffff", KinkyDungeonRootDirectory + "UI/Exit.png");
    if (true || KDToggles.Fullscreen) {
        KinkyDungeonGridWidthDisplay = 2000 / KinkyDungeonGridSizeDisplay;
        KinkyDungeonGridHeightDisplay = 1000 / KinkyDungeonGridSizeDisplay;
        canvasOffsetX = 0;
        canvasOffsetY = 0;
        KinkyDungeonCanvas.width = 2000;
        KinkyDungeonCanvas.height = 1000;
    }
    else {
        KinkyDungeonGridWidthDisplay = 16;
        KinkyDungeonGridHeightDisplay = 9;
        canvasOffsetX = canvasOffsetX_ui;
        canvasOffsetY = canvasOffsetY_ui;
        KinkyDungeonCanvas.width = KinkyDungeonGridSizeDisplay * KinkyDungeonGridWidthDisplay;
        KinkyDungeonCanvas.height = KinkyDungeonGridSizeDisplay * KinkyDungeonGridHeightDisplay;
    }
    KinkyDungeonCheckPlayerRefresh();
    if (KinkyDungeonState != "Consent" && (KinkyDungeonState != "Game" || KinkyDungeonDrawState != "Game") && KinkyDungeonState != "Stats" && KinkyDungeonState != "TileEditor")
        DrawCharacter(KinkyDungeonPlayer, 0, 0, 1);
    if ((KinkyDungeonState != "Game" || KinkyDungeonDrawState != "Game") && KinkyDungeonState != "TileEditor") {
        let BG = "BrickWall";
        KDDraw(kdcanvas, kdpixisprites, "bg", "Backgrounds/" + BG + (StandalonePatched ? ".png" : ".jpg"), 0, 0, CanvasWidth, CanvasHeight, undefined, {
            zIndex: -115,
        });
        kdgameboard.visible = false;
        kdgamefog.visible = false;
    }
    else {
        kdgameboard.visible = true;
        kdgamefog.visible = KinkyDungeonState != "TileEditor";
    }
    if (KinkyDungeonState == "Mods") {
        DrawButtonKDEx("mods_back", (bdata) => {
            KinkyDungeonState = "Menu";
            KDExecuteMods();
            return true;
        }, true, 975, 850, 350, 64, TextGet("KinkyDungeonLoadBack"), "#ffffff", "");
        DrawButtonKDEx("mods_load", (bdata) => {
            getFileInput();
            return true;
        }, true, 975, 250, 350, 64, TextGet("KinkyDungeonLoadMod"), "#ffffff", "");
        DrawTextKD(TextGet("KinkyDungeonLoadModWarning1"), 1175, 100, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonLoadModWarning2"), 1175, 150, "#ffffff", KDTextGray2);
        KDDrawMods();
    }
    else if (KinkyDungeonState == "Credits") {
        let credits = TextGet("KinkyDungeonCreditsList" + KinkyDungeonCreditsPos).split('|');
        let i = 0;
        for (let c of credits) {
            DrawTextKD(c, 550, 25 + 40 * i, "#ffffff", KDTextGray2, undefined, "left");
            i++;
        }
        DrawButtonVis(1870, 930, 110, 64, TextGet("KinkyDungeonBack"), "#ffffff", "");
        DrawButtonVis(1730, 930, 110, 64, TextGet("KinkyDungeonNext"), "#ffffff", "");
    }
    else if (KinkyDungeonState == "Patrons") {
        for (let x = KinkyDungeonPatronPos * KDMaxPatronPerPage; x < KinkyDungeonPatronPos * KDMaxPatronPerPage + KDMaxPatronPerPage && x <= KDMaxPatron; x++) {
            let credits = TextGet("KinkyDungeonPatronsList" + x).split('|');
            let i = 0;
            for (let c of credits) {
                DrawTextKD(c, 550 + 350 * (x - KinkyDungeonPatronPos * KDMaxPatronPerPage), 25 + 40 * i, "#ffffff", KDTextGray2, undefined, "left");
                i++;
            }
        }
        DrawButtonVis(1870, 930, 110, 64, TextGet("KinkyDungeonBack"), "#ffffff", "");
        DrawButtonVis(1730, 930, 110, 64, TextGet("KinkyDungeonNext"), "#ffffff", "");
    }
    else if (KinkyDungeonState == "Menu") {
        KinkyDungeonGameFlag = false;
        DrawCheckboxVis(600, 100, 64, 64, TextGet("KDToggleSound"), KDToggles.Sound, false, "#ffffff");
        if (KDLose) {
            DrawTextKD(TextGet("End"), 1250, 250, "#ffffff", KDTextGray2);
            DrawTextKD(TextGet("End2"), 1250, 310, "#ffffff", KDTextGray2);
            DrawTextKD(TextGet("End3"), 1250, 370, "#ffffff", KDTextGray2);
        }
        else {
            DrawTextKD(TextGet("KinkyDungeon"), 1250, 200, "#ffffff", KDTextGray2);
            DrawTextKD(TextGet("Intro"), 1250, 250, "#ffffff", KDTextGray2);
            DrawTextKD(TextGet("Intro2"), 1250, 300, "#ffffff", KDTextGray2);
            DrawTextKD(TextGet("Intro3"), 1250, 350, "#ffffff", KDTextGray2);
            DrawTextKD(TextGet("Intro4" + (ServerURL == 'foobar' ? "" : "BC")), 1250, 400, "#ffffff", KDTextGray2);
        }
        if (ArcadeDeviousChallenge && KinkyDungeonDeviousDungeonAvailable() && ServerURL != "foobar")
            DrawTextKD(TextGet("DeviousChallenge"), 1250, 925, "#ffffff", KDTextGray2);
        DrawButtonKDEx("GameContinue", () => {
            KinkyDungeonStartNewGame(true);
            return true;
        }, true, 1075, 460, 350, 64, TextGet("GameContinue"), localStorage.getItem('KinkyDungeonSave') ? "#ffffff" : "pink", "");
        DrawButtonKDEx("GameStart", () => {
            KinkyDungeonState = "Diff";
            KinkyDungeonLoadStats();
            return true;
        }, true, 1075, 540, 350, 64, TextGet("GameStart"), "#ffffff", "");
        DrawButtonKDEx("LoadGame", () => {
            KinkyDungeonState = "Load";
            ElementCreateTextArea("saveInputField");
            return true;
        }, true, 1075, 620, 350, 64, TextGet("LoadGame"), "#ffffff", "");
        DrawButtonKDEx("GameConfigKeys", () => {
            KinkyDungeonState = "Keybindings";
            if (!KinkyDungeonKeybindings)
                KDSetDefaultKeybindings();
            else {
                KinkyDungeonKeybindingsTemp = {};
                Object.assign(KinkyDungeonKeybindingsTemp, KinkyDungeonKeybindings);
            }
            return true;
        }, true, 1075, 700, 350, 64, TextGet("GameConfigKeys"), "#ffffff", "");
        DrawButtonKDEx("GameToggles", () => {
            KinkyDungeonState = "Toggles";
            return true;
        }, true, 1075, 780, 350, 64, TextGet("GameToggles"), "#ffffff", "");
        if (TestMode) {
            DrawButtonKDEx("TileEditor", () => {
                KDInitTileEditor();
                KinkyDungeonState = "TileEditor";
                return true;
            }, true, 1075, 860, 350, 64, "Tile Editor", "#ffffff", "");
        }
        DrawButtonKDEx("GoToWardrobe", (bdata) => {
            KinkyDungeonState = "Wardrobe";
            KDPlayerSetPose = false;
            KDInitCurrentPose();
            KinkyDungeonInitializeDresses();
            KDUpdateModelList();
            KDRefreshOutfitInfo();
            let appearance = LZString.decompressFromBase64(localStorage.getItem("kinkydungeonappearance" + KDCurrentOutfit));
            if (appearance) {
                CharacterAppearanceRestore(KinkyDungeonPlayer, appearance);
                CharacterRefresh(KinkyDungeonPlayer);
            }
            KinkyDungeonPlayer.OnlineSharedSettings = { AllowFullWardrobeAccess: true };
            KinkyDungeonNewDress = true;
            CharacterReleaseTotal(KinkyDungeonPlayer);
            KinkyDungeonDressPlayer();
            KinkyDungeonPlayer.OnlineSharedSettings = { BlockBodyCosplay: false, AllowFullWardrobeAccess: true };
            if (!StandalonePatched)
                CharacterAppearanceLoadCharacter(KinkyDungeonPlayer);
            KinkyDungeonConfigAppearance = true;
            return true;
        }, true, 30, 942, 440, 50, TextGet("KinkyDungeonDressPlayer"), "#ffffff", "");
        DrawButtonVis(1850, 942, 135, 50, TextGet("KinkyDungeonCredits"), "#ffffff", "");
        DrawButtonVis(1700, 942, 135, 50, TextGet("KinkyDungeonPatrons"), "#ffffff", "");
        DrawButtonKDEx("Deviantart", (bdata) => {
            let url = 'https://www.deviantart.com/ada18980';
            window.open(url, '_blank');
            return true;
        }, true, 1700, 694, 280, 50, TextGet("KinkyDungeonDeviantart"), "#ffffff", "");
        DrawButtonKDEx("Patreon", (bdata) => {
            let url = 'https://www.patreon.com/ada18980';
            KDSendEvent('patreon');
            window.open(url, '_blank');
            return true;
        }, true, 1700, 754, 280, 50, TextGet("KinkyDungeonPatreon"), "#ffeecc", "");
        DrawTextKD(TextGet("Language") + " ->", 1675, 898, "#ffffff", KDTextGray2, undefined, "right");
        DrawButtonVis(1700, 874, 280, 50, localStorage.getItem("BondageClubLanguage") || "EN", "#ffffff", "");
        if (KDPatched) {
            DrawButtonKDEx("mods_button", (bdata) => {
                KinkyDungeonState = "Mods";
                return true;
            }, !KDModsLoaded, 1700, 814, 280, 50, TextGet(!KDModsLoaded ? "KDMods" : "KDModsLoaded"), "#ffffff", "");
        }
        if (KDRestart)
            DrawTextKD(TextGet("RestartNeeded" + (localStorage.getItem("BondageClubLanguage") || "EN")), 1840, 600, "#ffffff", KDTextGray2);
    }
    else if (KinkyDungeonState == "Consent") {
        DrawTextKD(TextGet("KinkyDungeonConsent"), 1250, 300, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonConsent2"), 1250, 400, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonConsent3"), 1250, 500, "#ffffff", KDTextGray2);
        if (!KDLoadingFinished) {
            DrawTextKD(TextGet("KDLoading") + Math.round(100 * KDLoadingDone / KDLoadingMax) + "%", 1250, 950, "#ffffff", KDTextGray2);
        }
        if (KDLoadingDone >= KDLoadingMax) {
            KDLoadingFinished = true;
        }
        DrawButtonVis(1025, 720, 450, 64, TextGet("KDOptIn"), KDLoadingFinished ? "#ffffff" : "#888888", "");
        DrawButtonVis(1025, 820, 450, 64, TextGet("KDOptOut"), KDLoadingFinished ? "#ffffff" : "#888888", "");
    }
    else if (KinkyDungeonState == "TileEditor") {
        KDDrawTileEditor();
    }
    else if (KinkyDungeonState == "Load") {
        DrawButtonVis(875, 750, 350, 64, TextGet("KinkyDungeonLoadConfirm"), "#ffffff", "");
        DrawButtonVis(1275, 750, 350, 64, TextGet("KinkyDungeonLoadBack"), "#ffffff", "");
        ElementPosition("saveInputField", 1250, 550, 1000, 230);
    }
    else if (KinkyDungeonState == "LoadOutfit") {
        DrawButtonVis(875, 750, 350, 64, TextGet("LoadOutfit"), "#ffffff", "");
        DrawButtonVis(1275, 750, 350, 64, TextGet("KDWardrobeBackToWardrobe"), "#ffffff", "");
        let newValue = ElementValue("saveInputField");
        if (newValue != KDOldValue) {
            let decompressed = LZString.decompressFromBase64(ElementValue("saveInputField"));
            if (decompressed) {
                let origAppearance = KinkyDungeonPlayer.Appearance;
                try {
                    CharacterAppearanceRestore(KinkyDungeonPlayer, decompressed);
                    CharacterRefresh(KinkyDungeonPlayer);
                    KDOldValue = newValue;
                    KDInitProtectedGroups();
                }
                catch (e) {
                    KinkyDungeonPlayer.Appearance = origAppearance;
                    try {
                        let parsed = JSON.parse(decompressed);
                        if (parsed.length > 0) {
                            if (!StandalonePatched) {
                                for (let g of parsed) {
                                    InventoryWear(KinkyDungeonPlayer, g.Name, g.Group, g.Color);
                                }
                                CharacterRefresh(KinkyDungeonPlayer);
                            }
                            KDOldValue = newValue;
                            KDInitProtectedGroups();
                        }
                        else {
                            console.log("Invalid code. Maybe its corrupt?");
                        }
                    }
                    catch (error) {
                        console.log("Invalid code.");
                    }
                }
            }
        }
        ElementPosition("saveInputField", 1250, 550, 1000, 230);
    }
    else if (KinkyDungeonState == "Journey") {
        DrawTextKD(TextGet("KinkyDungeonJourney"), 1250, 300, "#ffffff", KDTextGray2);
        DrawButtonVis(875, 350, 750, 64, TextGet("KinkyDungeonJourney0"), "#ffffff", "");
        DrawButtonVis(875, 450, 750, 64, TextGet("KinkyDungeonJourney1"), "#ffffff", "");
        DrawButtonVis(875, 550, 750, 64, TextGet("KinkyDungeonJourney2"), "#ffffff", "");
        DrawButtonVis(1075, 850, 350, 64, TextGet("KinkyDungeonLoadBack"), "#ffffff", "");
    }
    else if (KinkyDungeonState == "Diff") {
        DrawTextKD(TextGet("KinkyDungeonDifficulty"), 1250, 170, "#ffffff", KDTextGray2);
        DrawButtonKDEx("startQuick", () => {
            KinkyDungeonStatsChoice = new Map();
            KDUpdatePlugSettings();
            KDLose = false;
            KinkyDungeonStartNewGame();
            return true;
        }, true, 875, 650, 750, 64, TextGet("KinkyDungeonStartGameQuick"), "#ffffff", "");
        DrawButtonKDEx("startGame", () => {
            KinkyDungeonState = "Stats";
            KDUpdatePlugSettings();
            return true;
        }, true, 875, 720, 750, 64, TextGet("KinkyDungeonStartGameAdv"), "#ffffff", "");
        if (MouseIn(875, 650, 750, 64)) {
            DrawTextFitKD(TextGet("KinkyDungeonStartGameDesc"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        if (MouseIn(875, 720, 750, 64)) {
            DrawTextFitKD(TextGet("KinkyDungeonStartGameDescAdc"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawButtonVis(1075, 850, 350, 64, TextGet("KinkyDungeonLoadBack"), "#ffffff", "");
        let buttonswidth = 168;
        let buttonsheight = 50;
        let buttonspad = 25;
        let buttonsypad = 10;
        let buttonsstart = 875;
        let X = 0;
        let Y = 0;
        DrawTextFitKD(TextGet("KDClasses"), 875 - 50, 210 + 22, 300, "#ffffff", KDTextGray1, undefined, "right");
        let classCount = Object.keys(KDClassStart).length;
        for (let i = 0; i < classCount; i++) {
            X = i % 4;
            Y = Math.floor(i / 4);
            DrawButtonKDEx("Class" + i, (bdata) => {
                KinkyDungeonClassMode = Object.keys(KDClassStart)[i];
                localStorage.setItem("KinkyDungeonClassMode", "" + KinkyDungeonClassMode);
                return true;
            }, (!KDClassReqs[Object.keys(KDClassStart)[i]]) || KDClassReqs[Object.keys(KDClassStart)[i]](), buttonsstart + (buttonspad + buttonswidth) * X, 210 + Y * (buttonsheight + buttonsypad), buttonswidth, buttonsheight, TextGet("KinkyDungeonClassMode" + i), ((!KDClassReqs[Object.keys(KDClassStart)[i]]) || KDClassReqs[Object.keys(KDClassStart)[i]]()) ?
                (KinkyDungeonClassMode == Object.keys(KDClassStart)[i] ? "#ffffff" : "#888888")
                : "#ff5555", "");
            if (MouseIn(buttonsstart + (buttonspad + buttonswidth) * X, 210 + Y * (buttonsheight + buttonsypad), buttonswidth, buttonsheight)) {
                DrawTextFitKD(TextGet("KinkyDungeonClassModeDesc" + i), 1250, 80, 1000, "#ffffff", KDTextGray0);
            }
        }
        DrawTextFitKD(TextGet("KDSexyMode"), 875 - 50, 350 + 22, 300, "#ffffff", KDTextGray1, undefined, "right");
        DrawButtonKDEx("KinkyDungeonSexyMode0", (bdata) => {
            KinkyDungeonSexyMode = false;
            KDUpdatePlugSettings();
            localStorage.setItem("KinkyDungeonSexyMode", KinkyDungeonSexyMode ? "True" : "False");
            return true;
        }, true, 875, 350, 275, 50, TextGet("KinkyDungeonSexyMode0"), !KinkyDungeonSexyMode ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonSexyMode0")) {
            DrawTextFitKD(TextGet("KinkyDungeonSexyModeDesc0"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawButtonKDEx("KinkyDungeonSexyMode1", (bdata) => {
            KinkyDungeonSexyMode = true;
            KDUpdatePlugSettings();
            localStorage.setItem("KinkyDungeonSexyMode", KinkyDungeonSexyMode ? "True" : "False");
            return true;
        }, true, 1175, 350, 275, 50, TextGet("KinkyDungeonSexyMode1"), KinkyDungeonSexyMode ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonSexyMode1")) {
            DrawTextFitKD(TextGet("KinkyDungeonSexyModeDesc1"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawTextFitKD(TextGet("KDRandomMode"), 875 - 50, 410 + 22, 300, "#ffffff", KDTextGray1, undefined, "right");
        DrawButtonKDEx("KinkyDungeonRandomMode0", (bdata) => {
            KinkyDungeonRandomMode = false;
            localStorage.setItem("KinkyDungeonRandomMode", KinkyDungeonRandomMode ? "True" : "False");
            return true;
        }, true, 875, 410, 275, 50, TextGet("KinkyDungeonRandomMode0"), !KinkyDungeonRandomMode ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonRandomMode0")) {
            DrawTextFitKD(TextGet("KinkyDungeonRandomModeDesc0"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawButtonKDEx("KinkyDungeonRandomMode1", (bdata) => {
            KinkyDungeonRandomMode = true;
            localStorage.setItem("KinkyDungeonRandomMode", KinkyDungeonRandomMode ? "True" : "False");
            return true;
        }, true, 1175, 410, 275, 50, TextGet("KinkyDungeonRandomMode1"), KinkyDungeonRandomMode ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonRandomMode1")) {
            DrawTextFitKD(TextGet("KinkyDungeonRandomModeDesc1"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawTextFitKD(TextGet("KDSaveMode"), 875 - 50, 470 + 22, 300, "#ffffff", KDTextGray1, undefined, "right");
        DrawButtonKDEx("KinkyDungeonSaveMode0", (bdata) => {
            KinkyDungeonSaveMode = false;
            localStorage.setItem("KinkyDungeonSaveMode", KinkyDungeonSaveMode ? "True" : "False");
            return true;
        }, true, 875, 470, 275, 50, TextGet("KinkyDungeonSaveMode0"), !KinkyDungeonSaveMode ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonSaveMode0")) {
            DrawTextFitKD(TextGet("KinkyDungeonSaveModeDesc0"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawButtonKDEx("KinkyDungeonSaveMode1", (bdata) => {
            KinkyDungeonSaveMode = true;
            localStorage.setItem("KinkyDungeonSaveMode", KinkyDungeonSaveMode ? "True" : "False");
            return true;
        }, true, 1175, 470, 275, 50, TextGet("KinkyDungeonSaveMode1"), KinkyDungeonSaveMode ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonSaveMode1")) {
            DrawTextFitKD(TextGet("KinkyDungeonSaveModeDesc1"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawTextFitKD(TextGet("KDEasyMode"), 875 - 50, 530 + 22, 300, "#ffffff", KDTextGray1, undefined, "right");
        DrawButtonKDEx("KinkyDungeonEasyMode0", (bdata) => {
            KinkyDungeonEasyMode = 0;
            localStorage.setItem("KinkyDungeonEasyMode", KinkyDungeonEasyMode ? "True" : "False");
            return true;
        }, true, 1075, 530, 175, 50, TextGet("KinkyDungeonEasyMode0"), KinkyDungeonEasyMode == 0 ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonEasyMode0")) {
            DrawTextFitKD(TextGet("KinkyDungeonEasyModeDesc0"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawButtonKDEx("KinkyDungeonEasyMode1", (bdata) => {
            KinkyDungeonEasyMode = 1;
            localStorage.setItem("KinkyDungeonEasyMode", KinkyDungeonEasyMode ? "True" : "False");
            return true;
        }, true, 1275, 530, 175, 50, TextGet("KinkyDungeonEasyMode1"), KinkyDungeonEasyMode == 1 ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonEasyMode1")) {
            DrawTextFitKD(TextGet("KinkyDungeonEasyModeDesc1"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        DrawButtonKDEx("KinkyDungeonEasyMode2", (bdata) => {
            KinkyDungeonEasyMode = 2;
            localStorage.setItem("KinkyDungeonEasyMode", KinkyDungeonEasyMode ? "True" : "False");
            return true;
        }, true, 875, 530, 175, 50, TextGet("KinkyDungeonEasyMode2"), KinkyDungeonEasyMode == 2 ? "#ffffff" : "#888888", "");
        if (MouseInKD("KinkyDungeonEasyMode2")) {
            DrawTextFitKD(TextGet("KinkyDungeonEasyModeDesc2"), 1250, 80, 1000, "#ffffff", KDTextGray0);
        }
        if (KinkyDungeonSexyMode) {
            DrawCheckboxKDEx("KinkyDungeonSexyPlugs", (bdata) => {
                KinkyDungeonSexyPlug = !KinkyDungeonSexyPlug;
                localStorage.setItem("KinkyDungeonSexyPlug", KinkyDungeonSexyPlug ? "True" : "False");
                return true;
            }, true, 1500, 350, 64, 64, TextGet("KinkyDungeonSexyPlugs"), KinkyDungeonSexyPlug, false, "#ffffff");
            DrawCheckboxKDEx("KinkyDungeonSexyPiercings", (bdata) => {
                KinkyDungeonSexyPiercing = !KinkyDungeonSexyPiercing;
                localStorage.setItem("KinkyDungeonSexyPiercing", KinkyDungeonSexyPiercing ? "True" : "False");
                return true;
            }, true, 1500, 430, 64, 64, TextGet("KinkyDungeonSexyPiercings"), KinkyDungeonSexyPiercing, false, "#ffffff");
        }
    }
    else if (KinkyDungeonState == "Wardrobe") {
        KDDrawWardrobe("menu");
    }
    else if (KinkyDungeonState == "Stats") {
        let tooltip = KinkyDungeonDrawPerks(false);
        DrawTextKD(TextGet("KinkyDungeonStats"), 1000, 30, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonStats2"), 1000, 80, "#ffffff", KDTextGray2);
        if (!tooltip) {
            let points = KinkyDungeonGetStatPoints(KinkyDungeonStatsChoice);
            let hardmode = points >= KDHardModeThresh ? TextGet("KDHardMode") : "";
            DrawTextKD(TextGet("KinkyDungeonStatPoints").replace("AMOUNT", "" + points) + hardmode, 1000, 150, "#ffffff", KDTextGray2);
        }
        DrawButtonKDEx("KDPerksStart", (bdata) => {
            if (KinkyDungeonGetStatPoints(KinkyDungeonStatsChoice) >= 0) {
                KDLose = false;
                KinkyDungeonStartNewGame();
            }
            return true;
        }, true, 875, 920, 350, 64, TextGet("KinkyDungeonStartGame"), KinkyDungeonGetStatPoints(KinkyDungeonStatsChoice) >= 0 ? "#ffffff" : "pink", "");
        DrawButtonKDEx("KDPerksBack", (bdata) => {
            KinkyDungeonState = "Menu";
            return true;
        }, true, 1275, 920, 350, 64, TextGet("KinkyDungeonLoadBack"), "#ffffff", "");
        DrawButtonKDEx("KDPerksClear", (bdata) => {
            KinkyDungeonStatsChoice = new Map();
            KDUpdatePlugSettings();
            return true;
        }, true, 40, 920, 190, 64, TextGet("KinkyDungeonClearAll"), "#ffffff", "");
        DrawButtonKDEx("KDPerkConfig1", (bdata) => {
            KinkyDungeonPerksConfig = "1";
            KinkyDungeonLoadStats();
            KDUpdatePlugSettings();
            return true;
        }, true, 270, 930, 100, 54, TextGet("KinkyDungeonConfig") + "1", KinkyDungeonPerksConfig == "1" ? "#ffffff" : "#888888", "");
        DrawButtonKDEx("KDPerkConfig2", (bdata) => {
            KinkyDungeonPerksConfig = "2";
            KinkyDungeonLoadStats();
            KDUpdatePlugSettings();
            return true;
        }, true, 380, 930, 100, 54, TextGet("KinkyDungeonConfig") + "2", KinkyDungeonPerksConfig == "2" ? "#ffffff" : "#888888", "");
        DrawButtonKDEx("KDPerkConfig3", (bdata) => {
            KinkyDungeonPerksConfig = "3";
            KinkyDungeonLoadStats();
            KDUpdatePlugSettings();
            return true;
        }, true, 490, 930, 100, 54, TextGet("KinkyDungeonConfig") + "3", KinkyDungeonPerksConfig == "3" ? "#ffffff" : "#888888", "");
        let TF = KDTextField("PerksFilter", 600, 930, 210, 54, "text", "", "45");
        if (TF.Created) {
            TF.Element.oninput = (event) => {
                KDPerksFilter = ElementValue("PerksFilter");
            };
        }
        DrawTextFitKD(TextGet("KinkyDungeonFilter"), 600 + 210 / 2, 930 + 54 / 2, 210, "#aaaaaa");
        DrawButtonKDEx("copyperks", (bdata) => {
            let txt = "";
            for (let k of KinkyDungeonStatsChoice.keys()) {
                if (!k.startsWith("arousal") && !k.endsWith("Mode"))
                    txt += (txt ? "\n" : "") + k;
            }
            navigator.clipboard.writeText(txt);
            return true;
        }, true, 1850, 930, 140, 54, TextGet("KinkyDungeonCopyPerks"), "#ffffff", "");
        DrawButtonKDEx("pasteperks", (bdata) => {
            navigator.clipboard.readText()
                .then(text => {
                let list = text.split('\n');
                let changed = 1;
                let iter = 0;
                while (changed > 0 && iter < 1000) {
                    changed = 0;
                    for (let l of list) {
                        let lp = l.replace('\r', '');
                        for (let perk of Object.entries(KinkyDungeonStatsPresets)) {
                            if (perk[0] == lp && KDValidatePerk(perk[1])) {
                                KinkyDungeonStatsChoice.set(perk[0], true);
                                changed += 1;
                            }
                        }
                    }
                    iter += 1;
                }
            })
                .catch(err => {
                console.error('Failed to read clipboard contents: ', err);
            });
            return true;
        }, true, 1700, 930, 140, 54, TextGet("KinkyDungeonPastePerks"), "#ffffff", "");
        if (KinkyDungeonKeybindingCurrentKey && KinkyDungeonGameKeyDown()) {
            if (KinkyDungeonKeybindingCurrentKey)
                KDLastKeyTime[KinkyDungeonKeybindingCurrentKey] = CommonTime();
            KinkyDungeonKeybindingCurrentKey = '';
        }
    }
    else if (KinkyDungeonState == "Save") {
        DrawTextKD(TextGet("KinkyDungeonSaveIntro0"), 1250, 350, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonSaveIntro"), 1250, 475, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonSaveIntro2"), 1250, 550, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonSaveIntro3"), 1250, 625, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonSaveIntro4"), 1250, 700, "#ffffff", KDTextGray2);
        ElementPosition("saveDataField", 1250, 150, 1000, 230);
        DrawButtonVis(1075, 750, 350, 64, TextGet("KinkyDungeonGameContinue"), "#ffffff", "");
    }
    else if (KinkyDungeonState == "Game") {
        KinkyDungeonGameRunning = true;
        KinkyDungeonGameFlag = true;
        KinkyDungeonDrawGame();
        if (KinkyDungeonInputQueue.length < 1) {
            let _CharacterRefresh = CharacterRefresh;
            let _CharacterAppearanceBuildCanvas = CharacterAppearanceBuildCanvas;
            CharacterRefresh = () => { KDRefresh = true; };
            CharacterAppearanceBuildCanvas = () => { };
            if (KDGameData.SleepTurns > 0) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    KDGameData.SleepTurns -= 1;
                    if (KinkyDungeonAggressive())
                        KinkyDungeonTotalSleepTurns += 1;
                    if (KinkyDungeonStatStamina >= KinkyDungeonStatStaminaMax && KinkyDungeonStatWill >= KinkyDungeonStatWillMax) {
                        KDGameData.SleepTurns = 0;
                    }
                    KDIncreaseOfferFatigue(-1);
                    KDSendInput("tick", { delta: 1, sleep: true }, false, true);
                    KinkyDungeonSleepTime = CommonTime() + 10;
                }
                if (KDGameData.SleepTurns == 0) {
                    KinkyDungeonChangeStamina(0);
                    KinkyDungeonChangeWill(0);
                    KDGameData.KneelTurns = 1;
                }
            }
            else if (KDGameData.PlaySelfTurns > 0) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    KDSendInput("tick", { delta: 1 }, false, true);
                    KDGameData.PlaySelfTurns -= 1;
                    KinkyDungeonSleepTime = CommonTime() + (KinkyDungeonFlags.get("PlayerOrgasm") ? KinkyDungeonOrgasmTime : KinkyDungeonPlaySelfTime) * (0.25 + KDAnimSpeed * 0.75);
                }
                if (KDGameData.SleepTurns == 0) {
                    KinkyDungeonChangeStamina(0);
                }
            }
            else if (KinkyDungeonStatFreeze > 0) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    KinkyDungeonStatFreeze -= 1;
                    KDSendInput("tick", { delta: 1, NoUpdate: false, NoMsgTick: true }, false, true);
                    KinkyDungeonSleepTime = CommonTime() + KinkyDungeonFreezeTime * (0.25 + KDAnimSpeed * 0.75);
                }
            }
            else if (KinkyDungeonSlowMoveTurns > 0) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    KinkyDungeonSlowMoveTurns -= 1;
                    KDSendInput("tick", { delta: 1, NoUpdate: false, NoMsgTick: true }, false, true);
                    KinkyDungeonSleepTime = CommonTime() + 150 * (0.25 + KDAnimSpeed * 0.75);
                }
            }
            else if (KinkyDungeonFastMove && KinkyDungeonFastMovePath && KinkyDungeonFastMovePath.length > 0) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    if (KinkyDungeonFastMovePath.length > 0) {
                        let next = KinkyDungeonFastMovePath[0];
                        KinkyDungeonFastMovePath.splice(0, 1);
                        if (Math.max(Math.abs(next.x - KinkyDungeonPlayerEntity.x), Math.abs(next.y - KinkyDungeonPlayerEntity.y)) < 1.5)
                            KDSendInput("move", { dir: { x: next.x - KinkyDungeonPlayerEntity.x, y: next.y - KinkyDungeonPlayerEntity.y }, delta: 1, AllowInteract: true, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: KinkyDungeonSuppressSprint }, false, true);
                        else
                            KinkyDungeonFastMovePath = [];
                    }
                    KinkyDungeonSleepTime = CommonTime() + 100 * (0.25 + KDAnimSpeed * 0.75);
                }
            }
            else if (KinkyDungeonFastStruggle && KinkyDungeonFastStruggleType && KinkyDungeonFastStruggleGroup) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    let result = KDSendInput("struggle", { group: KinkyDungeonFastStruggleGroup, type: KinkyDungeonFastStruggleType }, false, true);
                    if (result != "Fail" || !KinkyDungeonHasStamina(2.5)) {
                        KinkyDungeonFastStruggleType = "";
                        KinkyDungeonFastStruggleGroup = "";
                    }
                    KinkyDungeonSleepTime = CommonTime() + 250 * (0.25 + KDAnimSpeed * 0.75);
                }
            }
            else if (KinkyDungeonAutoWait) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    let lastStamina = KinkyDungeonStatStamina;
                    KDSendInput("move", { dir: { x: 0, y: 0, delta: 0 }, delta: 1, AllowInteract: true, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: KinkyDungeonSuppressSprint }, false, true);
                    if (KinkyDungeonFastStruggle && KinkyDungeonStatStamina == KinkyDungeonStatStaminaMax && lastStamina < KinkyDungeonStatStamina) {
                        if (KinkyDungeonTempWait && !KDGameData.KinkyDungeonLeashedPlayer && !KinkyDungeonInDanger())
                            KDDisableAutoWait();
                    }
                    KinkyDungeonSleepTime = CommonTime() + (KinkyDungeonFastWait ? 100 : 300);
                }
            }
            else if (KinkyDungeonAutoWaitStruggle) {
                if (CommonTime() > KinkyDungeonSleepTime) {
                    if (!(((_a = KDGameData.DelayedActions) === null || _a === void 0 ? void 0 : _a.length) > 0)) {
                        KDHandleAutoStruggle(KinkyDungeonPlayerEntity);
                    }
                    if (KinkyDungeonInDanger())
                        KDDisableAutoWait();
                    KinkyDungeonSleepTime = CommonTime() + (300 + Math.min(1200, KDAutoStruggleData.lastDelay * 270)) * (0.5 + KDAnimSpeed * 0.5);
                }
            }
            else
                KinkyDungeonSleepTime = CommonTime() + 100;
            CharacterRefresh = _CharacterRefresh;
            CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
        }
        else
            KinkyDungeonSleepTime = CommonTime() + 100;
    }
    else if (KinkyDungeonState == "End") {
        KinkyDungeonGameRunning = false;
        DrawTextKD(TextGet("EndWin"), 1250, 400, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("EndWin2"), 1250, 500, "#ffffff", KDTextGray2);
        DrawButtonVis(1075, 650, 350, 64, TextGet("KinkyDungeonNewGamePlus"), "#ffffff", "");
        DrawButtonVis(1075, 750, 350, 64, TextGet("GameReturnToMenu"), "#ffffff", "");
    }
    else if (KinkyDungeonState == "Keybindings") {
        DrawButtonKDEx("KBBack", () => {
            KinkyDungeonKeybindings = KinkyDungeonKeybindingsTemp;
            if (KinkyDungeonGameFlag) {
                KinkyDungeonState = "Game";
                if (KinkyDungeonKeybindings) {
                    KDCommitKeybindings();
                }
            }
            else
                KinkyDungeonState = "Menu";
            localStorage.setItem("KinkyDungeonKeybindings", JSON.stringify(KinkyDungeonKeybindings));
            return true;
        }, true, 1450, 780, 350, 64, TextGet("GameReturnToMenu"), "#ffffff", "");
        DrawButtonKDEx("KBBack2", () => {
            KinkyDungeonKeybindingsTemp = Object.assign({}, KinkyDungeonKeybindingsTemp);
            if (KinkyDungeonGameFlag) {
                KinkyDungeonState = "Game";
            }
            else
                KinkyDungeonState = "Menu";
            return true;
        }, true, 1450, 700, 350, 64, TextGet("GameReturnToMenu2"), "#ffffff", "");
        DrawButtonKDEx("KBUp", () => { KinkyDungeonKeybindingsTemp.Up = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 100, 300, 50, TextGet("KinkyDungeonKeyUp") + ": '" + (KinkyDungeonKeybindingsTemp.Up) + "'", "#ffffff", "");
        DrawButtonKDEx("KBDown", () => { KinkyDungeonKeybindingsTemp.Down = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 160, 300, 50, TextGet("KinkyDungeonKeyDown") + ": '" + (KinkyDungeonKeybindingsTemp.Down) + "'", "#ffffff", "");
        DrawButtonKDEx("KBLeft", () => { KinkyDungeonKeybindingsTemp.Left = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 220, 300, 50, TextGet("KinkyDungeonKeyLeft") + ": '" + (KinkyDungeonKeybindingsTemp.Left) + "'", "#ffffff", "");
        DrawButtonKDEx("KBRight", () => { KinkyDungeonKeybindingsTemp.Right = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 280, 300, 50, TextGet("KinkyDungeonKeyRight") + ": '" + (KinkyDungeonKeybindingsTemp.Right) + "'", "#ffffff", "");
        DrawButtonKDEx("KBUpLleft", () => { KinkyDungeonKeybindingsTemp.UpLeft = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 340, 300, 50, TextGet("KinkyDungeonKeyUpLeft") + ": '" + (KinkyDungeonKeybindingsTemp.UpLeft) + "'", "#ffffff", "");
        DrawButtonKDEx("KBUpRight", () => { KinkyDungeonKeybindingsTemp.UpRight = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 400, 300, 50, TextGet("KinkyDungeonKeyUpRight") + ": '" + (KinkyDungeonKeybindingsTemp.UpRight) + "'", "#ffffff", "");
        DrawButtonKDEx("KBDownLeft", () => { KinkyDungeonKeybindingsTemp.DownLeft = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 460, 300, 50, TextGet("KinkyDungeonKeyDownLeft") + ": '" + (KinkyDungeonKeybindingsTemp.DownLeft) + "'", "#ffffff", "");
        DrawButtonKDEx("KBDownRight", () => { KinkyDungeonKeybindingsTemp.DownRight = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 520, 300, 50, TextGet("KinkyDungeonKeyDownRight") + ": '" + (KinkyDungeonKeybindingsTemp.DownRight) + "'", "#ffffff", "");
        DrawButtonKDEx("KBWait", () => { KinkyDungeonKeybindingsTemp.Wait = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 600, 300, 50, TextGet("KinkyDungeonKeyWait") + ": '" + (KinkyDungeonKeybindingsTemp.Wait) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpell1", () => { KinkyDungeonKeybindingsTemp.Spell1 = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 100, 300, 50, TextGet("KinkyDungeonKeySpell1") + ": '" + (KinkyDungeonKeybindingsTemp.Spell1) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpell2", () => { KinkyDungeonKeybindingsTemp.Spell2 = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 160, 300, 50, TextGet("KinkyDungeonKeySpell2") + ": '" + (KinkyDungeonKeybindingsTemp.Spell2) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpell3", () => { KinkyDungeonKeybindingsTemp.Spell3 = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 220, 300, 50, TextGet("KinkyDungeonKeySpell3") + ": '" + (KinkyDungeonKeybindingsTemp.Spell3) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpell4", () => { KinkyDungeonKeybindingsTemp.Spell4 = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 280, 300, 50, TextGet("KinkyDungeonKeySpell4") + ": '" + (KinkyDungeonKeybindingsTemp.Spell4) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpell5", () => { KinkyDungeonKeybindingsTemp.Spell5 = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 340, 300, 50, TextGet("KinkyDungeonKeySpell5") + ": '" + (KinkyDungeonKeybindingsTemp.Spell5) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpell6", () => { KinkyDungeonKeybindingsTemp.Spell6 = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 400, 300, 50, TextGet("KinkyDungeonKeySpell6") + ": '" + (KinkyDungeonKeybindingsTemp.Spell6) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpell7", () => { KinkyDungeonKeybindingsTemp.Spell7 = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 460, 300, 50, TextGet("KinkyDungeonKeySpell7") + ": '" + (KinkyDungeonKeybindingsTemp.Spell7) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpellPage", () => { KinkyDungeonKeybindingsTemp.SpellPage = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 520, 300, 50, TextGet("KinkyDungeonKeySpellPage") + ": '" + (KinkyDungeonKeybindingsTemp.SpellPage) + "'", "#ffffff", "");
        DrawButtonKDEx("KBUpcast", () => { KinkyDungeonKeybindingsTemp.Upcast = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 580, 300, 50, TextGet("KinkyDungeonKeyUpcast") + ": '" + (KinkyDungeonKeybindingsTemp.Upcast) + "'", "#ffffff", "");
        DrawButtonKDEx("KBUpcastCancel", () => { KinkyDungeonKeybindingsTemp.UpcastCancel = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 640, 300, 50, TextGet("KinkyDungeonKeyUpcastCancel") + ": '" + (KinkyDungeonKeybindingsTemp.UpcastCancel) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSwitchWeapon", () => { KinkyDungeonKeybindingsTemp.SwitchWeapon = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 700, 300, 50, TextGet("KinkyDungeonKeySwitchWeapon") + ": '" + (KinkyDungeonKeybindingsTemp.SwitchWeapon) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSpellWeapon", () => { KinkyDungeonKeybindingsTemp.SpellWeapon = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 675, 760, 300, 50, TextGet("KinkyDungeonKeySpellWeapon") + ": '" + (KinkyDungeonKeybindingsTemp.SpellWeapon) + "'", "#ffffff", "");
        DrawButtonKDEx("KBSkip", () => { KinkyDungeonKeybindingsTemp.Skip = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 680, 300, 50, TextGet("KinkyDungeonKeySkip") + ": '" + (KinkyDungeonKeybindingsTemp.Skip) + "'", "#ffffff", "");
        DrawButtonKDEx("KBEnter", () => { KinkyDungeonKeybindingsTemp.Enter = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1075, 740, 300, 50, TextGet("KinkyDungeonKeyEnter") + ": '" + (KinkyDungeonKeybindingsTemp.Enter) + "'", "#ffffff", "");
        DrawButtonKDEx("KBMsgLog", () => { KinkyDungeonKeybindingsTemp.MsgLog = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 100, 300, 38, TextGet("KinkyDungeonKeyMsgLog") + ": '" + (KinkyDungeonKeybindingsTemp.MsgLog) + "'", "#ffffff", "");
        DrawButtonKDEx("KBDoor", () => { KinkyDungeonKeybindingsTemp.Door = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 145, 300, 38, TextGet("KinkyDungeonKeyDoor") + ": '" + (KinkyDungeonKeybindingsTemp.Door) + "'", "#ffffff", "");
        DrawButtonKDEx("KBPass", () => { KinkyDungeonKeybindingsTemp.Pass = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 190, 300, 38, TextGet("KinkyDungeonKeyPass") + ": '" + (KinkyDungeonKeybindingsTemp.Pass) + "'", "#ffffff", "");
        DrawButtonKDEx("KBAStruggle", () => { KinkyDungeonKeybindingsTemp.AStruggle = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 235, 300, 38, TextGet("KinkyDungeonKeyAStruggle") + ": '" + (KinkyDungeonKeybindingsTemp.AStruggle) + "'", "#ffffff", "");
        DrawButtonKDEx("KBAPathfind", () => { KinkyDungeonKeybindingsTemp.APathfind = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 280, 300, 38, TextGet("KinkyDungeonKeyAPathfind") + ": '" + (KinkyDungeonKeybindingsTemp.APathfind) + "'", "#ffffff", "");
        DrawButtonKDEx("KBASprint", () => { KinkyDungeonKeybindingsTemp.Sprint = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 325, 300, 38, TextGet("KinkyDungeonKeySprint") + ": '" + (KinkyDungeonKeybindingsTemp.Sprint) + "'", "#ffffff", "");
        DrawButtonKDEx("KBInspect", () => { KinkyDungeonKeybindingsTemp.AInspect = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 370, 300, 38, TextGet("KinkyDungeonKeyInspect") + ": '" + (KinkyDungeonKeybindingsTemp.AInspect) + "'", "#ffffff", "");
        DrawButtonKDEx("KBQInventory", () => { KinkyDungeonKeybindingsTemp.QInventory = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 425, 300, 45, TextGet("KinkyDungeonKeyQInventory") + ": '" + (KinkyDungeonKeybindingsTemp.QInventory) + "'", "#ffffff", "");
        DrawButtonKDEx("KBInventory", () => { KinkyDungeonKeybindingsTemp.Inventory = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 475, 300, 45, TextGet("KinkyDungeonKeyInventory") + ": '" + (KinkyDungeonKeybindingsTemp.Inventory) + "'", "#ffffff", "");
        DrawButtonKDEx("KBReputation", () => { KinkyDungeonKeybindingsTemp.Reputation = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 525, 300, 45, TextGet("KinkyDungeonKeyReputation") + ": '" + (KinkyDungeonKeybindingsTemp.Reputation) + "'", "#ffffff", "");
        DrawButtonKDEx("KBMagic", () => { KinkyDungeonKeybindingsTemp.Magic = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 575, 300, 45, TextGet("KinkyDungeonKeyMagic") + ": '" + (KinkyDungeonKeybindingsTemp.Magic) + "'", "#ffffff", "");
        DrawButtonKDEx("KBLog", () => { KinkyDungeonKeybindingsTemp.Log = KinkyDungeonKeybindingCurrentKey; return true; }, KinkyDungeonKeybindingCurrentKey != '', 1475, 625, 300, 45, TextGet("KinkyDungeonKeyLog") + ": '" + (KinkyDungeonKeybindingsTemp.Log) + "'", "#ffffff", "");
        if (KinkyDungeonKeybindingCurrentKey)
            DrawTextKD(TextGet("KinkyDungeonCurrentPress") + ": '" + (KinkyDungeonKeybindingCurrentKey) + "'", 1250, 900, "#ffffff", KDTextGray2);
        DrawTextKD(TextGet("KinkyDungeonCurrentPressInfo"), 1250, 950, "#ffffff", KDTextGray2);
    }
    else if (KinkyDungeonState == "Toggles") {
        let XX = 840;
        let YYstart = 200;
        let YYmax = 680;
        let YY = YYstart;
        let YYd = 70;
        let XXd = 400;
        let toggles = Object.keys(KDToggles);
        for (let toggle of toggles) {
            DrawCheckboxKDEx("toggle" + toggle, () => {
                KDToggles[toggle] = !KDToggles[toggle];
                KDSaveToggles();
                return true;
            }, true, XX, YY, 64, 64, TextGet("KDToggle" + toggle), KDToggles[toggle], false, "#ffffff", undefined, {
                maxWidth: 300,
            });
            YY += YYd;
            if (YY > YYmax) {
                YY = YYstart;
                XX += XXd;
            }
        }
        YY = YYstart;
        DrawBackNextButtonVis(450, YY, 350, 64, TextGet("KDVibeVolume") + " " + (KDVibeVolume * 100 + "%"), "#ffffff", "", () => KDVibeVolumeList[(KDVibeVolumeListIndex + KDVibeVolumeList.length - 1) % KDVibeVolumeList.length] * 100 + "%", () => KDVibeVolumeList[(KDVibeVolumeListIndex + 1) % KDVibeVolumeList.length] * 100 + "%");
        YY += YYd;
        DrawBackNextButtonVis(450, YY, 350, 64, TextGet("KDMusicVolume") + " " + (KDMusicVolume * 100 + "%"), "#ffffff", "", () => KDMusicVolumeList[(KDMusicVolumeListIndex + KDMusicVolumeList.length - 1) % KDMusicVolumeList.length] * 100 + "%", () => KDMusicVolumeList[(KDMusicVolumeListIndex + 1) % KDMusicVolumeList.length] * 100 + "%");
        YY += YYd;
        DrawBackNextButtonVis(450, YY, 350, 64, TextGet("KDSfxVolume") + " " + (KDSfxVolume * 100 + "%"), "#ffffff", "", () => KDSfxVolumeList[(KDSfxVolumeListIndex + KDSfxVolumeList.length - 1) % KDSfxVolumeList.length] * 100 + "%", () => KDSfxVolumeList[(KDSfxVolumeListIndex + 1) % KDSfxVolumeList.length] * 100 + "%");
        YY += YYd;
        DrawBackNextButtonVis(450, YY, 350, 64, TextGet("KDAnimSpeed") + " " + (KDAnimSpeed * 100 + "%"), "#ffffff", "", () => KDAnimSpeedList[(KDAnimSpeedListIndex + KDAnimSpeedList.length - 1) % KDAnimSpeedList.length] * 100 + "%", () => KDAnimSpeedList[(KDAnimSpeedListIndex + 1) % KDAnimSpeedList.length] * 100 + "%");
        YY += YYd;
        DrawButtonKDEx("KBBackOptions", () => {
            KinkyDungeonKeybindingsTemp = Object.assign({}, KinkyDungeonKeybindingsTemp);
            if (KinkyDungeonGameFlag) {
                KinkyDungeonState = "Game";
            }
            else
                KinkyDungeonState = "Menu";
            return true;
        }, true, 975, 780, 550, 64, TextGet("GameReturnToMenuFromOptions"), "#ffffff", "");
    }
    KDCullTempElements();
    KDCullSprites();
    if (!StandalonePatched) {
        if (!pixiview)
            pixiview = document.getElementById("MainCanvas");
        if (!pixirenderer) {
            if (pixiview) {
                pixirenderer = new PIXI.Renderer({
                    width: pixiview.width,
                    height: pixiview.height,
                    view: pixiview,
                    antialias: true,
                });
            }
        }
    }
    let delta = performance.now() - lastfps;
    fpscounter++;
    if (fpscounter > 10) {
        fpscounter = 0;
        dispfps = Math.round(1000 / Math.max(delta, 1));
    }
    lastfps = performance.now();
    KDUpdateParticles(delta);
    if (StandalonePatched) {
    }
    else {
        if (pixirenderer) {
            pixirenderer.render(kdcanvas, {
                clear: false,
            });
            pixirenderer.render(kdui, {
                clear: false,
            });
        }
    }
    KDLastButtonsCache = {};
    MouseClicked = false;
}
let kdTrackGameBoard = false;
let kdTrackGameFog = false;
let kdTrackGameParticles = false;
function KDCullSprites() {
    for (let sprite of kdpixisprites.entries()) {
        if (!kdSpritesDrawn.has(sprite[0])) {
            sprite[1].parent.removeChild(sprite[1]);
            if (kdprimitiveparams.has(sprite[0]))
                kdprimitiveparams.delete(sprite[0]);
            kdpixisprites.delete(sprite[0]);
            sprite[1].destroy();
        }
    }
}
let KDButtonsCache = {};
let KDLastButtonsCache = {};
function DrawButtonKD(name, enabled, Left, Top, Width, Height, Label, Color, Image, HoveringText, Disabled, NoBorder) {
    DrawButtonVis(Left, Top, Width, Height, Label, Color, Image, HoveringText, Disabled, NoBorder);
    KDButtonsCache[name] = {
        Left,
        Top,
        Width,
        Height,
        enabled,
    };
}
function DrawButtonKDEx(name, func, enabled, Left, Top, Width, Height, Label, Color, Image, HoveringText, Disabled, NoBorder, FillColor, FontSize, ShiftText, options) {
    DrawButtonVis(Left, Top, Width, Height, Label, Color, Image, HoveringText, Disabled, NoBorder, FillColor, FontSize, ShiftText, undefined, options === null || options === void 0 ? void 0 : options.zIndex, options);
    KDButtonsCache[name] = {
        Left,
        Top,
        Width,
        Height,
        enabled,
        func,
    };
}
function KDProcessButtons() {
    for (let button of Object.entries(KDButtonsCache)) {
        if (button[1].enabled && button[1].func) {
            if (MouseInKD(button[0])) {
                return button[1].func();
            }
        }
    }
    return false;
}
function KDClickButton(name) {
    let button = KDButtonsCache[name] || KDLastButtonsCache[name];
    if (button && button.enabled) {
        return button.func();
    }
    return false;
}
function MouseInKD(name) {
    let button = KDButtonsCache[name];
    if (button && button.enabled) {
        return MouseIn(button.Left, button.Top, button.Width, button.Height);
    }
    return false;
}
function KinkyDungeonGetTraitsCount() {
    return Array.from(KinkyDungeonStatsChoice.keys()).filter((element) => { return !element.includes('arousalMode'); }).length;
}
function KDSendTrait(trait) {
    if (window.dataLayer)
        window.dataLayer.push({
            'event': 'trait',
            'traitType': trait,
            'journey': KDJourney,
        });
}
function KDSendSpell(spell) {
    if (window.dataLayer)
        window.dataLayer.push({
            'event': 'spell',
            'spellType': spell,
            'currentLevel': MiniGameKinkyDungeonLevel,
            'currentCheckpoint': MiniGameKinkyDungeonCheckpoint,
            'journey': KDJourney,
        });
}
function KDSendSpellCast(spell) {
    if (window.dataLayer)
        window.dataLayer.push({
            'event': 'spellCast',
            'spellType': spell,
            'currentLevel': MiniGameKinkyDungeonLevel,
            'currentCheckpoint': MiniGameKinkyDungeonCheckpoint,
            'journey': KDJourney,
        });
}
function KDSendWeapon(weapon) {
    if (window.dataLayer)
        window.dataLayer.push({
            'event': 'weapon',
            'weapon': weapon,
            'currentLevel': MiniGameKinkyDungeonLevel,
            'currentCheckpoint': MiniGameKinkyDungeonCheckpoint,
            'journey': KDJourney,
        });
}
function KDSendStatus(type, data, data2) {
    if (window.dataLayer && !KDOptOut) {
        window.dataLayer.push({
            'event': 'gameStatus',
            'currentLevel': MiniGameKinkyDungeonLevel,
            'currentCheckpoint': MiniGameKinkyDungeonCheckpoint,
            'difficulty': KinkyDungeonStatsChoice.get("randomMode"),
            'newgameplus': KinkyDungeonNewGame,
            'statusType': type,
            'aroused': KinkyDungeonStatsChoice.get("arousalMode") ? 'yes' : 'no',
            'traitscount': KinkyDungeonGetTraitsCount(),
            'gold': Math.round(KinkyDungeonGold / 100) * 100,
            'spellType': type == 'learnspell' ? data : undefined,
            'goddess': type == 'goddess' ? data : undefined,
            'helpType': type == 'goddess' ? data2 : undefined,
            'restraint': (type == 'escape' || type == 'bound') ? data : undefined,
            'method': type == 'escape' ? data2 : undefined,
            'attacker': type == 'bound' ? data2 : undefined,
            'prisonerstate': KDGameData.PrisonerState,
        });
        if (type == 'nextLevel' && !KinkyDungeonStatsChoice.get("randomMode")) {
            for (let s of KinkyDungeonSpells) {
                KDSendSpell(s.name);
            }
            KDSendWeapon((KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.name) ? KinkyDungeonPlayerDamage.name : 'unarmed');
        }
    }
}
function KDSendEvent(type) {
    if (window.dataLayer && !KDOptOut)
        if (type == 'newGame') {
            window.dataLayer.push({
                'event': type,
                'aroused': KinkyDungeonStatsChoice.get("arousalMode") ? 'yes' : 'no',
                'traitscount': KinkyDungeonGetTraitsCount(),
                'journey': KDJourney,
            });
            for (let s of KinkyDungeonStatsChoice.keys()) {
                if (KinkyDungeonStatsChoice.get(s))
                    KDSendTrait(s);
            }
        }
        else if (type == 'jail') {
            window.dataLayer.push({
                'event': type,
                'currentLevel': MiniGameKinkyDungeonLevel,
                'alreadyInJail': KinkyDungeonInJail(KDJailFilters) ? 'true' : 'false',
                'currentCheckpoint': MiniGameKinkyDungeonCheckpoint,
                'difficulty': KinkyDungeonStatsChoice.get("randomMode"),
                'newgameplus': KinkyDungeonNewGame,
                'aroused': KinkyDungeonStatsChoice.get("arousalMode") ? 'yes' : 'no',
                'traitscount': KinkyDungeonGetTraitsCount(),
                'gold': Math.round(KinkyDungeonGold / 100) * 100,
                'journey': KDJourney,
            });
        }
        else if (type == 'loadGame') {
            window.dataLayer.push({
                'event': type,
                'currentLevel': MiniGameKinkyDungeonLevel,
                'currentCheckpoint': MiniGameKinkyDungeonCheckpoint,
                'difficulty': KinkyDungeonStatsChoice.get("randomMode"),
                'newgameplus': KinkyDungeonNewGame,
                'aroused': KinkyDungeonStatsChoice.get("arousalMode") ? 'yes' : 'no',
                'traitscount': KinkyDungeonGetTraitsCount(),
                'gold': Math.round(KinkyDungeonGold / 100) * 100,
                'journey': KDJourney,
            });
        }
        else if (type == 'patreon') {
            window.dataLayer.push({
                'event': type,
            });
        }
        else if (type == 'optout' || type == 'optin') {
            window.dataLayer.push({
                'event': type,
            });
        }
}
function KinkyDungeonLoadStats() {
    KinkyDungeonStatsChoice = new Map();
    let statsChoice = localStorage.getItem('KinkyDungeonStatsChoice' + KinkyDungeonPerksConfig);
    if (statsChoice) {
        let statsArray = JSON.parse(statsChoice);
        if (statsArray) {
            for (let s of statsArray) {
                if (!s.includes('arousalMode') && KinkyDungeonStatsPresets[s] && KDValidatePerk(KinkyDungeonStatsPresets[s]))
                    KinkyDungeonStatsChoice.set(s, true);
            }
        }
    }
}
let KinkyDungeonGameFlag = false;
let KDDefaultJourney = ["grv", "cat", "jng", "tmp", "bel"];
let KDDefaultAlt = ["tmb", "lib", "cry", "ore", "bel"];
function KDInitializeJourney(Journey) {
    let newIndex = {};
    for (let map of KDDefaultJourney) {
        newIndex[map] = map;
    }
    for (let map of KDDefaultAlt) {
        newIndex[map] = map;
    }
    if (Journey)
        KDGameData.Journey = Journey;
    if (KDGameData.Journey == "Random") {
        let randList = Array.from(Object.keys(newIndex));
        for (let i = randList.length - 1; i >= 0; i--) {
            let j = Math.floor(KDRandom() * (i + 1));
            let temp = randList[i];
            randList[i] = randList[j];
            randList[j] = temp;
        }
        let ii = 0;
        for (let index of Object.keys(newIndex)) {
            newIndex[index] = randList[ii];
            ii++;
        }
    }
    else if (KDGameData.Journey == "Harder") {
        for (let i = 0; i < KDDefaultJourney.length; i++) {
            newIndex[KDDefaultAlt[i]] = KDDefaultJourney[i];
            newIndex[KDDefaultJourney[i]] = KDDefaultAlt[i];
        }
    }
    else if (KDGameData.Journey == "Explorer") {
        newIndex.grv = 'jng';
        newIndex.tmb = 'cry';
        newIndex.cat = 'grv';
        newIndex.lib = 'cat';
        newIndex.jng = 'tmp';
        newIndex.cry = 'lib';
        newIndex.tmp = 'ore';
        newIndex.ore = 'tmb';
        newIndex.bel = 'bel';
    }
    else if (KDGameData.Journey == "Doll") {
        newIndex.grv = 'tmp';
        newIndex.tmb = 'bel';
        newIndex.cat = 'bel';
        newIndex.lib = 'ore';
        newIndex.jng = 'bel';
        newIndex.cry = 'lib';
        newIndex.tmp = 'cry';
        newIndex.ore = 'tmb';
        newIndex.bel = 'cat';
    }
    else if (KDGameData.Journey == "Test") {
        newIndex.grv = 'bel';
        newIndex.tmb = 'bel';
    }
    KinkyDungeonMapIndex = newIndex;
}
function KDCommitKeybindings() {
    KinkyDungeonKey = [KinkyDungeonKeybindings.Up, KinkyDungeonKeybindings.Left, KinkyDungeonKeybindings.Down, KinkyDungeonKeybindings.Right, KinkyDungeonKeybindings.UpLeft, KinkyDungeonKeybindings.UpRight, KinkyDungeonKeybindings.DownLeft, KinkyDungeonKeybindings.DownRight];
    KinkyDungeonGameKey.KEY_UP = (KinkyDungeonKeybindings.Up);
    KinkyDungeonGameKey.KEY_DOWN = (KinkyDungeonKeybindings.Down);
    KinkyDungeonGameKey.KEY_LEFT = (KinkyDungeonKeybindings.Left);
    KinkyDungeonGameKey.KEY_RIGHT = (KinkyDungeonKeybindings.Right);
    KinkyDungeonGameKey.KEY_UPLEFT = (KinkyDungeonKeybindings.UpLeft);
    KinkyDungeonGameKey.KEY_DOWNLEFT = (KinkyDungeonKeybindings.DownLeft);
    KinkyDungeonGameKey.KEY_UPRIGHT = (KinkyDungeonKeybindings.UpRight);
    KinkyDungeonGameKey.KEY_DOWNRIGHT = (KinkyDungeonKeybindings.DownRight);
    KinkyDungeonKeySpell = [
        KinkyDungeonKeybindings.Spell1,
        KinkyDungeonKeybindings.Spell2,
        KinkyDungeonKeybindings.Spell3,
        KinkyDungeonKeybindings.Spell4,
        KinkyDungeonKeybindings.Spell5,
        KinkyDungeonKeybindings.Spell6,
        KinkyDungeonKeybindings.Spell7,
    ];
    KinkyDungeonKeyWait = [KinkyDungeonKeybindings.Wait];
    KinkyDungeonKeySkip = [KinkyDungeonKeybindings.Skip];
    KinkyDungeonKeyUpcast = [KinkyDungeonKeybindings.Upcast, KinkyDungeonKeybindings.UpcastCancel];
    KinkyDungeonKeyWeapon = [KinkyDungeonKeybindings.SpellWeapon];
    KinkyDungeonKeyMenu = [
        KinkyDungeonKeybindings.QInventory,
        KinkyDungeonKeybindings.Inventory,
        KinkyDungeonKeybindings.Reputation,
        KinkyDungeonKeybindings.Magic,
        KinkyDungeonKeybindings.Log,
    ];
    KinkyDungeonKeyToggle = [
        KinkyDungeonKeybindings.MsgLog,
        KinkyDungeonKeybindings.Pass,
        KinkyDungeonKeybindings.Door,
        KinkyDungeonKeybindings.AStruggle,
        KinkyDungeonKeybindings.APathfind,
        KinkyDungeonKeybindings.AInspect,
    ];
    KinkyDungeonKeyEnter = [KinkyDungeonKeybindings.Enter];
    KinkyDungeonKeySpellPage = [KinkyDungeonKeybindings.SpellPage];
    KinkyDungeonKeySwitchWeapon = [KinkyDungeonKeybindings.SwitchWeapon];
    KinkyDungeonKeySprint = [KinkyDungeonKeybindings.Sprint];
    KinkyDungeonGameKey.KEY_WAIT = (KinkyDungeonKeybindings.Wait);
    KinkyDungeonGameKey.KEY_SKIP = (KinkyDungeonKeybindings.Skip);
}
let afterLoaded = false;
function KDModsAfterLoad() {
}
function KinkyDungeonStartNewGame(Load) {
    KinkyDungeonNewGame = 0;
    let cp = KinkyDungeonMapIndex.grv;
    KinkyDungeonInitialize(1, Load);
    MiniGameKinkyDungeonCheckpoint = "grv";
    KinkyDungeonGrid = "";
    if (Load) {
        KinkyDungeonLoadGame();
        KDSendEvent('loadGame');
    }
    else {
        KDSendEvent('newGame');
        KDGameData.RoomType = KinkyDungeonStatsChoice.get("easyMode") ? "ShopStart" : "JourneyFloor";
        MiniGameKinkyDungeonLevel = 0;
        KDInitializeJourney("");
        if (KDTileToTest) {
            KinkyDungeonMapIndex.grv = cp;
        }
    }
    if (!KinkyDungeonGrid)
        KinkyDungeonCreateMap(KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]], MiniGameKinkyDungeonLevel, false, Load);
    KinkyDungeonState = "Game";
    if (KinkyDungeonKeybindings) {
        KDCommitKeybindings();
    }
    if (KDToggles.Sound)
        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/StoneDoor_Close.ogg");
}
function KDUpdatePlugSettings() {
    KinkyDungeonStatsChoice.set("arousalMode", KinkyDungeonSexyMode ? true : undefined);
    KinkyDungeonStatsChoice.set("arousalModePlug", KinkyDungeonSexyPlug ? true : undefined);
    KinkyDungeonStatsChoice.set("arousalModePiercing", KinkyDungeonSexyPiercing ? true : undefined);
    KinkyDungeonStatsChoice.set("randomMode", KinkyDungeonRandomMode ? true : undefined);
    KinkyDungeonStatsChoice.set("saveMode", KinkyDungeonSaveMode ? true : undefined);
    KinkyDungeonStatsChoice.set("easyMode", KinkyDungeonEasyMode == 1 ? true : undefined);
    KinkyDungeonStatsChoice.set("norescueMode", KinkyDungeonEasyMode == 2 ? true : undefined);
    if (KDClassReqs[KinkyDungeonClassMode] && !KDClassReqs[KinkyDungeonClassMode]()) {
        KinkyDungeonClassMode = "Peasant";
    }
    let classCount = Object.keys(KDClassStart).length;
    for (let i = 0; i < classCount; i++) {
        KinkyDungeonStatsChoice.set("classMode", KinkyDungeonClassMode == Object.keys(KDClassStart)[i] ? true : undefined);
    }
    let points = KinkyDungeonGetStatPoints(KinkyDungeonStatsChoice);
    KinkyDungeonStatsChoice.set("hardMode", points >= KDHardModeThresh ? true : undefined);
}
let KDHardModeThresh = 10;
function KinkyDungeonHandleClick() {
    if (KDProcessButtons())
        return true;
    if (MouseIn(1885, 25, 90, 90) && (ServerURL != "foobar")) {
        ElementRemove("saveDataField");
        ElementRemove("saveInputField");
        KinkyDungeonExit();
        return true;
    }
    if (KinkyDungeonState == "Credits") {
        if (MouseIn(1870, 930, 110, 64)) {
            KinkyDungeonState = "Menu";
            return true;
        }
        if (MouseIn(1730, 930, 110, 64)) {
            if (KinkyDungeonCreditsPos < 1)
                KinkyDungeonCreditsPos += 1;
            else
                KinkyDungeonCreditsPos = 0;
        }
    }
    if (KinkyDungeonState == "Patrons") {
        if (MouseIn(1870, 930, 110, 64)) {
            KinkyDungeonState = "Menu";
            return true;
        }
        if (MouseIn(1730, 930, 110, 64)) {
            if (KinkyDungeonPatronPos < 1)
                KinkyDungeonPatronPos += 1;
            else
                KinkyDungeonPatronPos = 0;
        }
    }
    else if (KinkyDungeonState == "Journey") {
        if (MouseIn(875, 350, 750, 64)) {
            KDJourney = "";
            KinkyDungeonState = "Stats";
            return true;
        }
        else if (MouseIn(875, 450, 750, 64)) {
            KDJourney = "Random";
            KinkyDungeonState = "Stats";
            return true;
        }
        else if (MouseIn(875, 550, 750, 64)) {
            KDJourney = "Harder";
            KinkyDungeonState = "Stats";
            return true;
        }
        else if (MouseIn(1075, 850, 350, 64)) {
            KinkyDungeonState = "Menu";
            return true;
        }
    }
    else if (KinkyDungeonState == "Diff") {
        KDUpdatePlugSettings();
        if (MouseIn(1075, 850, 350, 64)) {
            KinkyDungeonState = "Menu";
            return true;
        }
    }
    else if (KinkyDungeonState == "Stats") {
    }
    else if (KinkyDungeonState == "TileEditor") {
        KDHandleTileEditor();
    }
    else if (KinkyDungeonState == "Load") {
        if (MouseIn(875, 750, 350, 64)) {
            KinkyDungeonNewGame = 0;
            KinkyDungeonGrid = "";
            KinkyDungeonInitialize(1, true);
            MiniGameKinkyDungeonCheckpoint = "grv";
            if (KinkyDungeonLoadGame(ElementValue("saveInputField"))) {
                KDSendEvent('loadGame');
                if (KinkyDungeonGrid == "")
                    KinkyDungeonCreateMap(KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]], MiniGameKinkyDungeonLevel, false, true);
                ElementRemove("saveInputField");
                KinkyDungeonState = "Game";
                if (KinkyDungeonKeybindings) {
                    KDCommitKeybindings();
                }
            }
            return true;
        }
        else if (MouseIn(1275, 750, 350, 64)) {
            KinkyDungeonState = "Menu";
            ElementRemove("saveInputField");
            return true;
        }
    }
    else if (KinkyDungeonState == "LoadOutfit") {
        if (MouseIn(875, 750, 350, 64)) {
            KDSaveCodeOutfit();
            KinkyDungeonState = "Wardrobe";
            ElementRemove("saveInputField");
            return true;
        }
        else if (MouseIn(1275, 750, 350, 64)) {
            KDRestoreOutfit();
            KinkyDungeonState = "Wardrobe";
            ElementRemove("saveInputField");
            return true;
        }
    }
    else if (KinkyDungeonState == "Consent") {
        if (KDLoadingFinished) {
            if (MouseIn(975, 720, 450, 64)) {
                KinkyDungeonState = "Menu";
                KDSendEvent('optin');
                CharacterReleaseTotal(KinkyDungeonPlayer);
                KinkyDungeonDressSet();
                CharacterNaked(KinkyDungeonPlayer);
                KinkyDungeonInitializeDresses();
                KinkyDungeonCheckClothesLoss = true;
                KinkyDungeonDressPlayer();
                KDInitProtectedGroups();
                CharacterRefresh(KinkyDungeonPlayer);
                return true;
            }
            else if (MouseIn(975, 820, 450, 64)) {
                KDSendEvent('optout');
                KDOptOut = true;
                KinkyDungeonState = "Menu";
                CharacterReleaseTotal(KinkyDungeonPlayer);
                KinkyDungeonDressSet();
                CharacterNaked(KinkyDungeonPlayer);
                KinkyDungeonInitializeDresses();
                KinkyDungeonCheckClothesLoss = true;
                KinkyDungeonDressPlayer();
                KDInitProtectedGroups();
                CharacterRefresh(KinkyDungeonPlayer);
                return true;
            }
        }
    }
    else if (KinkyDungeonState == "Menu" || KinkyDungeonState == "Lose") {
        if (MouseIn(600, 100, 64, 64)) {
            KDToggles.Sound = !KDToggles.Sound;
            KDSaveToggles();
        }
        if (MouseIn(1700, 874, 280, 50)) {
            let langIndex = KDLanguages.indexOf(localStorage.getItem("BondageClubLanguage")) || 0;
            let newIndex = (langIndex + 1) % KDLanguages.length;
            localStorage.setItem("BondageClubLanguage", KDLanguages[newIndex]);
            KDRestart = true;
            return true;
        }
        if (MouseIn(1850, 930, 135, 64)) {
            KinkyDungeonState = "Credits";
            return true;
        }
        if (MouseIn(1700, 930, 135, 64)) {
            KinkyDungeonState = "Patrons";
            return true;
        }
    }
    else if (KinkyDungeonState == "Save") {
        if (!KinkyDungeonIsPlayer())
            KinkyDungeonState = "Game";
        if (MouseIn(875, 750, 350, 64)) {
            KinkyDungeonState = "Game";
            ElementRemove("saveDataField");
            return true;
        }
        else if (MouseIn(1275, 750, 350, 64)) {
            KinkyDungeonState = "Game";
            ElementRemove("saveDataField");
            return true;
        }
    }
    else if (KinkyDungeonState == "Game") {
        if (KinkyDungeonIsPlayer())
            KinkyDungeonClickGame();
    }
    else if (KinkyDungeonState == "Keybindings") {
    }
    else if (KinkyDungeonState == "Toggles") {
        let YYstart = 200;
        let YY = YYstart;
        let YYd = 70;
        YY = YYstart;
        if (MouseIn(450, YY, 350, 64)) {
            if (MouseX <= 450 + 350 / 2)
                KDVibeVolumeListIndex = (KDVibeVolumeList.length + KDVibeVolumeListIndex - 1) % KDVibeVolumeList.length;
            else
                KDVibeVolumeListIndex = (KDVibeVolumeListIndex + 1) % KDVibeVolumeList.length;
            KDVibeVolume = KDVibeVolumeList[KDVibeVolumeListIndex];
            localStorage.setItem("KDVibeVolume", "" + KDVibeVolumeListIndex);
        }
        YY += YYd;
        if (MouseIn(450, YY, 350, 64)) {
            if (MouseX <= 450 + 350 / 2)
                KDMusicVolumeListIndex = (KDMusicVolumeList.length + KDMusicVolumeListIndex - 1) % KDMusicVolumeList.length;
            else
                KDMusicVolumeListIndex = (KDMusicVolumeListIndex + 1) % KDMusicVolumeList.length;
            KDMusicVolume = KDMusicVolumeList[KDMusicVolumeListIndex];
            localStorage.setItem("KDMusicVolume", "" + KDMusicVolumeListIndex);
        }
        YY += YYd;
        if (MouseIn(450, YY, 350, 64)) {
            if (MouseX <= 450 + 350 / 2)
                KDSfxVolumeListIndex = (KDSfxVolumeList.length + KDSfxVolumeListIndex - 1) % KDSfxVolumeList.length;
            else
                KDSfxVolumeListIndex = (KDSfxVolumeListIndex + 1) % KDSfxVolumeList.length;
            KDSfxVolume = KDSfxVolumeList[KDSfxVolumeListIndex];
            localStorage.setItem("KDSfxVolume", "" + KDSfxVolumeListIndex);
        }
        YY += YYd;
        if (MouseIn(450, YY, 350, 64)) {
            if (MouseX <= 450 + 350 / 2)
                KDAnimSpeedListIndex = (KDAnimSpeedList.length + KDAnimSpeedListIndex - 1) % KDAnimSpeedList.length;
            else
                KDAnimSpeedListIndex = (KDAnimSpeedListIndex + 1) % KDAnimSpeedList.length;
            KDAnimSpeed = KDAnimSpeedList[KDAnimSpeedListIndex] || 0;
            localStorage.setItem("KDAnimSpeed", "" + KDAnimSpeedListIndex);
        }
        YY += YYd;
    }
    else if (KinkyDungeonState == "End") {
        if (MouseIn(1075, 650, 350, 64)) {
            KinkyDungeonState = "Game";
            KinkyDungeonNewGamePlus();
            return true;
        }
        if (MouseIn(1075, 750, 350, 64)) {
            KinkyDungeonState = "Menu";
            return true;
        }
    }
    return false;
}
function KinkyDungeonClick() {
    if (KinkyDungeonHandleClick()) {
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
    }
    if (KinkyDungeonReplaceConfirm > 0)
        KinkyDungeonReplaceConfirm -= 1;
}
function KinkyDungeonExit() {
    CommonDynamicFunction(MiniGameReturnFunction + "()");
    if (ArcadeDeviousChallenge && KinkyDungeonPlayerNeedsRefresh) {
        if (ServerPlayerIsInChatRoom()) {
            ChatRoomCharacterUpdate(Player);
        }
        else {
            CharacterRefresh(Player);
        }
    }
    if (CharacterAppearancePreviousEmoticon) {
        CharacterSetFacialExpression(Player, "Emoticon", CharacterAppearancePreviousEmoticon);
        CharacterAppearancePreviousEmoticon = "";
    }
    if (MiniGameKinkyDungeonLevel > Math.max(KinkyDungeonRep, ReputationGet("Gaming")) || Math.max(KinkyDungeonRep, ReputationGet("Gaming")) > KinkyDungeonMaxLevel) {
        KinkyDungeonRep = Math.max(KinkyDungeonRep, MiniGameKinkyDungeonLevel);
        DialogSetReputation("Gaming", KinkyDungeonRep);
    }
    if (CurrentScreen == "ChatRoom" && KinkyDungeonState != "Menu" && KDLose) {
        let Dictionary = [
            { Tag: "SourceCharacter", Text: CharacterNickname(Player), MemberNumber: Player.MemberNumber },
            { Tag: "KinkyDungeonLevel", Text: String(MiniGameKinkyDungeonLevel) },
        ];
        ChatRoomPublishCustomAction("KinkyDungeonLose", false, Dictionary);
    }
    CharacterRefresh(Player, true);
    KinkyDungeonTeardownCrashHandler();
}
function KinkyDungeonKeyDown() {
}
let mouseDown = false;
let MouseClicked = false;
window.addEventListener('mousedown', function () {
    mouseDown = true;
    MouseClicked = true;
});
window.addEventListener('touchstart', function () {
    MouseClicked = true;
});
window.addEventListener('mouseup', function () {
    mouseDown = false;
});
let KinkyDungeonGameKey = {
    keyPressed: [false, false, false, false, false, false, false, false, false],
    KEY_UP: 'KeyB',
    KEY_DOWN: 'KeyV',
    KEY_LEFT: 'KeyC',
    KEY_RIGHT: 'KeyX',
    KEY_UPLEFT: 'KeyC',
    KEY_UPRIGHT: 'KeyB',
    KEY_DOWNLEFT: 'KeyX',
    KEY_DOWNRIGHT: 'KeyV',
    KEY_WAIT: 'KeyV',
    KEY_SKIP: 'KeyEnter',
    load: function () {
        KinkyDungeonGameKey.keyPressed = [false, false, false, false, false, false, false, false, false];
        KinkyDungeonGameKey.addKeyListener();
    },
    addKeyListener: function () {
        window.addEventListener('keydown', KinkyDungeonGameKey.keyDownEvent);
        window.addEventListener('keyup', KinkyDungeonGameKey.keyUpEvent);
    },
    removeKeyListener: function () {
        window.removeEventListener('keydown', KinkyDungeonGameKey.keyDownEvent);
        window.removeEventListener('keyup', KinkyDungeonGameKey.keyUpEvent);
    },
    keyDownEvent: {
        handleEvent: function (event) {
            let code = event.code;
            if (!KDLastKeyTime[code]) {
                KinkyDungeonKeybindingCurrentKey = code;
                KDLastKeyTime[KinkyDungeonKeybindingCurrentKey] = CommonTime();
            }
            switch (code) {
                case KinkyDungeonGameKey.KEY_UP:
                    if (!KinkyDungeonGameKey.keyPressed[0]) {
                        KinkyDungeonGameKey.keyPressed[0] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_DOWN:
                    if (!KinkyDungeonGameKey.keyPressed[1]) {
                        KinkyDungeonGameKey.keyPressed[1] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_LEFT:
                    if (!KinkyDungeonGameKey.keyPressed[2]) {
                        KinkyDungeonGameKey.keyPressed[2] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_RIGHT:
                    if (!KinkyDungeonGameKey.keyPressed[3]) {
                        KinkyDungeonGameKey.keyPressed[3] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_UPLEFT:
                    if (!KinkyDungeonGameKey.keyPressed[4]) {
                        KinkyDungeonGameKey.keyPressed[4] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_UPRIGHT:
                    if (!KinkyDungeonGameKey.keyPressed[5]) {
                        KinkyDungeonGameKey.keyPressed[5] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_DOWNLEFT:
                    if (!KinkyDungeonGameKey.keyPressed[6]) {
                        KinkyDungeonGameKey.keyPressed[6] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_DOWNRIGHT:
                    if (!KinkyDungeonGameKey.keyPressed[7]) {
                        KinkyDungeonGameKey.keyPressed[7] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_WAIT:
                    if (!KinkyDungeonGameKey.keyPressed[8]) {
                        KinkyDungeonGameKey.keyPressed[8] = true;
                    }
                    break;
                case KinkyDungeonGameKey.KEY_SKIP:
                    if (!KinkyDungeonGameKey.keyPressed[9]) {
                        KinkyDungeonGameKey.keyPressed[9] = true;
                    }
                    break;
            }
        }
    },
    keyUpEvent: {
        handleEvent: function (event) {
            let code = event.code;
            KinkyDungeonKeybindingCurrentKeyRelease = code;
            if (KinkyDungeonKeybindingCurrentKeyRelease)
                KinkyDungeonGameKeyUp(KDLastKeyTime[KinkyDungeonKeybindingCurrentKeyRelease]);
            if (KDLastKeyTime[code])
                delete KDLastKeyTime[code];
            KinkyDungeonKeybindingCurrentKeyRelease = '';
            switch (code) {
                case KinkyDungeonGameKey.KEY_UP:
                    if (KinkyDungeonGameKey.keyPressed[0])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[0] = false;
                    break;
                case KinkyDungeonGameKey.KEY_DOWN:
                    if (KinkyDungeonGameKey.keyPressed[1])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[1] = false;
                    break;
                case KinkyDungeonGameKey.KEY_LEFT:
                    if (KinkyDungeonGameKey.keyPressed[2])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[2] = false;
                    break;
                case KinkyDungeonGameKey.KEY_RIGHT:
                    if (KinkyDungeonGameKey.keyPressed[3])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[3] = false;
                    break;
                case KinkyDungeonGameKey.KEY_UPLEFT:
                    if (KinkyDungeonGameKey.keyPressed[4])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[4] = false;
                    break;
                case KinkyDungeonGameKey.KEY_UPRIGHT:
                    if (KinkyDungeonGameKey.keyPressed[5])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[5] = false;
                    break;
                case KinkyDungeonGameKey.KEY_DOWNLEFT:
                    if (KinkyDungeonGameKey.keyPressed[6])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[6] = false;
                    break;
                case KinkyDungeonGameKey.KEY_DOWNRIGHT:
                    if (KinkyDungeonGameKey.keyPressed[7])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[7] = false;
                    break;
                case KinkyDungeonGameKey.KEY_WAIT:
                    if (KinkyDungeonGameKey.keyPressed[8])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[8] = false;
                    break;
                case KinkyDungeonGameKey.KEY_SKIP:
                    if (KinkyDungeonGameKey.keyPressed[9])
                        KinkyDungeonLastMoveTimerStart = 0;
                    KinkyDungeonGameKey.keyPressed[9] = false;
                    break;
            }
        }
    },
};
function KinkyDungeonGenerateSaveData() {
    let save = {};
    save.level = MiniGameKinkyDungeonLevel;
    save.checkpoint = MiniGameKinkyDungeonCheckpoint;
    save.rep = KinkyDungeonGoddessRep;
    save.costs = KinkyDungeonShrineCosts;
    save.pcosts = KinkyDungeonPenanceCosts;
    save.dress = KinkyDungeonCurrentDress;
    save.gold = KinkyDungeonGold;
    save.points = KinkyDungeonSpellPoints;
    save.id = KinkyDungeonEnemyID;
    save.choices = KinkyDungeonSpellChoices;
    save.choices2 = KinkyDungeonSpellChoicesToggle;
    save.buffs = KinkyDungeonPlayerBuffs;
    save.lostitems = KinkyDungeonLostItems;
    save.grounditems = KinkyDungeonGroundItems;
    save.rescued = KinkyDungeonRescued;
    save.aid = KinkyDungeonAid;
    save.seed = KinkyDungeonSeed;
    save.statchoice = Array.from(KinkyDungeonStatsChoice);
    save.mapIndex = KinkyDungeonMapIndex;
    save.flags = Array.from(KinkyDungeonFlags);
    save.faction = KinkyDungeonFactionRelations;
    save.perks = KDUnlockedPerks;
    let spells = [];
    let newInv = [];
    for (let inv of KinkyDungeonFullInventory()) {
        let item = Object.assign({}, inv);
        newInv.push(item);
    }
    for (let spell of KinkyDungeonSpells) {
        spells.push(spell.name);
    }
    save.spells = spells;
    save.inventory = newInv;
    save.KDGameData = KDGameData;
    save.KDEventData = KDEventData;
    save.KinkyDungeonEffectTiles = KinkyDungeonEffectTiles;
    save.KinkyDungeonTiles = KinkyDungeonTiles;
    save.KinkyDungeonTilesSkin = KinkyDungeonTilesSkin;
    save.KinkyDungeonTilesMemory = KinkyDungeonTilesMemory;
    save.KinkyDungeonRandomPathablePoints = KinkyDungeonRandomPathablePoints;
    save.KinkyDungeonPlayerEntity = KinkyDungeonPlayerEntity;
    save.KinkyDungeonEntities = KinkyDungeonEntities;
    save.KinkyDungeonBullets = KinkyDungeonBullets;
    save.KinkyDungeonGrid = KinkyDungeonGrid;
    save.KinkyDungeonGridWidth = KinkyDungeonGridWidth;
    save.KinkyDungeonGridHeight = KinkyDungeonGridHeight;
    save.KinkyDungeonFogGrid = KinkyDungeonFogGrid;
    save.KinkyDungeonEndPosition = KinkyDungeonEndPosition;
    save.KinkyDungeonStartPosition = KinkyDungeonStartPosition;
    save.stats = {
        picks: KinkyDungeonLockpicks,
        keys: KinkyDungeonRedKeys,
        bkeys: KinkyDungeonBlueKeys,
        mana: KinkyDungeonStatMana,
        manapool: KinkyDungeonStatManaPool,
        stamina: KinkyDungeonStatStamina,
        willpower: KinkyDungeonStatWill,
        distraction: KinkyDungeonStatDistraction,
        distractionlower: KinkyDungeonStatDistractionLower,
        wep: KinkyDungeonPlayerWeapon,
        npp: KinkyDungeonNewGame,
        diff: KinkyDungeonStatsChoice.get("randomMode"),
    };
    return save;
}
function KinkyDungeonSaveGame(ToString) {
    let save = KinkyDungeonGenerateSaveData();
    let data = KinkyDungeonCompressSave(save);
    if (!ToString) {
        localStorage.setItem('KinkyDungeonSave', data);
    }
    return data;
}
function KinkyDungeonCompressSave(save) {
    return LZString.compressToBase64(JSON.stringify(save));
}
function KinkyDungeonLoadGame(String) {
    let str = String ? LZString.decompressFromBase64(String.trim()) : (localStorage.getItem('KinkyDungeonSave') ? LZString.decompressFromBase64(localStorage.getItem('KinkyDungeonSave')) : "");
    if (str) {
        let saveData = JSON.parse(str);
        if (saveData
            && saveData.spells != undefined
            && saveData.level != undefined
            && saveData.checkpoint != undefined
            && saveData.inventory != undefined
            && saveData.costs != undefined
            && saveData.rep != undefined
            && saveData.dress != undefined) {
            KDPathfindingCacheFails = 0;
            KDPathfindingCacheHits = 0;
            KDPathCache = new Map();
            KDThoughtBubbles = new Map();
            KinkyDungeonEntities = [];
            KDUpdateEnemyCache = true;
            if (saveData.flags && saveData.flags.length)
                KinkyDungeonFlags = new Map(saveData.flags);
            MiniGameKinkyDungeonLevel = saveData.level;
            if (Array.from(Object.keys(KinkyDungeonMapIndex)).includes(saveData.checkpoint))
                MiniGameKinkyDungeonCheckpoint = saveData.checkpoint;
            else
                MiniGameKinkyDungeonCheckpoint = "grv";
            KinkyDungeonShrineCosts = saveData.costs;
            KinkyDungeonGoddessRep = saveData.rep;
            KinkyDungeonCurrentDress = saveData.dress;
            KDGameData.KinkyDungeonSpawnJailers = 0;
            KDGameData.KinkyDungeonSpawnJailersMax = 0;
            if (saveData.seed)
                KDsetSeed(saveData.seed);
            if (saveData.pcosts)
                KinkyDungeonPenanceCosts = saveData.pcosts;
            if (saveData.choices)
                KinkyDungeonSpellChoices = saveData.choices;
            if (saveData.choices2)
                KinkyDungeonSpellChoicesToggle = saveData.choices2;
            if (saveData.buffs)
                KinkyDungeonPlayerBuffs = saveData.buffs;
            if (saveData.gold != undefined)
                KinkyDungeonGold = saveData.gold;
            if (saveData.id != undefined)
                KinkyDungeonEnemyID = saveData.id;
            if (saveData.points != undefined)
                KinkyDungeonSpellPoints = saveData.points;
            if (saveData.lostitems != undefined)
                KinkyDungeonLostItems = saveData.lostitems;
            if (saveData.rescued != undefined)
                KinkyDungeonRescued = saveData.rescued;
            if (saveData.aid != undefined)
                KinkyDungeonAid = saveData.aid;
            if (saveData.grounditems)
                KinkyDungeonGroundItems = saveData.grounditems;
            if (saveData.stats) {
                if (saveData.stats.picks != undefined)
                    KinkyDungeonLockpicks = saveData.stats.picks;
                if (saveData.stats.keys != undefined)
                    KinkyDungeonRedKeys = saveData.stats.keys;
                if (saveData.stats.bkeys != undefined)
                    KinkyDungeonBlueKeys = saveData.stats.bkeys;
                if (saveData.stats.mana != undefined)
                    KinkyDungeonStatMana = saveData.stats.mana;
                if (saveData.stats.manapool != undefined)
                    KinkyDungeonStatManaPool = saveData.stats.manapool;
                if (saveData.stats.stamina != undefined)
                    KinkyDungeonStatStamina = saveData.stats.stamina;
                if (saveData.stats.willpower != undefined)
                    KinkyDungeonStatWill = saveData.stats.willpower;
                if (saveData.stats.distraction != undefined)
                    KinkyDungeonStatDistraction = saveData.stats.distraction;
                if (saveData.stats.distractionlower != undefined)
                    KinkyDungeonStatDistractionLower = saveData.stats.distractionlower;
                if (saveData.stats.wep != undefined)
                    KDSetWeapon(saveData.stats.wep);
                if (saveData.stats.npp != undefined)
                    KinkyDungeonNewGame = saveData.stats.npp;
                KDOrigStamina = KinkyDungeonStatStamina * 10;
                KDOrigWill = KinkyDungeonStatWill * 10;
                KDOrigMana = KinkyDungeonStatMana * 10;
                KDOrigDistraction = KinkyDungeonStatDistraction * 10;
            }
            KDGameData = JSON.parse(JSON.stringify(KDGameDataBase));
            if (saveData.KDGameData != undefined)
                KDGameData = Object.assign({}, saveData.KDGameData);
            KDEventData = JSON.parse(JSON.stringify(KDEventDataBase));
            if (saveData.KDEventData != undefined)
                KDEventData = Object.assign({}, saveData.KDEventData);
            if (saveData.statchoice != undefined)
                KinkyDungeonStatsChoice = new Map(saveData.statchoice);
            if (saveData.faction != undefined)
                KinkyDungeonFactionRelations = saveData.faction;
            KDInitFactions();
            if (typeof KDGameData.TimeSinceLastVibeStart === "number")
                KDGameData.TimeSinceLastVibeStart = {};
            if (typeof KDGameData.TimeSinceLastVibeEnd === "number")
                KDGameData.TimeSinceLastVibeEnd = {};
            if (!KDGameData.AlreadyOpened)
                KDGameData.AlreadyOpened = [];
            if (saveData.perks) {
                KDUnlockedPerks = saveData.perks;
                KDLoadPerks();
            }
            KDUnlockPerk();
            KDInitInventory();
            for (let item of saveData.inventory) {
                if (item.type == Restraint) {
                    let restraint = KinkyDungeonGetRestraintByName(item.name);
                    if (restraint) {
                        KinkyDungeonAddRestraint(restraint, 0, true, item.lock, undefined, undefined, undefined, undefined, item.faction);
                        let createdrestraint = KinkyDungeonGetRestraintItem(restraint.Group);
                        if (createdrestraint)
                            createdrestraint.lock = item.lock;
                        if (createdrestraint)
                            createdrestraint.events = item.events;
                        KinkyDungeonInventoryAdd(item);
                    }
                }
                else {
                    if (item.type != LooseRestraint || KDRestraint(item) != undefined)
                        KinkyDungeonInventoryAdd(item);
                }
            }
            KinkyDungeonSpells = [];
            for (let spell of saveData.spells) {
                let sp = KinkyDungeonFindSpell(spell);
                if (sp)
                    KinkyDungeonSpells.push(sp);
            }
            if (saveData.KinkyDungeonEffectTiles)
                KinkyDungeonEffectTiles = saveData.KinkyDungeonEffectTiles;
            if (saveData.KinkyDungeonTiles)
                KinkyDungeonTiles = saveData.KinkyDungeonTiles;
            if (saveData.KinkyDungeonTilesSkin)
                KinkyDungeonTilesSkin = saveData.KinkyDungeonTilesSkin;
            if (saveData.KinkyDungeonTilesMemory)
                KinkyDungeonTilesMemory = saveData.KinkyDungeonTilesMemory;
            if (saveData.KinkyDungeonRandomPathablePoints)
                KinkyDungeonRandomPathablePoints = saveData.KinkyDungeonRandomPathablePoints;
            if (saveData.KinkyDungeonPlayerEntity)
                KinkyDungeonPlayerEntity = saveData.KinkyDungeonPlayerEntity;
            if (saveData.KinkyDungeonEntities)
                KinkyDungeonEntities = saveData.KinkyDungeonEntities;
            KDUpdateEnemyCache = true;
            if (saveData.KinkyDungeonBullets)
                KinkyDungeonBullets = saveData.KinkyDungeonBullets;
            if (saveData.KinkyDungeonStartPosition)
                KinkyDungeonStartPosition = saveData.KinkyDungeonStartPosition;
            if (saveData.KinkyDungeonEndPosition)
                KinkyDungeonEndPosition = saveData.KinkyDungeonEndPosition;
            if (saveData.KinkyDungeonGrid) {
                KinkyDungeonGrid = saveData.KinkyDungeonGrid;
                KinkyDungeonGridWidth = saveData.KinkyDungeonGridWidth;
                KinkyDungeonGridHeight = saveData.KinkyDungeonGridHeight;
            }
            KinkyDungeonResetFog();
            if (saveData.KinkyDungeonFogGrid)
                KinkyDungeonFogGrid = saveData.KinkyDungeonFogGrid;
            KinkyDungeonSetMaxStats();
            KinkyDungeonCheckClothesLoss = true;
            KDNaked = false;
            KinkyDungeonDressPlayer();
            KDRefresh = true;
            KDUpdateEnemyCache = true;
            if (KDGameData.Journey)
                KDJourney = KDGameData.Journey;
            if (saveData.mapIndex && !saveData.mapIndex.length)
                KinkyDungeonMapIndex = saveData.mapIndex;
            if (String)
                localStorage.setItem('KinkyDungeonSave', String);
            if (saveData.KDGameData && saveData.KDGameData.LastMapSeed)
                KDsetSeed(saveData.KDGameData.LastMapSeed);
            if (!KinkyDungeonMapIndex[KDGameData.MainPath] || !KinkyDungeonMapIndex[KDGameData.ShortcutPath])
                KDInitializeJourney(KDGameData.Journey);
            if (saveData.KinkyDungeonGrid) {
                KDUpdateVision();
            }
            KinkyDungeonFloaters = [];
            KinkyDungeonAdvanceTime(0, true, true);
            return true;
        }
    }
    return false;
}
let KinkyDungeonSeed = (Math.random() * 4294967296).toString();
let KDRandom = sfc32(xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)());
function KDrandomizeSeed(Native) {
    let rand = Native ? KDRandom : () => { return Math.random(); };
    KinkyDungeonSeed = (rand() * 4294967296).toString();
    for (let i = 0; i < 20; i++) {
        let index = rand() * KinkyDungeonSeed.length;
        KinkyDungeonSeed = KinkyDungeonSeed.replaceAt(index, String.fromCharCode(65 + Math.floor(rand() * 50)) + String.fromCharCode(65 + Math.floor(rand() * 50)));
    }
    KDRandom = sfc32(xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)());
    for (let i = 0; i < 1000; i++) {
        KDRandom();
    }
}
function KDsetSeed(string) {
    KinkyDungeonSeed = string;
    KDRandom = sfc32(xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)(), xmur3(KinkyDungeonSeed)());
    for (let i = 0; i < 1000; i++) {
        KDRandom();
    }
}
function xmur3(str) {
    let h = 1779033703 ^ str.length;
    for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = h << 13 | h >>> 19;
    }
    return function () {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        return (h ^= h >>> 16) >>> 0;
    };
}
function sfc32(a, b, c, d) {
    return function () {
        a >>>= 0;
        b >>>= 0;
        c >>>= 0;
        d >>>= 0;
        let t = (a + b) | 0;
        a = b ^ b >>> 9;
        b = c + (c << 3) | 0;
        c = (c << 21 | c >>> 11);
        d = d + 1 | 0;
        t = t + d | 0;
        c = c + t | 0;
        return (t >>> 0) / 4294967296;
    };
}
let kdSoundCache = new Map();
function AudioPlayInstantSoundKD(Path, volume) {
    const vol = KDSfxVolume * (volume != null ? volume : Player.AudioSettings.Volume);
    if (vol > 0) {
        let src = KDModFiles[Path] || Path;
        let audio = kdSoundCache.has(src) ? kdSoundCache.get(src) : new Audio();
        if (!kdSoundCache.has(src)) {
            audio.src = src;
            kdSoundCache.set(src, audio);
        }
        else {
            audio.pause();
            audio.currentTime = 0;
        }
        audio.volume = Math.min(vol, 1);
        audio.play();
    }
}
function hashCode(s) {
    let h = 0;
    for (let i = 0; i < s.length; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
    return h;
}
function TextGetKD(Text) {
    if (TextGet(Text))
        return TextGet(Text);
    else
        return KDLoadingTextKeys[Text] || "Missing text";
}
function KinkyDungeonCheckPlayerRefresh() {
    if (!ArcadeDeviousChallenge || CommonTime() < KinkyDungeonNextRefreshCheck) {
        return;
    }
    KinkyDungeonNextRefreshCheck = CommonTime() + 1000;
    if (!KinkyDungeonPlayerNeedsRefresh) {
        return;
    }
    KinkyDungeonPlayerNeedsRefresh = false;
    if (ServerPlayerIsInChatRoom()) {
        ChatRoomCharacterUpdate(Player);
    }
    else {
        CharacterRefresh(Player);
    }
}
function CJKcheck(text, p = 0, o = "search") {
    if (o == "search") {
        if (p == 1) {
            return text.match(/[a-zA-Z0-9\s\x21-\x2f\x3a-\x40\x5b-\x60\x7B-\x7F]+/g);
        }
        if (p == 2) {
            return text.match(/^[a-zA-Z\s\x21-\x2f\x3a-\x40\x5b-\x60\x7B-\x7F]+$/g);
        }
        if (p == 3) {
            return text.match(/[\uff1b\uff0c\uff1a\u201c\u201d\uff08\uff09\uff1f\uff01\uffe5\u3000-\u303f]+/g);
        }
        else {
            return text.match(/[\u3000-\u9fff\ue000-\uf8ff\uff01-\uffdc\uac00-\ud7af]+/g);
        }
    }
    else if (o == "test") {
        if (p == 3) {
            return (/[\uff1b\uff0c\uff1a\u201c\u201d\uff08\uff09\uff1f\uff01\uffe5\u3000-\u303f]+/g).test(text);
        }
    }
}
let KinkyDungeonGagMumbleChance = 0.02;
let KinkyDungeonGagMumbleChancePerRestraint = 0.0025;
let MiniGameKinkyDungeonCheckpoint = "grv";
let MiniGameKinkyDungeonLevel = -1;
let KinkyDungeonMapIndex = {};
let KinkyDungeonBoringness = [];
let KinkyDungeonVisionGrid = [];
let KinkyDungeonColorGrid = [];
let KinkyDungeonShadowGrid = [];
let KinkyDungeonBrightnessGrid = [];
let KinkyDungeonFogGrid = [];
let KinkyDungeonUpdateLightGrid = true;
let KinkyDungeonGrid = "";
let KinkyDungeonGrid_Last = "";
let KinkyDungeonGridSize = 50;
let KinkyDungeonGridWidth = 31;
let KinkyDungeonGridHeight = 19;
let KinkyDungeonGridSizeDisplay = 72;
let KinkyDungeonGridWidthDisplay = 2000 / KinkyDungeonGridSizeDisplay;
let KinkyDungeonGridHeightDisplay = 1000 / KinkyDungeonGridSizeDisplay;
let KinkyDungeonMoveDirection = KinkyDungeonGetDirection(0, 0);
let KinkyDungeonTextMessagePriority = 0;
let KinkyDungeonTextMessage = "";
let KinkyDungeonTextMessageNoPush = false;
let KinkyDungeonTextMessageTime = 0;
let KinkyDungeonTextMessageColor = "white";
let KinkyDungeonActionMessagePriority = 0;
let KinkyDungeonActionMessage = "";
let KinkyDungeonActionMessageNoPush = false;
let KinkyDungeonActionMessageTime = 0;
let KinkyDungeonActionMessageColor = "white";
let KinkyDungeonSpriteSize = 72;
let KinkyDungeonCanvas = document.createElement("canvas");
let KinkyDungeonContext = null;
let KinkyDungeonCanvasFow = document.createElement("canvas");
let KinkyDungeonContextFow = null;
let KinkyDungeonCanvasPlayer = document.createElement("canvas");
let KinkyDungeonContextPlayer = null;
let KinkyDungeonEntities = [];
let KinkyDungeonTerrain = [];
let KinkyDungeonPOI = [];
let KinkyDungeonMapBrightness = 5;
let KDDefaultAvoidTiles = "gtVN@";
let KinkyDungeonGroundTiles = "023w][?/";
let KinkyDungeonWallTiles = "14";
let KinkyDungeonMovableTilesEnemy = KinkyDungeonGroundTiles + "HB@lSsRrdzTgLNVt5";
let KinkyDungeonMovableTilesSmartEnemy = "D" + KinkyDungeonMovableTilesEnemy;
let KinkyDungeonMovableTiles = "OPCAMG$Y+=-F" + KinkyDungeonMovableTilesSmartEnemy;
let KDRandomDisallowedNeighbors = ",?/RAasSHcCHDdOoPp+FZzgtuVN";
let KDTrappableNeighbors = "DA+-F@";
let KDTrappableNeighborsLikely = "COP=";
let KinkyDungeonTransparentObjects = KinkyDungeonMovableTiles
    .replace("D", "")
    .replace("g", "")
    .replace("Y", "")
    + "OoAaMmCcB@lb+=-FXu";
let KinkyDungeonTransparentMovableObjects = KinkyDungeonMovableTiles
    .replace("Z", "")
    .replace("D", "")
    .replace("g", "");
let KDOpenDoorTiles = ["DoorOpen", "DoorVertContOpen", "DoorVertOpen"];
let KinkyDungeonRandomPathablePoints = {};
let KinkyDungeonTiles = {};
let KinkyDungeonEffectTiles = {};
let KinkyDungeonTilesMemory = {};
let KinkyDungeonTilesSkin = {};
let KinkyDungeonTargetTile = null;
let KinkyDungeonTargetTileLocation = "";
const KinkyDungeonBaseLockChance = 0.1;
const KinkyDungeonScalingLockChance = 0.1;
const KinkyDungeonBlueLockChance = -0.1;
const KinkyDungeonBlueLockChanceScaling = 0.015;
const KinkyDungeonBlueLockChanceScalingMax = 0.4;
const KinkyDungeonGoldLockChance = -0.25;
const KinkyDungeonGoldLockChanceScaling = 0.015;
const KinkyDungeonGoldLockChanceScalingMax = 0.25;
const KinkyDungeonPurpleLockChance = 0;
const KinkyDungeonPurpleLockChanceScaling = 0.02;
const KinkyDungeonPurpleLockChanceScalingMax = 0.6;
let KinkyDungeonCurrentMaxEnemies = 1;
let KinkyDungeonNextDataSendTime = 0;
const KinkyDungeonNextDataSendTimeDelay = 500;
let KinkyDungeonNextDataSendTimeDelayPing = 5000;
let KinkyDungeonNextDataSendStatsTimeDelay = 3000;
let KinkyDungeonNextDataSendStatsTime = 0;
let KinkyDungeonNextDataLastTimeReceived = 0;
let KinkyDungeonNextDataLastTimeReceivedTimeout = 15000;
let KinkyDungeonLastMoveDirection = null;
let KinkyDungeonTargetingSpell = null;
let KinkyDungeonTargetingSpellItem = null;
let KinkyDungeonTargetingSpellWeapon = null;
let KinkyDungeonMaxLevel = 21;
let KinkyDungeonLastMoveTimer = 0;
let KinkyDungeonLastMoveTimerStart = 0;
let KinkyDungeonLastMoveTimerCooldown = 175;
let KinkyDungeonLastMoveTimerCooldownStart = 50;
let KinkyDungeonPatrolPoints = [];
let KinkyDungeonStartPosition = { x: 1, y: 1 };
let KinkyDungeonEndPosition = { x: 1, y: 1 };
let KinkyDungeonShortcutPosition = { x: 1, y: 1 };
let KinkyDungeonJailLeash = 3;
let KinkyDungeonJailLeashX = 3;
let KinkyDungeonSaveInterval = 10;
let KinkyDungeonSFX = [];
function KinkyDungeonEffectTilesSet(location, value) {
    KinkyDungeonEffectTiles[location] = value;
}
function KinkyDungeonEffectTilesGet(location) {
    return KinkyDungeonEffectTiles[location];
}
function KinkyDungeonTilesSet(location, value) {
    KinkyDungeonTiles[location] = value;
}
function KinkyDungeonTilesGet(location) {
    return KinkyDungeonTiles[location];
}
function KinkyDungeonTilesDelete(location) {
    delete KinkyDungeonTiles[location];
}
function KinkyDungeonSkinSet(location, value) {
    KinkyDungeonTilesSkin[location] = value;
}
function KinkyDungeonSkinGet(location) {
    return KinkyDungeonTilesSkin[location];
}
function KinkyDungeonSkinDelete(location) {
    delete KinkyDungeonTilesSkin[location];
}
function KDAlreadyOpened(x, y) {
    if (KDGameData.AlreadyOpened) {
        for (let ao of KDGameData.AlreadyOpened) {
            if (ao.x == x && ao.y == y) {
                return true;
            }
        }
    }
    return false;
}
function KinkyDungeonPlaySound(src, entity) {
    if (KDToggles.Sound && !KinkyDungeonSFX.includes(src)) {
        if (!entity || KinkyDungeonVisionGet(entity.x, entity.y) > 0) {
            AudioPlayInstantSoundKD(src);
            KinkyDungeonSFX.push(src);
        }
    }
}
function KinkyDungeonSetCheckPoint(Checkpoint, AutoSave, suppressCheckPoint) {
    if (Checkpoint != undefined)
        MiniGameKinkyDungeonCheckpoint = Checkpoint;
    else if (Math.floor(MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint) == MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint)
        MiniGameKinkyDungeonCheckpoint = KDDefaultJourney[Math.min(KDDefaultJourney.length - 1, Math.floor((MiniGameKinkyDungeonLevel) / KDLevelsPerCheckpoint))];
}
function KinkyDungeonNewGamePlus() {
    KDInitializeJourney(KDGameData.Journey);
    MiniGameKinkyDungeonLevel = 1;
    KinkyDungeonSetCheckPoint("grv", true);
    KinkyDungeonCreateMap(KinkyDungeonMapParams.grv, 1);
    KinkyDungeonNewGame += 1;
    for (let t of KDResertNGTags) {
        if (KinkyDungeonFlags.has(t))
            KinkyDungeonFlags.delete(t);
    }
}
function KDResetData(Data) {
    if (!Data)
        Data = KDGameDataBase;
    KDGameData = JSON.parse(JSON.stringify(Data));
}
function KDResetEventData(Data) {
    if (!Data)
        Data = KDEventDataBase;
    KDEventData = JSON.parse(JSON.stringify(Data));
}
function KinkyDungeonInitialize(Level, Load) {
    KDInitCurrentPose(true);
    if (!afterLoaded) {
        KDModsAfterLoad();
        KinkyDungeonRefreshRestraintsCache();
        KinkyDungeonRefreshEnemiesCache();
        afterLoaded = true;
    }
    KDGameData.RespawnQueue = [];
    KDInitFactions(true);
    CharacterReleaseTotal(KinkyDungeonPlayer);
    KDResetData();
    KDResetEventData();
    KinkyDungeonRefreshRestraintsCache();
    KinkyDungeonRefreshEnemiesCache();
    KinkyDungeonRefreshOutfitCache();
    KinkyDungeonFlags = new Map();
    KinkyDungeonDressSet();
    if (KinkyDungeonConfigAppearance) {
        localStorage.setItem("kinkydungeonappearance" + KDCurrentOutfit, LZString.compressToBase64(CharacterAppearanceStringify(KinkyDungeonPlayer)));
        KinkyDungeonConfigAppearance = false;
    }
    CharacterAppearanceRestore(KinkyDungeonPlayer, CharacterAppearanceStringify(KinkyDungeonPlayer));
    KinkyDungeonDressPlayer();
    KinkyDungeonDrawState = "Game";
    KinkyDungeonMapIndex = {};
    for (let map of KDDefaultJourney) {
        KinkyDungeonMapIndex[map] = map;
    }
    for (let map of KDDefaultAlt) {
        KinkyDungeonMapIndex[map] = map;
    }
    for (let e of KinkyDungeonEntities) {
        KDClearItems(e);
    }
    KinkyDungeonEntities = [];
    KDUpdateEnemyCache = true;
    KinkyDungeonBullets = [];
    KinkyDungeonGroundItems = [];
    KinkyDungeonTextMessage = "";
    KinkyDungeonActionMessage = "";
    MiniGameKinkyDungeonLevel = Level;
    KinkyDungeonSetCheckPoint();
    KDInitCanvas();
    KinkyDungeonDefaultStats(Load);
}
function KDInitCanvas() {
    KinkyDungeonContextPlayer = KinkyDungeonCanvasPlayer.getContext("2d");
    KinkyDungeonCanvasPlayer.width = KinkyDungeonGridSizeDisplay;
    KinkyDungeonCanvasPlayer.height = KinkyDungeonGridSizeDisplay;
    KinkyDungeonContext = KinkyDungeonCanvas.getContext("2d");
    KinkyDungeonCanvas.height = KinkyDungeonCanvasPlayer.height * KinkyDungeonGridHeightDisplay;
    KinkyDungeonContextFow = KinkyDungeonCanvasFow.getContext("2d");
    KinkyDungeonCanvasFow.width = KinkyDungeonCanvas.width;
    KinkyDungeonCanvasFow.height = KinkyDungeonCanvas.height;
}
function KDCreateBoringness(noBoring) {
    let start = performance.now();
    KinkyDungeonBoringness = [];
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++)
            KinkyDungeonBoringness.push(0);
    }
    if (noBoring)
        return;
    let path = KinkyDungeonFindPath(KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, false, false, true, KinkyDungeonMovableTilesSmartEnemy, false, false, false);
    let pathLength = path ? path.length : 100;
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
            if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(X, Y))) {
                let startLength = KinkyDungeonFindPath(X, Y, KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, false, false, true, KinkyDungeonMovableTilesSmartEnemy, false, false, false);
                if (startLength) {
                    let endLength = KinkyDungeonFindPath(X, Y, KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, false, false, true, KinkyDungeonMovableTilesSmartEnemy, false, false, false);
                    if (endLength) {
                        let delta = Math.abs((startLength.length + endLength.length) - pathLength);
                        KinkyDungeonBoringSet(X, Y, delta);
                    }
                }
            }
        }
    }
    console.log("Time to create Boring" + (performance.now() - start));
}
function KDGetMapSize() {
    if (KinkyDungeonStatsChoice.get("MapLarge"))
        return 1;
    if (KinkyDungeonStatsChoice.get("MapHuge"))
        return 2;
    if (KinkyDungeonStatsChoice.get("MapGigantic"))
        return 3;
    return 0;
}
function KinkyDungeonCreateMap(MapParams, Floor, testPlacement, seed) {
    for (let iterations = 0; iterations < 100; iterations++) {
        KDGameData.ChestsGenerated = [];
        KDPathfindingCacheFails = 0;
        KDPathfindingCacheHits = 0;
        KDPathCache = new Map();
        KDThoughtBubbles = new Map();
        KinkyDungeonSpecialAreas = [];
        KinkyDungeonRescued = {};
        KDGameData.ChampionCurrent = 0;
        KinkyDungeonAid = {};
        KDGameData.KinkyDungeonPenance = false;
        KDRestraintsCache = new Map();
        KDEnemiesCache = new Map();
        KDEnemyCache = new Map();
        KinkyDungeonGrid = "";
        KinkyDungeonTiles = {};
        KinkyDungeonTilesSkin = {};
        KinkyDungeonEffectTiles = {};
        KinkyDungeonTargetTile = null;
        KinkyDungeonTargetTileLocation = "";
        KinkyDungeonGroundItems = [];
        KinkyDungeonBullets = [];
        KDGameData.OfferFatigue = 0;
        KDGameData.KeyringLocations = [];
        KinkyDungeonEndPosition = null;
        KinkyDungeonShortcutPosition = null;
        KinkyDungeonPatrolPoints = [];
        if (KDGameData.JailKey == undefined) {
            KDGameData.JailKey = false;
        }
        KDGameData.JailPoints = [];
        KDGameData.RescueFlag = false;
        KinkyDungeonTotalSleepTurns = 0;
        KinkyDungeonFastMovePath = [];
        KinkyDungeonGenerateShop(MiniGameKinkyDungeonLevel);
        let shrinefilter = KinkyDungeonGetMapShrines(MapParams.shrines);
        let traptypes = MapParams.traps.concat(KinkyDungeonGetGoddessTrapTypes());
        if (iterations == 0) {
            if (!seed) {
                KDGameData.AlreadyOpened = [];
                KDrandomizeSeed(true);
                KDGameData.LastMapSeed = KinkyDungeonSeed;
                if (KDGameData.PrisonerState == "chase") {
                    KDGameData.PrisonerState = "";
                }
            }
            console.log("Map Seed: " + KinkyDungeonSeed);
            KDsetSeed(KinkyDungeonSeed);
        }
        let mapMod = null;
        if (KDGameData.MapMod) {
            mapMod = KDMapMods[KDGameData.MapMod];
        }
        let allies = KinkyDungeonGetAllies();
        KinkyDungeonEntities = allies;
        KDUpdateEnemyCache = true;
        let altRoom = KDGameData.RoomType;
        let altType = altRoom ? KinkyDungeonAltFloor((mapMod && mapMod.altRoom) ? mapMod.altRoom : altRoom) : KinkyDungeonBossFloor(Floor);
        if (altType && altType.nokeys) {
            KDGameData.KeysNeeded = false;
        }
        else
            KDGameData.KeysNeeded = true;
        let height = MapParams.min_height * 2 + 2 * Math.floor(0.5 * KDRandom() * (MapParams.max_height * 2 - MapParams.min_height * 2));
        let width = MapParams.min_width * 2 + 2 * Math.floor(0.5 * KDRandom() * (MapParams.max_width * 2 - MapParams.min_width * 2));
        let mapSizeBonus = KDGetMapSize();
        height = Math.max(2, height + mapSizeBonus);
        width = Math.max(2, width + mapSizeBonus);
        if (KDTileToTest) {
            altType = alts.TestTile;
            width = Math.ceil(KDTileToTest.w / 2) + 7;
            height = Math.ceil(KDTileToTest.h / 2) + 7;
        }
        height += 1 - height % 2;
        width += 1 - width % 2;
        KDStageBossGenerated = true;
        let bossRules = false;
        if (altType) {
            bossRules = altType.bossroom;
            if (bossRules) {
                KinkyDungeonSetFlag("BossDialogue" + altType.name, 0);
                KDStageBossGenerated = false;
            }
            height = altType.height;
            width = altType.width;
        }
        KinkyDungeonSetFlag("BossUnlocked", 0);
        if (altType && !bossRules && altType.nokeys) {
            KinkyDungeonSetFlag("BossUnlocked", -1);
        }
        KinkyDungeonCanvas.width = KinkyDungeonCanvasPlayer.width * KinkyDungeonGridWidthDisplay;
        KinkyDungeonGridHeight = height;
        KinkyDungeonGridWidth = width;
        for (let X = 0; X < height; X++) {
            for (let Y = 0; Y < width; Y++)
                KinkyDungeonGrid = KinkyDungeonGrid + '1';
            KinkyDungeonGrid = KinkyDungeonGrid + '\n';
        }
        KinkyDungeonGrid_Last = "";
        KinkyDungeonUpdateLightGrid = true;
        let startpos = 1 + 2 * Math.floor(KDRandom() * 0.5 * (height - 2));
        if (startpos < 3)
            startpos = 3;
        if (startpos % 2 != 1)
            startpos += 1;
        let openness = MapParams.openness;
        let density = MapParams.density;
        let hallopenness = MapParams.hallopenness ? MapParams.hallopenness : MapParams.openness;
        let chargerchance = MapParams.chargerchance ? MapParams.chargerchance : 0.75;
        let litchargerchance = MapParams.litchargerchance ? MapParams.litchargerchance : 0.1;
        let chargercount = MapParams.chargercount ? MapParams.chargercount : 4;
        let crackchance = MapParams.crackchance;
        let barchance = MapParams.barchance;
        let treasurechance = 1.0;
        let treasurecount = MapParams.chestcount;
        let shrinechance = MapParams.shrinechance;
        let ghostchance = MapParams.ghostchance;
        let manaChance = MapParams.manaChance ? MapParams.manaChance : 0.3;
        let shrinecount = MapParams.shrinecount;
        let rubblechance = MapParams.rubblechance;
        if (KinkyDungeonStatsChoice.get("Pristine"))
            rubblechance = 0;
        let trapChance = MapParams.trapchance;
        let doorlocktrapchance = MapParams.doorlocktrapchance ? MapParams.doorlocktrapchance : MapParams.trapchance;
        let minortrapChance = MapParams.minortrapChance ? MapParams.minortrapChance : trapChance / 3;
        let gasChance = (MapParams.gaschance && KDRandom() < MapParams.gaschance) ? (MapParams.gasdensity ? MapParams.gasdensity : 0) : 0;
        let gasType = MapParams.gastype ? MapParams.gastype : 0;
        let brickchance = MapParams.brickchance;
        let wallRubblechance = MapParams.wallRubblechance ? MapParams.wallRubblechance : 0;
        let barrelChance = MapParams.barrelChance ? MapParams.barrelChance : 0.045;
        let foodChance = MapParams.foodChance ? MapParams.foodChance : 0.2;
        let cageChance = MapParams.cageChance ? MapParams.cageChance : 0.25;
        let wallhookchance = MapParams.wallhookchance ? MapParams.wallhookchance : 0.025;
        let ceilinghookchance = MapParams.ceilinghookchance ? MapParams.ceilinghookchance : 0.03;
        let torchchance = MapParams.torchchance ? MapParams.torchchance : 0.35;
        let torchlitchance = MapParams.torchlitchance ? MapParams.torchlitchance : 0.75;
        let torchchanceboring = MapParams.torchchanceboring ? MapParams.torchchanceboring : 0.85;
        let torchreplace = (altType && altType.torchreplace) ? altType.torchreplace : (MapParams.torchreplace ? MapParams.torchreplace : null);
        let factionList = MapParams.factionList;
        let shrineTypes = [];
        let shrinelist = [];
        let chargerlist = [];
        let chestlist = [];
        let startTime = performance.now();
        let genType = !altType ? "TileMaze" : altType.genType;
        let VisitedRooms = [];
        KinkyDungeonStartPosition = { x: 1, y: startpos * 2 };
        KinkyDungeonMapSet(1, startpos, '0', VisitedRooms);
        KinkyDungeonPOI = [];
        let POI = KinkyDungeonPOI;
        KinkyDungeonPlayerEntity = { MemberNumber: Player.MemberNumber, x: KinkyDungeonStartPosition.x, y: KinkyDungeonStartPosition.y, player: true };
        let traps = [];
        let spawnPoints = [];
        let data = {
            params: MapParams,
            chestlist: chestlist,
            traps: traps,
            shrinelist: shrinelist,
            chargerlist: chargerlist,
            spawnpoints: spawnPoints,
            notraps: altType === null || altType === void 0 ? void 0 : altType.notraps,
        };
        KinkyDungeonCreateMapGenType[genType](POI, VisitedRooms, width, height, openness, density, hallopenness, data);
        if (KDDebug) {
            console.log(`${performance.now() - startTime} ms for maze creation`);
            startTime = performance.now();
        }
        width = KinkyDungeonGridWidth;
        height = KinkyDungeonGridHeight;
        KinkyDungeonResetFog();
        KinkyDungeonPlayerEntity.x = KinkyDungeonStartPosition.x;
        KinkyDungeonPlayerEntity.y = KinkyDungeonStartPosition.y;
        if (!altType || !altType.noWear)
            KinkyDungeonReplaceDoodads(crackchance, barchance, wallRubblechance, wallhookchance, ceilinghookchance, width, height, altType);
        if (KDDebug) {
            console.log(`${performance.now() - startTime} ms for doodad creation`);
            startTime = performance.now();
        }
        KinkyDungeonPlaceStairs(KinkyDungeonGetMainPath(Floor, altType), KinkyDungeonStartPosition.y, width, height, altType && altType.nostairs, altType && altType.nostartstairs);
        if (KDDebug) {
            console.log(`${performance.now() - startTime} ms for stair creation`);
            startTime = performance.now();
        }
        let noBoring = altType === null || altType === void 0 ? void 0 : altType.noboring;
        KDCreateBoringness(noBoring);
        KinkyDungeonPlaceSetPieces(POI, traps, chestlist, shrinelist, chargerlist, spawnPoints, false, width, height);
        if (!((KinkyDungeonNearestJailPoint(1, 1) || (altType && altType.nojail)) && (!altType || KDStageBossGenerated || !bossRules))) {
            console.log("This map failed to generate! Please screenshot and send your save code to Ada on deviantart or discord!");
            continue;
        }
        if (altType && !altType.noFurniture)
            KinkyDungeonPlaceFurniture(barrelChance, cageChance, width, height, altType);
        if (altType && !altType.noFood)
            KinkyDungeonPlaceFood(foodChance, width, height, altType);
        if (KDDebug) {
            console.log(`${performance.now() - startTime} ms for setpiece generation`);
            startTime = performance.now();
        }
        KDCreateBoringness(noBoring);
        if (!testPlacement) {
            if (!altType || altType.shortcut)
                KinkyDungeonPlaceShortcut(KinkyDungeonGetShortcut(Floor, altType), width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for shortcut creation`);
                startTime = performance.now();
            }
            if (!altType || altType.chests)
                KinkyDungeonPlaceChests(chestlist, shrinelist, treasurechance, treasurecount, rubblechance, Floor, width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for chest creation`);
                startTime = performance.now();
            }
            let traps2 = [];
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for door creation`);
                startTime = performance.now();
            }
            for (let t of traps2) {
                traps.push(t);
            }
            if (altType && !altType.notorches)
                KinkyDungeonPlaceTorches(torchchance, torchlitchance, torchchanceboring, width, height, altType, torchreplace);
            KDCreateBoringness(noBoring);
            let orbcount = Math.min(2, Math.max(2 * (MiniGameKinkyDungeonLevel + KinkyDungeonNewGame * KinkyDungeonMaxLevel) - KDGameData.CollectedOrbs, 0));
            if (altType && altType.orbs != undefined)
                orbcount = altType.orbs;
            if (!altType || altType.shrines)
                KinkyDungeonPlaceShrines(chestlist, shrinelist, shrinechance, shrineTypes, shrinecount, shrinefilter, ghostchance, manaChance, orbcount, (altType && altType.noShrineTypes) ? altType.noShrineTypes : [], Floor, width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for shrine creation`);
                startTime = performance.now();
            }
            if (!altType || altType.chargers)
                KinkyDungeonPlaceChargers(chargerlist, chargerchance, litchargerchance, chargercount, Floor, width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for charger creation`);
                startTime = performance.now();
            }
            if (!altType || altType.nobrick)
                KinkyDungeonPlaceBrickwork(brickchance, Floor, width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for brickwork creation`);
                startTime = performance.now();
            }
            if (!altType || !altType.notraps)
                KinkyDungeonPlaceTraps(traps, traptypes, minortrapChance, doorlocktrapchance, Floor, width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for trap creation`);
                startTime = performance.now();
            }
            if (!altType || !altType.nopatrols)
                KinkyDungeonPlacePatrols(4, width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for patrol point creation`);
                startTime = performance.now();
            }
            if ((!altType || !altType.nolore))
                KinkyDungeonPlaceLore(width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for lore creation`);
                startTime = performance.now();
            }
            if ((!altType || altType.heart) && KDGameData.CollectedHearts < (MiniGameKinkyDungeonLevel + KinkyDungeonMaxLevel * KinkyDungeonNewGame)) {
                KinkyDungeonPlaceHeart(width, height, Floor);
            }
            if (!altType || altType.specialtiles)
                KinkyDungeonPlaceSpecialTiles(gasChance, gasType, Floor, width, height);
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for special tile creation`);
                startTime = performance.now();
            }
            KinkyDungeonGenNavMap();
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for navmap creation`);
                startTime = performance.now();
            }
            KinkyDungeonUpdateStats(0);
            let tags = Object.assign([], MapParams.enemyTags);
            if (mapMod && mapMod.tags) {
                for (let t of mapMod.tags) {
                    if (!tags.includes(t))
                        tags.push(t);
                }
            }
            KDGameData.JailFaction = [];
            if (mapMod === null || mapMod === void 0 ? void 0 : mapMod.jailType)
                KDGameData.JailFaction.push(mapMod.jailType);
            else if (altType === null || altType === void 0 ? void 0 : altType.jailType)
                KDGameData.JailFaction.push(altType.jailType);
            KDGameData.GuardFaction = [];
            if (mapMod === null || mapMod === void 0 ? void 0 : mapMod.guardType)
                KDGameData.GuardFaction.push(mapMod.guardType);
            else if (altType === null || altType === void 0 ? void 0 : altType.guardType)
                KDGameData.GuardFaction.push(mapMod.guardType);
            if (!altType || altType.enemies) {
                let bonus = (mapMod && mapMod.bonusTags) ? mapMod.bonusTags : undefined;
                if (altType && altType.bonusTags) {
                    if (!bonus)
                        bonus = altType.bonusTags;
                    else
                        bonus = Object.assign(Object.assign(Object.assign({}, bonus)), altType.bonusTags);
                }
                KinkyDungeonPlaceEnemies(spawnPoints, false, tags, bonus, Floor, width, height, altRoom, factionList);
            }
            if (KDDebug) {
                console.log(`${performance.now() - startTime} ms for enemy creation`);
                startTime = performance.now();
            }
            if (MapParams.worldGenCode)
                MapParams.worldGenCode();
            KinkyDungeonReplaceVert(width, height);
        }
        if (KDGameData.PrisonerState == 'jail' && seed) {
            let nearestJail = KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
            if (nearestJail) {
                KDMovePlayer(nearestJail.x, nearestJail.y, false);
                KDLockNearbyJailDoors(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
            }
        }
        if (KDGameData.KinkyDungeonSpawnJailers > 0)
            KDGameData.KinkyDungeonSpawnJailers -= 1;
        if (KDGameData.KinkyDungeonSpawnJailers > 3 && KDGameData.KinkyDungeonSpawnJailers < KDGameData.KinkyDungeonSpawnJailersMax - 1)
            KDGameData.KinkyDungeonSpawnJailers -= 1;
        KinkyDungeonMapBrightness = MapParams.brightness;
        KinkyDungeonMakeGhostDecision();
        KinkyDungeonLoseJailKeys(false, bossRules);
        if (KDTileToTest || (KinkyDungeonNearestJailPoint(1, 1) || (altType && altType.nojail)) && (!altType || KDStageBossGenerated || !bossRules)
            && KinkyDungeonFindPath(KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, false, false, true, KinkyDungeonMovableTilesSmartEnemy, false, false, false, undefined, false).length > 0)
            iterations = 100000;
        else
            console.log("This map failed to generate! Please screenshot and send your save code to Ada on deviantart or discord!");
        if (iterations == 100000) {
            if (!KinkyDungeonMapIndex[KDGameData.MainPath] || !KinkyDungeonMapIndex[KDGameData.ShortcutPath])
                KDInitializeJourney(KDGameData.Journey);
            KinkyDungeonSendEvent("postMapgen", {});
            KDQuestTick(KDGameData.Quests);
            if (altType && altType.tickFlags)
                KinkyDungeonSendEvent("tickFlags", { delta: 1 });
            KinkyDungeonSendEvent("postQuest", {});
            for (let e of KinkyDungeonGetAllies()) {
                KDMoveEntity(e, KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, false, undefined, undefined, true);
                e.visual_x = KinkyDungeonStartPosition.x;
                e.visual_y = KinkyDungeonStartPosition.y;
            }
            KinkyDungeonAdvanceTime(0);
        }
    }
    KDTileToTest = null;
    KDPathCache = new Map();
    KDPathCacheIgnoreLocks = new Map();
}
let KDStageBossGenerated = false;
function KinkyDungeonGenNavMap() {
    KinkyDungeonRandomPathablePoints = {};
    let accessible = KinkyDungeonGetAccessible(KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y);
    for (let a of Object.entries(accessible)) {
        let X = a[1].x;
        let Y = a[1].y;
        let tags = [];
        if (!KinkyDungeonTilesGet(a[0]) || !KinkyDungeonTilesGet(a[0]).OffLimits)
            KinkyDungeonRandomPathablePoints[a[0]] = { x: X, y: Y, tags: tags };
    }
}
function KinkyDungeonGetAccessible(startX, startY, testX, testY) {
    let tempGrid = {};
    let checkGrid = {};
    checkGrid[(startX + "," + startY)] = { x: startX, y: startY };
    while (Object.entries(checkGrid).length > 0) {
        for (let g of Object.entries(checkGrid)) {
            let X = g[1].x;
            let Y = g[1].y;
            for (let XX = -1; XX <= 1; XX++)
                for (let YY = -1; YY <= 1; YY++) {
                    let testLoc = ((X + XX) + "," + (Y + YY));
                    let locked = (testX != undefined && testY != undefined && X + XX == testX && Y + YY == testY)
                        || (KinkyDungeonTilesGet("" + (X + XX) + "," + (Y + YY)) && KinkyDungeonTilesGet("" + (X + XX) + "," + (Y + YY)).Lock);
                    if (!checkGrid[testLoc] && !tempGrid[testLoc] && X + XX > 0 && X + XX < KinkyDungeonGridWidth - 1 && Y + YY > 0 && Y + YY < KinkyDungeonGridHeight - 1
                        && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(X + XX, Y + YY)) && !locked) {
                        checkGrid[testLoc] = { x: X + XX, y: Y + YY };
                        tempGrid[testLoc] = { x: X + XX, y: Y + YY };
                    }
                }
            delete checkGrid[g[0]];
        }
    }
    return tempGrid;
}
function KinkyDungeonGetAccessibleRoom(startX, startY) {
    let tempGrid = {};
    let checkGrid = {};
    checkGrid[startX + "," + startY] = { x: startX, y: startY };
    while (Object.entries(checkGrid).length > 0) {
        for (let g of Object.entries(checkGrid)) {
            for (let XX = -1; XX <= 1; XX++)
                for (let YY = -1; YY <= 1; YY++) {
                    let test = ((g[1].x + XX) + "," + (g[1].y + YY));
                    let Tiles = KinkyDungeonMovableTiles.replace("D", "").replace("d", "");
                    if (!checkGrid[test] && !tempGrid[test] && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(g[1].x + XX, g[1].y + YY))) {
                        if (Tiles.includes(KinkyDungeonMapGet(g[1].x + XX, g[1].y + YY)))
                            checkGrid[test] = { x: g[1].x + XX, y: g[1].y + YY };
                        tempGrid[test] = true;
                    }
                }
            delete checkGrid[g[0]];
        }
    }
    return Object.keys(tempGrid);
}
function KinkyDungeonIsAccessible(testX, testY) {
    let accessible = KinkyDungeonGetAccessible(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, testX, testY);
    for (let a of Object.entries(accessible)) {
        let X = a[1].x;
        let Y = a[1].y;
        if (KinkyDungeonMapGet(X, Y) == 's')
            return true;
    }
    return false;
}
function KinkyDungeonIsReachable(testX, testY, testLockX, testLockY) {
    let accessible = KinkyDungeonGetAccessible(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, testLockX, testLockY);
    for (let a of Object.entries(accessible)) {
        let X = a[1].x;
        let Y = a[1].y;
        if (X == testX && Y == testY)
            return true;
    }
    return false;
}
function KinkyDungeonGetAllies() {
    let temp = [];
    for (let e of KinkyDungeonEntities) {
        if (e.Enemy && e.Enemy.keepLevel) {
            KDMoveEntity(e, KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, false, undefined, undefined, true);
            e.visual_x = KinkyDungeonStartPosition.x;
            e.visual_y = KinkyDungeonStartPosition.y;
            temp.push(e);
        }
    }
    return temp;
}
function KinkyDungeonPlaceEnemies(spawnPoints, InJail, Tags, BonusTags, Floor, width, height, altRoom, factionList) {
    KinkyDungeonHuntDownPlayer = false;
    KinkyDungeonFirstSpawn = true;
    KinkyDungeonSearchTimer = 0;
    let enemyCount = 8 + Math.floor(Math.sqrt(Floor) + width / 16 + height / 16 + KinkyDungeonDifficulty / 7);
    if (KinkyDungeonStatsChoice.get("Stealthy"))
        enemyCount = Math.round(enemyCount * KDStealthyEnemyCountMult);
    let neutralCount = 0.4 * enemyCount;
    if (KDTileToTest) {
        enemyCount = 1;
    }
    let count = 0;
    let ncount = 0;
    let tries = 0;
    let miniboss = false;
    let boss = false;
    let jailerCount = 0;
    let EnemyNames = [];
    if (altRoom) {
        if (altRoom.enemyMult) {
            enemyCount *= altRoom.enemyMult;
            neutralCount *= altRoom.enemyMult;
        }
    }
    let factions = factionList || Object.keys(KinkyDungeonFactionTag);
    let primaryFaction = factions[Math.floor(KDRandom() * factions.length)];
    let randomFactions = [
        primaryFaction
    ];
    let allyCandidates = [];
    for (let f of factions) {
        if (KDFactionRelation(primaryFaction, f) > 0.2)
            allyCandidates.push(f);
    }
    let enemyCandidates = [];
    for (let f of factions) {
        if (KDFactionRelation(primaryFaction, f) < -0.2)
            enemyCandidates.push(f);
    }
    let factionAllied = allyCandidates.length > 0 ? allyCandidates[Math.floor(KDRandom() * allyCandidates.length)] : "";
    let factionEnemy = enemyCandidates.length > 0 ? enemyCandidates[Math.floor(KDRandom() * enemyCandidates.length)] : "";
    if (factionAllied)
        randomFactions.push(factionAllied);
    if (factionEnemy)
        randomFactions.push(factionEnemy);
    KDGameData.JailFaction.push(primaryFaction);
    KDGameData.GuardFaction.push(primaryFaction);
    if (factionAllied) {
        KDGameData.GuardFaction.push(factionAllied);
    }
    console.log(randomFactions[0] + "," + randomFactions[1] + "," + randomFactions[2]);
    let filterTags = ["boss", "miniboss", "elite", "minor"];
    let filterTagsCluster = ["boss", "miniboss"];
    let spawnBoxes = [
        { requiredTags: ["boss"], tags: [], currentCount: 0, maxCount: 0.025 },
        { requiredTags: ["miniboss"], tags: [], currentCount: 0, maxCount: 0.075 },
        { requiredTags: ["elite"], tags: [], currentCount: 0, maxCount: 0.15 },
        { requiredTags: ["minor"], tags: [], currentCount: 0, maxCount: 0.1 },
    ];
    if (KDGameData.MapMod) {
        let mapMod = KDMapMods[KDGameData.MapMod];
        if (mapMod && mapMod.spawnBoxes) {
            for (let m of mapMod.spawnBoxes) {
                spawnBoxes.unshift(Object.assign({}, m));
            }
        }
    }
    else {
        for (let rf of randomFactions) {
            spawnBoxes.push({ requiredTags: [KinkyDungeonFactionTag[rf]], filterTags: ["boss", "miniboss"], tags: [KinkyDungeonFactionTag[rf]], currentCount: 0, maxCount: 0.15, bias: rf == factionEnemy ? 2 : 1 });
            spawnBoxes.push({ requiredTags: ["miniboss", KinkyDungeonFactionTag[rf]], tags: [KinkyDungeonFactionTag[rf]], currentCount: 0, maxCount: 0.1, bias: rf == factionEnemy ? 2 : 1 });
            spawnBoxes.push({ requiredTags: ["boss", KinkyDungeonFactionTag[rf]], tags: [KinkyDungeonFactionTag[rf]], currentCount: 0, maxCount: 0.01, bias: rf == factionEnemy ? 2 : 1 });
        }
    }
    let currentCluster = null;
    let spawns = [];
    for (let sp of spawnPoints) {
        spawns.push(sp);
    }
    let enemyPoints = [];
    let dd = 3.5;
    for (let X = 1; X < width - 1.01 - dd; X += dd)
        for (let Y = 1; Y < width - 1.01 - dd; Y += dd) {
            enemyPoints.push({ x: Math.round(X + KDRandom() * dd), y: Math.round(Y + KDRandom() * dd) });
        }
    let eep = [];
    while (enemyPoints.length > 0) {
        let index = Math.floor(KDRandom() * enemyPoints.length);
        eep.push(enemyPoints[index]);
        enemyPoints.splice(index, 1);
    }
    enemyPoints.sort((a, b) => {
        let sizea = KinkyDungeonGetAccessibleRoom(a.x, a.y).length;
        let sizeb = KinkyDungeonGetAccessibleRoom(b.x, b.y).length;
        return sizeb - sizea;
    });
    let culledSpawns = false;
    while (((count < enemyCount) || (spawns.length > 0)) && tries < 10000) {
        if (count >= enemyCount && !culledSpawns) {
            spawns = spawns.filter((spawn) => {
                return spawn.force;
            });
            culledSpawns = true;
            if (spawns.length == 0)
                break;
        }
        let pointIndex = Math.floor(KDRandom() * 0.5 * enemyPoints.length);
        let point = enemyPoints[pointIndex];
        let X = point ? point.x : (1 + Math.floor(KDRandom() * (width - 1)));
        let Y = point ? point.y : (1 + Math.floor(KDRandom() * (height - 1)));
        if (point && KinkyDungeonBoringGet(X, Y) > 0 && KDRandom() < 0.5) {
            continue;
        }
        if (point) {
            enemyPoints.splice(pointIndex);
        }
        let required = [];
        let spawnPoint = false;
        let AI = undefined;
        let faction = undefined;
        let tags = [];
        if (currentCluster && !(3 * KDRandom() < currentCluster.count)) {
            required.push(currentCluster.required);
            X = currentCluster.x - 2 + Math.floor(KDRandom() * 5);
            Y = currentCluster.y - 2 + Math.floor(KDRandom() * 5);
            if (!KinkyDungeonCheckPath(currentCluster.x, currentCluster.y, X, Y, false, true)) {
                if (5 * KDRandom() < currentCluster.count)
                    currentCluster = null;
                continue;
            }
        }
        else {
            currentCluster = null;
            if (spawns.length > 0 && KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(spawns[0].x, spawns[0].y))) {
                spawnPoint = true;
                let specific = false;
                if (spawns[0].required) {
                    required = Object.assign([], spawns[0].required);
                    for (let t of required) {
                        if (filterTags.includes(t))
                            filterTags.splice(filterTags.indexOf(t), 1);
                    }
                }
                if (spawns[0].tags) {
                    specific = true;
                    tags = spawns[0].tags;
                    for (let t of tags) {
                        if (filterTags.includes(t))
                            filterTags.splice(filterTags.indexOf(t), 1);
                    }
                }
                if (spawns[0].ftags) {
                    for (let t of spawns[0].ftags) {
                        filterTags.push(t);
                    }
                }
                if (!specific) {
                    tags.push(randomFactions[Math.floor(randomFactions.length * KDRandom())]);
                }
                X = spawns[0].x;
                Y = spawns[0].y;
                AI = spawns[0].AI;
                faction = spawns[0].faction;
                spawns.splice(0, 1);
            }
        }
        let playerDist = 6;
        let PlayerEntity = KinkyDungeonStartPosition;
        let spawnBox_filter = spawnBoxes.filter((bb) => {
            return bb.currentCount < bb.maxCount * enemyCount && (!bb.bias
                || (bb.bias == 1 && X > width * 0.25 && X < width * 0.75 && Y > height * 0.25 && Y < height * 0.75)
                || (bb.bias == 2 && (X < width * 0.25 || X > width * 0.75) && (Y < height * 0.25 || Y > height * 0.75)));
        });
        let box = null;
        if (spawnBox_filter.length > 0) {
            box = spawnBox_filter[Math.floor(KDRandom() * spawnBox_filter.length)];
        }
        if (box && (!spawnPoint || box.addToSpawn) && !currentCluster) {
            if (!spawnPoint) {
                for (let rtag of box.requiredTags) {
                    if (filterTags.includes(rtag))
                        filterTags.splice(filterTags.indexOf(rtag), 1);
                    required.push(rtag);
                }
                if (box.filterTags)
                    for (let ftag of box.filterTags) {
                        if (!filterTags.includes(ftag))
                            filterTags.push(ftag);
                    }
            }
            for (let tag of box.tags) {
                if (filterTags.includes(tag))
                    filterTags.splice(filterTags.indexOf(tag), 1);
                tags.push(tag);
            }
        }
        else {
            box = null;
        }
        if ((spawnPoint && KinkyDungeonNoEnemy(X, Y, true)) || ((!KinkyDungeonTilesGet("" + X + "," + Y) || !KinkyDungeonTilesGet("" + X + "," + Y).OffLimits)
            && Math.sqrt((X - PlayerEntity.x) * (X - PlayerEntity.x) + (Y - PlayerEntity.y) * (Y - PlayerEntity.y)) > playerDist && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(X, Y))
            && KinkyDungeonNoEnemy(X, Y, true) && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits))) {
            if (KDGameData.KinkyDungeonSpawnJailers > 0 && jailerCount < KDGameData.KinkyDungeonSpawnJailersMax)
                tags.push("jailer");
            if (KinkyDungeonMapGet(X, Y) == 'R' || KinkyDungeonMapGet(X, Y) == 'r')
                tags.push("rubble");
            if (KinkyDungeonMapGet(X, Y) == 'D' || KinkyDungeonMapGet(X, Y) == 'd')
                tags.push("door");
            if (KinkyDungeonMapGet(X, Y) == 'g')
                tags.push("grate");
            if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y + 1)) && !KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y - 1)))
                tags.push("passage");
            else if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X + 1, Y)) && !KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X - 1, Y)))
                tags.push("passage");
            else if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X + 1, Y + 1))
                && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X + 1, Y - 1))
                && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X - 1, Y + 1))
                && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X - 1, Y - 1)))
                tags.push("open");
            for (let XX = X - 1; XX <= X + 1; XX += 1)
                for (let YY = Y - 1; YY <= Y + 1; YY += 1)
                    if (!(XX == X && YY == Y)) {
                        if (KinkyDungeonMapGet(XX, YY) == '1' || KinkyDungeonMapGet(XX, YY) == 'X')
                            tags.push("adjWall");
                        if (KinkyDungeonMapGet(XX, YY) == 'D' || KinkyDungeonMapGet(XX, YY) == 'd')
                            tags.push("adjDoor");
                        if (KinkyDungeonMapGet(XX, YY) == 'D')
                            tags.push("adjClosedDoor");
                        if (KinkyDungeonMapGet(XX, YY) == 'c' || KinkyDungeonMapGet(XX, YY) == 'C')
                            tags.push("adjChest");
                        if (KinkyDungeonMapGet(XX, YY) == 'r' || KinkyDungeonMapGet(XX, YY) == 'R')
                            tags.push("adjRubble");
                    }
            if (miniboss)
                tags.push("miniboss");
            if (boss)
                tags.push("boss");
            KinkyDungeonAddTags(tags, Floor);
            for (let t of Tags) {
                tags.push(t);
            }
            if (randomFactions.length > 0 && !box && !currentCluster && !spawnPoint)
                tags.push(randomFactions[Math.floor(randomFactions.length * KDRandom())]);
            if (required.length == 0)
                required = undefined;
            let Enemy = KinkyDungeonGetEnemy(tags, Floor + KinkyDungeonDifficulty / 5, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], KinkyDungeonMapGet(X, Y), required, ncount > neutralCount && (!box || !box.ignoreAllyCount), BonusTags, currentCluster ? filterTagsCluster : filterTags);
            if (box && !Enemy) {
                box.currentCount += 0.05;
            }
            if (Enemy && (!InJail || (Enemy.tags.jailer || Enemy.tags.jail || Enemy.tags.leashing))) {
                let e = { Enemy: Enemy, id: KinkyDungeonGetEnemyID(), x: X, y: Y, hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0, AI: AI, faction: faction };
                KDAddEntity(e);
                KDProcessCustomPatron(Enemy, e);
                let incrementCount = 1;
                KinkyDungeonSetEnemyFlag(e, "NoFollow", -1);
                let shop = KinkyDungeonGetShopForEnemy(e, false);
                if (shop) {
                    KinkyDungeonSetEnemyFlag(e, "Shop", -1);
                    KinkyDungeonSetEnemyFlag(e, shop, -1);
                }
                let loadout = KinkyDungeonGetLoadoutForEnemy(e, false);
                KDSetLoadout(e, loadout);
                if (!spawnPoint && !currentCluster && Enemy.clusterWith) {
                    let clusterChance = 0.5;
                    if (Enemy.tags.boss)
                        clusterChance = 0;
                    else if (Enemy.tags.miniboss)
                        clusterChance = 0;
                    else if (Enemy.tags.elite)
                        clusterChance = 0.15;
                    if (KDRandom() < clusterChance)
                        currentCluster = {
                            x: X,
                            y: Y,
                            required: Enemy.clusterWith,
                            count: 1,
                            AI: Enemy.guardChance && KDRandom() < Enemy.guardChance ? "looseguard" : undefined,
                        };
                }
                else if (currentCluster)
                    currentCluster.count += 1;
                if (!currentCluster && Enemy.guardChance && KDRandom() < Enemy.guardChance) {
                    e.AI = "looseguard";
                }
                else if (currentCluster && currentCluster.AI)
                    e.AI = currentCluster.AI;
                if (Enemy.tags.mimicBlock && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)))
                    KinkyDungeonMapSet(X, Y, '3');
                if (Enemy.tags.minor)
                    incrementCount = 0.2;
                else
                    incrementCount = currentCluster ? 0.5 : 1.0;
                if (Enemy.difficulty)
                    incrementCount += Enemy.difficulty;
                if (Enemy.tags.boss) {
                }
                else if (Enemy.tags.miniboss)
                    miniboss = true;
                if (Enemy.tags.removeDoorSpawn && KinkyDungeonMapGet(X, Y) == "d") {
                    KinkyDungeonMapSet(X, Y, '0');
                    KinkyDungeonTilesDelete(X + "," + Y);
                }
                if (Enemy.tags.jailer)
                    jailerCount += 1;
                if (Enemy.summon) {
                    for (let sum of Enemy.summon) {
                        if (!sum.chance || KDRandom() < sum.chance)
                            KinkyDungeonSummonEnemy(X, Y, sum.enemy, sum.count, sum.range, sum.strict);
                    }
                }
                if (incrementCount)
                    count += spawnPoint ? 0.025 : incrementCount;
                if (!spawnPoint && box)
                    box.currentCount += incrementCount;
                if (KDFactionRelation("Player", KDGetFaction(e)) > -0.5) {
                    ncount += 1;
                }
                EnemyNames.push(Enemy.name + `_${box ? `box-${box.requiredTags}, ${box.tags}` : ""},${currentCluster ? "cluster" : ""},${spawnPoint}`);
            }
        }
        tries += 1;
    }
    console.log(EnemyNames);
    KinkyDungeonCurrentMaxEnemies = KinkyDungeonEntities.length;
}
let KinkyDungeonSpecialAreas = [];
function KinkyDungeonGetClosestSpecialAreaDist(x, y) {
    let minDist = 10000;
    for (let area of KinkyDungeonSpecialAreas) {
        let dist = KDistChebyshev(x - area.x, y - area.y) - area.radius;
        if (dist < minDist)
            minDist = dist;
    }
    return minDist;
}
function KinkyDungeonCreateRectangle(Left, Top, Width, Height, Border, Fill, Padding, OffLimits, NoWander, flexCorner, Jail) {
    let pad = Padding ? Padding : 0;
    let borderType = (Border) ? '1' : '0';
    let fillType = (Fill) ? '1' : '0';
    for (let X = -pad; X < Width + pad; X++)
        for (let Y = -pad; Y < Height + pad; Y++) {
            if (X + Left < KinkyDungeonGridWidth - 1 && Y + Top < KinkyDungeonGridHeight - 1 && X + Left > 0 && Y + Top > 0) {
                let setTo = "";
                let offlimit = true;
                if (X < 0 || Y < 0 || X >= Width || Y >= Height) {
                    setTo = '0';
                    offlimit = false;
                }
                else {
                    if (X == 0 || X == Width - 1 || Y == 0 || Y == Height - 1) {
                        setTo = borderType;
                    }
                    else
                        setTo = fillType;
                }
                if (setTo != "" && KinkyDungeonMapGet(Left + X, Top + Y) != "s") {
                    KinkyDungeonMapSet(Left + X, Top + Y, setTo);
                    delete KinkyDungeonEffectTiles[(Left + X) + "," + (Top + Y)];
                    if (offlimit && (OffLimits || Jail || NoWander)) {
                        KinkyDungeonTilesSet((Left + X) + "," + (Top + Y), { OffLimits: OffLimits, Jail: Jail, NoWander: NoWander });
                    }
                }
            }
        }
    if (flexCorner) {
        if (!KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - pad - 1, Top - pad))
            && !KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - pad, Top - pad - 1))
            && KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - pad - 1, Top - pad - 1))) {
            KinkyDungeonMapSet(Left - pad, Top - pad, 'X');
        }
        if (!KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - pad - 1, Top - 1 + Height + pad))
            && !KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - pad, Top - 1 + Height + pad + 1))
            && KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - pad - 1, Top - 1 + Height + pad + 1))) {
            KinkyDungeonMapSet(Left - pad, Top - 1 + Height + pad, 'X');
        }
        if (!KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - 1 + Height + pad + 1, Top - pad))
            && !KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - 1 + Height + pad, Top - pad - 1))
            && KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - 1 + Height + pad + 1, Top - pad - 1))) {
            KinkyDungeonMapSet(Left - 1 + Height + pad, Top - pad, 'X');
        }
        if (!KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - 1 + Height + pad + 1, Top - 1 + Height + pad))
            && !KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - 1 + Height + pad, Top - 1 + Height + pad + 1))
            && KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(Left - 1 + Height + pad + 1, Top - 1 + Height + pad + 1))) {
            KinkyDungeonMapSet(Left - 1 + Height + pad, Top - 1 + Height + pad, 'X');
        }
    }
}
function KinkyDungeonPlaceStairs(checkpoint, startpos, width, height, noStairs, nostartstairs) {
    if (!nostartstairs)
        KinkyDungeonMapSet(1, startpos, 'S');
    if (!noStairs) {
        let placed = false;
        if (KinkyDungeonEndPosition) {
            placed = true;
            KinkyDungeonMapSet(KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, 's');
        }
        if (!placed)
            for (let X = width - 2; X > 0.75 * width - 2 && !placed; X--)
                for (let L = 100; L > 0; L -= 1) {
                    let Y = 1 + 2 * Math.floor(KDRandom() * 0.5 * (height - 2));
                    if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y))) {
                        let wallcount = 0;
                        for (let XX = X - 1; XX <= X + 1; XX += 1)
                            for (let YY = Y - 1; YY <= Y + 1; YY += 1)
                                if (!(XX == X && YY == Y) && (KinkyDungeonMapGet(XX, YY) == '1' || KinkyDungeonMapGet(XX, YY) == 'X'))
                                    wallcount += 1;
                        if (wallcount == 7
                            || (wallcount >= 5
                                && (KinkyDungeonMapGet(X + 1, Y) == '1' || KinkyDungeonMapGet(X - 1, Y) == '1')
                                && (KinkyDungeonMapGet(X, Y + 1) == '1' || KinkyDungeonMapGet(X, Y - 1) == '1'))) {
                            placed = true;
                            KinkyDungeonMapSet(X, Y, 's');
                            KinkyDungeonEndPosition = { x: X, y: Y };
                            L = 0;
                            break;
                        }
                    }
                }
        if (!placed)
            for (let L = 100; L > 0; L -= 1) {
                let X = width - 2 - Math.floor(KDRandom() * width / (4));
                let Y = 1 + Math.floor(KDRandom() * (height - 2));
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y))) {
                    KinkyDungeonMapSet(X, Y, 's');
                    KinkyDungeonEndPosition = { x: X, y: Y };
                    L = 0;
                }
            }
    }
    KDGameData.MainPath = checkpoint;
    if (KDGameData.MainPath != MiniGameKinkyDungeonCheckpoint)
        KinkyDungeonSkinArea({ skin: KDGameData.MainPath }, KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, 4.99);
    KinkyDungeonSpecialAreas.push({ x: KinkyDungeonEndPosition.x, y: KinkyDungeonEndPosition.y, radius: 2 });
}
function KinkyDungeonSkinArea(skin, X, Y, Radius, NoStairs) {
    for (let xx = Math.floor(X - Radius); xx <= Math.ceil(X + Radius); xx++) {
        for (let yy = Math.floor(Y - Radius); yy <= Math.ceil(Y + Radius); yy++) {
            if (xx >= 0 && xx <= KinkyDungeonGridWidth - 1 && yy >= 0 && yy <= KinkyDungeonGridHeight - 1) {
                if (KDistEuclidean(xx - X, yy - Y) <= Radius + 0.01 && (!NoStairs || KinkyDungeonMapGet(xx, yy) != 's')) {
                    if (!KinkyDungeonTilesSkin[xx + "," + yy]) {
                        KinkyDungeonTilesSkin[xx + "," + yy] = skin;
                    }
                    else {
                    }
                }
            }
        }
    }
}
function KinkyDungeonGetMainPath(level, altType) {
    if (altType && altType.keepMainPath)
        return MiniGameKinkyDungeonCheckpoint;
    let params = KinkyDungeonMapParams[MiniGameKinkyDungeonCheckpoint];
    let paths = params ? params.mainpath : null;
    let path = null;
    let chanceRoll = KDRandom();
    if (paths) {
        for (let p of paths) {
            if (p.Level == MiniGameKinkyDungeonLevel) {
                path = p;
                break;
            }
        }
    }
    if (path) {
        if (chanceRoll < path.chance || !path.chance) {
            return path.checkpoint;
        }
    }
    if ((MiniGameKinkyDungeonLevel) % KDLevelsPerCheckpoint == 0) {
        return KDDefaultJourney[Math.min(KDDefaultJourney.length - 1, Math.floor((MiniGameKinkyDungeonLevel + 1) / KDLevelsPerCheckpoint))];
    }
    return MiniGameKinkyDungeonCheckpoint;
}
function KinkyDungeonGetShortcut(level, altType) {
    let params = KinkyDungeonMapParams[MiniGameKinkyDungeonCheckpoint];
    let paths = params ? params.shortcuts : null;
    let path = null;
    let chanceRoll = KDRandom();
    if (paths) {
        for (let p of paths) {
            if (p.Level == MiniGameKinkyDungeonLevel) {
                path = p;
                break;
            }
        }
    }
    if (path) {
        if (chanceRoll < path.chance || !path.chance) {
            return path.checkpoint;
        }
    }
    return "grv";
}
function KinkyDungeonPlaceShortcut(checkpoint, width, height) {
    if (checkpoint != "grv") {
        let placed = false;
        if (!KinkyDungeonShortcutPosition) {
            for (let L = 1000; L > 0; L -= 1) {
                let X = Math.floor(width * 0.75) - 2 - Math.floor(KDRandom() * width / 2);
                let Y = 1 + 2 * Math.floor(KDRandom() * 0.5 * (height - 2));
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                    let wallcount = 0;
                    for (let XX = X - 1; XX <= X + 1; XX += 1)
                        for (let YY = Y - 1; YY <= Y + 1; YY += 1)
                            if (!(XX == X && YY == Y) && (KinkyDungeonMapGet(XX, YY) == '1' || KinkyDungeonMapGet(XX, YY) == 'X'))
                                wallcount += 1;
                    if (wallcount == 7
                        || (wallcount >= 5
                            && (KinkyDungeonMapGet(X + 1, Y) == '1' || KinkyDungeonMapGet(X - 1, Y) == '1')
                            && (KinkyDungeonMapGet(X, Y + 1) == '1' || KinkyDungeonMapGet(X, Y - 1) == '1'))) {
                        placed = true;
                        KinkyDungeonShortcutPosition = { x: X, y: Y };
                        L = 0;
                        break;
                    }
                }
            }
        }
        else {
            placed = true;
        }
        if (!placed)
            for (let L = 1000; L > 0; L -= 1) {
                let X = Math.floor(width * 0.75) - 2 - Math.floor(KDRandom() * width / 2);
                let Y = 1 + Math.floor(KDRandom() * (height - 2));
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y))
                    && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                    L = 0;
                    placed = true;
                    KinkyDungeonShortcutPosition = { x: X, y: Y };
                }
            }
        if (KinkyDungeonShortcutPosition) {
            KinkyDungeonMapSet(KinkyDungeonShortcutPosition.x, KinkyDungeonShortcutPosition.y, 'H');
        }
        if (placed) {
            KDGameData.ShortcutPath = checkpoint;
            if (KDGameData.ShortcutPath != MiniGameKinkyDungeonCheckpoint)
                KinkyDungeonSkinArea({ skin: KDGameData.ShortcutPath }, KinkyDungeonShortcutPosition.x, KinkyDungeonShortcutPosition.y, 2.99, true);
        }
    }
}
let KDMinBoringness = 0;
function KinkyDungeonPlaceChests(chestlist, shrinelist, treasurechance, treasurecount, rubblechance, Floor, width, height) {
    let shrinePoints = new Map();
    for (let s of shrinelist) {
        shrinePoints.set(s.x + "," + s.y, true);
    }
    let chestPoints = new Map();
    for (let s of chestlist) {
        if (KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(s.x, s.y)))
            chestPoints.set(s.x + "," + s.y, true);
    }
    let extra = KDRandom() < treasurechance;
    treasurecount += (extra ? 1 : 0);
    if (KinkyDungeonStatsChoice.get("Stealthy"))
        treasurecount *= 2;
    if (chestlist.length < treasurecount) {
        for (let X = 1; X < width; X += 1)
            for (let Y = 1; Y < height; Y += 1) {
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && KDistChebyshev(X - KinkyDungeonStartPosition.x, Y - KinkyDungeonStartPosition.y) > 10 &&
                    (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                    let wallcount = 0;
                    let adjcount = 0;
                    let diagadj = 0;
                    for (let XX = X - 1; XX <= X + 1; XX += 1)
                        for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                            if (!(XX == X && YY == Y) && (KinkyDungeonMapGet(XX, YY) == '1' || KinkyDungeonMapGet(XX, YY) == 'X')) {
                                wallcount += 1;
                                if (XX == X || YY == Y)
                                    adjcount += 1;
                            }
                            else if (!(XX == X && YY == Y) && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY))) {
                                if (!(XX == X || YY == Y)) {
                                    if (XX == X + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X + 1, Y)))
                                        diagadj += 1;
                                    else if (XX == X - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X - 1, Y)))
                                        diagadj += 1;
                                    else if (YY == Y + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y + 1)))
                                        diagadj += 1;
                                    else if (YY == Y - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y - 1)))
                                        diagadj += 1;
                                }
                            }
                        }
                    if (wallcount == 7
                        || (wallcount >= 4 && (wallcount - adjcount - diagadj == 0 || (wallcount == 5 && adjcount == 2 && diagadj == 1) || (wallcount > 4 && adjcount == 3 && diagadj == 7 - wallcount))
                            && (KinkyDungeonMapGet(X + 1, Y) == '1' || KinkyDungeonMapGet(X - 1, Y) == '1')
                            && (KinkyDungeonMapGet(X, Y + 1) == '1' || KinkyDungeonMapGet(X, Y - 1) == '1')
                            && (!(KinkyDungeonMapGet(X + 1, Y) == '1' && KinkyDungeonMapGet(X - 1, Y) == '1') || (wallcount > 4 && adjcount == 3 && diagadj == 7 - wallcount))
                            && (!(KinkyDungeonMapGet(X, Y + 1) == '1' && KinkyDungeonMapGet(X, Y - 1) == '1') || (wallcount > 4 && adjcount == 3 && diagadj == 7 - wallcount)))) {
                        if (!chestPoints.get((X + 1) + "," + (Y))
                            && !chestPoints.get((X - 1) + "," + (Y))
                            && !chestPoints.get((X + 1) + "," + (Y + 1))
                            && !chestPoints.get((X + 1) + "," + (Y - 1))
                            && !chestPoints.get((X - 1) + "," + (Y + 1))
                            && !chestPoints.get((X - 1) + "," + (Y - 1))
                            && !chestPoints.get((X) + "," + (Y + 1))
                            && !chestPoints.get((X) + "," + (Y - 1))
                            && !shrinePoints.get((X) + "," + (Y))
                            && !shrinePoints.get((X + 1) + "," + (Y))
                            && !shrinePoints.get((X - 1) + "," + (Y))
                            && !shrinePoints.get((X + 1) + "," + (Y + 1))
                            && !shrinePoints.get((X + 1) + "," + (Y - 1))
                            && !shrinePoints.get((X - 1) + "," + (Y + 1))
                            && !shrinePoints.get((X - 1) + "," + (Y - 1))
                            && !shrinePoints.get((X) + "," + (Y + 1))
                            && !shrinePoints.get((X) + "," + (Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y + 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y + 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y + 1))) {
                            chestlist.push({ x: X, y: Y, boringness: KinkyDungeonBoringGet(X, Y) });
                            chestPoints.set(X + "," + Y, true);
                        }
                    }
                }
            }
    }
    let count = 0;
    let alreadyOpened = 0;
    if (KinkyDungeonNewGame < 1)
        treasurecount -= alreadyOpened;
    let list = [];
    let maxBoringness = Math.max(...KinkyDungeonBoringness);
    while (chestlist.length > 0) {
        let N = Math.floor(KDRandom() * chestlist.length);
        let chest = chestlist[N];
        if (!chest.boringness)
            chest.boringness = KinkyDungeonBoringGet(chest.x, chest.y);
        if (chest.boringness > 0)
            chest.boringness = chest.boringness + (0.05 + 0.1 * KDRandom()) * maxBoringness;
        else
            chest.boringness = chest.boringness + 0.05 * KDRandom() * maxBoringness;
        if (chest.priority) {
            list.unshift(chest);
        }
        else
            list.push(chest);
        chestlist.splice(N, 1);
    }
    list.sort((a, b) => {
        let boringa = a.boringness ? a.boringness : 0;
        let boringb = b.boringness ? b.boringness : 0;
        if (a.priority)
            boringa += 1000;
        if (b.priority)
            boringb += 1000;
        return boringb - boringa;
    });
    let silverchest = 0;
    while (list.length > 0) {
        let N = 0;
        if (count < treasurecount) {
            let chest = list[N];
            KinkyDungeonMapSet(chest.x, chest.y, 'C');
            let lock = KinkyDungeonGenerateLock((extra && count == 0) ? true : false, Floor);
            if (chest.Loot)
                lock = chest.Lock;
            if (silverchest == 0 && !chest.Loot) {
                silverchest += 1;
                KDGameData.ChestsGenerated.push("silver");
                KinkyDungeonTilesSet("" + chest.x + "," + chest.y, {
                    Loot: "silver", Roll: KDRandom(), NoTrap: chest.NoTrap, Faction: chest.Faction,
                    lootTrap: KDGenChestTrap(false, chest.x, chest.y, "silver", lock, chest.noTrap),
                });
            }
            else if (lock) {
                KDGameData.ChestsGenerated.push(lock == "Blue" ? "blue" : (chest.Loot ? chest.Loot : "chest"));
                KinkyDungeonTilesSet("" + chest.x + "," + chest.y, {
                    NoTrap: chest.NoTrap, Type: "Lock", Lock: lock,
                    Loot: lock == "Blue" ? "blue" : (chest.Loot ? chest.Loot : "chest"),
                    Faction: chest.Faction,
                    Roll: KDRandom(),
                    Special: lock == "Blue",
                    RedSpecial: lock == "Red",
                    lootTrap: KDGenChestTrap(false, chest.x, chest.y, (chest.Loot ? chest.Loot : "chest"), lock, chest.noTrap),
                });
            }
            else {
                KDGameData.ChestsGenerated.push(chest.Loot ? chest.Loot : "chest");
                KinkyDungeonTilesSet("" + chest.x + "," + chest.y, { Loot: chest.Loot ? chest.Loot : "chest", Faction: chest.Faction, Roll: KDRandom(),
                    NoTrap: chest.NoTrap,
                    lootTrap: KDGenChestTrap(false, chest.x, chest.y, (chest.Loot ? chest.Loot : "chest"), lock, chest.noTrap), });
            }
            if (KDAlreadyOpened(chest.x, chest.y)) {
                KinkyDungeonMapSet(chest.x, chest.y, 'c');
                KinkyDungeonTilesDelete("" + chest.x + "," + chest.y);
            }
            count += 1;
        }
        list.splice(N, 1);
    }
    for (let tile of Object.entries(KinkyDungeonTiles)) {
        if (tile[1].lootTrap) {
            let x = parseInt(tile[0].split(',')[0]);
            let y = parseInt(tile[0].split(',')[1]);
            let spawned = 0;
            let mult = tile[1].lootTrap.mult;
            let trap = tile[1].lootTrap.trap;
            let maxspawn = 1 + Math.round(Math.min(2 + KDRandom() * 2, KinkyDungeonDifficulty / 25) + Math.min(2 + KDRandom() * 2, 0.5 * MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint));
            if (mult)
                maxspawn *= mult;
            let requireTags = trap ? [trap] : undefined;
            let tags = ["trap", trap];
            KinkyDungeonAddTags(tags, MiniGameKinkyDungeonLevel);
            for (let i = 0; i < 30; i++) {
                if (spawned < maxspawn) {
                    let Enemy = KinkyDungeonGetEnemy(tags, MiniGameKinkyDungeonLevel + KinkyDungeonDifficulty / 5, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', requireTags, true);
                    if (Enemy) {
                        let point = KinkyDungeonGetNearbyPoint(x, y, true, undefined, undefined, false, (xx, yy) => {
                            return !KDEffectTileTags(xx, yy).rune;
                        });
                        if (point) {
                            if (!KinkyDungeonTilesGet(point.x + ',' + point.y))
                                KinkyDungeonTilesSet(point.x + ',' + point.y, {});
                            KinkyDungeonTilesGet(point.x + ',' + point.y).lootTrapEnemy = Enemy.name;
                            KDCreateEffectTile(point.x, point.y, {
                                name: "Runes",
                                duration: 9999,
                            }, 0);
                            if (Enemy.tags.minor)
                                spawned += 0.5;
                            else if (Enemy.tags.elite)
                                spawned += 1.5;
                            else if (Enemy.tags.miniboss)
                                spawned += 2;
                            else if (Enemy.tags.boss)
                                spawned += 4;
                            else
                                spawned += 1;
                            if (Enemy.summonTags) {
                                for (let t of Enemy.summonTags) {
                                    if (!tags.includes(t))
                                        tags.push(t);
                                }
                            }
                            if (Enemy.summonTagsMulti) {
                                for (let t of Enemy.summonTagsMulti) {
                                    tags.push(t);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
function KinkyDungeonPlaceLore(width, height) {
    let loreList = [];
    for (let X = 1; X < width; X += 1)
        for (let Y = 1; Y < height; Y += 1)
            if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits) && KDRandom() < 0.6)
                loreList.push({ x: X, y: Y });
    let count = 0;
    let maxcount = 2;
    while (loreList.length > 0) {
        let N = Math.floor(KDRandom() * loreList.length);
        KinkyDungeonGroundItems.push({ x: loreList[N].x, y: loreList[N].y, name: "Lore" });
        count += 1;
        if (count >= maxcount)
            return count;
    }
    return count;
}
function KinkyDungeonPlaceHeart(width, height, Floor) {
    let heartList = [];
    for (let X = 1; X < width; X += 1)
        for (let Y = 1; Y < height; Y += 1)
            if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y))
                && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)
                && KDistChebyshev(X - KinkyDungeonStartPosition.x, Y - KinkyDungeonStartPosition.y) > 8)
                heartList.push({ x: X, y: Y });
    while (heartList.length > 0) {
        let N = Math.floor(KDRandom() * heartList.length);
        if (!KDGameData.HeartTaken) {
            KinkyDungeonGroundItems.push({ x: heartList[N].x, y: heartList[N].y, name: "Heart" });
        }
        return true;
    }
}
function KinkyDungeonPlaceShrines(chestlist, shrinelist, shrinechance, shrineTypes, shrinecount, shrinefilter, ghostchance, manaChance, orbcount, filterTypes, Floor, width, height) {
    KinkyDungeonCommercePlaced = 0;
    let chestPoints = new Map();
    for (let s of chestlist) {
        chestPoints.set(s.x + "," + s.y, true);
    }
    let shrinePoints = new Map();
    for (let s of shrinelist) {
        if (KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(s.x, s.y)))
            shrinePoints.set(s.x + "," + s.y, true);
    }
    let maxcount = shrinecount + orbcount;
    let tablets = {
        "Determination": 0,
    };
    let tabletsAmount = {
        "Determination": 3,
    };
    for (let goddess of Object.keys(KinkyDungeonShrineBaseCosts)) {
        tablets[goddess] = 0;
        tabletsAmount[goddess] = Math.max(0, KinkyDungeonGoddessRep[goddess] / 5);
        maxcount += Math.floor(Math.max(0, KinkyDungeonGoddessRep[goddess] / 5));
    }
    if (shrinelist <= maxcount)
        for (let X = 1; X < width; X += 1)
            for (let Y = 1; Y < height; Y += 1)
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && Math.max(Math.abs(X - KinkyDungeonStartPosition.x), Math.abs(Y - KinkyDungeonStartPosition.y)) > KinkyDungeonJailLeash
                    && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                    let wallcount = 0;
                    let adjcount = 0;
                    let diagadj = 0;
                    for (let XX = X - 1; XX <= X + 1; XX += 1)
                        for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                            if (!(XX == X && YY == Y) && (KinkyDungeonMapGet(XX, YY) == '1' || KinkyDungeonMapGet(XX, YY) == 'X')) {
                                wallcount += 1;
                                if (XX == X || YY == Y)
                                    adjcount += 1;
                            }
                            else if (!(XX == X && YY == Y) && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY))) {
                                if (!(XX == X || YY == Y)) {
                                    if (XX == X + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X + 1, Y)))
                                        diagadj += 1;
                                    else if (XX == X - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X - 1, Y)))
                                        diagadj += 1;
                                    else if (YY == Y + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y + 1)))
                                        diagadj += 1;
                                    else if (YY == Y - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y - 1)))
                                        diagadj += 1;
                                }
                            }
                        }
                    if (wallcount == 7
                        || (wallcount >= 4 && (wallcount - adjcount - diagadj == 0 || (wallcount == 5 && adjcount == 2 && diagadj == 1) || (wallcount == 6 && adjcount == 3 && diagadj == 1))
                            && (KinkyDungeonMapGet(X + 1, Y) == '1' || KinkyDungeonMapGet(X - 1, Y) == '1')
                            && (KinkyDungeonMapGet(X, Y + 1) == '1' || KinkyDungeonMapGet(X, Y - 1) == '1')
                            && (!(KinkyDungeonMapGet(X + 1, Y) == '1' && KinkyDungeonMapGet(X - 1, Y) == '1') || (wallcount == 6 && adjcount == 3 && diagadj == 1))
                            && (!(KinkyDungeonMapGet(X, Y + 1) == '1' && KinkyDungeonMapGet(X, Y - 1) == '1') || (wallcount == 6 && adjcount == 3 && diagadj == 1)))) {
                        if (!shrinePoints.get((X + 1) + "," + (Y))
                            && !shrinePoints.get((X - 1) + "," + (Y))
                            && !shrinePoints.get((X + 1) + "," + (Y + 1))
                            && !shrinePoints.get((X + 1) + "," + (Y - 1))
                            && !shrinePoints.get((X - 1) + "," + (Y + 1))
                            && !shrinePoints.get((X - 1) + "," + (Y - 1))
                            && !shrinePoints.get((X) + "," + (Y + 1))
                            && !shrinePoints.get((X) + "," + (Y - 1))
                            && !chestPoints.get((X + 1) + "," + (Y))
                            && !chestPoints.get((X - 1) + "," + (Y))
                            && !chestPoints.get((X + 1) + "," + (Y + 1))
                            && !chestPoints.get((X + 1) + "," + (Y - 1))
                            && !chestPoints.get((X - 1) + "," + (Y + 1))
                            && !chestPoints.get((X - 1) + "," + (Y - 1))
                            && !chestPoints.get((X) + "," + (Y + 1))
                            && !chestPoints.get((X) + "," + (Y - 1))
                            && !chestPoints.get((X) + "," + (Y))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y + 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y + 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y + 1))) {
                            shrinelist.push({ x: X, y: Y, boringness: KinkyDungeonBoringGet(X, Y) });
                            shrinePoints.set(X + "," + Y, true);
                        }
                    }
                }
    let count = 0;
    let orbs = 0;
    let list = [];
    let maxBoringness = Math.max(...KinkyDungeonBoringness);
    while (shrinelist.length > 0) {
        let N = Math.floor(KDRandom() * shrinelist.length);
        let chest = shrinelist[N];
        if (!chest.boringness)
            chest.boringness = KinkyDungeonBoringGet(chest.x, chest.y);
        if (chest.boringness > 0)
            chest.boringness = chest.boringness + (0.05 + 0.1 * KDRandom()) * maxBoringness;
        else
            chest.boringness = chest.boringness + 0.05 * KDRandom() * maxBoringness;
        if (chest.priority) {
            list.unshift(chest);
        }
        else
            list.push(chest);
        shrinelist.splice(N, 1);
    }
    list.sort((a, b) => {
        let boringa = a.boringness ? a.boringness : 0;
        let boringb = b.boringness ? b.boringness : 0;
        if (a.priority)
            boringa += 1000;
        if (b.priority)
            boringb += 1000;
        return boringb - boringa;
    });
    while (list.length > 0) {
        let N = 0;
        if (count <= shrinecount) {
            let shrine = list[N];
            if (count == shrinecount && KDRandom() > shrinechance)
                KinkyDungeonMapSet(shrine.x, shrine.y, 'a');
            else {
                let playerTypes = KinkyDungeonRestraintTypes(shrinefilter);
                let stype = shrineTypes.length < orbcount ? { type: "Orb" }
                    : (shrineTypes.length == orbcount && playerTypes.length > 0 ?
                        { type: playerTypes[Math.floor(KDRandom() * playerTypes.length)] }
                        : KinkyDungeonGenerateShrine(Floor, filterTypes, manaChance));
                let type = stype.type;
                let tile = 'A';
                if (type != "Orb" && shrineTypes.includes(type) && (KDRandom() < 0.5 || type == "Commerce"))
                    type = "";
                if (type == "Orb") {
                    if (orbs < orbcount) {
                        tile = 'O';
                        orbs += 1;
                    }
                    else
                        tile = 'o';
                    if (KDAlreadyOpened(shrine.x, shrine.y)) {
                        tile = 'o';
                    }
                    shrineTypes.push("Orb");
                }
                else if (type) {
                    if (KDAlreadyOpened(shrine.x, shrine.y)) {
                        tile = 'a';
                    }
                    else {
                        KinkyDungeonTilesSet("" + shrine.x + "," + shrine.y, { Type: "Shrine", Name: type, drunk: stype.drunk });
                    }
                    shrineTypes.push(type);
                }
                else if (!shrineTypes.includes("Ghost") || KDRandom() < 0.5) {
                    shrineTypes.push("Ghost");
                    tile = 'G';
                    KinkyDungeonTilesSet("" + shrine.x + "," + shrine.y, { Type: "Ghost" });
                }
                else
                    tile = 'a';
                KinkyDungeonMapSet(shrine.x, shrine.y, tile);
            }
            count += 1;
        }
        else
            for (let goddess of Object.keys(tablets)) {
                if (tablets[goddess] < tabletsAmount[goddess]) {
                    let shrine = list[N];
                    KinkyDungeonTilesSet("" + shrine.x + "," + shrine.y, { Type: "Tablet", Name: goddess, Light: 3, lightColor: 0x8888ff });
                    KinkyDungeonMapSet(shrine.x, shrine.y, 'M');
                    tablets[goddess] += 1;
                }
            }
        list.splice(N, 1);
    }
}
function KinkyDungeonPlaceChargers(chargerlist, chargerchance, litchargerchance, chargercount, Floor, width, height) {
    let chargerPoints = new Map();
    for (let s of chargerlist) {
        if (KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(s.x, s.y)))
            chargerPoints.set(s.x + "," + s.y, true);
    }
    if (chargerlist.length < chargercount)
        for (let X = 1; X < width; X += 1)
            for (let Y = 1; Y < height; Y += 1)
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && Math.max(Math.abs(X - KinkyDungeonStartPosition.x), Math.abs(Y - KinkyDungeonStartPosition.y)) > KinkyDungeonJailLeash
                    && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                    let wallcount = 0;
                    let adjcount = 0;
                    let diagadj = 0;
                    for (let XX = X - 1; XX <= X + 1; XX += 1)
                        for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                            if (!(XX == X && YY == Y) && (KinkyDungeonMapGet(XX, YY) == '1' || KinkyDungeonMapGet(XX, YY) == 'X')) {
                                wallcount += 1;
                                if (XX == X || YY == Y)
                                    adjcount += 1;
                            }
                            else if (!(XX == X && YY == Y) && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY))) {
                                if (!(XX == X || YY == Y)) {
                                    if (XX == X + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X + 1, Y)))
                                        diagadj += 1;
                                    else if (XX == X - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X - 1, Y)))
                                        diagadj += 1;
                                    else if (YY == Y + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y + 1)))
                                        diagadj += 1;
                                    else if (YY == Y - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y - 1)))
                                        diagadj += 1;
                                }
                            }
                        }
                    if (wallcount == 7 || wallcount == 0
                        || (wallcount >= 4 && (wallcount - adjcount - diagadj == 0 || (wallcount == 5 && adjcount == 2 && diagadj == 1) || (wallcount == 6 && adjcount == 3 && diagadj == 1))
                            && (KinkyDungeonMapGet(X + 1, Y) == '1' || KinkyDungeonMapGet(X - 1, Y) == '1')
                            && (KinkyDungeonMapGet(X, Y + 1) == '1' || KinkyDungeonMapGet(X, Y - 1) == '1')
                            && (!(KinkyDungeonMapGet(X + 1, Y) == '1' && KinkyDungeonMapGet(X - 1, Y) == '1') || (wallcount == 6 && adjcount == 3 && diagadj == 1))
                            && (!(KinkyDungeonMapGet(X, Y + 1) == '1' && KinkyDungeonMapGet(X, Y - 1) == '1') || (wallcount == 6 && adjcount == 3 && diagadj == 1)))) {
                        if (!chargerPoints.get((X + 1) + "," + (Y))
                            && !chargerPoints.get((X - 1) + "," + (Y))
                            && !chargerPoints.get((X + 1) + "," + (Y + 1))
                            && !chargerPoints.get((X + 1) + "," + (Y - 1))
                            && !chargerPoints.get((X - 1) + "," + (Y + 1))
                            && !chargerPoints.get((X - 1) + "," + (Y - 1))
                            && !chargerPoints.get((X) + "," + (Y + 1))
                            && !chargerPoints.get((X) + "," + (Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y - 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y + 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y + 1))
                            && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y + 1))) {
                            chargerlist.push({ x: X, y: Y });
                            chargerPoints.set(X + "," + Y, true);
                        }
                    }
                }
    let count = 0;
    let list = [];
    while (chargerlist.length > 0) {
        let N = Math.floor(KDRandom() * chargerlist.length);
        let chest = chargerlist[N];
        if (chest.priority) {
            list.unshift(chest);
        }
        else
            list.push(chest);
        chargerlist.splice(N, 1);
    }
    while (list.length > 0) {
        let N = 0;
        if (count <= chargercount) {
            let charger = list[N];
            let tile = KDRandom() > chargerchance ? '-' : (KDRandom() < litchargerchance ? '=' : '+');
            if (tile != '-') {
                KinkyDungeonTilesSet("" + charger.x + "," + charger.y, { Type: "Charger", NoRemove: tile == '=', lightColor: KDChargerColor, Light: (tile == '=' ? KDChargerLight : undefined) });
            }
            KinkyDungeonMapSet(charger.x, charger.y, tile);
            count += (tile == '-' ? 0.4 : 1.0);
        }
        list.splice(N, 1);
    }
}
let KinkyDungeonCommercePlaced = 0;
function KinkyDungeonGenerateShrine(Floor, filterTypes, manaChance) {
    let Params = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]];
    let drunk = !(KDRandom() < manaChance);
    if (Params.shrines) {
        let shrineWeightTotal = 0;
        let shrineWeights = [];
        for (let shrine of Params.shrines) {
            shrineWeights.push({ shrine: shrine, weight: shrineWeightTotal });
            if (!filterTypes || !filterTypes.includes(shrine.Type)) {
                shrineWeightTotal += shrine.Weight;
                if (shrine.Type == "Commerce" && KinkyDungeonStatsChoice.has("Supermarket")) {
                    shrineWeightTotal += 15;
                }
            }
        }
        let selection = KDRandom() * shrineWeightTotal;
        for (let L = shrineWeights.length - 1; L >= 0; L--) {
            if (selection > shrineWeights[L].weight) {
                return { type: shrineWeights[L].shrine.Type, drunk: drunk };
            }
        }
    }
    return { type: "" };
}
function KinkyDungeonPlaceSpecialTiles(gaschance, gasType, Floor, width, height) {
    for (let X = 1; X < width; X += 1)
        for (let Y = 1; Y < height; Y += 1)
            if (KinkyDungeonMapGet(X, Y) == '0') {
                let chance = 0;
                for (let XX = X - 1; XX <= X + 1; XX += 1)
                    for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                        if (!(XX == X && YY == Y) && !KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(XX, YY)))
                            chance += gaschance;
                    }
                if (KDRandom() < chance)
                    KinkyDungeonMapSet(X, Y, gasType);
            }
}
function KinkyDungeonPlaceBrickwork(brickchance, Floor, width, height) {
    for (let X = 1; X < width; X += 1)
        for (let Y = 1; Y < height; Y += 1)
            if (KinkyDungeonMapGet(X, Y) == '0') {
                let chance = brickchance;
                for (let XX = X - 1; XX <= X + 1; XX += 1)
                    for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                        if (!(XX == X && YY == Y) && !KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(XX, YY)))
                            chance += 0.01;
                        if (KinkyDungeonMapGet(XX, YY) == 'A')
                            chance += 0.5;
                        else if (KinkyDungeonMapGet(XX, YY) == 'a')
                            chance += 0.25;
                    }
                if (KDRandom() < chance)
                    KinkyDungeonMapSet(X, Y, '2');
            }
}
function KinkyDungeonPlaceTraps(traps, traptypes, trapchance, doorlocktrapchance, Floor, width, height) {
    for (let X = 1; X < width - 1; X += 1)
        for (let Y = 1; Y < height - 1; Y += 1) {
            let hosttile = KinkyDungeonMapGet(X, Y);
            let chance = KDTrappableNeighbors.includes(hosttile) ? trapchance * trapchance : (KDTrappableNeighborsLikely.includes(hosttile) ? trapchance : 0);
            if (chance > 0) {
                for (let XX = X - 1; XX <= X + 1; XX += 1)
                    for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                        let tile = KinkyDungeonMapGet(XX, YY);
                        if (KinkyDungeonGroundTiles.includes(tile)) {
                            if (KDRandom() < chance) {
                                traps.push({ x: XX, y: YY });
                            }
                        }
                    }
            }
            if (hosttile == 'L' && KinkyDungeonStatsChoice.has("Nowhere") && KDRandom() < 0.25) {
                let tile = KinkyDungeonTilesGet(X + "," + Y) ? KinkyDungeonTilesGet(X + "," + Y) : {};
                KinkyDungeonTilesSet(X + "," + Y, Object.assign(tile, {
                    Type: "Trap",
                    Trap: tile.Furniture ? tile.Furniture + "Trap" : "BarrelTrap",
                }));
            }
        }
    for (let trap of traps) {
        if (KinkyDungeonMapGet(trap.x, trap.y) != 'T') {
            if ((KinkyDungeonMapGet(trap.x, trap.y) == 'D' || KinkyDungeonMapGet(trap.x, trap.y) == 'd') && KDRandom() < doorlocktrapchance) {
                if (KinkyDungeonTilesGet(trap.x + "," + trap.y)) {
                    KinkyDungeonTilesGet(trap.x + "," + trap.y).StepOffTrap = "DoorLock";
                    KinkyDungeonTilesGet(trap.x + "," + trap.y).Lock = undefined;
                    for (let item of KinkyDungeonGroundItems) {
                        if (item.x == trap.x && item.y == trap.y && item.name == "Gold") {
                            KinkyDungeonGroundItems.splice(KinkyDungeonGroundItems.indexOf(item), 1);
                        }
                    }
                }
            }
            else {
                KinkyDungeonMapSet(trap.x, trap.y, 'T');
                let t = KinkyDungeonGetTrap(traptypes, Floor, []);
                let tile = KinkyDungeonTilesGet(trap.x + "," + trap.y);
                KinkyDungeonTilesSet(trap.x + "," + trap.y, {
                    Type: "Trap",
                    Trap: t.Name,
                    Restraint: t.Restraint,
                    Enemy: t.Enemy,
                    Spell: t.Spell,
                    extraTag: t.extraTag,
                    Power: t.Power,
                    OffLimits: tile === null || tile === void 0 ? void 0 : tile.OffLimits,
                });
                if (KDRandom() < 0.05) {
                    let dropped = { x: trap.x, y: trap.y, name: "Gold", amount: 1 };
                    KinkyDungeonGroundItems.push(dropped);
                }
                let spell = t.Spell ? KinkyDungeonFindSpell(t.Spell, true) : "";
                if (spell && !spell.nonmagical) {
                    KDCreateEffectTile(trap.x, trap.y, {
                        name: "RunesTrap",
                        duration: 9999,
                    }, 0);
                }
            }
        }
    }
}
function KinkyDungeonPlacePatrols(Count, width, height) {
    for (let i = 1; i <= Count; i++) {
        if (KinkyDungeonPatrolPoints.length < Count)
            for (let L = 1000; L > 0; L -= 1) {
                let X = Math.floor(i * width / (Count + 1)) + Math.floor(KDRandom() * width / (Count + 1));
                let Y = Math.floor(KDRandom() * height);
                if (!KinkyDungeonPointInCell(X, Y) && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                    KinkyDungeonPatrolPoints.push({ x: X, y: Y });
                    break;
                }
            }
    }
}
function KDGetEffLevel() {
    let effLevel = MiniGameKinkyDungeonLevel + Math.round(KinkyDungeonDifficulty / 5);
    if (KinkyDungeonNewGame)
        effLevel += KinkyDungeonMaxLevel;
    return effLevel;
}
function KDRandomizeRedLock() {
    let level = KDGetEffLevel();
    if (KDRandom() < -0.1 + Math.min(0.5, level * 0.03))
        return "Red_Hi";
    if (KDRandom() < 0.25 + Math.min(0.55, level * 0.03))
        return "Red_Med";
    return "Red";
}
function KinkyDungeonGenerateLock(Guaranteed, Floor, AllowGold, Type) {
    let level = (Floor) ? Floor : MiniGameKinkyDungeonLevel;
    let chance = (level == 0) ? 0 : KinkyDungeonBaseLockChance;
    chance += KinkyDungeonScalingLockChance * level / KDLevelsPerCheckpoint;
    if (Guaranteed)
        chance = 1.0;
    let lock = undefined;
    if (KDRandom() < chance) {
        let locktype = KDRandom();
        let locktype2 = KDRandom();
        let modifiers = "";
        let bmax = KinkyDungeonBlueLockChanceScalingMax + Math.min(0.25, KinkyDungeonDifficulty * 0.002);
        let pmax = KinkyDungeonPurpleLockChanceScalingMax + Math.min(0.8, KinkyDungeonDifficulty * 0.004);
        let BlueChance = Math.min(KinkyDungeonBlueLockChance + (KinkyDungeonStatsChoice.get("HighSecurity") ? 1.5 : 1.0) * level * KinkyDungeonBlueLockChanceScaling, (KinkyDungeonStatsChoice.get("HighSecurity") ? 1.6 : 1.0) * bmax);
        let PurpleChance = Math.min(KinkyDungeonPurpleLockChance + (KinkyDungeonStatsChoice.get("HighSecurity") ? 1.5 : 1.0) * level * KinkyDungeonPurpleLockChanceScaling, (KinkyDungeonStatsChoice.get("HighSecurity") ? 1.6 : 1.0) * pmax);
        if (KinkyDungeonStatsChoice.get("HighSecurity")) {
            BlueChance *= 1.5;
            BlueChance += 0.05;
            PurpleChance *= 1.5;
            PurpleChance += 0.05;
        }
        if (locktype2 < PurpleChance && locktype2 * PurpleChance > locktype * BlueChance) {
            lock = "Purple" + modifiers;
        }
        else if (locktype < BlueChance) {
            let max = KinkyDungeonGoldLockChanceScalingMax + Math.min(0.4, KinkyDungeonDifficulty * 0.001);
            let GoldChance = Math.min(KinkyDungeonGoldLockChance + (KinkyDungeonStatsChoice.get("HighSecurity") ? 1.6 : 1.0) * level * KinkyDungeonGoldLockChanceScaling, (KinkyDungeonStatsChoice.get("HighSecurity") ? 1.9 : 1.0) * max);
            if (AllowGold && KDRandom() < GoldChance)
                lock = "Gold" + modifiers;
            else
                lock = "Blue" + modifiers;
        }
        else {
            lock = KDRandomizeRedLock() + modifiers;
        }
    }
    if (Type == "Door") {
        if (lock.includes("Blue") || lock.includes("Gold"))
            lock = KDRandomizeRedLock();
    }
    return lock;
}
function KinkyDungeonPlaceDoors(doorchance, nodoorchance, doorlockchance, trapChance, grateChance, Floor, width, height) {
    let doorlist = [];
    let doorlist_2ndpass = [];
    let trapLocations = [];
    for (let X = 1; X < width; X += 1)
        for (let Y = 1; Y < height; Y += 1)
            if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && KinkyDungeonMapGet(X, Y) != 'D' && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                let wallcount = 0;
                let up = false;
                let down = false;
                let left = false;
                let right = false;
                for (let XX = X - 1; XX <= X + 1; XX += 1)
                    for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                        let get = KinkyDungeonMapGet(XX, YY);
                        if (!(XX == X && YY == Y) && (get == '1' || get == 'X' || get == 'C')) {
                            wallcount += 1;
                            if (XX == X + 1 && YY == Y && get == '1')
                                right = true;
                            else if (XX == X - 1 && YY == Y && get == '1')
                                left = true;
                            else if (XX == X && YY == Y + 1 && get == '1')
                                down = true;
                            else if (XX == X && YY == Y - 1 && get == '1')
                                up = true;
                        }
                        else if (get == 'D')
                            wallcount = 100;
                    }
                if (wallcount < 5 && ((up && down) != (left && right)) && KDRandom() > nodoorchance) {
                    doorlist.push({ x: X, y: Y });
                    doorlist_2ndpass.push({ x: X, y: Y });
                }
            }
    while (doorlist.length > 0) {
        let N = Math.floor(KDRandom() * doorlist.length);
        let door = doorlist[N];
        let X = door.x;
        let Y = door.y;
        let closed = KDRandom() < doorchance;
        KinkyDungeonMapSet(X, Y, (closed ? 'D' : 'd'));
        KinkyDungeonTilesSet("" + X + "," + Y, { Type: "Door" });
        if (closed && KDRandom() < doorlockchance && KinkyDungeonIsAccessible(X, Y)) {
            KinkyDungeonTilesGet("" + X + "," + Y).Lock = KinkyDungeonGenerateLock(true, Floor);
        }
        doorlist.splice(N, 1);
    }
    while (doorlist_2ndpass.length > 0) {
        let N = Math.floor(KDRandom() * doorlist_2ndpass.length);
        let minLockedRoomSize = 12;
        let maxPlayerDist = 4;
        let door = doorlist_2ndpass[N];
        let X = door.x;
        let Y = door.y;
        let roomDoors = [];
        let trap = KDRandom() < trapChance;
        let grate = KDRandom() < grateChance;
        if ((trap || grate) && KinkyDungeonTilesGet(X + "," + Y) && !KinkyDungeonTilesGet(X + "," + Y).NoTrap && !KinkyDungeonTilesGet(X + "," + Y).OffLimits) {
            let accessible = KinkyDungeonGetAccessibleRoom(X, Y);
            if (accessible.length > minLockedRoomSize) {
                for (let a of accessible) {
                    let split = a.split(',');
                    let XX = parseInt(split[0]);
                    let YY = parseInt(split[1]);
                    let tileType = KinkyDungeonMapGet(XX, YY);
                    if ((tileType == "D" || tileType == 'd') && !KinkyDungeonTilesGet(a).Lock && XX != X && YY != Y) {
                        roomDoors.push({ x: XX, y: YY });
                    }
                }
                let rooms = [];
                let room2 = KinkyDungeonGetAccessibleRoom(X, Y);
                for (let ddoor of roomDoors) {
                    rooms.push({ door: ddoor, room: room2 });
                }
                for (let room of rooms) {
                    let success = room.room.length == accessible.length;
                    for (let tile of accessible) {
                        if (!room.room.includes(tile)) {
                            success = false;
                            break;
                        }
                    }
                    if (success) {
                        if (!KinkyDungeonTilesGet(room.door.x + "," + room.door.y).Lock && !KinkyDungeonTilesGet(X + "," + Y).Lock && !KinkyDungeonTilesGet(room.door.x + "," + room.door.y).NoTrap
                            && ((KinkyDungeonGetAccessibleRoom(X + 1, Y).length != KinkyDungeonGetAccessibleRoom(X - 1, Y).length
                                && KinkyDungeonIsReachable(X + 1, Y, X, Y) && KinkyDungeonIsReachable(X - 1, Y, X, Y))
                                || (KinkyDungeonGetAccessibleRoom(X, Y + 1).length != KinkyDungeonGetAccessibleRoom(X, Y - 1).length)
                                    && KinkyDungeonIsReachable(X, Y + 1, X, Y) && KinkyDungeonIsReachable(X, Y - 1, X, Y))
                            && KinkyDungeonIsAccessible(X, Y)) {
                            let lock = false;
                            if (trap && Math.max(Math.abs(room.door.x - KinkyDungeonPlayerEntity.x), Math.abs(room.door.y - KinkyDungeonPlayerEntity.y)) > maxPlayerDist) {
                                if (KDDebug)
                                    console.log("Trap at " + X + "," + Y);
                                trapLocations.push({ x: room.door.x, y: room.door.y });
                                if (KDRandom() < 0.1) {
                                    let dropped = { x: room.door.x, y: room.door.y, name: "Gold", amount: 1 };
                                    KinkyDungeonGroundItems.push(dropped);
                                }
                                lock = true;
                            }
                            else if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(room.door.x, room.door.y + 1)) && ((grate && (!room.room || room.room.length > minLockedRoomSize))
                                || (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(X, Y + 1)) && Math.max(Math.abs(room.door.x - KinkyDungeonPlayerEntity.x), Math.abs(room.door.y - KinkyDungeonPlayerEntity.y)) <= maxPlayerDist))
                                && room.door.y != KinkyDungeonStartPosition.y) {
                                KinkyDungeonMapSet(room.door.x, room.door.y, 'g');
                                lock = true;
                            }
                            if (lock) {
                                KinkyDungeonTilesGet("" + X + "," + Y).Lock = KinkyDungeonGenerateLock(true, Floor, false, "Door");
                                KinkyDungeonMapSet(X, Y, 'D');
                            }
                        }
                        break;
                    }
                }
            }
        }
        doorlist_2ndpass.splice(N, 1);
    }
    return trapLocations;
}
function KinkyDungeonReplaceDoodads(Chance, barchance, wallRubblechance, wallhookchance, ceilinghookchance, width, height, altType) {
    for (let X = 1; X < width - 1; X += 1)
        for (let Y = 1; Y < height - 1; Y += 1) {
            if (KinkyDungeonMapGet(X, Y) == '1' && KDRandom() < Chance)
                KinkyDungeonMapSet(X, Y, '4');
            else if (KinkyDungeonMapGet(X, Y) == '1' && KDRandom() < wallRubblechance && !KinkyDungeonTilesSkin[X + "," + Y]) {
                KinkyDungeonMapSet(X, Y, 'Y');
                if (KDAlreadyOpened(X, Y)) {
                    KinkyDungeonMapSet(X, Y, '1');
                }
            }
        }
    if (altType && !altType.noClutter) {
        for (let X = 1; X < width - 1; X += 1)
            for (let Y = 1; Y < height - 1; Y += 1) {
                let tl = KinkyDungeonMapGet(X, Y);
                let tr = KinkyDungeonMapGet(X + 1, Y);
                let bl = KinkyDungeonMapGet(X, Y + 1);
                let br = KinkyDungeonMapGet(X + 1, Y + 1);
                if (tl == '1' && br == '1' && KinkyDungeonMovableTilesEnemy.includes(tr) && KinkyDungeonMovableTilesEnemy.includes(bl))
                    KinkyDungeonMapSet(X, Y, 'X');
                else if (tr == '1' && bl == '1' && KinkyDungeonMovableTilesEnemy.includes(tl) && KinkyDungeonMovableTilesEnemy.includes(br))
                    KinkyDungeonMapSet(X, Y + 1, 'X');
            }
        for (let X = 1; X < width - 1; X += 1)
            for (let Y = 1; Y < height - 1; Y += 1) {
                if (KinkyDungeonMapGet(X, Y) == '1' && KDRandom() < barchance
                    && ((KinkyDungeonMapGet(X, Y - 1) == '1' && KinkyDungeonMapGet(X, Y + 1) == '1' && KinkyDungeonMapGet(X - 1, Y) == '0' && KinkyDungeonMapGet(X + 1, Y) == '0')
                        || (KinkyDungeonMapGet(X - 1, Y) == '1' && KinkyDungeonMapGet(X + 1, Y) == '1' && KinkyDungeonMapGet(X, Y - 1) == '0' && KinkyDungeonMapGet(X, Y + 1) == '0'))) {
                    KinkyDungeonMapSet(X, Y, 'b');
                }
                else if ((KinkyDungeonMapGet(X, Y) == '2' || KinkyDungeonMapGet(X, Y) == '0') && ((KDRandom() < wallhookchance && KinkyDungeonMapGet(X - 1, Y) == '1' && KinkyDungeonMapGet(X, Y - 1) == '1' && KinkyDungeonMapGet(X + 1, Y) == '0' && KinkyDungeonMapGet(X + 1, Y - 1) == '0' && KinkyDungeonMapGet(X + 1, Y + 1) == '0')
                    || (KDRandom() < wallhookchance && KinkyDungeonMapGet(X + 1, Y) == '1' && KinkyDungeonMapGet(X, Y - 1) == '1' && KinkyDungeonMapGet(X - 1, Y) == '0' && KinkyDungeonMapGet(X - 1, Y - 1) == '0' && KinkyDungeonMapGet(X - 1, Y + 1) == '0')
                    || (KDRandom() < wallhookchance && KinkyDungeonMapGet(X, Y - 1) == '1' && KinkyDungeonMapGet(X, Y + 1) == '0' && KinkyDungeonMapGet(X + 1, Y + 1) == '0' && KinkyDungeonMapGet(X - 1, Y + 1) == '0')
                    || (KDRandom() < wallhookchance && KinkyDungeonMapGet(X, Y + 1) == '1' && KinkyDungeonMapGet(X, Y - 1) == '1' && KinkyDungeonMapGet(X, Y - 1) == '0' && KinkyDungeonMapGet(X + 1, Y - 1) == '0' && KinkyDungeonMapGet(X - 1, Y - 1) == '0'))) {
                    KinkyDungeonMapSet(X, Y - 1, ',');
                }
                else if (KDRandom() < ceilinghookchance && (KinkyDungeonMapGet(X, Y) == '2' || KinkyDungeonMapGet(X, Y) == '0' &&
                    (KinkyDungeonMapGet(X - 1, Y) != '1'
                        && KinkyDungeonMapGet(X + 1, Y) != '1'
                        && KinkyDungeonMapGet(X, Y - 1) != '1'
                        && KinkyDungeonMapGet(X, Y + 1) != '1'
                        && KinkyDungeonMapGet(X + 1, Y + 1) != '1'
                        && KinkyDungeonMapGet(X + 1, Y - 1) != '1'
                        && KinkyDungeonMapGet(X - 1, Y + 1) != '1'
                        && KinkyDungeonMapGet(X - 1, Y - 1) != '1'))) {
                    KinkyDungeonMapSet(X, Y, '?');
                }
            }
    }
}
function KinkyDungeonPlaceFurniture(barrelChance, cageChance, width, height, altType) {
    if (!altType || !altType.noClutter)
        for (let X = 1; X < width - 1; X += 1)
            for (let Y = 1; Y < height - 1; Y += 1) {
                if (KinkyDungeonMapGet(X, Y) == '0' && !(KinkyDungeonTilesGet(X + "," + Y) && KinkyDungeonTilesGet(X + "," + Y).OffLimits)
                    && (KinkyDungeonMapGet(X + 1, Y) != 'd' && KinkyDungeonMapGet(X + 1, Y) != 'D'
                        && KinkyDungeonMapGet(X - 1, Y) != 'd' && KinkyDungeonMapGet(X - 1, Y) != 'D'
                        && KinkyDungeonMapGet(X, Y + 1) != 'd' && KinkyDungeonMapGet(X, Y + 1) != 'D'
                        && KinkyDungeonMapGet(X, Y - 1) != 'd' && KinkyDungeonMapGet(X, Y - 1) != 'D')
                    && ((KDRandom() < barrelChance * 4 && KinkyDungeonMapGet(X - 2, Y) == '1' && KinkyDungeonMapGet(X + 2, Y) == '1' && KinkyDungeonMapGet(X, Y - 2) == '1' && KinkyDungeonMapGet(X, Y + 2) == '1')
                        || (KDRandom() < barrelChance * 2 && KinkyDungeonMapGet(X - 1, Y - 1) == '1' && KinkyDungeonMapGet(X + 1, Y - 1) == '1' && KinkyDungeonMapGet(X - 1, Y + 1) == '1' && KinkyDungeonMapGet(X - 1, Y + 1) == '1')
                        || (KDRandom() < barrelChance && KinkyDungeonMapGet(X - 1, Y) == '1' && KinkyDungeonMapGet(X + 1, Y) == '0' && KinkyDungeonMapGet(X + 1, Y - 1) == '0' && KinkyDungeonMapGet(X + 1, Y + 1) == '0')
                        || (KDRandom() < barrelChance && KinkyDungeonMapGet(X + 1, Y) == '1' && KinkyDungeonMapGet(X - 1, Y) == '0' && KinkyDungeonMapGet(X - 1, Y - 1) == '0' && KinkyDungeonMapGet(X - 1, Y + 1) == '0')
                        || (KDRandom() < barrelChance && KinkyDungeonMapGet(X, Y - 1) == '1' && KinkyDungeonMapGet(X, Y + 1) == '0' && KinkyDungeonMapGet(X + 1, Y + 1) == '0' && KinkyDungeonMapGet(X - 1, Y + 1) == '0')
                        || (KDRandom() < barrelChance && KinkyDungeonMapGet(X, Y + 1) == '1' && KinkyDungeonMapGet(X, Y - 1) == '0' && KinkyDungeonMapGet(X + 1, Y - 1) == '0' && KinkyDungeonMapGet(X - 1, Y - 1) == '0'))) {
                    KinkyDungeonMapSet(X, Y, 'L');
                    if (KDRandom() < cageChance) {
                        let furn = KDRandom() ? "Cage" : "DisplayStand";
                        KinkyDungeonTilesSet(X + "," + Y, { Furniture: furn });
                        KDGameData.JailPoints.push({ x: X, y: Y, type: "furniture", radius: 1 });
                    }
                }
            }
}
let KDFood = [
    {
        Food: "",
        Weight: 10,
    },
    {
        Food: "Plate",
        Weight: 1,
    },
    {
        Food: "Cookies",
        Weight: 8,
    },
    {
        Food: "Pizza",
        Weight: 4,
    },
];
function KinkyDungeonPlaceFood(foodChance, width, height, altType) {
    if (altType && altType.noClutter)
        return;
    let foodPoints = new Map();
    let foodList = [];
    for (let X = 1; X < width; X += 1)
        for (let Y = 1; Y < height; Y += 1)
            if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && Math.max(Math.abs(X - KinkyDungeonStartPosition.x), Math.abs(Y - KinkyDungeonStartPosition.y)) > KinkyDungeonJailLeash
                && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)) {
                let wallcount = 0;
                let adjcount = 0;
                let diagadj = 0;
                for (let XX = X - 1; XX <= X + 1; XX += 1)
                    for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                        if (!(XX == X && YY == Y) && (KinkyDungeonMapGet(XX, YY) == '1' || KinkyDungeonMapGet(XX, YY) == 'X')) {
                            wallcount += 1;
                            if (XX == X || YY == Y)
                                adjcount += 1;
                        }
                        else if (!(XX == X && YY == Y) && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY))) {
                            if (!(XX == X || YY == Y)) {
                                if (XX == X + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X + 1, Y)))
                                    diagadj += 1;
                                else if (XX == X - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X - 1, Y)))
                                    diagadj += 1;
                                else if (YY == Y + 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y + 1)))
                                    diagadj += 1;
                                else if (YY == Y - 1 && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y - 1)))
                                    diagadj += 1;
                            }
                        }
                    }
                if (wallcount == 7
                    || (wallcount >= 4 && (wallcount - adjcount - diagadj == 0 || (wallcount == 5 && adjcount == 2 && diagadj == 1) || (wallcount == 6 && adjcount == 3 && diagadj == 1))
                        && (KinkyDungeonMapGet(X + 1, Y) == '1' || KinkyDungeonMapGet(X - 1, Y) == '1')
                        && (KinkyDungeonMapGet(X, Y + 1) == '1' || KinkyDungeonMapGet(X, Y - 1) == '1')
                        && (!(KinkyDungeonMapGet(X + 1, Y) == '1' && KinkyDungeonMapGet(X - 1, Y) == '1') || (wallcount == 6 && adjcount == 3 && diagadj == 1))
                        && (!(KinkyDungeonMapGet(X, Y + 1) == '1' && KinkyDungeonMapGet(X, Y - 1) == '1') || (wallcount == 6 && adjcount == 3 && diagadj == 1)))) {
                    if (!foodPoints.get((X + 1) + "," + (Y))
                        && !foodPoints.get((X - 1) + "," + (Y))
                        && !foodPoints.get((X + 1) + "," + (Y + 1))
                        && !foodPoints.get((X + 1) + "," + (Y - 1))
                        && !foodPoints.get((X - 1) + "," + (Y + 1))
                        && !foodPoints.get((X - 1) + "," + (Y - 1))
                        && !foodPoints.get((X) + "," + (Y + 1))
                        && !foodPoints.get((X) + "," + (Y - 1))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y - 1))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y - 1))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y - 1))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X - 1, Y + 1))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X, Y + 1))
                        && !KDRandomDisallowedNeighbors.includes(KinkyDungeonMapGet(X + 1, Y + 1))) {
                        foodList.push({ x: X, y: Y, boringness: KinkyDungeonBoringGet(X, Y), priority: 0 });
                        foodPoints.set(X + "," + Y, true);
                    }
                }
            }
    let count = 0;
    let list = [];
    let maxBoringness = Math.max(...KinkyDungeonBoringness);
    while (foodList.length > 0) {
        let N = Math.floor(KDRandom() * foodList.length);
        let chest = foodList[N];
        if (!chest.boringness)
            chest.boringness = KinkyDungeonBoringGet(chest.x, chest.y);
        if (chest.boringness > 0)
            chest.boringness = chest.boringness + (0.05 + 0.1 * KDRandom()) * maxBoringness;
        else
            chest.boringness = chest.boringness + 0.05 * KDRandom() * maxBoringness;
        if (chest.priority) {
            list.unshift(chest);
        }
        else
            list.push(chest);
        foodList.splice(N, 1);
    }
    list.sort((a, b) => {
        let boringa = a.boringness ? a.boringness : 0;
        let boringb = b.boringness ? b.boringness : 0;
        if (a.priority)
            boringa += 1000;
        if (b.priority)
            boringb += 1000;
        return boringb - boringa;
    });
    let foodcount = list.length * foodChance;
    while (list.length > 0) {
        let N = 0;
        if (count <= foodcount) {
            let shrine = list[N];
            let tile = 'F';
            let type = undefined;
            let WeightTotal = 0;
            let Weights = [];
            for (let obj of Object.values(KDFood)) {
                Weights.push({ event: obj, weight: WeightTotal });
                WeightTotal += obj.Weight;
            }
            let selection = KDRandom() * WeightTotal;
            for (let L = Weights.length - 1; L >= 0; L--) {
                if (selection > Weights[L].weight) {
                    type = Weights[L].event.Food;
                    break;
                }
            }
            KinkyDungeonTilesSet("" + shrine.x + "," + shrine.y, { Food: type, Type: "Food" });
            KinkyDungeonMapSet(shrine.x, shrine.y, tile);
            count += 1;
        }
        list.splice(N, 1);
    }
}
function KinkyDungeonPlaceTorches(torchchance, torchlitchance, torchchanceboring, width, height, altType, torchreplace) {
    for (let X = 1; X < width - 1; X += 1)
        for (let Y = 1; Y < height - 1; Y += 1) {
            if (KinkyDungeonMapGet(X, Y) == '1'
                && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(X, Y + 1))
                && !KinkyDungeonEffectTilesGet((X - 1) + "," + (Y + 1))
                && !KinkyDungeonEffectTilesGet((X) + "," + (Y + 1))
                && !KinkyDungeonEffectTilesGet((X + 1) + "," + (Y + 1))
                && !KinkyDungeonTilesGet((X - 1) + "," + (Y + 1))
                && !KinkyDungeonTilesGet((X) + "," + (Y + 1))
                && !KinkyDungeonTilesGet((X + 1) + "," + (Y + 1))
                && KDRandom() < torchchance + KinkyDungeonBoringGet(X, Y) * torchchanceboring) {
                let spr = torchreplace ? torchreplace.sprite : "Torch";
                if ((!torchreplace || torchreplace.unlitsprite) && KDRandom() > torchlitchance) {
                    spr = torchreplace ? torchreplace.unlitsprite : "TorchUnlit";
                }
                let torchref = {
                    name: spr,
                    duration: 9999,
                };
                KDCreateEffectTile(X, Y + 1, torchref, 0);
            }
        }
}
function KinkyDungeonReplaceVert(width, height) {
    for (let X = 0; X <= width - 1; X += 1)
        for (let Y = 0; Y <= height - 1; Y += 1) {
            let tileUp = KinkyDungeonMapGet(X, Y);
            let tileBelow = KinkyDungeonMapGet(X, Y + 1);
            if ((tileUp == '1'
                || tileUp == '4') && (tileBelow == '1'
                || tileBelow == '4'
                || tileBelow == 'd'
                || tileBelow == 'D'
                || tileBelow == ',')) {
            }
        }
}
function KinkyDungeonMazeWalls(Cell, Walls, WallsList) {
    if (Walls[(Cell.x + 1) + "," + Cell.y])
        WallsList[(Cell.x + 1) + "," + Cell.y] = { x: Cell.x + 1, y: Cell.y };
    if (Walls[(Cell.x - 1) + "," + Cell.y])
        WallsList[(Cell.x - 1) + "," + Cell.y] = { x: Cell.x - 1, y: Cell.y };
    if (Walls[Cell.x + "," + (Cell.y + 1)])
        WallsList[Cell.x + "," + (Cell.y + 1)] = { x: Cell.x, y: Cell.y + 1 };
    if (Walls[Cell.x + "," + (Cell.y - 1)])
        WallsList[Cell.x + "," + (Cell.y - 1)] = { x: Cell.x, y: Cell.y - 1 };
}
function KinkyDungeonMapSet(X, Y, SetTo, VisitedRooms) {
    let height = KinkyDungeonGridHeight;
    let width = KinkyDungeonGridWidth;
    if (X > 0 && X < width - 1 && Y > 0 && Y < height - 1) {
        KinkyDungeonGrid = KinkyDungeonGrid.replaceAt(X + Y * (width + 1), SetTo);
        if (VisitedRooms)
            VisitedRooms.push({ x: X, y: Y });
        return true;
    }
    return false;
}
function KinkyDungeonMapSetForce(X, Y, SetTo, VisitedRooms) {
    let width = KinkyDungeonGridWidth;
    KinkyDungeonGrid = KinkyDungeonGrid.replaceAt(X + Y * (width + 1), SetTo);
    if (VisitedRooms)
        VisitedRooms.push({ x: X, y: Y });
    return true;
}
function KinkyDungeonBoringGet(X, Y) {
    return KinkyDungeonBoringness[X + Y * (KinkyDungeonGridWidth)];
}
function KinkyDungeonBoringSet(X, Y, SetTo) {
    if (X >= 0 && X <= KinkyDungeonGridWidth - 1 && Y >= 0 && Y <= KinkyDungeonGridHeight - 1) {
        KinkyDungeonBoringness[X + Y * (KinkyDungeonGridWidth)] = SetTo;
        return true;
    }
    return false;
}
function KinkyDungeonMapGet(X, Y) {
    return KinkyDungeonGrid[X + Y * (KinkyDungeonGridWidth + 1)];
}
function KinkyDungeonVisionSet(X, Y, SetTo) {
    if (X >= 0 && X <= KinkyDungeonGridWidth - 1 && Y >= 0 && Y <= KinkyDungeonGridHeight - 1) {
        KinkyDungeonVisionGrid[X + Y * (KinkyDungeonGridWidth)] = SetTo;
        return true;
    }
    return false;
}
function KinkyDungeonBrightnessSet(X, Y, SetTo, monotonic) {
    if (X >= 0 && X <= KinkyDungeonGridWidth - 1 && Y >= 0 && Y <= KinkyDungeonGridHeight - 1) {
        if (!monotonic || SetTo > KinkyDungeonBrightnessGrid[X + Y * (KinkyDungeonGridWidth)])
            KinkyDungeonBrightnessGrid[X + Y * (KinkyDungeonGridWidth)] = SetTo;
        return true;
    }
    return false;
}
function KinkyDungeonColorSet(X, Y, SetTo, monotonic) {
    if (X >= 0 && X <= KinkyDungeonGridWidth - 1 && Y >= 0 && Y <= KinkyDungeonGridHeight - 1) {
        if (!monotonic || SetTo > KinkyDungeonColorGrid[X + Y * (KinkyDungeonGridWidth)])
            KinkyDungeonColorGrid[X + Y * (KinkyDungeonGridWidth)] = SetTo;
        return true;
    }
    return false;
}
function KinkyDungeonShadowSet(X, Y, SetTo, monotonic) {
    if (X >= 0 && X <= KinkyDungeonGridWidth - 1 && Y >= 0 && Y <= KinkyDungeonGridHeight - 1) {
        if (!monotonic || SetTo > KinkyDungeonShadowGrid[X + Y * (KinkyDungeonGridWidth)])
            KinkyDungeonShadowGrid[X + Y * (KinkyDungeonGridWidth)] = SetTo;
        return true;
    }
    return false;
}
function KinkyDungeonVisionGet(X, Y) {
    return KinkyDungeonVisionGrid[X + Y * (KinkyDungeonGridWidth)];
}
function KinkyDungeonBrightnessGet(X, Y) {
    return KinkyDungeonBrightnessGrid[X + Y * (KinkyDungeonGridWidth)];
}
function KinkyDungeonColorGet(X, Y) {
    return KinkyDungeonColorGrid[X + Y * (KinkyDungeonGridWidth)];
}
function KinkyDungeonShadowGet(X, Y) {
    return KinkyDungeonShadowGrid[X + Y * (KinkyDungeonGridWidth)];
}
function KinkyDungeonFogGet(X, Y) {
    return KinkyDungeonFogGrid[X + Y * (KinkyDungeonGridWidth)];
}
let canvasOffsetX = 0;
let canvasOffsetY = 0;
const canvasOffsetX_ui = 500;
const canvasOffsetY_ui = 164;
function KinkyDungeonGetDirection(dx, dy) {
    let X = 0;
    let Y = 0;
    if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5)
        return { x: 0, y: 0, delta: 1 };
    if (dy > 0 && Math.abs(dx) < Math.abs(dy) / 2.61312593)
        Y = 1;
    else if (dy < 0 && Math.abs(dx) < Math.abs(dy) / 2.61312593)
        Y = -1;
    else if (dx > 0 && Math.abs(dy) < Math.abs(dx) / 2.61312593)
        X = 1;
    else if (dx < 0 && Math.abs(dy) < Math.abs(dx) / 2.61312593)
        X = -1;
    else if (dy > 0 && dx > dy / 2.61312593) {
        Y = 1;
        X = 1;
    }
    else if (dy > 0 && -dx > dy / 2.61312593) {
        Y = 1;
        X = -1;
    }
    else if (dy < 0 && dx > -dy / 2.61312593) {
        Y = -1;
        X = 1;
    }
    else if (dy < 0 && -dx > -dy / 2.61312593) {
        Y = -1;
        X = -1;
    }
    return { x: X, y: Y, delta: Math.round(Math.sqrt(X * X + Y * Y) * 2) / 2 };
}
function KinkyDungeonGetDirectionRandom(dx, dy) {
    let dir = KinkyDungeonGetDirection(dx, dy);
    let pivot = Math.floor(KDRandom() * 3) - 1;
    if (dir.x == 0 && dir.y == 1)
        dir.x = pivot;
    else if (dir.x == 0 && dir.y == -1)
        dir.x = -pivot;
    else if (dir.x == 1 && dir.y == 0)
        dir.y = pivot;
    else if (dir.x == -1 && dir.y == 0)
        dir.y = -pivot;
    else if (dir.x == 1 && dir.y == 1) {
        if (pivot == 1) {
            dir.y = 0;
        }
        else if (pivot == -1) {
            dir.x = 0;
        }
    }
    else if (dir.x == 1 && dir.y == -1) {
        if (pivot == 1) {
            dir.x = 0;
        }
        else if (pivot == -1) {
            dir.y = 0;
        }
    }
    else if (dir.x == -1 && dir.y == 1) {
        if (pivot == 1) {
            dir.x = 0;
        }
        else if (pivot == -1) {
            dir.y = 0;
        }
    }
    else if (dir.x == -1 && dir.y == -1) {
        if (pivot == 1) {
            dir.y = 0;
        }
        else if (pivot == -1) {
            dir.x = 0;
        }
    }
    dir.delta = Math.round(Math.sqrt(dir.x * dir.x + dir.y * dir.y) * 2) / 2;
    return dir;
}
let KinkyDungeonAutoWaitSuppress = false;
function KinkyDungeonControlsEnabled() {
    return !KinkyDungeonInspect && KinkyDungeonSlowMoveTurns < 1 && KinkyDungeonStatFreeze < 1 && KDGameData.SleepTurns < 1 && !KDGameData.CurrentDialog && !KinkyDungeonMessageToggle;
}
function KDStartSpellcast(tx, ty, SpellToCast, enemy, player, bullet, data) {
    let spell = KinkyDungeonFindSpell(SpellToCast.name, true);
    let spellname = undefined;
    if (spell) {
        spellname = spell.name;
        spell = undefined;
    }
    else
        spell = SpellToCast;
    return KDSendInput("tryCastSpell", Object.assign({ tx: tx, ty: ty, spell: spell, spellname: spellname, enemy: enemy, player: player, bullet: bullet }, data));
}
function KinkyDungeonClickGame(Level) {
    let _CharacterRefresh = CharacterRefresh;
    let _CharacterAppearanceBuildCanvas = CharacterAppearanceBuildCanvas;
    CharacterRefresh = () => { KDRefresh = true; };
    CharacterAppearanceBuildCanvas = () => { };
    let prevSpell = KinkyDungeonTargetingSpell;
    let prevInv = KinkyDungeonShowInventory;
    if (KDGameData.CurrentDialog) {
        let result = false;
        try {
            result = KDHandleDialogue();
        }
        finally {
            CharacterRefresh = _CharacterRefresh;
            CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
        }
        return result;
    }
    if (KinkyDungeonControlsEnabled() && KinkyDungeonHandleHUD()) {
        try {
            if (prevSpell) {
                if (prevInv)
                    KDCloseQuickInv();
                else
                    KinkyDungeonTargetingSpell = null;
            }
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            KinkyDungeonGameKey.keyPressed = [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
            ];
            if (KinkyDungeonAutoWaitSuppress)
                KinkyDungeonAutoWaitSuppress = false;
            else if (KDIsAutoAction()) {
                KDDisableAutoWait();
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Damage.ogg");
            }
        }
        finally {
            CharacterRefresh = _CharacterRefresh;
            CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
        }
        return;
    }
    else if (KDIsAutoAction() && MouseIn(canvasOffsetX, canvasOffsetY, KinkyDungeonCanvas.width, KinkyDungeonCanvas.height)) {
        KDDisableAutoWait();
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Damage.ogg");
    }
    else if (KinkyDungeonControlsEnabled() && KinkyDungeonDrawState == "Game") {
        try {
            if (KDModalArea || KinkyDungeonTargetTile) {
                KDModalArea = false;
                KinkyDungeonTargetTile = null;
                KinkyDungeonTargetTileLocation = "";
            }
            else {
                KinkyDungeonSetMoveDirection();
                if (KinkyDungeonTargetingSpell) {
                    if (MouseIn(canvasOffsetX, canvasOffsetY, KinkyDungeonCanvas.width, KinkyDungeonCanvas.height)) {
                        if (KinkyDungeoCheckComponents(KinkyDungeonTargetingSpell).length == 0 || ((KinkyDungeonStatsChoice.get("Slayer") && KinkyDungeonTargetingSpell.school == "Elements")
                            || (KinkyDungeonStatsChoice.get("Conjurer") && KinkyDungeonTargetingSpell.school == "Conjure")
                            || (KinkyDungeonStatsChoice.get("Magician") && KinkyDungeonTargetingSpell.school == "Illusion"))) {
                            if (KinkyDungeonSpellValid) {
                                KDStartSpellcast(KinkyDungeonTargetX, KinkyDungeonTargetY, KinkyDungeonTargetingSpell, undefined, KinkyDungeonPlayerEntity, undefined, { targetingSpellItem: KinkyDungeonTargetingSpellItem, targetingSpellWeapon: KinkyDungeonTargetingSpellWeapon });
                                KinkyDungeonTargetingSpell = null;
                            }
                        }
                        else
                            KinkyDungeonTargetingSpell = null;
                    }
                    else
                        KinkyDungeonTargetingSpell = null;
                }
                else if (KinkyDungeonIsPlayer() && MouseIn(canvasOffsetX, canvasOffsetY, KinkyDungeonCanvas.width, KinkyDungeonCanvas.height)) {
                    let fastMove = KinkyDungeonFastMove && !KinkyDungeonToggleAutoSprint;
                    if (fastMove && Math.max(Math.abs(KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x), Math.abs(KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y)) > 1
                        && (KinkyDungeonVisionGet(KinkyDungeonTargetX, KinkyDungeonTargetY) > 0 || KinkyDungeonFogGet(KinkyDungeonTargetX, KinkyDungeonTargetY) > 0 || KDistChebyshev(KinkyDungeonPlayerEntity.x - KinkyDungeonTargetX, KinkyDungeonPlayerEntity.y - KinkyDungeonTargetY) < 1.5)) {
                        let requireLight = KinkyDungeonVisionGet(KinkyDungeonTargetX, KinkyDungeonTargetY) > 0;
                        let path = KinkyDungeonFindPath(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonTargetX, KinkyDungeonTargetY, false, false, false, KinkyDungeonMovableTilesEnemy, requireLight, false, true);
                        if (path) {
                            KinkyDungeonFastMovePath = path;
                            KinkyDungeonSleepTime = 100;
                        }
                    }
                    else if (!fastMove || Math.max(Math.abs(KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x), Math.abs(KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y)) <= 1) {
                        KDSendInput("move", { dir: KinkyDungeonMoveDirection, delta: 1, AllowInteract: true, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: KinkyDungeonSuppressSprint });
                    }
                }
            }
        }
        finally {
            CharacterRefresh = _CharacterRefresh;
            CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
        }
    }
    CharacterRefresh = _CharacterRefresh;
    CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
    return;
}
function KinkyDungeonGetMovable() {
    let MovableTiles = KinkyDungeonMovableTiles;
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Squeeze") > 0)
        MovableTiles = MovableTiles + "b";
    return MovableTiles;
}
function KinkyDungeonListenKeyMove() {
    if (KinkyDungeonLastMoveTimer < performance.now() && KinkyDungeonControlsEnabled() && KinkyDungeonDrawState == "Game" && !KDModalArea) {
        let moveDirection = null;
        let moveDirectionDiag = null;
        let MovableTiles = KinkyDungeonGetMovable();
        if ((KinkyDungeonGameKey.keyPressed[0]) && MovableTiles.includes(KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y - 1)))
            moveDirection = KinkyDungeonGetDirection(0, -1);
        else if ((KinkyDungeonGameKey.keyPressed[1]) && MovableTiles.includes(KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y + 1)))
            moveDirection = KinkyDungeonGetDirection(0, 1);
        else if ((KinkyDungeonGameKey.keyPressed[2]) && MovableTiles.includes(KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x - 1, KinkyDungeonPlayerEntity.y)))
            moveDirection = KinkyDungeonGetDirection(-1, 0);
        else if ((KinkyDungeonGameKey.keyPressed[3]) && MovableTiles.includes(KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x + 1, KinkyDungeonPlayerEntity.y)))
            moveDirection = KinkyDungeonGetDirection(1, 0);
        if ((KinkyDungeonGameKey.keyPressed[4]) || (KinkyDungeonGameKey.keyPressed[2] && KinkyDungeonGameKey.keyPressed[0]))
            moveDirectionDiag = KinkyDungeonGetDirection(-1, -1);
        else if ((KinkyDungeonGameKey.keyPressed[5]) || (KinkyDungeonGameKey.keyPressed[3] && KinkyDungeonGameKey.keyPressed[0]))
            moveDirectionDiag = KinkyDungeonGetDirection(1, -1);
        else if ((KinkyDungeonGameKey.keyPressed[6]) || (KinkyDungeonGameKey.keyPressed[2] && KinkyDungeonGameKey.keyPressed[1]))
            moveDirectionDiag = KinkyDungeonGetDirection(-1, 1);
        else if ((KinkyDungeonGameKey.keyPressed[7]) || (KinkyDungeonGameKey.keyPressed[3] && KinkyDungeonGameKey.keyPressed[1]))
            moveDirectionDiag = KinkyDungeonGetDirection(1, 1);
        if ((KinkyDungeonGameKey.keyPressed[8])) {
            moveDirection = KinkyDungeonGetDirection(0, 0);
            moveDirectionDiag = null;
        }
        if (moveDirectionDiag && MovableTiles.includes(KinkyDungeonMapGet(moveDirectionDiag.x + KinkyDungeonPlayerEntity.x, moveDirectionDiag.y + KinkyDungeonPlayerEntity.y))) {
            moveDirection = moveDirectionDiag;
        }
        if (moveDirection) {
            if (KinkyDungeonLastMoveTimerStart < performance.now() && KinkyDungeonLastMoveTimerStart > 0) {
                let _CharacterRefresh = CharacterRefresh;
                let _CharacterAppearanceBuildCanvas = CharacterAppearanceBuildCanvas;
                CharacterRefresh = () => { KDRefresh = true; };
                CharacterAppearanceBuildCanvas = () => { };
                try {
                    KDSendInput("move", { dir: moveDirection, delta: 1, AllowInteract: KinkyDungeonLastMoveTimer == 0, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: false });
                    KinkyDungeonLastMoveTimer = performance.now() + KinkyDungeonLastMoveTimerCooldown;
                }
                finally {
                    CharacterRefresh = _CharacterRefresh;
                    CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
                }
            }
            else if (KinkyDungeonLastMoveTimerStart == 0) {
                KinkyDungeonLastMoveTimerStart = performance.now() + KinkyDungeonLastMoveTimerCooldownStart;
            }
        }
    }
    if (KinkyDungeonLastMoveTimerStart < performance.now() && KinkyDungeonLastMoveTimer == 0)
        KinkyDungeonLastMoveTimerStart = 0;
    if (!KinkyDungeonGameKey.keyPressed.some((element) => { return element; })) {
        KinkyDungeonLastMoveTimer = 0;
    }
}
let KDShopBuyConfirm = false;
function KinkyDungeonGameKeyDown() {
    let moveDirection = null;
    for (let keybinding of Object.values(KDKeyCheckers)) {
        if (keybinding())
            return true;
    }
    KDShopBuyConfirm = false;
    if (KinkyDungeonState == "TileEditor") {
        if (KinkyDungeonKey[0] == KinkyDungeonKeybindingCurrentKey) {
            KDClickButton("maptileU");
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
        else if (KinkyDungeonKey[1] == KinkyDungeonKeybindingCurrentKey) {
            KDClickButton("maptileL");
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
        else if (KinkyDungeonKey[2] == KinkyDungeonKeybindingCurrentKey) {
            KDClickButton("maptileD");
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
        else if (KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey) {
            KDClickButton("maptileR");
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
    }
    if (KDGameData.CurrentDialog)
        return;
    if (!KinkyDungeonControlsEnabled())
        return;
    if (moveDirection && KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Game") {
        KDSendInput("move", { dir: moveDirection, delta: 1, AutoDoor: KinkyDungeonToggleAutoDoor, AutoPass: KinkyDungeonToggleAutoPass, sprint: KinkyDungeonToggleAutoSprint, SuppressSprint: false });
        return true;
    }
    else if (KinkyDungeonKeySpell.includes(KinkyDungeonKeybindingCurrentKey)) {
        if (KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Magic") {
            if (KinkyDungeonSpellChoices.includes(KinkyDungeonCurrentPage)) {
                KDSendInput("spellRemove", { I: KinkyDungeonSpellChoices.indexOf(KinkyDungeonCurrentPage) });
            }
            KinkyDungeonClickSpellChoice(KinkyDungeonKeySpell.indexOf(KinkyDungeonKeybindingCurrentKey), KinkyDungeonCurrentPage);
        }
        else if (KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Game") {
            KinkyDungeonSpellPress = KinkyDungeonKeybindingCurrentKey;
            KinkyDungeonHandleSpell();
        }
        return true;
    }
    else if (KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Game" && KinkyDungeonKeyWeapon.includes(KinkyDungeonKeybindingCurrentKey)) {
        KinkyDungeonSpellPress = KinkyDungeonKeybindingCurrentKey;
        KinkyDungeonRangedAttack();
        return true;
    }
    else if (KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Game" && KinkyDungeonKeyUpcast.includes(KinkyDungeonKeybindingCurrentKey)) {
        if (KinkyDungeonKeybindingCurrentKey == KinkyDungeonKeyUpcast[0]) {
            KDSendInput("upcast", {});
        }
        else {
            KDSendInput("upcastcancel", {});
        }
        return true;
    }
    else if (KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Game" && KinkyDungeonKeySprint.includes(KinkyDungeonKeybindingCurrentKey)) {
        KinkyDungeonToggleAutoSprint = !KinkyDungeonToggleAutoSprint;
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
        return true;
    }
    else if (KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Game" && KinkyDungeonKeySpellPage.includes(KinkyDungeonKeybindingCurrentKey)) {
        KDCycleSpellPage();
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
        return true;
    }
    else if (KinkyDungeonState == "Game" && KinkyDungeonDrawState == "Game" && KinkyDungeonKeySwitchWeapon.includes(KinkyDungeonKeybindingCurrentKey)) {
        KDSwitchWeapon();
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
        return true;
    }
    else if (KinkyDungeonState == "Stats") {
        if (KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey) {
            KDClickButton("perks>");
        }
        else if (KinkyDungeonKey[1] == KinkyDungeonKeybindingCurrentKey) {
            KDClickButton("perks<");
        }
    }
    else if (KinkyDungeonDrawState != "Restart" && KinkyDungeonDrawState != "Keybindings" && KinkyDungeonDrawState != "Perks2") {
        if (KinkyDungeonDrawState == "Inventory" && (KinkyDungeonKey[1] == KinkyDungeonKeybindingCurrentKey || KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey || KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey)) {
            if (KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey) {
                KinkyDungeonCurrentPageInventory += 1;
            }
            else if (KinkyDungeonCurrentPageInventory > 0) {
                KinkyDungeonCurrentPageInventory -= 1;
            }
            else if (KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey) {
                KinkyDungeonDrawState = "Game";
            }
        }
        else if (KinkyDungeonDrawState == "Magic" && (KinkyDungeonKey[1] == KinkyDungeonKeybindingCurrentKey || KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey || KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey)) {
            if (KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey) {
                KinkyDungeonCurrentPage += 1;
                if (KinkyDungeonCurrentPage >= KinkyDungeonSpells.length) {
                    KinkyDungeonCurrentPage = 0;
                }
            }
            else if (KinkyDungeonKey[1] == KinkyDungeonKeybindingCurrentKey && KinkyDungeonCurrentPage > 0) {
                KinkyDungeonCurrentPage -= 1;
            }
            else if (KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey) {
                if (KinkyDungeonPreviewSpell) {
                    if (KinkyDungeonPreviewSpell.hideLearned)
                        KinkyDungeonDrawState = "MagicSpells";
                    KDSendInput("spellLearn", { SpellName: KinkyDungeonPreviewSpell.name });
                }
                else
                    KinkyDungeonDrawState = "MagicSpells";
            }
        }
        else if (KinkyDungeonDrawState == "MagicSpells" && (KinkyDungeonKey[1] == KinkyDungeonKeybindingCurrentKey || KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey || KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey)) {
            if (KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey) {
                KinkyDungeonCurrentSpellsPage += 1;
                if (KinkyDungeonCurrentSpellsPage >= KinkyDungeonLearnableSpells.length)
                    KinkyDungeonCurrentSpellsPage = 0;
            }
            else if (KinkyDungeonCurrentSpellsPage > 0) {
                KinkyDungeonCurrentSpellsPage -= 1;
            }
            else if (KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey) {
                KinkyDungeonDrawState = "Game";
            }
        }
        else if (KinkyDungeonKeyMenu.includes(KinkyDungeonKeybindingCurrentKey)) {
            switch (KinkyDungeonKeybindingCurrentKey) {
                case KinkyDungeonKeyMenu[0]:
                    KinkyDungeonShowInventory = !KinkyDungeonShowInventory;
                    break;
                case KinkyDungeonKeyMenu[1]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "Inventory" ? "Game" : "Inventory";
                    break;
                case KinkyDungeonKeyMenu[2]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "Reputation" ? "Game" : "Reputation";
                    break;
                case KinkyDungeonKeyMenu[3]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "MagicSpells" ? "Game" : "MagicSpells";
                    break;
                case KinkyDungeonKeyMenu[4]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "Logbook" ? "Game" : "Logbook";
                    break;
            }
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
    }
    KinkyDungeonKeybindingCurrentKey = '';
    return false;
}
function KinkyDungeonGameKeyUp(lastPress) {
    let delta = CommonTime() - lastPress;
    if (delta > 60000)
        return;
    if (delta < 250)
        return;
    if (KinkyDungeonState == "Game") {
        if (document.activeElement) {
            if (KinkyDungeonKeySpell.includes(KinkyDungeonKeybindingCurrentKeyRelease)) {
                if (KinkyDungeonDrawState == "Game") {
                    KinkyDungeonTargetingSpell = null;
                }
                return true;
            }
            else if (KinkyDungeonDrawState == "Game" && KinkyDungeonKeyWeapon.includes(KinkyDungeonKeybindingCurrentKeyRelease)) {
                KinkyDungeonTargetingSpell = null;
                return true;
            }
            else if (KinkyDungeonDrawState == "Game" && KinkyDungeonKeySprint.includes(KinkyDungeonKeybindingCurrentKeyRelease)) {
                KinkyDungeonToggleAutoSprint = !KinkyDungeonToggleAutoSprint;
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
                return true;
            }
            else if (KinkyDungeonDrawState == "Game" && KinkyDungeonKeySpellPage.includes(KinkyDungeonKeybindingCurrentKeyRelease)) {
                KDCycleSpellPage(true);
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
                return true;
            }
            else if (KinkyDungeonDrawState == "Game" && KinkyDungeonKeySwitchWeapon.includes(KinkyDungeonKeybindingCurrentKeyRelease)) {
                KDSwitchWeapon();
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
                return true;
            }
        }
        if (KinkyDungeonKeyMenu.includes(KinkyDungeonKeybindingCurrentKeyRelease)) {
            switch (KinkyDungeonKeybindingCurrentKeyRelease) {
                case KinkyDungeonKeyMenu[0]:
                    KinkyDungeonShowInventory = !KinkyDungeonShowInventory;
                    break;
                case KinkyDungeonKeyMenu[1]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "Inventory" ? "Game" : "Inventory";
                    break;
                case KinkyDungeonKeyMenu[2]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "Reputation" ? "Game" : "Reputation";
                    break;
                case KinkyDungeonKeyMenu[3]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "MagicSpells" ? "Game" : "MagicSpells";
                    break;
                case KinkyDungeonKeyMenu[4]:
                    KinkyDungeonDrawState = KinkyDungeonDrawState == "Logbook" ? "Game" : "Logbook";
                    break;
            }
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
        else if (KinkyDungeonKeyToggle.includes(KinkyDungeonKeybindingCurrentKeyRelease)) {
            switch (KinkyDungeonKeybindingCurrentKeyRelease) {
                case KinkyDungeonKeyToggle[0]:
                    KinkyDungeonMessageToggle = !KinkyDungeonMessageToggle;
                    break;
                case KinkyDungeonKeyToggle[1]:
                    KinkyDungeonToggleAutoPass = !KinkyDungeonToggleAutoPass;
                    break;
                case KinkyDungeonKeyToggle[2]:
                    KinkyDungeonToggleAutoDoor = !KinkyDungeonToggleAutoDoor;
                    break;
                case KinkyDungeonKeyToggle[3]:
                    KDAutoStruggleClick();
                    break;
                case KinkyDungeonKeyToggle[4]:
                    KinkyDungeonFastMove = !KinkyDungeonFastMove;
                    break;
                case KinkyDungeonKeyToggle[5]:
                    KinkyDungeonInspect = !KinkyDungeonInspect;
                    break;
            }
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
    }
    KinkyDungeonKeybindingCurrentKey = '';
    return false;
}
function KinkyDungeonSendTextMessage(priority, text, color, time, noPush, noDupe, entity) {
    if (entity && KinkyDungeonVisionGet(entity.x, entity.y) < 1)
        return false;
    if (text) {
        if (!noPush)
            if (!noDupe || KinkyDungeonMessageLog.length == 0 || !KinkyDungeonMessageLog[KinkyDungeonMessageLog.length - 1] || text != KinkyDungeonMessageLog[KinkyDungeonMessageLog.length - 1].text) {
                if (KDLogIndex > 0)
                    KDLogIndex += 1;
                KinkyDungeonMessageLog.push({ text: text, color: color, time: KinkyDungeonCurrentTick });
            }
        if (priority >= KinkyDungeonTextMessagePriority || KinkyDungeonActionMessageTime < 0.5) {
            KinkyDungeonTextMessageTime = time;
            KinkyDungeonTextMessage = text;
            KinkyDungeonTextMessageColor = color;
            KinkyDungeonTextMessagePriority = priority;
            KinkyDungeonTextMessageNoPush = noPush;
            return true;
        }
    }
    return false;
}
function KinkyDungeonSendActionMessage(priority, text, color, time, noPush, noDupe, entity) {
    if (entity && KinkyDungeonVisionGet(entity.x, entity.y) < 1)
        return false;
    if (text) {
        if (!noPush)
            if (!noDupe || KinkyDungeonMessageLog.length == 0 || !KinkyDungeonMessageLog[KinkyDungeonMessageLog.length - 1] || text != KinkyDungeonMessageLog[KinkyDungeonMessageLog.length - 1].text) {
                if (KDLogIndex > 0)
                    KDLogIndex += 1;
                KinkyDungeonMessageLog.push({ text: text, color: color, time: KinkyDungeonCurrentTick });
            }
        if (priority >= KinkyDungeonActionMessagePriority || KinkyDungeonActionMessageTime < 0.5) {
            KinkyDungeonActionMessageTime = time;
            KinkyDungeonActionMessage = text;
            KinkyDungeonActionMessageColor = color;
            KinkyDungeonActionMessagePriority = priority;
            KinkyDungeonActionMessageNoPush = noPush;
            return true;
        }
    }
    return false;
}
let KinkyDungeonNoMoveFlag = false;
function KDAttackCost() {
    let attackCost = KinkyDungeonStatStaminaCostAttack;
    if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.staminacost)
        attackCost = -KinkyDungeonPlayerDamage.staminacost;
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackStamina")) {
        attackCost = Math.min(0, attackCost * KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackStamina")));
    }
    return attackCost;
}
function KinkyDungeonLaunchAttack(Enemy, skip) {
    let attackCost = KDAttackCost();
    let capture = false;
    if (Enemy && KDHelpless(Enemy) && Enemy.hp < 0.52) {
        attackCost = 0;
        capture = true;
    }
    let noadvance = false;
    if (KinkyDungeonHasStamina(Math.abs(attackCost), true)) {
        if (!KDGameData.ConfirmAttack && (!KinkyDungeonAggressive(Enemy) || KDAllied(Enemy)) && !(Enemy.playWithPlayer && KDCanDom(Enemy))) {
            if ((!Enemy.lifetime || Enemy.lifetime > 9000) && !Enemy.Enemy.tags.notalk) {
                let d = Enemy.Enemy.specialdialogue ? Enemy.Enemy.specialdialogue : "GenericAlly";
                if (Enemy.specialdialogue)
                    d = Enemy.specialdialogue;
                KDStartDialog(d, Enemy.Enemy.name, true, Enemy.personality, Enemy);
                noadvance = true;
            }
            else {
                KinkyDungeonSendActionMessage(10, TextGet("KDGameData.ConfirmAttack"), "#ff0000", 1);
                KDGameData.ConfirmAttack = true;
                noadvance = true;
            }
        }
        else {
            if (!capture) {
                if (attackCost < 0 && KinkyDungeonStatsChoice.has("BerserkerRage")) {
                    KinkyDungeonChangeDistraction(0.7 - 0.5 * attackCost, false, 0.33);
                }
                KinkyDungeonAttackEnemy(Enemy, {
                    damage: KinkyDungeonPlayerDamage.dmg,
                    type: KinkyDungeonPlayerDamage.type,
                    distract: KinkyDungeonPlayerDamage.distract,
                    distractEff: KinkyDungeonPlayerDamage.distractEff,
                    bind: KinkyDungeonPlayerDamage.bind,
                    bindType: KinkyDungeonPlayerDamage.bindType,
                    bindEff: KinkyDungeonPlayerDamage.bindEff,
                    boundBonus: KinkyDungeonPlayerDamage.boundBonus,
                    novulnerable: KinkyDungeonPlayerDamage.novulnerable,
                    tease: KinkyDungeonPlayerDamage.tease
                });
                KinkyDungeonChangeStamina(attackCost, false, 1);
                KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "attack", 1);
            }
            else {
                KinkyDungeonAggro(Enemy, undefined, KinkyDungeonPlayerEntity);
                Enemy.hp = 0;
                KinkyDungeonKilledEnemy = Enemy;
                KinkyDungeonSendEvent("capture", { enemy: Enemy, attacker: KinkyDungeonPlayerEntity, skip: skip });
                KinkyDungeonChangeStamina(attackCost, false, 1);
                KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "capture", 1);
            }
            KinkyDungeonLastAction = "Attack";
            KDGameData.ConfirmAttack = false;
        }
    }
    else {
        KinkyDungeonWaitMessage();
    }
    if (!noadvance) {
        KinkyDungeonInterruptSleep();
        if (!skip)
            KinkyDungeonAdvanceTime(1);
    }
}
function KinkyDungeonMove(moveDirection, delta, AllowInteract, SuppressSprint) {
    let moveX = moveDirection.x + KinkyDungeonPlayerEntity.x;
    let moveY = moveDirection.y + KinkyDungeonPlayerEntity.y;
    let moved = false;
    let Enemy = KinkyDungeonEnemyAt(moveX, moveY);
    let passThroughSprint = false;
    let nextPosX = moveX * 2 - KinkyDungeonPlayerEntity.x;
    let nextPosY = moveY * 2 - KinkyDungeonPlayerEntity.y;
    let nextTile = KinkyDungeonMapGet(nextPosX, nextPosY);
    if (KinkyDungeonMovableTilesEnemy.includes(nextTile) && KinkyDungeonNoEnemy(nextPosX, nextPosY) && KinkyDungeonToggleAutoSprint) {
        let data = {
            canSprint: KDCanSprint(),
            passThru: false,
            nextPosx: moveX,
            nextPosy: moveY,
        };
        KinkyDungeonSendEvent("canSprint", data);
        if (data.canSprint && data.passThru) {
            passThroughSprint = true;
        }
    }
    let allowPass = Enemy
        && KDCanPassEnemy(KinkyDungeonPlayerEntity, Enemy);
    if (Enemy && !allowPass && !passThroughSprint) {
        if (AllowInteract) {
            KDDelayedActionPrune(["Action", "Attack"]);
            KinkyDungeonLaunchAttack(Enemy);
        }
    }
    else {
        let MovableTiles = KinkyDungeonGetMovable();
        let moveObject = KinkyDungeonMapGet(moveX, moveY);
        if (MovableTiles.includes(moveObject) && (passThroughSprint || KinkyDungeonNoEnemy(moveX, moveY) || (Enemy && Enemy.allied) || allowPass)) {
            KDGameData.ConfirmAttack = false;
            let quick = false;
            if (KinkyDungeonTilesGet("" + moveX + "," + moveY)
                && KinkyDungeonTilesGet("" + moveX + "," + moveY).Type
                && ((KinkyDungeonToggleAutoDoor
                    && moveObject == 'd'
                    && KinkyDungeonTargetTile == null
                    && KinkyDungeonNoEnemy(moveX, moveY, true))
                    || ((KDObjectDraw[KinkyDungeonTilesGet("" + moveX + "," + moveY).Type]
                        || KDObjectClick[KinkyDungeonTilesGet("" + moveX + "," + moveY).Type])
                        && (KinkyDungeonTilesGet("" + moveX + "," + moveY).Type != "Door"
                            || (KinkyDungeonTilesGet("" + moveX + "," + moveY).Lock
                                && KinkyDungeonTilesGet("" + moveX + "," + moveY).Type == "Door"))))) {
                if (AllowInteract) {
                    if (KDObjectClick[KinkyDungeonTilesGet("" + moveX + "," + moveY).Type]) {
                        KDObjectClick[KinkyDungeonTilesGet("" + moveX + "," + moveY).Type](moveX, moveY);
                    }
                    else {
                        KDDelayedActionPrune(["Action", "World"]);
                        KinkyDungeonTargetTileLocation = "" + moveX + "," + moveY;
                        KinkyDungeonTargetTile = KinkyDungeonTilesGet(KinkyDungeonTargetTileLocation);
                        if (moveObject == 'd') {
                            KinkyDungeonCloseDoor({ targetTile: KinkyDungeonTargetTileLocation });
                        }
                        else {
                            KinkyDungeonTargetTileMsg();
                        }
                    }
                }
            }
            else if (moveX != KinkyDungeonPlayerEntity.x || moveY != KinkyDungeonPlayerEntity.y) {
                KDDelayedActionPrune(["Action", "Move"]);
                let newDelta = 1;
                KinkyDungeonTargetTile = null;
                KinkyDungeonTargetTileLocation = "";
                if (!KinkyDungeonHandleMoveObject(moveX, moveY, moveObject)) {
                    KinkyDungeonItemCheck(moveX, moveY, MiniGameKinkyDungeonLevel);
                    KinkyDungeonNoMoveFlag = false;
                    KinkyDungeonConfirmStairs = false;
                    KinkyDungeonSendEvent("beforeMove", { x: moveX, y: moveY });
                    if (!KinkyDungeonNoMoveFlag) {
                        KinkyDungeonMovePoints = Math.min(Math.ceil(KinkyDungeonSlowLevel + 1), KinkyDungeonMovePoints + delta);
                        if (KinkyDungeonFlags.has("Quickness") && KinkyDungeonSlowLevel < 9) {
                            KinkyDungeonMovePoints = 1;
                            quick = true;
                        }
                        if (KinkyDungeonStatBind)
                            KinkyDungeonMovePoints = 0;
                        if (KinkyDungeonMovePoints >= 1) {
                            if (Enemy && allowPass) {
                                KDMoveEntity(Enemy, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, true, undefined, undefined, true);
                                if (KinkyDungeonFlags.has("Passthrough"))
                                    KinkyDungeonSetFlag("Passthrough", 2);
                            }
                            newDelta = Math.max(newDelta, KinkyDungeonMoveTo(moveX, moveY, SuppressSprint));
                            KinkyDungeonLastAction = "Move";
                            moved = true;
                            if (KDToggles.Sound) {
                                if (quick) {
                                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Miss.ogg");
                                }
                                else {
                                    if (moveObject == 'w')
                                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/FootstepWater.ogg");
                                    else
                                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Footstep.ogg");
                                }
                            }
                            if (moveObject == 'g') {
                                KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonGrateEnter"), "white", 3);
                                KinkyDungeonSlowMoveTurns = Math.max(KinkyDungeonSlowMoveTurns, 1);
                                KDGameData.SleepTurns = CommonTime() + 250;
                            }
                        }
                        let plugLevel = Math.round(Math.min(3, KinkyDungeonStatPlugLevel));
                        let dict = KinkyDungeonPlugCount > 1 ? "plugs" : "plug";
                        let dicts = KinkyDungeonPlugCount > 1 ? "" : "s";
                        if (KinkyDungeonSlowLevel == 0 && KinkyDungeonPlugCount > 0)
                            KinkyDungeonSendTextMessage(0, TextGet("KinkyDungeonPlugWalk" + plugLevel).replace("plugs", dict).replace("(s)", dicts), "yellow", 2, true);
                        if (KinkyDungeonSlowLevel == 1 && !KinkyDungeonStatsChoice.has("HeelWalker"))
                            KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonSlowed" + plugLevel).replace("plugs", dict).replace("(s)", dicts), "yellow", 2, true);
                        else if (KinkyDungeonSlowLevel == 2)
                            KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonHopping" + plugLevel).replace("plugs", dict).replace("(s)", dicts), "orange", 2, true);
                        else if (KinkyDungeonSlowLevel == 3)
                            KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonInching" + plugLevel).replace("plugs", dict).replace("(s)", dicts), "#ff0000", 2, true);
                        else if (KinkyDungeonSlowLevel > 3 && KinkyDungeonSlowLevel < 10)
                            KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonCrawling" + plugLevel).replace("plugs", dict).replace("(s)", dicts), "#ff0000", 2, true);
                        else if (KinkyDungeonSlowLevel >= 10)
                            KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonCantMove" + plugLevel).replace("plugs", dict).replace("(s)", dicts), "#ff0000", 2, true);
                        let moveMult = Math.max(1, KinkyDungeonSlowLevel);
                        if (KinkyDungeonStatsChoice.has("Quickness")) {
                            KinkyDungeonSetFlag("BlockQuicknessPerk", 3 + moveMult);
                        }
                        if (quick)
                            moveMult = 1;
                        if (KinkyDungeonSlowLevel > 9)
                            moveMult = 1;
                        if ((moveDirection.x != 0 || moveDirection.y != 0)) {
                            if (KinkyDungeonSlowLevel > 1 || (!KinkyDungeonStatsChoice.has("HeelWalker") && KinkyDungeonSlowLevel > 0)) {
                                if (KinkyDungeonSlowLevel < 10) {
                                    KinkyDungeonChangeStamina(moveMult * (KinkyDungeonStatStaminaRegenPerSlowLevel * KinkyDungeonSlowLevel) * delta, false, moveMult, true);
                                }
                            }
                            let plugIncreaseAmount = (KinkyDungeonStatPlugLevel * KinkyDungeonDistractionPerPlug);
                            KinkyDungeonStatDistraction += plugIncreaseAmount;
                            if (plugIncreaseAmount > 0)
                                KinkyDungeonStatDistractionLower += plugIncreaseAmount * 0.2;
                            if (KinkyDungeonHasCrotchRope) {
                                if (KinkyDungeonStatPlugLevel == 0)
                                    KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonCrotchRope"), "pink", 2);
                                KinkyDungeonStatDistraction += (KinkyDungeonCrotchRopeDistraction);
                                if (moveMult > 0)
                                    KinkyDungeonStatDistractionLower += (KinkyDungeonCrotchRopeDistraction) * 0.2;
                            }
                        }
                        else if (KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax) {
                            KinkyDungeonWaitMessage();
                        }
                        KinkyDungeonMovePoints = Math.min(KinkyDungeonMovePoints + 1, 0);
                        if (moveObject == 'R') {
                            if (KDToggles.Sound)
                                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Coins.ogg");
                            KinkyDungeonLoot(MiniGameKinkyDungeonLevel, MiniGameKinkyDungeonCheckpoint, "rubble");
                            KinkyDungeonMapSet(moveX, moveY, 'r');
                            KinkyDungeonAggroAction('rubble', {});
                        }
                    }
                    KinkyDungeonAdvanceTime(quick ? 0 : 1);
                }
                KinkyDungeonInterruptSleep();
                if (newDelta > 1 && newDelta < 10 && !quick) {
                    KinkyDungeonSlowMoveTurns = newDelta - 1;
                    KinkyDungeonSleepTime = CommonTime() + 200;
                }
            }
            else {
                KinkyDungeonMovePoints = Math.min(KinkyDungeonMovePoints + 1, 0);
                KinkyDungeonWaitMessage();
                KinkyDungeonAdvanceTime(1);
            }
        }
        else if (KinkyDungeonGroundItems.some((item) => { return item.x == moveX && item.y == moveY; })) {
            KinkyDungeonItemCheck(moveX, moveY, MiniGameKinkyDungeonLevel);
            KinkyDungeonInterruptSleep();
            KinkyDungeonAdvanceTime(1);
        }
        else {
            if (KinkyDungeonGetVisionRadius() <= 1) {
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Footstep.ogg");
                KinkyDungeonSendActionMessage(2, TextGet("KDWallBump"), "white", 2);
                KinkyDungeonInterruptSleep();
                KinkyDungeonAdvanceTime(1);
            }
        }
    }
    KinkyDungeonLastMoveDirection = moveDirection;
    return moved;
}
function KinkyDungeonWaitMessage(NoTime) {
    if (!KDIsAutoAction()) {
        if (KinkyDungeonStatWillpowerExhaustion > 1)
            KinkyDungeonSendActionMessage(3, TextGet("WaitSpellExhaustion"), "orange", 2);
        else if (!KinkyDungeonHasStamina(2.5, false))
            KinkyDungeonSendActionMessage(1, TextGet("WaitExhaustion"
                + (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.33 ?
                    ((KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.67 ?
                        "ArousedHeavy"
                        : "Aroused"))
                    : "")), "yellow", 2);
        else
            KinkyDungeonSendActionMessage(1, TextGet("Wait" + (KinkyDungeonStatDistraction > 12 ? "Aroused" : "")), "silver", 2);
    }
    if (!NoTime && KinkyDungeonStatStamina < KinkyDungeoNStatStaminaLow)
        KinkyDungeonStatStamina += KinkyDungeonStatStaminaRegenWait;
    KinkyDungeonLastAction = "Wait";
    KinkyDungeonTrapMoved = false;
}
function KinkyDungeonMoveTo(moveX, moveY, SuppressSprint) {
    let stepOff = false;
    let xx = KinkyDungeonPlayerEntity.x;
    let yy = KinkyDungeonPlayerEntity.y;
    if (KinkyDungeonPlayerEntity.x != moveX || KinkyDungeonPlayerEntity.y != moveY) {
        KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "move", 1);
        stepOff = true;
    }
    if (xx != moveX || yy != moveY) {
        KinkyDungeonTrapMoved = true;
    }
    let willSprint = KinkyDungeonToggleAutoSprint && (xx != moveX || yy != moveY) && !SuppressSprint;
    let cencelled = !KinkyDungeonUpdateTether(true, KinkyDungeonPlayerEntity, moveX, moveY) ? KDMovePlayer(moveX, moveY, true, willSprint) : true;
    if (stepOff)
        KinkyDungeonHandleStepOffTraps(KinkyDungeonPlayerEntity, xx, yy, moveX, moveY);
    KinkyDungeonMovePoints = 0;
    KinkyDungeonSetFlag("Quickness", 0);
    if (KinkyDungeonStatsChoice.has("Quickness")) {
        KinkyDungeonSetFlag("BlockQuicknessPerk", 4);
    }
    if (!cencelled && willSprint) {
        if (KDCanSprint()) {
            let unblocked = KinkyDungeonSlowLevel > 1;
            if (!unblocked) {
                let nextPosX = moveX * 2 - xx;
                let nextPosY = moveY * 2 - yy;
                let nextTile = KinkyDungeonMapGet(nextPosX, nextPosY);
                if (KinkyDungeonMovableTilesEnemy.includes(nextTile) && KinkyDungeonNoEnemy(nextPosX, nextPosY)) {
                    unblocked = true;
                }
            }
            if (unblocked) {
                let data = {
                    player: KinkyDungeonPlayerEntity,
                    xTo: moveX * 2 - xx,
                    yTo: moveY * 2 - yy,
                    cancelSprint: false,
                    sprintCostMult: KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SprintEfficiency")),
                };
                KinkyDungeonSendEvent("sprint", data);
                if (!data.cancelSprint) {
                    KinkyDungeonChangeStamina((-KDSprintCostBase - KDSprintCostSlowLevel[Math.round(KinkyDungeonSlowLevel)]) * data.sprintCostMult, false, 1);
                    KinkyDungeonSendActionMessage(5, TextGet("KDSprinting" + (KinkyDungeonSlowLevel > 1 ? "Hop" : "")), "lightgreen", 2);
                    if (KinkyDungeonSlowLevel < 2) {
                        KinkyDungeonTrapMoved = true;
                        KDMovePlayer(moveX * 2 - xx, moveY * 2 - yy, true);
                    }
                }
            }
            return 1;
        }
    }
    return Math.max(1, KinkyDungeonSlowLevel);
}
function KDCanSprint() {
    return KinkyDungeonSlowLevel < 4 && KinkyDungeonHasStamina(KDSprintCostBase + KDSprintCostSlowLevel[Math.min(Math.round(KinkyDungeonSlowLevel), KDSprintCostSlowLevel.length)]) && KinkyDungeonCanStand();
}
let KinkyDungeonLastAction = "";
let KinkyDungeonLastTurnAction = "";
let KDDrawUpdate = 0;
let KDVisionUpdate = 0;
let KDLastTick = 0;
function KinkyDungeonAdvanceTime(delta, NoUpdate, NoMsgTick) {
    KDUpdateFog = true;
    KDLastTick = performance.now();
    if (delta > 0 && CommonTime() > lastFloaterRefresh + 1000) {
        KDEntitiesFloaterRegisty = new Map();
        lastFloaterRefresh = CommonTime();
    }
    let _CharacterRefresh = CharacterRefresh;
    let _CharacterAppearanceBuildCanvas = CharacterAppearanceBuildCanvas;
    CharacterRefresh = () => { KDRefresh = true; };
    CharacterAppearanceBuildCanvas = () => { };
    let start = performance.now();
    if (KinkyDungeonMovePoints < -1 && KDGameData.KinkyDungeonLeashedPlayer < 1)
        KinkyDungeonMovePoints += delta;
    if (delta > 0) {
        KDDrawUpdate = delta;
        KDVisionUpdate = delta;
    }
    KDRecentRepIndex = 0;
    KinkyDungeonRestraintAdded = false;
    KinkyDungeonSFX = [];
    KDPlayerHitBy = [];
    KinkyDungeonUpdateAngel(delta);
    KinkyDungeonUpdateTether(true, KinkyDungeonPlayerEntity);
    KinkyDungeonResetEventVariablesTick(delta);
    KinkyDungeonSendEvent("tick", { delta: delta });
    KinkyDungeonUpdateLightGrid = true;
    if (!NoMsgTick) {
        if (KinkyDungeonTextMessageTime > 0)
            KinkyDungeonTextMessageTime -= 1;
        if (KinkyDungeonTextMessageTime <= 0)
            KinkyDungeonTextMessagePriority = 0;
        if (KinkyDungeonActionMessageTime > 0)
            KinkyDungeonActionMessageTime -= 1;
        if (KinkyDungeonActionMessageTime <= 0)
            KinkyDungeonActionMessagePriority = 0;
    }
    KinkyDungeonCurrentTick += 1;
    if (KinkyDungeonCurrentTick > 100000)
        KinkyDungeonCurrentTick = 0;
    KinkyDungeonItemCheck(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, MiniGameKinkyDungeonLevel);
    KinkyDungeonUpdateBuffs(delta);
    KinkyDungeonUpdateEnemies(delta, true);
    KinkyDungeonSendEvent("afterEnemyTick", { delta: delta, allied: true });
    KinkyDungeonUpdateBullets(delta, true);
    KinkyDungeonUpdateBulletsCollisions(delta);
    KinkyDungeonUpdateEnemies(delta, false);
    KinkyDungeonSendEvent("afterEnemyTick", { delta: delta, allied: false });
    KinkyDungeonUpdateTether(true, KinkyDungeonPlayerEntity);
    KinkyDungeonUpdateBullets(delta);
    KinkyDungeonUpdateBulletsCollisions(delta, true);
    KinkyDungeonUpdateJailKeys();
    KDUpdateEffectTiles(delta);
    KinkyDungeonUpdateTileEffects(delta);
    for (let E = 0; E < KinkyDungeonEntities.length; E++) {
        let enemy = KinkyDungeonEntities[E];
        if (KinkyDungeonEnemyCheckHP(enemy, E)) {
            E -= 1;
            continue;
        }
    }
    KinkyDungeonUpdateStats(delta);
    let toTile = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
    KinkyDungeonHandleMoveToTile(toTile);
    if (!KDGameData.DelayedActions)
        KDGameData.DelayedActions = [];
    let runActions = Object.assign([], KDGameData.DelayedActions);
    KDGameData.DelayedActions = KDGameData.DelayedActions.filter((action) => {
        return action.time - delta > 0;
    });
    for (let action of runActions) {
        action.time -= delta;
        if (action.time <= 0) {
            if (KDDelayedActionCommit[action.commit]) {
                KDDelayedActionCommit[action.commit](action);
            }
        }
        else if (action.update && KDDelayedActionUpdate[action.update]) {
            KDDelayedActionUpdate[action.update](action);
        }
    }
    if (!NoUpdate)
        KinkyDungeonMultiplayerUpdate(KinkyDungeonNextDataSendTimeDelay);
    if (KinkyDungeonStatStamina < 5) {
        let msg = "KinkyDungeonStaminaWarningMed";
        if (KinkyDungeonStatStamina < 2.5)
            msg = "KinkyDungeonStaminaWarningLow";
        if (KinkyDungeonStatStamina < 1)
            msg = "KinkyDungeonStaminaWarningNone";
        if (!KinkyDungeonSendActionMessage(1, TextGet(msg), "#448844", 1, true))
            KinkyDungeonSendTextMessage(1, TextGet(msg), "#448844", 1, true);
    }
    let gagchance = KinkyDungeonGagMumbleChance;
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv))
            gagchance += KinkyDungeonGagMumbleChancePerRestraint;
    }
    if (!KinkyDungeonCanTalk() && KDRandom() < gagchance) {
        let msg = "KinkyDungeonGagMumble";
        let gagMsg = Math.floor(KDRandom() * 5);
        const GagEffect = KinkyDungeonGagTotal() * 5;
        gagMsg += GagEffect;
        gagMsg = Math.max(0, Math.min(7, Math.floor(gagMsg)));
        if (KDRandom() < KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax)
            msg = "KinkyDungeonGagMumbleAroused";
        msg = msg + gagMsg;
        KinkyDungeonSendDialogue(KinkyDungeonPlayerEntity, TextGet(msg), "#ffffff", 2, 0);
    }
    let end = performance.now();
    if (KDDebug)
        console.log(`Tick ${KinkyDungeonCurrentTick} took ${(end - start)} milliseconds.`);
    KinkyDungeonLastTurnAction = KinkyDungeonLastAction;
    KinkyDungeonLastAction = "";
    if (KDGameData.AncientEnergyLevel > 1)
        KDGameData.AncientEnergyLevel = 1;
    KinkyDungeonUpdateBulletVisuals(delta);
    CharacterRefresh = _CharacterRefresh;
    CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
    if (KinkyDungeonInDanger())
        KinkyDungeonSetFlag("DangerFlag", 3);
    if (KinkyDungeonStatsChoice.has("Quickness") && !KinkyDungeonFlags.has("BlockQuicknessPerk")) {
        KinkyDungeonSetFlag("Quickness", -1);
    }
    if (KinkyDungeonMovePoints < 0 || KinkyDungeonStatBlind) {
        KinkyDungeonSetFlag("Quickness", 0);
    }
    KinkyDungeonSendEvent("tickAfter", { delta: delta });
    KinkyDungeonUpdateStats(0);
    let Dstart = performance.now();
    KinkyDungeonDressPlayer();
    if (KDDebug)
        console.log(`Dressing ${KinkyDungeonCurrentTick} took ${(performance.now() - Dstart)} milliseconds.`);
    KDGetEnemyCache();
    KDAllowDialogue = true;
}
let KDAllowDialogue = true;
let lastFloaterRefresh = 0;
function KinkyDungeonTargetTileMsg() {
    if (KDObjectMessages[KinkyDungeonTargetTile.Type]) {
        KDObjectMessages[KinkyDungeonTargetTile.Type]();
    }
    else if (KinkyDungeonTargetTile.Lock) {
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Locked.ogg");
        KinkyDungeonSendTextMessage(8, TextGet("KinkyDungeonObjectLock").replace("TYPE", TextGet("KinkyDungeonShrine" + KinkyDungeonTargetTile.Name)), "#ffffff", 1, true);
    }
    else {
        let suff = "";
        if (KinkyDungeonTargetTile.Name == "Commerce")
            suff = "Commerce";
        KinkyDungeonSendTextMessage(8, TextGet("KinkyDungeonObject" + KinkyDungeonTargetTile.Type + suff).replace("TYPE", TextGet("KinkyDungeonShrine" + KinkyDungeonTargetTile.Name)), "#ffffff", 1, true);
    }
}
function KDAddAppearance(C, Group, ItemAsset, NewColor, DifficultyFactor, ItemMemberNumber, Refresh, item) {
    DifficultyFactor = 0;
    let data = {
        color: NewColor,
        item: item,
    };
    KinkyDungeonSendEvent("onWear", data);
    if (ItemAsset != null) {
        const NA = {
            Asset: ItemAsset,
            Difficulty: parseInt((ItemAsset.Difficulty == null) ? 0 : ItemAsset.Difficulty) + parseInt(DifficultyFactor),
            Color: data.color,
            Property: ItemAsset.CharacterRestricted ? { ItemMemberNumber: ItemMemberNumber == null ? -1 : ItemMemberNumber } : undefined
        };
        C.Appearance.push(NA);
        return NA;
    }
    return null;
}
function KDAddModel(C, Group, ItemModel, NewColor, filters, item) {
    let data = {
        color: NewColor,
        item: item,
    };
    KinkyDungeonSendEvent("onWear", data);
    if (ItemModel != null) {
        const NA = {
            Model: JSON.parse(JSON.stringify(ItemModel)),
            Difficulty: 0,
            Color: data.color,
            Property: undefined,
            Filters: filters,
        };
        NA.Model.Filters = NA.Filters || NA.Model.Filters;
        C.Appearance.push(NA);
        return NA;
    }
    return null;
}
function KinkyDungeonCloseDoor(data) {
    KinkyDungeonTargetTileLocation = data.targetTile;
    KinkyDungeonTargetTile = null;
    KinkyDungeonMapSet(parseInt(KinkyDungeonTargetTileLocation.split(',')[0]), parseInt(KinkyDungeonTargetTileLocation.split(',')[1]), "D");
    KinkyDungeonTargetTileLocation = "";
    if (KDToggles.Sound)
        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/DoorClose.ogg");
    if (!KDLastKeyTime[KinkyDungeonKeyToggle[2]])
        KinkyDungeonToggleAutoDoor = false;
    KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonCloseDoorDone"), "white", 2);
    KinkyDungeonAdvanceTime(1, true);
    KinkyDungeonMultiplayerUpdate(KinkyDungeonNextDataSendTimeDelay);
}
let KDEnemyCache = null;
let KDUpdateEnemyCache = true;
function KDGetEnemyCache() {
    if (KDUpdateEnemyCache || !KDEnemyCache) {
        KDUpdateEnemyCache = false;
        KDEnemyCache = new Map();
        for (let e of KinkyDungeonEntities) {
            KDEnemyCache.set(e.x + "," + e.y, e);
        }
    }
    return KDEnemyCache;
}
let KDTileQuery = "";
let KDTileLast = null;
function KDTile(x, y) {
    if (x == undefined)
        x = KinkyDungeonPlayerEntity.x;
    if (y == undefined)
        y = KinkyDungeonPlayerEntity.y;
    let q = x + "," + y;
    if (q == KDTileQuery)
        return KDTileLast;
    else {
        let t = KinkyDungeonTilesGet(q);
        KDTileLast = t;
        KDTileQuery = q;
        return t;
    }
}
function KDTileDelete(x, y) {
    if (x == undefined)
        x = KinkyDungeonPlayerEntity.x;
    if (y == undefined)
        y = KinkyDungeonPlayerEntity.y;
    KinkyDungeonTilesDelete(x + "," + y);
}
function KDStunTurns(turns, noFlag) {
    if (!noFlag)
        KinkyDungeonSetFlag("playerStun", turns + 1);
    KinkyDungeonSlowMoveTurns = Math.max(KinkyDungeonSlowMoveTurns, turns);
    KinkyDungeonSleepTime = CommonTime() + 200;
}
function KDKneelTurns(turns) {
    KinkyDungeonSetFlag("playerStun", turns + 1);
    KDGameData.KneelTurns = Math.max(KDGameData.KneelTurns || 0, turns);
}
function KDGetByWeight(list) {
    let WeightTotal = 0;
    let Weights = [];
    let type = "";
    for (let obj of Object.entries(list)) {
        Weights.push({ obj: obj[0], weight: WeightTotal });
        WeightTotal += obj[1];
    }
    let selection = KDRandom() * WeightTotal;
    for (let L = Weights.length - 1; L >= 0; L--) {
        if (selection > Weights[L].weight) {
            type = Weights[L].obj;
            break;
        }
    }
    return type;
}
let KDKeyCheckers = {
    "Toggles": () => {
        if (KinkyDungeonState == 'Game' && KinkyDungeonDrawState == 'Game' && KinkyDungeonKeyToggle.includes(KinkyDungeonKeybindingCurrentKey)) {
            switch (KinkyDungeonKeybindingCurrentKey) {
                case KinkyDungeonKeyToggle[0]:
                    KinkyDungeonMessageToggle = !KinkyDungeonMessageToggle;
                    break;
                case KinkyDungeonKeyToggle[1]:
                    KinkyDungeonToggleAutoPass = !KinkyDungeonToggleAutoPass;
                    break;
                case KinkyDungeonKeyToggle[2]:
                    KinkyDungeonToggleAutoDoor = !KinkyDungeonToggleAutoDoor;
                    break;
                case KinkyDungeonKeyToggle[3]:
                    KDAutoStruggleClick();
                    break;
                case KinkyDungeonKeyToggle[4]:
                    KinkyDungeonFastMove = !KinkyDungeonFastMove;
                    break;
                case KinkyDungeonKeyToggle[5]:
                    KinkyDungeonInspect = !KinkyDungeonInspect;
                    break;
            }
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
            return true;
        }
    },
    "Shop": () => {
        if (KinkyDungeonState == 'Game' && KinkyDungeonDrawState == 'Game' && (KinkyDungeonTargetTile === null || KinkyDungeonTargetTile === void 0 ? void 0 : KinkyDungeonTargetTile.Type) == "Shrine" && KinkyDungeonTargetTile.Name == "Commerce") {
            if (KinkyDungeonKey[0] == KinkyDungeonKeybindingCurrentKey) {
                KinkyDungeonShopIndex = (KinkyDungeonShopIndex + 1) % KDGameData.ShopItems.length;
                KDShopBuyConfirm = false;
                return true;
            }
            else if (KinkyDungeonKey[2] == KinkyDungeonKeybindingCurrentKey) {
                KinkyDungeonShopIndex = KinkyDungeonShopIndex - 1;
                if (KinkyDungeonShopIndex < 0)
                    KinkyDungeonShopIndex = KDGameData.ShopItems.length - 1;
                KDShopBuyConfirm = false;
                return true;
            }
            else if (KinkyDungeonKey[3] == KinkyDungeonKeybindingCurrentKey || KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey) {
                let cost = KinkyDungeonShrineCost("Commerce");
                if (cost <= KinkyDungeonGold) {
                    if (!KDShopBuyConfirm)
                        KDShopBuyConfirm = true;
                    else {
                        KDSendInput("shrineBuy", { type: "Commerce", shopIndex: KinkyDungeonShopIndex });
                        KDShopBuyConfirm = false;
                    }
                }
                return true;
            }
            else if (KinkyDungeonKey[1] == KinkyDungeonKeybindingCurrentKey) {
                KDShopBuyConfirm = false;
                return true;
            }
        }
    },
    "Dialogue": () => {
        if (KDGameData.CurrentDialog && !(KinkyDungeonSlowMoveTurns > 0)) {
            if (KinkyDungeonState == 'Game' && KinkyDungeonDrawState == 'Game' && KDGameData.CurrentDialog) {
                if (KinkyDungeonKey[2] == KinkyDungeonKeybindingCurrentKey) {
                    KDDialogueData.CurrentDialogueIndex += 1;
                    return true;
                }
                else if (KinkyDungeonKey[0] == KinkyDungeonKeybindingCurrentKey) {
                    KDDialogueData.CurrentDialogueIndex = Math.max(0, KDDialogueData.CurrentDialogueIndex - 1);
                    return true;
                }
                else if (KinkyDungeonKeyEnter[0] == KinkyDungeonKeybindingCurrentKey) {
                    KDClickButton("dialogue" + KDDialogueData.CurrentDialogueIndex);
                    return true;
                }
                else if (KinkyDungeonKeySkip[0] == KinkyDungeonKeybindingCurrentKey) {
                    let dialogue = KDGetDialogue();
                    if (dialogue.options) {
                        let entries = Object.entries(dialogue.options);
                        let II = 0;
                        let gagged = KDDialogueGagged();
                        for (let i = KDOptionOffset; i < entries.length && II < KDMaxDialogue; i++) {
                            if ((!entries[i][1].prerequisiteFunction || entries[i][1].prerequisiteFunction(gagged, KinkyDungeonPlayerEntity))
                                && (!entries[i][1].gagRequired || gagged)
                                && (!entries[i][1].gagDisabled || !gagged)) {
                                if (entries[i][0] == "Leave" || entries[i][0] == "Continue" || entries[i][1].skip) {
                                    KDClickButton("dialogue" + i);
                                    return true;
                                }
                            }
                        }
                    }
                    return true;
                }
            }
        }
    },
};
function KDGetAltType(Floor) {
    let mapMod = null;
    if (KDGameData.MapMod) {
        mapMod = KDMapMods[KDGameData.MapMod];
    }
    let altRoom = KDGameData.RoomType;
    let altType = altRoom ? KinkyDungeonAltFloor((mapMod && mapMod.altRoom) ? mapMod.altRoom : altRoom) : KinkyDungeonBossFloor(Floor);
    return altType;
}
function KDCanPassEnemy(player, Enemy) {
    return !KDIsImmobile(Enemy)
        && ((!KinkyDungeonAggressive(Enemy) && !Enemy.playWithPlayer) || (KDHelpless(Enemy)))
        && (KinkyDungeonToggleAutoPass || KDEnemyHasFlag(Enemy, "passthrough") || (KinkyDungeonFlags.has("Passthrough")) || Enemy.Enemy.noblockplayer);
}
let KDVibeSounds = {
    "ItemVulva": { sound: "", Audio: null, update: false },
    "ItemButt": { sound: "", Audio: null, update: false },
    "ItemNipples": { sound: "", Audio: null, update: false, vol: 0.5 },
};
let KDVibeSoundRedirect = {
    "ItemVulva": "ItemVulva",
    "ItemVulvaPiercings": "ItemNipples",
    "ItemButt": "ItemButt",
    "ItemNipplesPiercings": "ItemNipples",
    "ItemNipples": "ItemNipples",
    "ItemPelvis": "ItemNipples",
    "ItemBreast": "ItemNipples",
    "ItemBoots": "ItemNipples",
};
let KDVibeSound = {
    "ItemVulva": "Vibe1",
    "ItemButt": "Vibe2",
    "ItemNipples": "Vibe3",
};
let KDVibeVolume = 1;
let KDVibeVolumeListIndex = 0;
let KDVibeVolumeList = [1, 0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
let KDMusicVolumeMult = 0.25;
let KDMusicVolume = 1;
let KDMusicVolumeListIndex = 0;
let KDMusicVolumeList = [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0, 0.1, 0.2];
let KDSfxVolume = 1;
let KDSfxVolumeListIndex = 0;
let KDSfxVolumeList = [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0, 0.1, 0.2];
let KDAnimSpeed = 1;
let KDAnimSpeedListIndex = 0;
let KDAnimSpeedList = [1, 1.25, 1.5, 2.0, 0, 0.25, 0.5, 0.75,];
function KDStopAllVibeSounds(Exceptions) {
    let EE = [];
    if (Exceptions)
        for (let e of Exceptions) {
            EE.push(KDVibeSoundRedirect[e] ? KDVibeSoundRedirect[e] : e);
        }
    for (let loc of Object.entries(KDVibeSounds)) {
        if (!Exceptions || !EE.includes(loc[0])) {
            if (!loc[1].update) {
                let audio = loc[1];
                if (audio.sound)
                    audio.sound = "";
                if (audio.Audio) {
                    audio.Audio.pause();
                    audio.Audio.currentTime = 0;
                }
                loc[1].update = true;
            }
        }
    }
}
function KDUpdateVibeSound(Location, Sound, Volume) {
    let prev = "";
    if (KDVibeSounds[Location]) {
        prev = KDVibeSounds[Location].sound;
    }
    if (KDVibeSounds[Location])
        KDVibeSounds[Location].sound = Sound;
    else
        return;
    if (prev != Sound) {
        if (prev && KDVibeSounds[Location].Audio && !KDVibeSounds[Location].update) {
            KDVibeSounds[Location].Audio.pause();
            KDVibeSounds[Location].Audio.currentTime = 0;
        }
        if (Sound && !KDVibeSounds[Location].update) {
            let audio = new Audio();
            let vol = Player.AudioSettings.Volume * (Volume != undefined ? Volume : 1.0);
            if (KDVibeSounds[Location].vol)
                vol *= KDVibeSounds[Location].vol;
            KDVibeSounds[Location].Audio = audio;
            KDVibeSounds[Location].update = true;
            if (ServerURL == 'foobar') {
                audio.crossOrigin = "Anonymous";
                audio.src = remap(Sound);
            }
            else
                audio.src = KDModFiles[Sound] || Sound;
            audio.volume = Math.min(vol, 1);
            audio.loop = true;
            audio.play();
        }
    }
    if (!Sound && KDVibeSounds[Location].Audio && !KDVibeSounds[Location].update) {
        KDVibeSounds[Location].Audio.pause();
        KDVibeSounds[Location].Audio.currentTime = 0;
        KDVibeSounds[Location].update = true;
    }
    if (Volume != undefined && KDVibeSounds[Location] && KDVibeSounds[Location].Audio) {
        KDVibeSounds[Location].Audio.volume = Math.min(Player.AudioSettings.Volume * Volume * (KDVibeSounds[Location].vol ? KDVibeSounds[Location].vol : 1.0), 1);
    }
}
function KDUpdateVibeSounds() {
    for (let v of Object.entries(KDVibeSounds)) {
        v[1].update = false;
    }
    let vibe = KDGameData.CurrentVibration;
    if (vibe && KinkyDungeonState == "Game" && KDToggles.Sound) {
        let globalVolume = KDToggles.VibeSounds ? KDVibeVolume * (KinkyDungeonDrawState == "Game" ? 1 : 0.5) : 0;
        let locations = KDSumVibeLocations();
        KDStopAllVibeSounds(locations);
        for (let location of locations) {
            let power = "Weak";
            if (vibe.location && vibe.location.includes(location)) {
                if (vibe.intensity >= 3)
                    power = "Strong";
                else if (vibe.intensity >= 2)
                    power = "Medium";
            }
            else if (vibe.VibeModifiers) {
                for (let mod of vibe.VibeModifiers) {
                    if (mod.location == location) {
                        if (mod.intensityMod >= 3 || mod.intensitySetpoint >= 3)
                            power = "Strong";
                        else if (mod.intensityMod >= 2 || mod.intensitySetpoint >= 2)
                            power = "Medium";
                    }
                }
            }
            if (KinkyDungeonVibeLevel <= 0) {
                power = "Off";
            }
            if (power != "Off") {
                let sound = (KDVibeSoundRedirect[location] && KDVibeSound[KDVibeSoundRedirect[location]]) ? KDVibeSound[KDVibeSoundRedirect[location]] : "Vibe1";
                KDUpdateVibeSound(KDVibeSoundRedirect[location] ? KDVibeSoundRedirect[location] : "ItemVulva", KinkyDungeonRootDirectory + `Audio/${sound}_${power}.ogg`, globalVolume);
            }
            else
                KDUpdateVibeSound(KDVibeSoundRedirect[location] ? KDVibeSoundRedirect[location] : "ItemVulva", "", globalVolume);
        }
    }
    else {
        KDStopAllVibeSounds();
    }
}
function KDSumVibeLocations() {
    if (KDGameData.CurrentVibration) {
        let groups = [];
        for (let g of KDGameData.CurrentVibration.location) {
            groups.push(g);
        }
        for (let mod of KDGameData.CurrentVibration.VibeModifiers) {
            if (!groups.includes(mod.location))
                groups.push(mod.location);
        }
        return groups;
    }
    return [];
}
function KDGetVibeLocation(item) {
    let restraint = KDRestraint(item);
    let groups = [restraint.vibeLocation ? restraint.vibeLocation : restraint.Group];
    if (restraint.linkedVibeTags) {
        for (let tag of restraint.linkedVibeTags) {
            for (let inv of KinkyDungeonAllRestraint()) {
                let res = KDRestraint(inv);
                if (res.linkedVibeTags && res.linkedVibeTags.includes(tag) && !groups.includes(res.vibeLocation ? res.vibeLocation : res.Group)) {
                    groups.push(res.vibeLocation ? res.vibeLocation : res.Group);
                }
            }
        }
    }
    return groups;
}
function KinkyDungeonStartVibration(source, name, locations, intensity, duration, numLoops, denyTime, denialsLeft, edgeTime, edgeOnly, alwaysDeny, denialChance, denialChanceLikely, tickEdgeAtMaxArousal, vibeMods) {
    if (KDGameData.CurrentVibration) {
        KinkyDungeonSetFlag("VibeContinued", 3);
        if (!KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonStartVibeContinue"), "#FFaadd", 2))
            KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonStartVibeContinue"), "#FFaadd", 2, true, true);
    }
    else {
        KinkyDungeonSetFlag("VibeStarted", 8);
    }
    KDGameData.CurrentVibration = {
        source: source,
        name: name,
        location: locations,
        intensity: intensity,
        duration: duration,
        durationLeft: duration,
        loopsLeft: numLoops,
        denyTime: denyTime,
        denyTimeLeft: 0,
        edgeTime: edgeTime,
        edgeTimeLeft: edgeTime,
        edgeOnly: edgeOnly,
        alwaysDeny: alwaysDeny,
        tickEdgeAtMaxArousal: tickEdgeAtMaxArousal,
        denialChance: denialChance,
        denialChanceLikely: denialChanceLikely,
        denialsLeft: denialsLeft,
        VibeModifiers: vibeMods ? vibeMods : [],
    };
    if (!KDGameData.TimeSinceLastVibeStart)
        KDGameData.TimeSinceLastVibeStart = {};
    KDGameData.TimeSinceLastVibeStart[name] = 0;
}
function KDIsVibeCD(cooldown) {
    if (!KDGameData.TimeSinceLastVibeStart)
        KDGameData.TimeSinceLastVibeStart = {};
    if (!KDGameData.TimeSinceLastVibeEnd)
        KDGameData.TimeSinceLastVibeEnd = {};
    let pass = true;
    for (let cd of Object.entries(cooldown)) {
        if (KDGameData.TimeSinceLastVibeStart[cd[0]] && KDGameData.TimeSinceLastVibeStart[cd[0]] < cd[1] && KDGameData.TimeSinceLastVibeEnd[cd[0]] && KDGameData.TimeSinceLastVibeEnd[cd[0]] < cd[1]) {
            pass = false;
            break;
        }
    }
    return pass;
}
function KinkyDungeonAddVibeModifier(source, name, location, intensityMod, duration, intensitySetpoint, edgeOnly, forceDeny, bypassDeny, bypassEdge, extendDuration, denyChanceMod, denyChanceLikelyMod) {
    if (KDGameData.CurrentVibration) {
        for (let mod of KDGameData.CurrentVibration.VibeModifiers) {
            if (mod.name == name && mod.source == source) {
                KDGameData.CurrentVibration.VibeModifiers.splice(KDGameData.CurrentVibration.VibeModifiers.indexOf(mod));
                break;
            }
        }
        KDGameData.CurrentVibration.VibeModifiers.push({
            source: source,
            name: name,
            location: location,
            intensityMod: intensityMod,
            duration: duration,
            durationLeft: duration,
            intensitySetpoint: intensitySetpoint,
            edgeOnly: edgeOnly,
            forceDeny: forceDeny,
            bypassDeny: bypassDeny,
            bypassEdge: bypassEdge,
            extendDuration: extendDuration,
            denyChanceMod: denyChanceMod,
            denyChanceLikelyMod: denyChanceLikelyMod,
        });
    }
}
function KinkyDungeonGetDenyChance(chance) {
    if (!KDGameData.CurrentVibration)
        return 0;
    let data = {
        denyChance: KDGameData.CurrentVibration.denialChance ? KDGameData.CurrentVibration.denialChance : 0.0,
        orgasmChance: chance,
    };
    if (chance > 0) {
        if (KDGameData.CurrentVibration.denialChanceLikely)
            data.denyChance = KDGameData.CurrentVibration.denialChanceLikely;
    }
    let forceDeny = false;
    if (KDGameData.CurrentVibration.VibeModifiers) {
        for (let mod of KDGameData.CurrentVibration.VibeModifiers) {
            if (chance > 0 && mod.denyChanceLikelyMod)
                data.denyChanceLikelyMod += mod.denyChanceMod;
            else if (mod.denyChanceMod)
                data.denyChance += mod.denyChanceMod;
            if (mod.forceDeny)
                forceDeny = true;
        }
    }
    if (!forceDeny && KDGameData.CurrentVibration.denialsLeft != undefined && KDGameData.CurrentVibration.denialsLeft <= 0) {
        data.denyChance = 0;
    }
    KinkyDungeonSendEvent("getDenyChance", data);
    return data.denyChance;
}
function KinkyDungeonVibratorsDeny(chance) {
    let data = { toDeny: false };
    let allowDeny = KDRandom() < KinkyDungeonGetDenyChance(chance);
    if (allowDeny) {
        data.toDeny = true;
        KinkyDungeonSendEvent("getDeny", data);
    }
    return data.toDeny;
}
function KinkyDungeonCalculateVibeLevel(delta) {
    let oldVibe = KinkyDungeonVibeLevel;
    KinkyDungeonVibeLevel = 0;
    KinkyDungeonOrgasmVibeLevel = 0;
    KinkyDungeonStatPlugLevel = 0;
    KinkyDungeonPlugCount = 0;
    for (let item of KinkyDungeonAllRestraint()) {
        if (item && KDRestraint(item)) {
            if (KDRestraint(item).plugSize) {
                let size = KDRestraint(item).plugSize;
                KinkyDungeonStatPlugLevel = Math.max(KinkyDungeonStatPlugLevel + size / 2, size);
                KinkyDungeonPlugCount += 1;
            }
        }
    }
    KDGameData.Edged = false;
    let cease = true;
    if (KDGameData.CurrentVibration) {
        for (let r of KinkyDungeonAllRestraint()) {
            if (KDGameData.CurrentVibration.source == r.name) {
                cease = false;
                break;
            }
        }
        if (cease) {
            if (!KDGameData.TimeSinceLastVibeEnd)
                KDGameData.TimeSinceLastVibeEnd = {};
            KDGameData.TimeSinceLastVibeEnd[KDGameData.CurrentVibration.name] = 0;
            KDGameData.CurrentVibration = null;
        }
    }
    if (KDGameData.CurrentVibration) {
        let vibration = KDGameData.CurrentVibration;
        if (vibration.durationLeft > 0) {
            let edge = false;
            let bypassDeny = false;
            let bypassEdge = false;
            let extendDuration = false;
            KinkyDungeonVibeLevel = vibration.intensity;
            if (vibration.VibeModifiers) {
                let intensityMod = 0;
                let intensityModMax = 0;
                let intensityModMin = 0;
                for (let mod of vibration.VibeModifiers) {
                    if (mod.durationLeft > 0) {
                        mod.durationLeft -= delta;
                        if (mod.edgeOnly) {
                            edge = true;
                        }
                        if (mod.bypassDeny) {
                            bypassDeny = true;
                        }
                        if (mod.bypassEdge) {
                            bypassEdge = true;
                        }
                        if (mod.extendDuration) {
                            extendDuration = true;
                        }
                        if (mod.intensityMod > intensityModMax)
                            intensityModMax = mod.intensityMod;
                        if (mod.intensityMod < intensityModMin)
                            intensityModMin = mod.intensityMod;
                        intensityMod += mod.intensityMod;
                    }
                    else {
                        vibration.VibeModifiers.splice(vibration.VibeModifiers.indexOf(mod));
                    }
                }
                if (intensityMod > intensityModMax)
                    intensityMod = intensityModMax;
                if (intensityMod > intensityModMin)
                    intensityMod = intensityModMin;
                if (intensityMod) {
                    KinkyDungeonVibeLevel = Math.max(1, KinkyDungeonVibeLevel + intensityMod);
                }
            }
            if (!extendDuration)
                vibration.durationLeft -= delta;
            if (vibration.denyTimeLeft > 0) {
                vibration.denyTimeLeft -= delta;
                if (!bypassDeny) {
                    KinkyDungeonVibeLevel = 0;
                }
            }
            else if (vibration.edgeTimeLeft > 0 && (!vibration.tickEdgeAtMaxArousal || KinkyDungeonStatDistraction >= KinkyDungeonStatDistractionMax * 0.99)) {
                vibration.edgeTimeLeft -= delta;
                edge = true;
            }
            if (edge && !bypassEdge) {
                KDGameData.Edged = true;
            }
            else {
                KinkyDungeonOrgasmVibeLevel = Math.max(KinkyDungeonOrgasmVibeLevel || 0, vibration.intensity);
            }
        }
        else {
            KinkyDungeonEndVibration();
        }
    }
    if (oldVibe > 0 && KinkyDungeonVibeLevel == 0) {
        if (cease)
            if (!KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonEndVibeCease"), "#FFaadd", 2))
                KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonEndVibeCease"), "#FFaadd", 2, true, true);
        if (!KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonEndVibe"), "#FFaadd", 2))
            KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonEndVibe"), "#FFaadd", 2, true, true);
    }
    else if (oldVibe == 0 && KinkyDungeonVibeLevel > 0) {
        if (!KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonStartVibe"), "#FFaadd", 2))
            KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonStartVibe"), "#FFaadd", 2, true, true);
    }
}
function KinkyDungeonEndVibration() {
    if (KDGameData.CurrentVibration) {
        let vibe = KDGameData.CurrentVibration;
        if (vibe.loopsLeft > 0) {
            vibe.loopsLeft -= 1;
            vibe.durationLeft = vibe.duration;
        }
        else {
            if (!KDGameData.TimeSinceLastVibeEnd)
                KDGameData.TimeSinceLastVibeEnd = {};
            KDGameData.TimeSinceLastVibeEnd[KDGameData.CurrentVibration.name] = 0;
            KDGameData.CurrentVibration = null;
        }
    }
}
function KinkyDungeonCanOrgasm() {
    return !KDGameData.Edged || KinkyDungeonChastityMult() < 0.9;
}
let KDConduction = { id: "Conduction", type: "event", aura: "#ffff88", noAuraColor: true, aurasprite: "Conduction", power: 7.0, player: true, duration: 5, enemies: true, range: 2.99, events: [
        { type: "RemoveConduction", duration: 1, trigger: "tick" },
        { type: "Conduction", power: 0.5, duration: 5, damage: "electric", aoe: 3.99, trigger: "playerTakeDamage" },
        { type: "Conduction", power: 0.5, duration: 5, damage: "electric", aoe: 3.99, trigger: "beforeDamageEnemy" },
    ] };
let KDDrenched = { id: "Drenched", type: "fireDamageResist", aura: "#59a0d1", aurasprite: "Drenched", power: 0.425, player: true, duration: 20, enemies: true, events: [
        { type: "RemoveDrench", duration: 1, trigger: "tick" },
        { type: "ApplyConduction", duration: 1, trigger: "tick", kind: "invis" },
        { type: "ApplyConduction", duration: 1, trigger: "tickAfter", kind: "invis" },
    ] };
let KDBurning = { id: "Burning", type: "event", aura: "#ff8933", aurasprite: "Flaming", noAuraColor: true, power: 0.5, player: true, duration: 6, enemies: true, events: [
        { type: "RemoveBurning", trigger: "tick" },
        { type: "ElementalEffect", power: 0.5, damage: "fire", trigger: "tick" },
        { type: "EchoDamage", power: 1.0, damage: "fire", damageTrigger: "stun", trigger: "beforeDamageEnemy" },
        { type: "EchoDamage", power: 1.0, damage: "fire", damageTrigger: "stun", trigger: "playerTakeDamage" },
    ] };
let KDDisenchant1 = { id: "Disenchant1", type: "MoveSpeed", aura: "#440088", power: -0.5, player: false, duration: 9999, enemies: true };
let KDDisenchant2 = { id: "Disenchant2", type: "AttackSlow", aura: "#440088", power: 0.5, player: false, duration: 9999, enemies: true };
let KDVolcanism = { id: "Volcanism", type: "event", aura: "#ff0000", power: 0.5, player: false, duration: 9999, enemies: true, events: [
        { type: "Volcanism", power: 4.0, damage: "fire", trigger: "beforeDamageEnemy" },
    ] };
let KDDrenched2 = { id: "Drenched2", type: "electricDamageResist", power: -0.2, player: true, duration: 20, enemies: true };
let KDDrenched3 = { id: "Drenched3", type: "iceDamageResist", power: -0.35, player: true, duration: 20, enemies: true };
let KDBoundByFate = { id: "BoundByFate", type: "Fate", power: 1, player: true, duration: 3, enemies: false, aura: "#dddddd", events: [
        { type: "BoundByFate", kind: "mithrilRope", count: 2, trigger: "tick", power: 1 },
    ] };
let KDEager = {
    id: "Eager", type: "MoveSpeed", power: 0.95, duration: 1, events: [
        { type: "ApplyVuln", duration: 1, trigger: "tick" },
        { type: "ApplyVuln", duration: 1, power: -1.0, trigger: "tickAfter" },
    ]
};
let KDMasochist = {
    id: "Masochist", type: "DamageAmp", power: -1, duration: 1
};
let KDChilled = { id: "Chilled", aura: "#73efe8", type: "MoveSpeed", power: -1.0, player: true, enemies: true, duration: 2, };
let KDSlimed = {
    id: "Slimed", aura: "#dc16bc", aurasprite: "Slimed", noAuraColor: true, type: "SlimeProgress", power: 1.0, player: true, enemies: true, duration: 3, range: 0.5, hideHelpless: true, tags: ["slimed"], events: [
        { type: "RemoveSlimeWalk", duration: 1, trigger: "tick" },
        { type: "Flammable", trigger: "beforeDamageEnemy" },
        { type: "Flammable", trigger: "beforePlayerDamage" },
        { type: "ApplySlowed", duration: 1, power: -1.0, trigger: "tick" },
        { type: "ApplySlowed", duration: 1, power: -1.0, trigger: "tickAfter" },
        { type: "ApplyGlueVuln", duration: 1, power: -0.3, trigger: "tick" },
        { type: "ApplyGlueVuln", duration: 1, power: -0.3, trigger: "tickAfter" },
    ]
};
let KDEncased = {
    id: "Encased", type: "SlimeProgress", power: 2.0, player: false, enemies: true, duration: 9999, range: 0.5, replaceSprite: "EncasedDoll", tags: ["encased"], events: [
        { type: "RemoveSlimeWalk", duration: 1, trigger: "tick" },
        { type: "RemoveFree", trigger: "tick" },
        { type: "ApplySlowed", duration: 1, power: -2.0, trigger: "tick" },
        { type: "ApplySlowed", duration: 1, power: -2.0, trigger: "tickAfter" },
        { type: "ApplyAttackSlow", duration: 1, power: 1.0, trigger: "tick" },
        { type: "ApplyAttackSlow", duration: 1, power: 1.0, trigger: "tickAfter" },
        { type: "ApplySilence", duration: 2, power: 1.0, trigger: "tick" },
        { type: "ApplySilence", duration: 2, power: 1.0, trigger: "tickAfter" },
        { type: "ApplyGlueVuln", duration: 1, power: -0.5, trigger: "tick" },
        { type: "ApplyGlueVuln", duration: 1, power: -0.5, trigger: "tickAfter" },
    ]
};
let KDEncasedDoll = {
    id: "EncasedDoll", type: "SlimeProgress", power: 2.0, player: false, enemies: true, duration: 9999, range: 0.5, replaceSprite: "EncasedFactoryDoll", tags: ["encased"], events: [
        { type: "RemoveSlimeWalk", duration: 1, trigger: "tick" },
        { type: "RemoveFree", trigger: "tick" },
        { type: "ApplySlowed", duration: 1, power: -2.0, trigger: "tick" },
        { type: "ApplySlowed", duration: 1, power: -2.0, trigger: "tickAfter" },
        { type: "ApplyAttackSlow", duration: 1, power: 1.0, trigger: "tick" },
        { type: "ApplyAttackSlow", duration: 1, power: 1.0, trigger: "tickAfter" },
        { type: "ApplySilence", duration: 2, power: 1.0, trigger: "tick" },
        { type: "ApplySilence", duration: 2, power: 1.0, trigger: "tickAfter" },
        { type: "ApplyGlueVuln", duration: 1, power: -0.5, trigger: "tick" },
        { type: "ApplyGlueVuln", duration: 1, power: -0.5, trigger: "tickAfter" },
    ]
};
let KDChastity = {
    id: "Chastity", type: "Chastity", power: 1.0, aura: "#dddddd", aurasprite: "Chastity", player: false, enemies: true, duration: 9999, range: 0.5, tags: ["chastity"], events: [
        { type: "Distract", power: 0.1, trigger: "tick", prereq: "bound" },
    ]
};
let KDVibrate1 = {
    id: "Vibrate1", type: "Vibration", power: 1.0, aura: "#ffaaaa", duration: 3, tags: ["plugged"], events: [
        { type: "RemoveNoPlug", trigger: "tick" },
    ]
};
let KDVibrate2 = {
    id: "Vibrate2", type: "Vibration", power: 1.0, aura: "#ffaaaa", duration: 3, tags: ["plugged"], events: [
        { type: "RemoveNoPlug", trigger: "tick" },
    ]
};
let KDVibrate3 = {
    id: "Vibrate3", type: "Vibration", power: 1.0, aura: "#ffaaaa", duration: 3, tags: ["plugged"], events: [
        { type: "RemoveNoPlug", trigger: "tick" },
    ]
};
let KDToy = {
    id: "Toy", type: "Plug", power: 0.1, aura: "#dddddd", aurasprite: "Toy", player: false, enemies: true, duration: 30, range: 0.5, tags: ["toy"]
};
let KDPlugged = {
    id: "Plugged", type: "Plug", power: 1.0, aura: "#dddddd", aurasprite: "Plugged", player: false, enemies: true, duration: 9999, range: 0.5, tags: ["plugged"], events: [
        { type: "Distract", power: 2.0, trigger: "tick" },
        { type: "RemoveFree", trigger: "tick", prereq: "NoChastity" },
    ]
};
let KDDoublePlugged = {
    id: "DoublePlugged", type: "Plug", power: 2.0, aura: "#dddddd", aurasprite: "DoublePlugged", player: false, enemies: true, duration: 9998, range: 0.5, tags: ["plugged"], events: [
        { type: "Distract", power: 5.0, trigger: "tick" },
        { type: "RemoveFree", trigger: "tick", prereq: "NoChastity" },
    ]
};
let KDGlueVulnLow = {
    id: "GlueVuln", type: "glueDamageResist", power: -0.3, player: true, enemies: true, duration: 1
};
let KDGlueResist = {
    id: "GlueVuln", type: "glueDamageResist", power: 0.5, player: false, enemies: true, duration: 1
};
let KDDollDebuff = {
    id: "DollDebuff", type: "soulDamageResist", power: -0.5, player: false, enemies: true, duration: 2, aura: "#ff8888",
};
let KDDollDebuff2 = {
    id: "DollDebuff2", type: "charmDamageResist", power: -0.5, player: false, enemies: true, duration: 2
};
let KDSlowed = {
    id: "Slowed", type: "MoveSpeed", power: -1.0, player: true, enemies: true, duration: 1
};
let KDAttackSlow = {
    id: "AttackSlow", type: "AttackSlow", power: 0.5, player: true, enemies: true, duration: 1
};
let KDUnsteady = { id: "Unsteady", aura: "#aa8888", type: "MoveSpeed", power: -1.0, player: true, enemies: true, duration: 1, };
let KDUnsteady2 = { id: "Unsteady2", aura: "#aa8888", type: "Armor", power: -1.0, player: true, enemies: false, duration: 3, };
let KDUnsteady3 = { id: "Unsteady3", type: "Evasion", power: -0.5, player: true, enemies: false, duration: 3, };
let KDNoChill = { id: "ChillWalk", aura: "#73efe8", type: "ChillWalk", power: -1.0, player: true, enemies: true, duration: 2, };
let KDNoChillNoAura = { id: "ChillWalk2", type: "ChillWalk", power: -1.0, player: true, enemies: true, duration: 2, };
function KDChillWalk(entity) {
    return KDEntityHasBuff(entity, "ChillWalk") || KDEntityHasBuff(entity, "ChillWalk2");
}
let KDRestraintDisarmLight = { id: "RestDisarmLight", aura: "#ff5555", type: "DisarmOnAttack", power: 3, player: false, enemies: true, duration: 9999, events: [
        { type: "RemoveRestraint", trigger: "tick" },
        { type: "ApplyDisarm", trigger: "playerAttack" },
    ] };
let KDBuffReference = {
    "RestraintDisarmLight": [KDRestraintDisarmLight],
    "Unsteady": [KDUnsteady, KDUnsteady2, KDUnsteady3],
    "Plugged": [KDPlugged],
    "DoublePlugged": [KDDoublePlugged],
    "Chastity": [KDChastity],
    "Vibrate1": [KDVibrate1],
    "Vibrate2": [KDVibrate2],
    "Vibrate3": [KDVibrate3],
};
let KDDisenchantSelf = { id: "DisenchantSelf", aura: "#8888ff", type: "Disenchant", power: 9.9, player: true, enemies: true, duration: 10, };
let KDJourneyMapMod = {
    "Random": true,
};
let KDDefaultMaxFlags = {
    goldchest: 1,
    lessergold: 1,
    silverchest: 2,
    darkchest: 2,
    redchest: 6,
    bluechest: 2,
    forbidden: 1,
    artifact: 2,
    jail: 2,
    playroom: 4,
    supplydepot: 1,
    barracks: 2,
    robotroom: 3,
    laboratory: 1,
    library: 1,
    armory: 1,
    workshop: 2,
    tinker: 1,
    office: 3,
    worship: 1,
    graveyard: 2,
    well: 3,
    wildlife: 2,
    range: 2,
    arena: 1,
    arena_boss: 1,
    arena_miniboss: 5,
    slimespawn: 3,
    beastspawn: 3,
    magicspawn: 3,
    robotspawn: 3,
};
let alts = {
    "Tunnel": {
        name: "Tunnel",
        bossroom: false,
        width: 8,
        height: 8,
        genType: "Tunnel",
        spawns: false,
        chests: false,
        shrines: false,
        orbs: 0,
        setpieces: {},
        chargers: false,
        notorches: false,
        heart: false,
        specialtiles: true,
        shortcut: false,
        enemies: false,
        nojail: true,
        nolore: true,
        nokeys: true,
        nostairs: true,
        notraps: true,
        noClutter: true,
        noShrineTypes: ["Commerce", "Will"],
        tickFlags: true,
        noMusic: true,
        keepMainPath: true,
    },
    "PerkRoom": {
        name: "PerkRoom",
        bossroom: false,
        width: 9,
        height: 8,
        genType: "PerkRoom",
        setpieces: {
            "PearlChest": 100,
        },
        spawns: false,
        chests: false,
        shrines: false,
        orbs: 0,
        chargers: false,
        notorches: false,
        heart: false,
        specialtiles: true,
        shortcut: false,
        enemies: false,
        nojail: true,
        nolore: true,
        nokeys: true,
        nostairs: true,
        notraps: true,
        noClutter: true,
        noShrineTypes: ["Commerce", "Will"],
        noMusic: true,
        keepMainPath: true,
    },
    "Jail": {
        name: "Jail",
        bossroom: false,
        width: 15,
        height: 15,
        enemyMult: 0.6,
        setpieces: {
            "GuaranteedCell": 100,
            "ExtraCell": 20,
            "Bedroom": 10,
            "QuadCell": 7,
            "Storage": 12,
        },
        bonusTags: {
            "construct": { bonus: 0, mult: 0 },
        },
        genType: "NarrowMaze",
        spawns: false,
        chests: false,
        shrines: true,
        orbs: 0,
        chargers: true,
        notorches: false,
        heart: false,
        specialtiles: true,
        shortcut: false,
        enemies: true,
        nojail: false,
        nokeys: true,
        nostairs: false,
        notraps: false,
        noRelease: true,
        releaseOnLowSec: true,
        noShrineTypes: ["Commerce"],
    },
    "DollRoom": {
        name: "DollRoom",
        noWear: true,
        bossroom: false,
        width: 15,
        height: 10,
        nopatrols: true,
        setpieces: {},
        data: {
            dollroom: true,
        },
        genType: "DollRoom",
        spawns: false,
        chests: false,
        shrines: false,
        orbs: 0,
        chargers: false,
        notorches: true,
        heart: false,
        specialtiles: false,
        shortcut: false,
        enemies: false,
        nojail: true,
        nokeys: true,
        nostairs: true,
        nostartstairs: true,
        notraps: false,
        noClutter: true,
        nobrick: true,
        nolore: true,
        noboring: true,
    },
    "TestTile": {
        name: "TestTile",
        noWear: true,
        bossroom: false,
        width: 15,
        height: 10,
        setpieces: {},
        genType: "TestTile",
        spawns: true,
        chests: false,
        shrines: false,
        orbs: 0,
        chargers: false,
        notorches: true,
        heart: false,
        specialtiles: false,
        shortcut: false,
        enemies: true,
        nojail: true,
        nokeys: true,
        nostairs: true,
        nostartstairs: true,
        notraps: false,
        noClutter: true,
        nobrick: true,
        nolore: true,
        noboring: true,
    },
    "JourneyFloor": {
        name: "JourneyFloor",
        bossroom: false,
        width: 10,
        height: 8,
        setpieces: {},
        genType: "JourneyFloor",
        spawns: false,
        chests: false,
        shrines: false,
        orbs: 0,
        chargers: false,
        notorches: false,
        heart: false,
        specialtiles: false,
        shortcut: false,
        enemies: false,
        nojail: true,
        nokeys: true,
        nolore: true,
        nostairs: true,
        notraps: true,
        noClutter: true,
        skiptunnel: true,
    },
    "ShopStart": {
        name: "ShopStart",
        bossroom: false,
        width: 10,
        height: 8,
        setpieces: {},
        genType: "ShopStart",
        spawns: false,
        chests: false,
        shrines: false,
        orbs: 0,
        chargers: false,
        notorches: false,
        heart: false,
        specialtiles: false,
        shortcut: false,
        enemies: false,
        nojail: true,
        nokeys: true,
        nolore: true,
        nostairs: true,
        notraps: true,
        noClutter: true,
        skiptunnel: true,
    },
    "Tutorial": {
        name: "Tutorial",
        bossroom: false,
        width: 30,
        height: 7,
        setpieces: {},
        genType: "Tutorial",
        spawns: false,
        chests: false,
        shrines: false,
        orbs: 0,
        chargers: false,
        notorches: false,
        heart: false,
        specialtiles: false,
        shortcut: false,
        enemies: false,
        nojail: true,
        nokeys: true,
        nolore: true,
        nostairs: true,
        notraps: true,
        noClutter: true,
    },
};
let KDJourneyList = ["Random", "Harder", "Explorer", "Doll"];
if (param_test)
    KDJourneyList.push("Test");
function KinkyDungeonAltFloor(Type) {
    return alts[Type];
}
let KinkyDungeonCreateMapGenType = {
    "Room": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateRoom(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "JourneyFloor": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateJourneyFloor(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "ShopStart": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateShopStart(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "TestTile": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateTestTile(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "Tutorial": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateTutorial(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "Tunnel": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateTunnel(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "PerkRoom": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreatePerkRoom(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "Chamber": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateMaze(POI, VisitedRooms, width, height, 2, 1.5, 8, data);
    },
    "Maze": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateMaze(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "TileMaze": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateTileMaze(POI, VisitedRooms, width, height, openness, density, hallopenness, data);
    },
    "NarrowMaze": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateMaze(POI, VisitedRooms, width, height, 0, 10, 0, data);
    },
    "DollRoom": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateDollRoom(POI, VisitedRooms, width, height, 0, 10, 0, data);
    },
    "Dollmaker": (POI, VisitedRooms, width, height, openness, density, hallopenness, data) => {
        KinkyDungeonCreateDollmaker(POI, VisitedRooms, width, height, 0, 10, 0, data);
    },
};
function KinkyDungeonCreateMaze(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    let Walls = {};
    let WallsList = {};
    let VisitedCells = {};
    if (KDDebug)
        console.log("Created maze with dimensions " + width + "x" + height + ", openness: " + openness + ", density: " + density);
    VisitedCells[VisitedRooms[0].x + "," + VisitedRooms[0].y] = { x: VisitedRooms[0].x, y: VisitedRooms[0].y };
    for (let X = 2; X < width; X += 2)
        for (let Y = 1; Y < height; Y += 2)
            if (KinkyDungeonMapGet(X, Y) == '1') {
                Walls[X + "," + Y] = { x: X, y: Y };
            }
    for (let X = 1; X < width; X += 2)
        for (let Y = 2; Y < height; Y += 2)
            if (KinkyDungeonMapGet(X, Y) == '1') {
                Walls[X + "," + Y] = { x: X, y: Y };
            }
    KinkyDungeonMazeWalls(VisitedRooms[0], Walls, WallsList);
    let WallKeys = Object.keys(WallsList);
    while (WallKeys.length > 0) {
        let I = Math.floor(KDRandom() * WallKeys.length);
        let wall = Walls[WallKeys[I]];
        let unvisitedCell = null;
        if (wall.x % 2 == 0) {
            if (!VisitedCells[(wall.x - 1) + "," + wall.y])
                unvisitedCell = { x: wall.x - 1, y: wall.y };
            if (!VisitedCells[(wall.x + 1) + "," + wall.y]) {
                if (unvisitedCell)
                    unvisitedCell = null;
                else
                    unvisitedCell = { x: wall.x + 1, y: wall.y };
            }
        }
        else {
            if (!VisitedCells[wall.x + "," + (wall.y - 1)])
                unvisitedCell = { x: wall.x, y: wall.y - 1 };
            if (!VisitedCells[wall.x + "," + (wall.y + 1)]) {
                if (unvisitedCell)
                    unvisitedCell = null;
                else
                    unvisitedCell = { x: wall.x, y: wall.y + 1 };
            }
        }
        if (unvisitedCell) {
            delete Walls[wall.x + "," + wall.y];
            KinkyDungeonMapSet(wall.x, wall.y, '0');
            KinkyDungeonMapSet(unvisitedCell.x, unvisitedCell.y, '0');
            VisitedCells[unvisitedCell.x + "," + unvisitedCell.y] = unvisitedCell;
            KinkyDungeonMazeWalls(unvisitedCell, Walls, WallsList);
        }
        delete WallsList[wall.x + "," + wall.y];
        WallKeys = Object.keys(WallsList);
    }
    for (let X = 1; X < KinkyDungeonGridWidth; X += 1)
        for (let Y = 1; Y < KinkyDungeonGridWidth; Y += 1) {
            if ((X % 2 == 0 && Y % 2 == 1) || (X % 2 == 1 && Y % 2 == 0)) {
                let size = 1 + Math.ceil(KDRandom() * (openness));
                if (KDRandom() < 0.4 - 0.02 * density * size * size) {
                    let tile = '0';
                    for (let XX = X; XX < X + size; XX++)
                        for (let YY = Y; YY < Y + size; YY++) {
                            if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY)))
                                KinkyDungeonMapSet(XX, YY, tile);
                            VisitedCells[XX + "," + YY] = { x: XX, y: YY };
                            KinkyDungeonMazeWalls({ x: XX, y: YY }, Walls, WallsList);
                            delete Walls[XX + "," + YY];
                        }
                }
            }
        }
    for (let X = 1; X < KinkyDungeonGridWidth; X += 1)
        for (let Y = 1; Y < KinkyDungeonGridWidth; Y += 1) {
            let nearwalls = 0;
            for (let XX = X - 1; XX <= X + 1; XX += 1)
                for (let YY = Y - 1; YY <= Y + 1; YY += 1) {
                    if (KinkyDungeonMapGet(XX, YY) == '1') {
                        nearwalls += 1;
                    }
                }
            if (nearwalls == 7) {
                POI.push({ x: X * 2, y: Y * 2, requireTags: ["endpoint"], favor: [], used: false });
            }
        }
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    for (let Y = 2; Y < KinkyDungeonGridHeight - 1; Y += 1) {
        if (KDRandom() < 0.4 - 0.04 * hallopenness) {
            let row_top = [];
            let row_mid = [];
            let row_bot = [];
            for (let X = 0; X < KinkyDungeonGridWidth; X++) {
                row_top.push(KinkyDungeonMapGet(X, Y - 1));
                row_mid.push(KinkyDungeonMapGet(X, Y));
                row_bot.push(KinkyDungeonMapGet(X, Y + 1));
            }
            for (let X = 1; X < KinkyDungeonGridWidth - 1; X++) {
                if (row_mid[X] == '0') {
                    if (row_mid[X - 1] == '0' || row_mid[X + 1] == '0') {
                        if (row_top[X] == '0' && row_bot[X] == '0' && (row_top[X - 1] == '1' || row_bot[X + 1] == '1')) {
                            if (((row_top[X + 1] == '0' && row_bot[X + 1] == '0') || row_mid[X + 1] == '1')
                                && ((row_top[X - 1] == '0' && row_bot[X - 1] == '0') || row_mid[X - 1] == '1')) {
                                KinkyDungeonMapSet(X, Y, 'X');
                                X++;
                            }
                        }
                    }
                }
            }
        }
    }
    for (let X = 2; X < KinkyDungeonGridWidth - 1; X += 1) {
        if (KDRandom() < 0.4 - 0.04 * hallopenness) {
            let col_top = [];
            let col_mid = [];
            let col_bot = [];
            for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
                col_top.push(KinkyDungeonMapGet(X - 1, Y));
                col_mid.push(KinkyDungeonMapGet(X, Y));
                col_bot.push(KinkyDungeonMapGet(X + 1, Y));
            }
            for (let Y = 1; Y < KinkyDungeonGridHeight - 1; Y++) {
                if (col_mid[Y] == '0') {
                    if (col_mid[Y - 1] == '0' || col_mid[Y + 1] == '0') {
                        if (col_top[Y] == '0' && col_bot[Y] == '0' && (col_top[Y - 1] == '1' || col_bot[Y + 1] == '1')) {
                            if (((col_top[Y + 1] == '0' && col_bot[Y + 1] == '0') || col_mid[Y + 1] == '1')
                                && ((col_top[Y - 1] == '0' && col_bot[Y - 1] == '0') || col_mid[Y - 1] == '1')) {
                                KinkyDungeonMapSet(X, Y, '1');
                                Y++;
                            }
                        }
                    }
                }
            }
        }
    }
    for (let X = 2; X < KinkyDungeonGridWidth; X += 2)
        for (let Y = 2; Y < KinkyDungeonGridWidth; Y += 2) {
            let size = 2 * Math.ceil(KDRandom() * (openness));
            if (KDRandom() < 0.4 - 0.04 * density * size) {
                let tile = '0';
                if (data.params.floodChance > 0 && KDRandom() < data.params.floodChance)
                    tile = 'w';
                for (let XX = X; XX < X + size; XX++)
                    for (let YY = Y; YY < Y + size; YY++) {
                        if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY)))
                            KinkyDungeonMapSet(XX, YY, tile);
                    }
            }
        }
}
function KinkyDungeonCreateTileMaze(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    VisitedRooms = [];
    KinkyDungeonMapSet(1, 1, '0', VisitedRooms);
    let Walls = {};
    let WallsList = {};
    let VisitedCells = {};
    console.log("Created maze with dimensions " + width + "x" + height + ", openness: " + openness + ", density: " + density);
    VisitedCells[VisitedRooms[0].x + "," + VisitedRooms[0].y] = { x: VisitedRooms[0].x, y: VisitedRooms[0].y };
    for (let X = 2; X < width; X += 2)
        for (let Y = 1; Y < height; Y += 2)
            if (KinkyDungeonMapGet(X, Y) == '1') {
                Walls[X + "," + Y] = { x: X, y: Y };
            }
    for (let X = 1; X < width; X += 2)
        for (let Y = 2; Y < height; Y += 2)
            if (KinkyDungeonMapGet(X, Y) == '1') {
                Walls[X + "," + Y] = { x: X, y: Y };
            }
    KinkyDungeonMazeWalls(VisitedRooms[0], Walls, WallsList);
    let WallKeys = Object.keys(WallsList);
    while (WallKeys.length > 0) {
        let I = Math.floor(KDRandom() * WallKeys.length);
        let wall = Walls[WallKeys[I]];
        let unvisitedCell = null;
        if (wall.x % 2 == 0) {
            if (!VisitedCells[(wall.x - 1) + "," + wall.y])
                unvisitedCell = { x: wall.x - 1, y: wall.y };
            if (!VisitedCells[(wall.x + 1) + "," + wall.y]) {
                if (unvisitedCell)
                    unvisitedCell = null;
                else
                    unvisitedCell = { x: wall.x + 1, y: wall.y };
            }
        }
        else {
            if (!VisitedCells[wall.x + "," + (wall.y - 1)])
                unvisitedCell = { x: wall.x, y: wall.y - 1 };
            if (!VisitedCells[wall.x + "," + (wall.y + 1)]) {
                if (unvisitedCell)
                    unvisitedCell = null;
                else
                    unvisitedCell = { x: wall.x, y: wall.y + 1 };
            }
        }
        if (unvisitedCell) {
            delete Walls[wall.x + "," + wall.y];
            KinkyDungeonMapSet(wall.x, wall.y, '0');
            KinkyDungeonMapSet(unvisitedCell.x, unvisitedCell.y, '0');
            VisitedCells[unvisitedCell.x + "," + unvisitedCell.y] = unvisitedCell;
            KinkyDungeonMazeWalls(unvisitedCell, Walls, WallsList);
        }
        delete WallsList[wall.x + "," + wall.y];
        WallKeys = Object.keys(WallsList);
    }
    for (let X = 1; X < KinkyDungeonGridWidth; X += 1)
        for (let Y = 1; Y < KinkyDungeonGridWidth; Y += 1) {
            if ((X % 2 == 0 && Y % 2 == 1) || (X % 2 == 1 && Y % 2 == 0)) {
                let size = 1;
                if (KDRandom() < 0.4 - 0.02 * density * size * size) {
                    let tile = '0';
                    for (let XX = X; XX < X + size; XX++)
                        for (let YY = Y; YY < Y + size; YY++) {
                            if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY)))
                                KinkyDungeonMapSet(XX, YY, tile);
                            VisitedCells[XX + "," + YY] = { x: XX, y: YY };
                            KinkyDungeonMazeWalls({ x: XX, y: YY }, Walls, WallsList);
                            delete Walls[XX + "," + YY];
                        }
                }
                if (KDRandom() < 0.02 * openness) {
                    let tile = '0';
                    for (let XX = X - 1; XX <= X + 1; XX++)
                        for (let YY = Y; YY <= Y + 1; YY++)
                            if (XX == 0 || YY == 0) {
                                if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY)))
                                    KinkyDungeonMapSet(XX, YY, tile);
                                VisitedCells[XX + "," + YY] = { x: XX, y: YY };
                                KinkyDungeonMazeWalls({ x: XX, y: YY }, Walls, WallsList);
                                delete Walls[XX + "," + YY];
                            }
                }
            }
        }
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    let index_w = 0;
    let index_h = 0;
    for (let x = 1; x * 2 < KinkyDungeonGridWidth; x += 1) {
        index_w += 1;
        index_h = 0;
        for (let y = 1; y * 2 < KinkyDungeonGridHeight; y += 1) {
            index_h += 1;
        }
    }
    let starty = Math.floor(KDRandom() * (index_h));
    let endy = Math.floor(KDRandom() * (index_h));
    let topx = Math.floor(KDRandom() * (index_w));
    let botx = Math.floor(KDRandom() * (index_w));
    let requiredAccess = {};
    requiredAccess[1 + "," + (starty + 1)] = true;
    requiredAccess[(topx + 1) + "," + 1] = true;
    requiredAccess[w + "," + (endy + 1)] = true;
    requiredAccess[(botx + 1) + "," + h] = true;
    let indices = {};
    for (let x = 1; x < KinkyDungeonGridWidth; x += 2) {
        for (let y = 1; y < KinkyDungeonGridHeight; y += 2) {
            let index = "";
            if (KinkyDungeonMapGet(x, y - 1) == '0' || (y == 1 && (x - 1) / 2 == topx))
                index = index + "u";
            if (KinkyDungeonMapGet(x, y + 1) == '0' || (y == -1 + index_h * 2 && (x - 1) / 2 == botx))
                index = index + "d";
            if (KinkyDungeonMapGet(x - 1, y) == '0' || (x == 1 && (y - 1) / 2 == starty))
                index = index + "l";
            if (KinkyDungeonMapGet(x + 1, y) == '0' || (x == -1 + index_w * 2 && (y - 1) / 2 == endy))
                index = index + "r";
            indices[(1 + (x - 1) / 2) + "," + (1 + (y - 1) / 2)] = index;
        }
    }
    console.log(indices);
    KinkyDungeonGridWidth = Math.floor(index_w * KDTE_Scale) + 2;
    KinkyDungeonGridHeight = Math.floor(index_h * KDTE_Scale) + 2;
    KinkyDungeonStartPosition = { x: 1, y: 4 + (starty) * KDTE_Scale };
    KinkyDungeonEndPosition = { x: KinkyDungeonGridWidth - 2, y: 4 + (endy) * KDTE_Scale };
    if (KDRandom() < 0.5)
        KinkyDungeonShortcutPosition = { x: 4 + (botx) * KDTE_Scale, y: KinkyDungeonGridHeight - 2 };
    else
        KinkyDungeonShortcutPosition = { x: 4 + (topx) * KDTE_Scale, y: 1 };
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + '1';
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    let tagModifiers = data.params.tagModifiers ? data.params.tagModifiers : undefined;
    let maxTagFlags = Object.assign({
        chest: data.params.chestcount || 0,
        shrine: data.params.shrinecount || 0,
        charger: data.params.chargercount || 0,
    }, KDDefaultMaxFlags);
    KDMapTilesPopulate(w, h, indices, data, requiredAccess, maxTagFlags, tagModifiers);
    let floodChance = data.params.floodchance || 0;
    for (let X = 2; X < KinkyDungeonGridWidth; X += 2)
        for (let Y = 2; Y < KinkyDungeonGridWidth; Y += 2) {
            let size = 2 * Math.ceil(KDRandom() * (openness));
            if (KDRandom() < 0.4 - 0.04 * density * size) {
                if (floodChance > 0 && KDRandom() < floodChance)
                    for (let XX = X; XX < X + size; XX++)
                        for (let YY = Y; YY < Y + size; YY++) {
                            if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(XX, YY)))
                                KinkyDungeonMapSet(XX, YY, 'w');
                        }
            }
        }
}
function KinkyDungeonCreateRoom(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonCreateRectangle(0, 0, width, height, true, false, false, false);
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
}
function KinkyDungeonCreateDollRoom(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    width = KinkyDungeonGridWidth;
    height = KinkyDungeonGridHeight;
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + '1';
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    let CellWidth = 10;
    let CellHeight = 12;
    let CellX = width / 2 - CellWidth / 2;
    let CellY = height / 2 - CellHeight / 2;
    let cavityStart = 5;
    let cavityEnd = 2;
    KinkyDungeonCreateRectangle(cavityStart, 0, CellX + CellWidth - cavityEnd, height, false, false, false, false);
    KinkyDungeonCreateRectangle(CellX, CellY, CellWidth, CellHeight, true, false, false, true, true, false, true);
    let leftPassages = [];
    for (let i = 0; i < 6; i++) {
        leftPassages.push(1 + Math.ceil(KDRandom() * 2));
    }
    let rightPassages = [];
    for (let i = 0; i < 6; i++) {
        rightPassages.push(2 + Math.ceil(KDRandom() * 3));
    }
    let ii = 0;
    for (let l of leftPassages) {
        KinkyDungeonCreateRectangle(cavityStart - l, 1 + 3 * ii, l, 2, false, false, false, false);
        KinkyDungeonMapSet(cavityStart, 3 + 3 * ii, 'X');
        KinkyDungeonMapSet(cavityStart, 1 + 3 * ii, '2');
        KinkyDungeonMapSet(cavityStart, 2 + 3 * ii, '2');
        ii += 1;
    }
    ii = 0;
    for (let l of rightPassages) {
        KinkyDungeonCreateRectangle(cavityStart - cavityEnd + CellX + CellWidth, 1 + 3 * ii, l, 2, false, false, false, false);
        KinkyDungeonMapSet(cavityStart - cavityEnd + CellX + CellWidth, 3 + 3 * ii, 'X');
        KinkyDungeonMapSet(cavityStart - cavityEnd + CellX + CellWidth, 1 + 3 * ii, '2');
        KinkyDungeonMapSet(cavityStart - cavityEnd + CellX + CellWidth, 2 + 3 * ii, '2');
        ii += 1;
    }
    KinkyDungeonMapSet(CellX + 2 + Math.floor(KDRandom() * (CellWidth - 5)), KDRandom() < 0.5 ? CellY : (CellY + CellHeight - 1), 'g');
    if (KDRandom() < 0.5)
        KinkyDungeonMapSet(CellX + 2 + Math.floor(KDRandom() * (CellWidth - 5)), KDRandom() < 0.5 ? CellY : (CellY + CellHeight - 1), 'g');
    if (KDRandom() < 0.5)
        KinkyDungeonMapSet(CellX, CellY + 2 + Math.floor(KDRandom() * (CellHeight - 5)), 'g');
    if (KDRandom() < 0.5)
        KinkyDungeonMapSet((CellX + CellWidth - 1), CellY + 2 + Math.floor(KDRandom() * (CellHeight - 5)), 'g');
    for (let xx = CellX + 2; xx < CellX + CellWidth; xx += 5) {
        for (let yy = 2; yy < height; yy += 5) {
            if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(xx, yy))) {
                KinkyDungeonMapSet(xx, yy, '0');
                KinkyDungeonTilesSet((xx) + "," + (yy), Object.assign(KinkyDungeonTilesGet((xx) + "," + (yy)) || {}, { Light: 6, Skin: "LightRaysDoll" }));
            }
        }
    }
    let dollCount = 10;
    for (let i = 0; i < dollCount; i++) {
        let XX = CellX + 1 + Math.round(KDRandom() * (CellWidth - 3));
        let YY = CellY + 1 + Math.round(KDRandom() * (CellHeight - 3));
        let entity = KinkyDungeonEntityAt(XX, YY);
        if (entity || (XX == width / 2 && YY == height / 2))
            continue;
        let Enemy = KinkyDungeonGetEnemy(["bellowsDoll"], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["doll", "peaceful"]);
        if (Enemy) {
            let e = DialogueCreateEnemy(XX, YY, Enemy.name);
            if (KDRandom() < 0.33)
                KDTieUpEnemy(e, 15 + Math.floor(45 * KDRandom()), "Tape");
            else if (KDRandom() < 0.32)
                KDTieUpEnemy(e, 15 + Math.floor(45 * KDRandom()), "Slime");
            else if (KDRandom() < 0.34)
                KDTieUpEnemy(e, 15 + Math.floor(45 * KDRandom()), "Metal");
            if (e.boundLevel > 0 && KDRandom() < 0.33)
                e.hp = 0.5;
        }
    }
    KDGameData.JailPoints.push({ x: width / 2, y: height / 2, type: "dropoff", radius: 1 });
    let takenIndex = 0;
    let takenRight = false;
    if (KDRandom() < 0.5) {
        let cavityNum = Math.floor(KDRandom() * leftPassages.length);
        takenIndex = cavityNum;
        KinkyDungeonEndPosition = { x: cavityStart - leftPassages[cavityNum], y: 1 + 3 * cavityNum };
    }
    else {
        let cavityNum = Math.floor(KDRandom() * rightPassages.length);
        takenIndex = cavityNum;
        takenRight = true;
        KinkyDungeonEndPosition = { x: cavityStart - cavityEnd + CellX + CellWidth + rightPassages[cavityNum] - 1, y: 1 + 3 * cavityNum };
    }
    if (KDRandom() < 0.5) {
        let cavityNum = Math.floor(KDRandom() * leftPassages.length);
        if (!takenRight && takenIndex == cavityNum) {
            if (cavityNum > 0)
                cavityNum -= 1;
            else
                cavityNum += 1;
        }
        KinkyDungeonStartPosition = { x: cavityStart - leftPassages[cavityNum], y: 2 + 3 * cavityNum };
    }
    else {
        let cavityNum = Math.floor(KDRandom() * rightPassages.length);
        if (takenRight && takenIndex == cavityNum) {
            if (cavityNum > 0)
                cavityNum -= 1;
            else
                cavityNum += 1;
        }
        KinkyDungeonStartPosition = { x: cavityStart - cavityEnd + CellX + CellWidth + rightPassages[cavityNum] - 1, y: 2 + 3 * cavityNum };
    }
    let exitGuardTags = ["robot"];
    KinkyDungeonAddTags(exitGuardTags, MiniGameKinkyDungeonLevel);
    if (KDGameData.DollRoomCount > 0)
        exitGuardTags.push("open");
    let robotTags = ["robot"];
    KinkyDungeonAddTags(robotTags, MiniGameKinkyDungeonLevel);
    let eliteTags = ["robot"];
    KinkyDungeonAddTags(eliteTags, MiniGameKinkyDungeonLevel);
    let robotCount = 5 + Math.min(10, KinkyDungeonDifficulty / 10 + MiniGameKinkyDungeonLevel / 3) + 5 * (KDGameData.DollRoomCount || 0);
    for (let i = 0; i < robotCount; i++) {
        let XX = i % 2 == 0 ?
            (cavityStart + Math.round(KDRandom() * (CellX - cavityStart - 1)))
            : (CellX + CellWidth + 1 + Math.round(KDRandom() * (cavityStart - 2 - cavityEnd)));
        let YY = CellY + 1 + Math.round(KDRandom() * (CellHeight - 2));
        let entity = KinkyDungeonEntityAt(XX, YY);
        if (entity || (XX == width / 2 && YY == height / 2))
            continue;
        let Enemy = KinkyDungeonGetEnemy(robotTags, MiniGameKinkyDungeonLevel + 3, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["robot"], undefined, undefined);
        if (Enemy) {
            let e = DialogueCreateEnemy(XX, YY, Enemy.name);
            e.faction = "Enemy";
        }
    }
    if (KDGameData.DollRoomCount > 1) {
        for (let i = 0; i < 1 + Math.ceil(robotCount * 0.1); i++) {
            let point = KinkyDungeonGetNearbyPoint(KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y);
            let Enemy = KinkyDungeonGetEnemy(eliteTags, MiniGameKinkyDungeonLevel + 4, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["robot"], undefined, undefined, ["minor", "miniboss", "noguard"]);
            if (Enemy) {
                let e = DialogueCreateEnemy(point.x, point.y, Enemy.name);
                e.faction = "Enemy";
                e.AI = "looseguard";
            }
        }
    }
    let ExitGuard = KinkyDungeonGetEnemy(exitGuardTags, MiniGameKinkyDungeonLevel + 10, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["robot", "dollRoomBoss"], undefined, undefined, ["noguard"]);
    if (ExitGuard) {
        let e = DialogueCreateEnemy(KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, ExitGuard.name);
        e.faction = "Enemy";
        e.AI = "verylooseguard";
    }
    KinkyDungeonPatrolPoints.push({ x: CellX - 2, y: CellY - 2 });
    KinkyDungeonPatrolPoints.push({ x: CellX - 2, y: CellY + 2 + CellHeight });
    KinkyDungeonPatrolPoints.push({ x: CellX + 2 + CellWidth, y: CellY + 2 + CellHeight });
    KinkyDungeonPatrolPoints.push({ x: CellX + 2 + CellWidth, y: CellY - 2 });
    KinkyDungeonMapSet(KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, 's');
    if (KDGameData.DollRoomCount > 0)
        KinkyDungeonMapSet(KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, 'S');
}
function KinkyDungeonCreateDollmaker(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonSetFlag("NoDollRoomBypass", -1, 1);
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    width = KinkyDungeonGridWidth;
    height = KinkyDungeonGridHeight;
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + '1';
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    let cavitywidth = 21;
    let cavityheight = 21;
    let cavityStart = 2;
    KinkyDungeonStartPosition = { x: cavityStart, y: 1 + Math.floor(cavityheight / 2) };
    KinkyDungeonCreateRectangle(cavityStart, 0, cavitywidth, cavityheight, false, false, false, false);
    KD_PasteTile(KDMapTilesList.Arena_Dollmaker, cavityStart, 1, data);
    DialogueCreateEnemy(KinkyDungeonStartPosition.x + Math.floor(cavityheight / 2), KinkyDungeonStartPosition.y, "DollmakerBoss1");
    KinkyDungeonEndPosition = { x: KinkyDungeonStartPosition.x + cavitywidth, y: KinkyDungeonStartPosition.y };
    KinkyDungeonMapSet(KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, 's');
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, 'S');
}
function KinkyDungeonCreateTunnel(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonCreateRectangle(0, 0, width, height, true, true, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y - 1, width - 3, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y, width - 2, 1, false, false, false, false);
    let b1 = 3 + Math.floor(KDRandom() * (width - 7));
    let b2 = 4 + Math.floor(KDRandom() * (width - 6));
    let y1 = VisitedRooms[0].y > 4 ? 1 : VisitedRooms[0].y;
    let h1 = VisitedRooms[0].y > 4 ? Math.abs(y1 - VisitedRooms[0].y) : height - VisitedRooms[0].y - 1;
    let y2 = VisitedRooms[0].y < height - 4 ? VisitedRooms[0].y : 1;
    let h2 = VisitedRooms[0].y < height - 4 ? Math.abs(height - 1 - VisitedRooms[0].y) : VisitedRooms[0].y - 1;
    if (Math.abs(b1 - b2) < 2) {
        if (b1 < width - 4)
            b2 = b1 + 2;
        else
            b2 = b1 - 2;
    }
    KinkyDungeonCreateRectangle(b1, y1, 1, h1, false, false, false, false);
    KinkyDungeonCreateRectangle(b2, y2, 1, h2, false, false, false, false);
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    let boss = KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel + 1);
    let mods = !boss ? KDGetMapGenList(3, KDMapMods) : ["None", "None", "None"];
    if (!boss) {
        let exit1 = mods[0].name;
        KinkyDungeonMapSet(b1 * 2, VisitedRooms[0].y > 4 ? 2 : height * 2 - 3, 's');
        KinkyDungeonMapSet(b1 * 2 + 1, VisitedRooms[0].y > 4 ? 2 : height * 2 - 3, 'G');
        KinkyDungeonTilesSet("" + (b1 * 2) + "," + (VisitedRooms[0].y > 4 ? 2 : height * 2 - 3), { MapMod: exit1 });
        KinkyDungeonTilesSet("" + (b1 * 2 + 1) + "," + (VisitedRooms[0].y > 4 ? 2 : height * 2 - 3), { Type: "Ghost", Msg: "MapMod" + exit1 });
        let exit2 = mods[1].name;
        KinkyDungeonMapSet(b2 * 2 + 1, VisitedRooms[0].y < height - 4 ? height * 2 - 3 : 2, 's');
        KinkyDungeonMapSet(b2 * 2, VisitedRooms[0].y < height - 4 ? height * 2 - 3 : 2, 'G');
        KinkyDungeonTilesSet("" + (b2 * 2 + 1) + "," + (VisitedRooms[0].y < height - 4 ? height * 2 - 3 : 2), { MapMod: exit2 });
        KinkyDungeonTilesSet("" + (b2 * 2) + "," + (VisitedRooms[0].y < height - 4 ? height * 2 - 3 : 2), { Type: "Ghost", Msg: "MapMod" + exit2 });
    }
    let exit3 = boss ? "Boss" : mods[2].name;
    KinkyDungeonMapSet(width * 2 - 2, VisitedRooms[0].y * 2, 's');
    KinkyDungeonMapSet(width * 2 - 2, VisitedRooms[0].y * 2 + 1, 'G');
    if (!boss)
        KinkyDungeonTilesSet("" + (width * 2 - 2) + "," + (VisitedRooms[0].y * 2), { MapMod: exit3 });
    KinkyDungeonTilesSet("" + (width * 2 - 2) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "MapMod" + exit3 });
    KinkyDungeonEndPosition = { x: width * 2 - 2, y: VisitedRooms[0].y * 2 };
    let quests = KDQuestList(2 + Math.round(KDRandom()), KDQuests, "Tunnel", "");
    for (let q of quests) {
        if (q.npc)
            KinkyDungeonSummonEnemy(KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, q.npc, 1, 14, true);
    }
}
function KinkyDungeonCreatePerkRoom(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonCreateRectangle(0, 0, width, height, true, true, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y - 1, 2, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y, width - 2, 1, false, false, false, false);
    let b1 = 3 + Math.floor(KDRandom() * (width - 7));
    let b2 = 4 + Math.floor(KDRandom() * (width - 6));
    if (Math.abs(b1 - b2) < 2) {
        if (b1 < width - 4)
            b2 = b1 + 2;
        else
            b2 = b1 - 2;
    }
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    KinkyDungeonMapSet(VisitedRooms[0].x * 2 + 3, VisitedRooms[0].y * 2 + 1, 'l');
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x * 2 + 3) + "," + (VisitedRooms[0].y * 2 + 1), { Leyline: true, Light: KDLeylineLight, lightColor: KDLeylineLightColor });
    if (KinkyDungeonFlags.get("SpawnMap")) {
        if (KinkyDungeonSpells.filter((spell) => { return spell.name == "ManaPoolUp"; }).length < Math.ceil(MiniGameKinkyDungeonLevel / 4))
            KinkyDungeonGroundItems.push({ x: VisitedRooms[0].x * 2 + 3, y: (VisitedRooms[0].y * 2), name: "LeylineMap" });
        KinkyDungeonSetFlag("SpawnMap", -1);
    }
    KinkyDungeonMapSet(VisitedRooms[0].x * 2 + 3, VisitedRooms[0].y * 2 - 2, 'A');
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x * 2 + 3) + "," + (VisitedRooms[0].y * 2 - 2), { Type: "Shrine", Name: "Commerce" });
    let py = VisitedRooms[0].y * 2 - 2;
    let p1x = VisitedRooms[0].x * 2 + 5;
    KinkyDungeonCreateRectangle(p1x, py, 5, 2, false, false, false, false);
    POI.push({ x: VisitedRooms[0].x * 2 + 7, y: VisitedRooms[0].y * 2, requireTags: [], favor: ["PearlChest"], used: false });
    let perkCount = 3;
    let perks = {};
    for (let i = 0; i < perkCount; i++) {
        let newperks = KDGetRandomPerks(perks);
        if (newperks.length > 0) {
            KinkyDungeonMapSet(p1x + i * 2, py, 'P');
            KinkyDungeonTilesSet("" + (p1x + i * 2) + "," + (py), { Perks: newperks });
            for (let p of newperks) {
                perks[p] = true;
            }
        }
    }
    if (KinkyDungeonLostItems.length > 0)
        KDChest(VisitedRooms[0].x * 2 + 0, VisitedRooms[0].y * 2 - 2, "lost_items");
    KinkyDungeonMapSet(width * 2 - 2, VisitedRooms[0].y * 2, 's');
    KinkyDungeonTilesSet("" + (width * 2 - 2) + "," + (VisitedRooms[0].y * 2), { RoomType: "Tunnel" });
    KinkyDungeonEndPosition = { x: width * 2 - 2, y: VisitedRooms[0].y * 2 };
}
function KinkyDungeonCreateJourneyFloor(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonStartPosition = { x: 2, y: height };
    VisitedRooms[0].x = 1;
    VisitedRooms[0].y = Math.floor(height / 2);
    KinkyDungeonCreateRectangle(0, 0, width, height, true, true, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y - 1, 2, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y, 6, 1, false, false, false, false);
    let b1 = 4;
    KinkyDungeonCreateRectangle(b1, VisitedRooms[0].y - 3, width - b1, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(b1, VisitedRooms[0].y - 3, 1, 3, false, false, false, false);
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    KinkyDungeonMapSet(b1 * 2 + 5, VisitedRooms[0].y * 2, 's');
    KinkyDungeonMapSet(b1 * 2 + 5, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (b1 * 2 + 5) + "," + (VisitedRooms[0].y * 2), { Journey: undefined });
    KinkyDungeonTilesSet("" + (b1 * 2 + 5) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "JourneyNone" });
    KinkyDungeonMapSet(VisitedRooms[0].x * 2 + 3, VisitedRooms[0].y * 2 - 2, 's');
    KinkyDungeonMapSet(VisitedRooms[0].x * 2 + 3, VisitedRooms[0].y * 2 - 1, 'G');
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x * 2 + 3) + "," + (VisitedRooms[0].y * 2 - 2), { RoomType: "Tutorial" });
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x * 2 + 3) + "," + (VisitedRooms[0].y * 2 - 1), { Type: "Ghost", Msg: "JourneyTutorial" });
    let x = b1 * 2;
    let i = 0;
    while (x < width * 2 - 2) {
        if (KDJourneyList[i]) {
            KinkyDungeonMapSet(x, VisitedRooms[0].y * 2 - 6, 's');
            KinkyDungeonMapSet(x, VisitedRooms[0].y * 2 - 5, 'G');
            KinkyDungeonTilesSet("" + (x) + "," + (VisitedRooms[0].y * 2 - 6), { Journey: KDJourneyList[i], MapMod: KDJourneyMapMod[KDJourneyList[i]] ? KDGetMapGenList(1, KDMapMods)[0].name : undefined });
            KinkyDungeonTilesSet("" + (x) + "," + (VisitedRooms[0].y * 2 - 5), { Type: "Ghost", Msg: "Journey" + KDJourneyList[i] });
        }
        i++;
        x += 2;
    }
    KinkyDungeonEndPosition = { x: b1 * 2 + 5, y: VisitedRooms[0].y * 2 };
}
function KinkyDungeonCreateShopStart(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonStartPosition = { x: 2, y: height };
    VisitedRooms[0].x = 1;
    VisitedRooms[0].y = Math.floor(height / 2);
    KinkyDungeonCreateRectangle(0, 0, width, height, true, true, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y - 1, 4, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y, 6, 1, false, false, false, false);
    let b1 = 4;
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    KD_PasteTile(KDMapTilesList.ShopStart, KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y - 4, data);
    DialogueCreateEnemy(KinkyDungeonStartPosition.x + 5, KinkyDungeonStartPosition.y, "ShopkeeperStart");
    KinkyDungeonMapSet(b1 * 2 + 7, VisitedRooms[0].y * 2, 's');
    if (MiniGameKinkyDungeonLevel == 0)
        KinkyDungeonTilesSet("" + (b1 * 2 + 7) + "," + (VisitedRooms[0].y * 2), { RoomType: "JourneyFloor" });
    KinkyDungeonEndPosition = { x: b1 * 2 + 5, y: VisitedRooms[0].y * 2 };
}
function KinkyDungeonCreateTestTile(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonStartPosition = { x: 2, y: height };
    VisitedRooms[0].x = 1;
    VisitedRooms[0].y = Math.floor(height / 2);
    KinkyDungeonCreateRectangle(0, 0, width, height, false, false, false, false);
    let b1 = 4;
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    KD_PasteTile(KDTileToTest, KinkyDungeonStartPosition.x + 4, 3, data);
    KinkyDungeonEndPosition = { x: b1 * 2 + 5, y: VisitedRooms[0].y * 2 };
}
function KinkyDungeonCreateTutorial(POI, VisitedRooms, width, height, openness, density, hallopenness, data) {
    KinkyDungeonStartPosition = { x: 2, y: height };
    VisitedRooms[0].x = 1;
    VisitedRooms[0].y = Math.floor(height / 2);
    KinkyDungeonCreateRectangle(0, 0, width, height, true, true, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y - 1, 2, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(VisitedRooms[0].x, VisitedRooms[0].y, width, 1, false, false, false, false);
    let KinkyDungeonOldGrid = KinkyDungeonGrid;
    let w = KinkyDungeonGridWidth;
    let h = KinkyDungeonGridHeight;
    KinkyDungeonGridWidth = Math.floor(KinkyDungeonGridWidth * 2);
    KinkyDungeonGridHeight = Math.floor(KinkyDungeonGridHeight * 2);
    KinkyDungeonGrid = "";
    for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
        for (let X = 0; X < KinkyDungeonGridWidth; X++)
            KinkyDungeonGrid = KinkyDungeonGrid + KinkyDungeonOldGrid[Math.floor(X * w / KinkyDungeonGridWidth) + Math.floor(Y * h / KinkyDungeonGridHeight) * (w + 1)];
        KinkyDungeonGrid = KinkyDungeonGrid + '\n';
    }
    KinkyDungeonMapSet(width * 2 - 2, VisitedRooms[0].y * 2, 's');
    KinkyDungeonMapSet(width * 2 - 2, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (width * 2 - 2) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "TutorialCongrats" });
    KinkyDungeonMapSet(VisitedRooms[0].x + 3, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x + 3) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial0" });
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + 7, 3, 2, height * 2, false, false, false, false);
    KinkyDungeonMapSet(VisitedRooms[0].x + 7, VisitedRooms[0].y * 2, 'L');
    KinkyDungeonMapSet(VisitedRooms[0].x + 7, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x + 7) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Dialogue: "Tutorial1" });
    KinkyDungeonMapSet(VisitedRooms[0].x + 11, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x + 11) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial2" });
    let xx = 13;
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx + 4, 3, 2, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx + 4, 3, 1, 5, false, false, false, false);
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 4, 5, 'd');
    KinkyDungeonTilesSet((KinkyDungeonStartPosition.x + xx + 4) + "," + 5, {
        Type: "Door",
    });
    KinkyDungeonGroundItems.push({ x: KinkyDungeonStartPosition.x + xx + 4, y: 4, name: "PotionWill" });
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 2, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 1, 5, false, false, false, false);
    KinkyDungeonGroundItems.push({ x: KinkyDungeonStartPosition.x + xx, y: 4, name: "PotionWill" });
    KinkyDungeonMapSet(VisitedRooms[0].x + xx + 1, 5, 'T');
    KinkyDungeonTilesSet((VisitedRooms[0].x + xx + 1) + "," + 5, {
        Type: "Trap",
        Trap: "SpecificSpell",
        noVary: true,
        Spell: "TrapSCloud",
    });
    KinkyDungeonMapSet(VisitedRooms[0].x + xx + 3, VisitedRooms[0].y * 2, 'T');
    KinkyDungeonTilesSet((VisitedRooms[0].x + xx + 3) + "," + (VisitedRooms[0].y * 2), {
        Type: "Trap",
        Trap: "SpecificSpell",
        noVary: true,
        Spell: "TrapSCloud",
    });
    KinkyDungeonMapSet(VisitedRooms[0].x + xx + 3, VisitedRooms[0].y * 2 + 1, 'T');
    KinkyDungeonTilesSet((VisitedRooms[0].x + xx + 3) + "," + (VisitedRooms[0].y * 2 + 1), {
        Type: "Trap",
        Trap: "SpecificSpell",
        noVary: true,
        Spell: "TrapSCloud",
    });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx - 1, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx - 1) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial2_sp1" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 1, 3, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx + 1) + "," + (3), { Type: "Ghost", Msg: "Tutorial2_sp2" });
    KinkyDungeonMapSet(VisitedRooms[0].x + xx + 4, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (VisitedRooms[0].x + xx + 4) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial2_sp3" });
    xx = 22;
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 2, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 1, 5, false, false, false, false);
    KinkyDungeonGroundItems.push({ x: KinkyDungeonStartPosition.x + xx, y: 4, name: "PotionMana" });
    KinkyDungeonMapSet(VisitedRooms[0].x + xx + 1, 5, 'd');
    KinkyDungeonTilesSet((VisitedRooms[0].x + xx + 1) + "," + 5, {
        Type: "Door",
    });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx - 5, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx - 5) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial2_mp1" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx - 3, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx - 3) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial2_mp2" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx - 1, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx - 1) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Dialogue: "Tutorial2_mp3" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 2, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx + 2) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial2_mp4" });
    xx = 28;
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 7, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 1, 5, false, false, false, false);
    KinkyDungeonGroundItems.push({ x: KinkyDungeonStartPosition.x + xx, y: 4, name: "PotionFrigid" });
    KinkyDungeonMapSet(VisitedRooms[0].x + xx + 1, 5, 'T');
    KinkyDungeonTilesSet((VisitedRooms[0].x + xx + 1) + "," + 5, {
        Type: "Trap",
        Trap: "SpecificSpell",
        noVary: true,
        Spell: "TrapLustCloud",
    });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx - 1, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx - 1) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial2_dp1" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 1, 3, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx + 1) + "," + (3), { Type: "Ghost", Dialogue: "Tutorial2_dp2" });
    xx = 36;
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 5, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 1, 5, false, false, false, false);
    KinkyDungeonGroundItems.push({ x: KinkyDungeonStartPosition.x + xx + 4, y: 4, name: "RedKey" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx - 1, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx - 1) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial3_1" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 4, 3, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx + 4) + "," + (3), { Type: "Ghost", Msg: "Tutorial3_2" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 1, 3, 'C');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx + 1) + "," + (3), { Loot: "tutorial1", Roll: KDRandom() });
    xx = 43;
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 5, 2, false, false, false, false);
    KinkyDungeonCreateRectangle(KinkyDungeonStartPosition.x + xx, 3, 1, 5, false, false, false, false);
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 4, 4, '?');
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx - 1, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx - 1) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial3_3" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 4, 3, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx + 4) + "," + (3), { Type: "Ghost", Msg: "Tutorial3_4" });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx, 3, 'C');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx) + "," + (3), { Loot: "tutorial2", Roll: KDRandom() });
    KinkyDungeonMapSet(KinkyDungeonStartPosition.x + xx + 4, VisitedRooms[0].y * 2 + 1, 'G');
    KinkyDungeonTilesSet("" + (KinkyDungeonStartPosition.x + xx + 4) + "," + (VisitedRooms[0].y * 2 + 1), { Type: "Ghost", Msg: "Tutorial4" });
    DialogueCreateEnemy(width * 2 - 7, VisitedRooms[0].y * 2, "FastZombie").AI = "guard";
    DialogueCreateEnemy(width * 2 - 5, VisitedRooms[0].y * 2 + 1, "FastZombie").AI = "guard";
    DialogueCreateEnemy(width * 2 - 3, VisitedRooms[0].y * 2, "FastZombie").AI = "guard";
    DialogueCreateEnemy(width * 2 - 3, VisitedRooms[0].y * 2 + 1, "BlindZombie").AI = "guard";
    KinkyDungeonMapSet(width * 2 - 5, VisitedRooms[0].y * 2, 'C');
    KinkyDungeonTilesSet("" + (width * 2 - 5) + "," + (VisitedRooms[0].y * 2), { Loot: "silver", Roll: KDRandom() });
    KinkyDungeonMapSet(width * 2 - 6, VisitedRooms[0].y * 2, 'C');
    KinkyDungeonTilesSet("" + (width * 2 - 6) + "," + (VisitedRooms[0].y * 2), { Loot: "chest", Roll: KDRandom() });
    KinkyDungeonEndPosition = { x: width * 2 - 2, y: VisitedRooms[0].y * 2 };
}
let KinkyDungeonBones = {};
let KDPatronAdventurers = [];
let KDPatronCustomEnemies = new Map([
    ["Wolfgirl", [
            { name: "Sivasa", color: "#9c2a70", prisoner: false, free: true, customSprite: "" },
            { name: "Alexandra", color: "#6241e1", prisoner: true, free: true, customSprite: "" },
            { name: "Nekora", color: "#42a459", prisoner: true, free: true, customSprite: "" },
            { name: "Emeia", color: "#00A7FF", prisoner: true, free: true, customSprite: "" },
            { name: "Dana", color: "#4444ff", prisoner: true, free: true, customSprite: "" },
            { name: "Yami", color: "#88ff88", prisoner: true, free: true, customSprite: "" },
            { name: "Animi", color: "#ff9999", prisoner: true, free: false, customSprite: "" },
            { name: "Ladica", color: "#44ff44", prisoner: false, free: true, customSprite: "" },
        ],
    ],
    ["WolfgirlPet", [
            { name: "Demetria", color: "#c9d4fd", prisoner: true, free: false, customSprite: "" },
            { name: "Arii", color: "#ff88ff", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["Nurse", [
            { name: "Rena", color: "#a452ff", prisoner: true, free: true, customSprite: "" },
            { name: "Str Nurse", color: "#ffffff", prisoner: false, free: true, customSprite: "" },
        ],
    ],
    ["ElementalLatex", [
            { name: "Samsy", color: "#2f847f", prisoner: false, free: true, customSprite: "" },
        ],
    ],
    ["Dragon", [
            { name: "Garss", color: "#ff8888", prisoner: true, free: false, customSprite: "" },
        ],
    ],
    ["DragonLeaderDuelist", [
            { name: "Kaitlyn", color: "#ff5555", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["SlimeAdv", [
            { name: "Rena", color: "#C8C8FF", prisoner: true, free: true, customSprite: "" },
            { name: "Rappy The Toy", color: "#C759FF", prisoner: true, free: false, customSprite: "" },
        ],
    ],
    ["SmallSlime", [
            { name: "TY", color: "#ff5555", prisoner: false, free: true, customSprite: "" },
        ],
    ],
    ["WitchRope", [
            { name: "Kamikaze roper", color: "#ffae70", prisoner: true, free: false, customSprite: "" },
        ],
    ],
    ["MaidforceStalker", [
            { name: "Chandra", color: "#340000", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["ApprenticeSlime", [
            { name: "Gabrielle", color: "#ffff00", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["Alchemist", [
            { name: "Morgan", color: "#6241e1", prisoner: true, free: true, customSprite: "" },
            { name: "Myth", color: "#22ffff", prisoner: false, free: true, customSprite: "" },
        ],
    ],
    ["Dressmaker", [
            { name: "A Lazy Dressmaker", color: "#fad6ff", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["Maidforce", [
            { name: "Ester", color: "#97edca", prisoner: true, free: false, customSprite: "" },
            { name: "Rest", color: "#999999", prisoner: false, free: true, customSprite: "" },
            { name: "Rika Mercury", color: "#92e8e5", prisoner: true, free: false, customSprite: "" },
            { name: "Maidlinmo", color: "#ff5555", prisoner: true, free: true, customSprite: "" },
            { name: "April", color: "#4444ff", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["WitchFlame", [
            { name: "Myrtrice", color: "#d30000", prisoner: false, free: true, customSprite: "Myrtrice" },
        ],
    ],
    ["BanditPet", [
            { name: "Liz", color: "#d480bb", prisoner: true, free: true, customSprite: "" },
            { name: "Jinxy", color: "#7d27a5", prisoner: true, free: true, customSprite: "" },
            { name: "Genna", color: "#42bfe8", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["ElfRanger", [
            { name: "Valeria", color: "#ebaaf4", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["Elf", [
            { name: "Ferahla", color: "#44ff44", prisoner: true, free: true, customSprite: "" },
        ],
    ],
    ["Dollsmith", [
            { name: "Kiera", color: "#310051", prisoner: false, free: true, customSprite: "" },
        ],
    ],
]);
function KDProcessCustomPatron(Enemy, e) {
    if (KDPatronCustomEnemies.get(Enemy.name) && KDRandom() < 0.05) {
        let customs = KDPatronCustomEnemies.get(Enemy.name).filter((element) => {
            return (element.prisoner && Enemy.specialdialogue && Enemy.specialdialogue.includes("Prisoner")) || (element.free && !Enemy.specialdialogue);
        });
        if (customs.length > 0) {
            let custom = customs[Math.floor(customs.length * KDRandom())];
            e.CustomName = custom.name;
            e.CustomNameColor = custom.color;
            e.CustomSprite = custom.customSprite;
        }
    }
}
let KDMapMods = {
    "None": {
        name: "None",
        roomType: "",
        weight: 100,
        tags: [],
        bonusTags: {},
        bonussetpieces: [
            { Type: "BanditPrison", Weight: 12 },
        ],
        altRoom: "",
    },
    "Mold": {
        name: "Mold",
        roomType: "",
        weight: 100,
        tags: ["maid", "mold"],
        faction: "Slime",
        tagsOverride: ["maid", "mold"],
        jailType: "maid",
        guardType: "maid",
        bonusTags: {
            "mold": { bonus: 4, mult: 2.5 },
            "maid": { bonus: 5, mult: 1.5 },
            "construct": { bonus: 0, mult: 0 },
        },
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["mold"], tags: [], currentCount: 0, maxCount: 0.5, ignoreAllyCount: true },
            { requiredTags: ["maid"], tags: [], currentCount: 0, maxCount: 0.25, ignoreAllyCount: true },
        ],
    },
    "Bandit": {
        name: "Bandit",
        roomType: "",
        weight: 50,
        tags: ["bandit", "banditleader", "bountyhunter", "dragon"],
        faction: "Bandit",
        jailType: "bandit",
        guardType: "bandit",
        bonusTags: {
            "bandit": { bonus: 4, mult: 2.5 },
            "bountyhunter": { bonus: 1, mult: 2.5 },
            "banditleader": { bonus: 40, mult: 0.3 },
        },
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["bandit"], tags: [], currentCount: 0, maxCount: 0.4, ignoreAllyCount: true },
            { requiredTags: ["bountyhunter"], tags: [], currentCount: 0, maxCount: 0.2, ignoreAllyCount: true },
        ],
    },
    "Dragon": {
        name: "Dragon",
        roomType: "",
        weight: 50,
        tags: ["witch", "elemental", "dragon"],
        faction: "Dragon",
        jailType: "dragon",
        guardType: "dragon",
        bonusTags: {
            "dragon": { bonus: 7, mult: 2 },
            "elemental": { bonus: 3, mult: 1.5 },
        },
        bonussetpieces: [
            { Type: "BanditPrison", Weight: 8 },
        ],
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["dragon"], tags: [], currentCount: 0, maxCount: 0.33, ignoreAllyCount: true },
            { requiredTags: ["elemental"], tags: [], currentCount: 0, maxCount: 0.33, ignoreAllyCount: true },
        ],
    },
    "Witch": {
        name: "Witch",
        roomType: "",
        weight: 50,
        tags: ["witch", "apprentice", "skeleton"],
        faction: "Witch",
        jailType: "witch",
        guardType: "apprentice",
        bonusTags: {
            "witch": { bonus: 3, mult: 1.5 },
            "apprentice": { bonus: 3, mult: 1.4 },
        },
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["witch"], tags: [], currentCount: 0, maxCount: 0.25, ignoreAllyCount: true },
            { requiredTags: ["apprentice"], tags: [], currentCount: 0, maxCount: 0.25, ignoreAllyCount: true },
        ],
    },
    "Wolf": {
        name: "Wolf",
        roomType: "",
        weight: 70,
        tags: ["nevermere"],
        faction: "Nevermmere",
        jailType: "trainer",
        guardType: "trainer",
        bonusTags: {
            "nevermere": { bonus: 11, mult: 1.5 },
            "trainer": { bonus: 11, mult: 0.75 },
        },
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["nevermere"], tags: [], currentCount: 0, maxCount: 0.3, ignoreAllyCount: true },
        ],
    },
    "Robot": {
        name: "Robot",
        roomType: "",
        weight: 35,
        tags: ["robot"],
        faction: "AncientRobots",
        bonusTags: {
            "robot": { bonus: 10, mult: 4 },
        },
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["robot"], tags: [], currentCount: 0, maxCount: 0.3, ignoreAllyCount: true },
        ],
    },
    "Plant": {
        name: "Plant",
        roomType: "",
        weight: 50,
        tags: ["plant", "elf"],
        jailType: "elf",
        guardType: "elf",
        faction: "Beast",
        bonusTags: {
            "plant": { bonus: 5, mult: 2 },
            "maid": { bonus: 4.5, mult: 1 },
        },
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["plant"], tags: [], currentCount: 0, maxCount: 0.35, ignoreAllyCount: true },
        ],
    },
    "Slime": {
        name: "Slime",
        roomType: "",
        weight: 50,
        tags: ["slime", "alchemist"],
        faction: "Slime",
        jailType: "alchemist",
        guardType: "alchemist",
        bonusTags: {
            "slime": { bonus: 4, mult: 3 },
            "maid": { bonus: 4.5, mult: 1.5 },
        },
        altRoom: "",
        spawnBoxes: [
            { requiredTags: ["slime"], tags: [], currentCount: 0, maxCount: 0.3, ignoreAllyCount: true },
        ],
    },
};
function KDGetMapGenList(count, mods) {
    let ret = [];
    for (let i = 0; i < count; i++) {
        let genWeightTotal = 0;
        let genWeights = [];
        for (let mod of Object.values(mods)) {
            if (!ret.includes(mod)) {
                genWeights.push({ mod: mod, weight: genWeightTotal });
                genWeightTotal += mod.weight;
            }
        }
        let selection = KDRandom() * genWeightTotal;
        for (let L = genWeights.length - 1; L >= 0; L--) {
            if (selection > genWeights[L].weight) {
                ret.push(genWeights[L].mod);
                break;
            }
        }
    }
    return ret;
}
let bosses = {
    "Fuuka": {
        boss: "Fuuka",
        bossroom: true,
        width: 13,
        height: 13,
        setpieces: {
            "GuaranteedCell": 1000,
            "FuukaAltar": 1000,
        },
        genType: "Chamber",
        spawns: false,
        chests: false,
        shrines: true,
        chargers: true,
        torches: true,
        heart: false,
        specialtiles: true,
        shortcut: false,
        enemies: false,
        nokeys: true,
        nojail: false,
    },
    "Dollmaker": {
        boss: "Dollmaker",
        bossroom: true,
        jailType: "dollsmith",
        guardType: "dollsmith",
        width: 21,
        height: 21,
        setpieces: {},
        genType: "Dollmaker",
        spawns: false,
        chests: false,
        shrines: false,
        noWear: true,
        chargers: false,
        notorches: true,
        heart: false,
        specialtiles: true,
        shortcut: false,
        enemies: false,
        nokeys: true,
        nojail: true,
        noClutter: true,
        nostairs: true,
        nostartstairs: true,
        nobrick: true,
        nolore: true,
        skin: 'bel',
        noboring: true,
    },
};
function KinkyDungeonBossFloor(Floor) {
    if (Floor == 4)
        return bosses.Fuuka;
    if (Floor == 20)
        return bosses.Dollmaker;
    return null;
}
let KDDoorKnobChance = 0.1;
let KDDoorKnobChanceArms = 0.5;
let KDDoorAttractChance = 0.25;
let KDDoorAttractChanceArms = 0.1;
let KDCategoriesStart = [
    { name: "Toggles", buffs: [], debuffs: [], },
    { name: "Multiclass", buffs: [], debuffs: [], },
    { name: "Restraints", buffs: [], debuffs: [], },
    { name: "Kinky", buffs: [], debuffs: [], },
    { name: "Damage", buffs: [], debuffs: [], },
    { name: "Combat", buffs: [], debuffs: [], },
    { name: "Magic", buffs: [], debuffs: [], },
    { name: "Enemies", buffs: [], debuffs: [], },
    { name: "Map", buffs: [], debuffs: [], },
    { name: "Start", buffs: [], debuffs: [], },
    { name: "Boss", buffs: [], debuffs: [], },
];
let KDPerkIcons = {
    "Pacifist": () => { return true; },
    "BerserkerRage": () => { return true; },
    "BoundPower": () => { return true; },
    "UnstableMagic": () => { return true; },
    "BurningDesire": () => { return true; },
    "FrigidPersonality": () => { return true; },
    "ImmovableObject": () => { return KinkyDungeonStatWill >= KinkyDungeonStatWillMax * 0.90; },
    "GroundedInReality": () => { return KinkyDungeonPlayerDamage && KinkyDungeonStatMana >= KinkyDungeonStatManaMax * 0.999; },
    "LikeTheWind": () => { return KinkyDungeonStatStamina >= KinkyDungeonStatStaminaMax * 0.95; },
    "LeastResistance": () => { return KinkyDungeonStatWill < KinkyDungeonStatWillMax * 0.01; },
};
let KDPerkUpdateStats = {
    "Rigger": () => {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "Rigger1",
            type: "glueDamageBuff",
            power: KDRiggerDmgBoost,
            duration: 2
        });
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "Rigger2",
            type: "chainDamageBuff",
            power: KDRiggerDmgBoost,
            duration: 2
        });
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "Rigger3",
            type: "BindAmp",
            power: KDRiggerBindBoost,
            duration: 2
        });
    },
    "Ticklish": () => {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "Ticklish", type: "tickleDamageResist", power: -0.5, duration: 2
        });
    },
    "Stoic": () => {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "Stoic", type: "tickleDamageResist", power: 0.82, duration: 2
        });
    },
    "Lascivious": () => {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "Lascivious", type: "gropeDamageResist", power: -0.5, duration: 2
        });
    },
    "Unperturbed": () => {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "Unperturbed", type: "gropeDamageResist", power: 0.82, duration: 2
        });
    },
    "PainTolerance": () => {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "PainTolerance", type: "painDamageResist", power: 2.0, duration: 2
        });
    },
    "Sticky": () => {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
            id: "StickySituation", type: "glueDamageResist", power: -0.4, duration: 2
        });
    },
    "BoundPower": () => {
        KDDamageAmpPerks += KDBoundPowerLevel * KDBoundPowerMult;
    },
    "BerserkerRage": () => {
        KDDamageAmpPerksMelee += KDBerserkerAmp * KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax;
    },
    "Dodge": () => {
        if (KinkyDungeonMiscastChance < 0.001) {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                id: "FocusedDodge", type: "Evasion", power: 0.4, duration: 1, sfxApply: "Fwoosh"
            });
        }
    },
    "UnstableMagic": () => {
        KDDamageAmpPerksSpell += KDUnstableAmp * Math.min(1, Math.max(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax, KinkyDungeonMiscastChance));
    },
    "CommonLatex": () => {
        KDExtraEnemyTags.latexRestraints = 0;
        KDExtraEnemyTags.latexRestraintsHeavy = 3;
    },
    "CommonLeather": () => {
        KDExtraEnemyTags.leatherRestraints = 0;
        KDExtraEnemyTags.leatherRestraintsHeavy = 3;
    },
    "CommonMaid": () => {
        KDExtraEnemyTags.maidRestraints = 0;
        KDExtraEnemyTags.maidVibeRestraintsLimited = 0;
    },
    "CommonWolf": () => {
        KDExtraEnemyTags.wolfRestraints = 0;
        KDExtraEnemyTags.wolfCuffs = 3;
        KDExtraEnemyTags.wolfGear = 0;
    },
    "CommonDress": () => {
        KDExtraEnemyTags.dressRestraints = 0;
    },
    "CommonFuuka": () => {
        KDExtraEnemyTags.mikoRestraints = 0;
    },
    "CommonCyber": () => {
        KDExtraEnemyTags.cyberdollrestraints = 0;
        KDExtraEnemyTags.cyberdollchastity = 3;
        KDExtraEnemyTags.cyberdollheavy = 7;
    },
    "CommonExp": () => {
        KDExtraEnemyTags.expRestraints = 0;
    },
    "CommonKitty": () => {
        KDExtraEnemyTags.kittyRestraints = 0;
    },
};
let KDPerkCount = {
    "BerserkerRage": () => {
        return " "
            + (KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > 0.25 ? "! " : "")
            + (KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > 0.5 ? "! " : "")
            + (KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > 0.75 ? "! " : "");
    },
    "UnstableMagic": () => {
        return " "
            + (KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > 0.25 ? "! " : "")
            + (KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > 0.5 ? "! " : "")
            + (KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > 0.75 ? "! " : "");
    },
    "BoundPower": () => {
        return KDBoundPowerLevel > 0 ? Math.round(KDBoundPowerLevel * 100) + "%" : "";
    },
};
let KinkyDungeonStatsPresets = {
    "MC_Trainee": { category: "Multiclass", id: "MC_Trainee", cost: 2, requireArousal: true, blockclass: ["Trainee"], tags: ["start", "mc"] },
    "FutileStruggles": { category: "Restraints", id: "FutileStruggles", cost: -1, block: ["SecondWind"] },
    "SecondWind": { category: "Restraints", id: "SecondWind", cost: 1, block: ["FutileStruggles"] },
    "Stranger": { startPriority: 1000, category: "Enemies", id: "Stranger", cost: 0, block: ["WrongNeighborhood"], tags: ["start"] },
    "WrongNeighborhood": { startPriority: 1000, category: "Enemies", id: "WrongNeighborhood", cost: -1, block: ["Stranger"], tags: ["start"] },
    "Strong": { category: "Restraints", id: 0, cost: 2, block: ["Weak"] },
    "Weak": { category: "Restraints", id: 1, cost: -1, block: ["Strong"] },
    "Flexible": { category: "Restraints", id: 2, cost: 2, block: ["Inflexible"] },
    "Inflexible": { category: "Restraints", id: 3, cost: -1, block: ["Flexible"] },
    "Locksmith": { category: "Restraints", id: 4, cost: 2, block: ["Clueless"] },
    "Clueless": { category: "Restraints", id: 5, cost: -1, block: ["Locksmith"] },
    "HighSecurity": { category: "Restraints", id: 48, cost: -1 },
    "NoWayOut": { category: "Restraints", id: 52, cost: -1 },
    "TightRestraints": { category: "Restraints", id: 54, cost: -1 },
    "MagicHands": { category: "Restraints", id: "MagicHands", cost: -1 },
    "CursedLocks": { category: "Restraints", id: "CursedLocks", cost: -1 },
    "FranticStruggle": { category: "Restraints", id: "FranticStruggle", cost: 1 },
    "Unchained": { category: "Kinky", id: 26, cost: 2, block: ["Damsel"] },
    "Damsel": { category: "Kinky", id: 27, cost: -1, block: ["Unchained"] },
    "Artist": { category: "Kinky", id: 28, cost: 2, block: ["Bunny"] },
    "Bunny": { category: "Kinky", id: 29, cost: -1, block: ["Artist"] },
    "Slippery": { category: "Kinky", id: 30, cost: 2, block: ["Doll"] },
    "Doll": { category: "Kinky", id: 31, cost: -1, block: ["Slippery"] },
    "Escapee": { category: "Kinky", id: 32, cost: 2, block: ["Dragon"] },
    "Dragon": { category: "Kinky", id: 33, cost: -1, block: ["Escapee"] },
    "Dodge": { category: "Combat", id: 18, cost: 3, block: ["Distracted"] },
    "Distracted": { category: "Combat", id: 19, cost: -1, block: ["Dodge"] },
    "Submissive": { startPriority: 0, category: "Kinky", id: 10, cost: 0 },
    "Wanted": { category: "Kinky", id: 11, cost: -1 },
    "QuickDraw": { category: "Combat", id: 55, cost: 1, block: ["Disorganized"] },
    "Disorganized": { category: "Combat", id: 57, cost: -2, block: ["QuickDraw", "QuickScribe"] },
    "Brawler": { category: "Combat", id: 20, cost: 1 },
    "Clumsy": { category: "Combat", id: 21, cost: -1 },
    "Unfocused": { category: "Combat", id: "Unfocused", cost: -1 },
    "HeelWalker": { category: "Combat", id: 53, cost: 1 },
    "BondageLover": { category: "Kinky", id: 15, cost: -1 },
    "Undeniable": { category: "Kinky", id: "Undeniable", cost: -1 },
    "Needs": { category: "Kinky", id: "Needs", cost: -1 },
    "BoundPower": { category: "Combat", id: 40, cost: 3 },
    "SavourTheTaste": { category: "Combat", id: "SavourTheTaste", cost: -1 },
    "ResilientFoes": { category: "Enemies", id: "ResilientFoes", cost: -1 },
    "KillSquad": { category: "Enemies", id: 41, cost: -3, block: ["Conspicuous"] },
    "Stealthy": { category: "Enemies", id: 38, cost: 0 },
    "Conspicuous": { category: "Enemies", id: 39, cost: -1, block: ["KillSquad"] },
    "Dominant": { category: "Map", id: "Dominant", cost: 2, block: ["Oppression"] },
    "Oppression": { category: "Map", id: 50, cost: -1, block: ["Dominant"] },
    "Supermarket": { category: "Map", id: 42, cost: 1 },
    "PriceGouging": { category: "Map", id: 43, cost: -2 },
    "Psychic": { category: "Restraints", id: 6, cost: 4 },
    "Slayer": { category: "Magic", id: 34, cost: 3 },
    "Magician": { category: "Magic", id: 36, cost: 3 },
    "Pristine": { category: "Map", id: 22, cost: -1 },
    "Conjurer": { category: "Magic", id: 35, cost: 3 },
    "LostTechnology": { category: "Map", id: 23, cost: -1 },
    "Cursed": { category: "Enemies", id: 9, cost: -3 },
    "Studious": { category: "Magic", id: 12, cost: 1, tags: ["start"] },
    "Clearheaded": { category: "Magic", id: "Clearheaded", cost: 1, block: ["ArousingMagic"] },
    "ArousingMagic": { category: "Magic", id: "ArousingMagic", cost: -1, block: ["Clearheaded"] },
    "BerserkerRage": { category: "Combat", id: "BerserkerRage", cost: 3 },
    "UnstableMagic": { category: "Magic", id: "UnstableMagic", cost: 2 },
    "Vengeance": { category: "Enemies", id: "Vengeance", cost: -1 },
    "AbsoluteFocus": { category: "Magic", id: "AbsoluteFocus", cost: -1 },
    "Hogtied": { startPriority: 50, category: "Start", id: "Hogtied", cost: -1, tags: ["start"] },
    "StartObsidian": { startPriority: 5, category: "Start", id: "StartObsidian", cost: -2, outfit: "Obsidian", tags: ["start"] },
    "StartWolfgirl": { startPriority: 10, category: "Start", id: "StartWolfgirl", cost: -2, outfit: "Wolfgirl", tags: ["start"] },
    "StartMaid": { startPriority: 20, category: "Start", id: "StartMaid", cost: -2, outfit: "Maid", tags: ["start"] },
    "StartLatex": { startPriority: 15, category: "Start", id: "StartLatex", cost: -2, tags: ["start"] },
    "StartCyberDoll": { startPriority: 7, category: "Boss", id: "StartCyberDoll", cost: -2, locked: true, tags: ["start"] },
    "DollmakerVisor": { startPriority: 31, category: "Boss", id: "DollmakerVisor", cost: -1, locked: true, tags: ["start"] },
    "FuukaCollar": { startPriority: 40, category: "Boss", buff: true, id: "FuukaCollar", cost: -2, locked: true, tags: ["start"] },
    "CommonCyber": { category: "Boss", id: "CommonCyber", cost: -1, locked: true },
    "CommonFuuka": { category: "Boss", id: "CommonFuuka", buff: true, cost: -1, locked: true },
    "Nowhere": { category: "Enemies", id: "Nowhere", cost: -1 },
    "Prisoner": { category: "Start", id: "Prisoner", cost: 0 },
    "Panic": { category: "Map", id: "Panic", cost: -1 },
    "Rusted": { category: "Map", id: "Rusted", cost: 1 },
    "Forgetful": { category: "Map", id: "Forgetful", cost: -1, block: ["TotalBlackout"] },
    "Unmasked": { category: "Toggles", id: "Unmasked", cost: 0, tags: ["start"] },
    "NoNurse": { category: "Toggles", id: "NoNurse", cost: 0, tags: ["start"] },
    "NoBrats": { category: "Toggles", id: "NoBrats", cost: 0, tags: ["start"], debuff: true, block: ["OnlyBrats"] },
    "OnlyBrats": { category: "Toggles", id: "OnlyBrats", cost: 0, tags: ["start"], debuff: true, block: ["NoBrats"] },
    "TapePref": { category: "Toggles", id: "TapePref", cost: 0, tags: ["start"], block: ["TapeOptout"] },
    "TapeOptout": { category: "Toggles", id: "TapeOptout", cost: 0, tags: ["start"], debuff: true, block: ["TapePref"] },
    "NoDoll": { category: "Toggles", id: "NoDoll", cost: 0, tags: ["start"], debuff: true },
    "Quickness": { category: "Combat", id: "Quickness", cost: 2 },
    "BoundCrusader": { category: "Kinky", id: "BoundCrusader", cost: -1 },
    "Trespasser": { category: "Map", id: "Trespasser", cost: -2 },
    "Butterfingers": { category: "Restraints", id: "Butterfingers", cost: -1 },
    "WeakGrip": { category: "Restraints", id: "WeakGrip", cost: -1 },
    "Blackout": { category: "Combat", id: "Blackout", cost: -1, block: ["TotalBlackout"] },
    "TotalBlackout": { category: "Combat", id: "TotalBlackout", cost: -2, block: ["Blackout", "Forgetful"] },
    "Incantation": { category: "Magic", id: "Incantation", cost: -1 },
    "Stoic": { category: "Damage", id: "Stoic", cost: 1, block: ["Ticklish"] },
    "Ticklish": { category: "Damage", id: "Ticklish", cost: -1, block: ["Stoic"] },
    "Unperturbed": { category: "Damage", id: "Unperturbed", cost: 1, block: ["Lascivious"] },
    "Lascivious": { category: "Damage", id: "Lascivious", cost: -1, block: ["Unperturbed"] },
    "Masochist": { category: "Damage", id: "Masochist", cost: -1 },
    "PainTolerance": { category: "Damage", id: "PainTolerance", cost: 1 },
    "Rigger": { category: "Damage", id: 24, cost: 2 },
    "Pacifist": { category: "Damage", id: 25, cost: -2 },
    "BurningDesire": { category: "Damage", id: "BurningDesire", cost: 1 },
    "FrigidPersonality": { category: "Damage", id: "FrigidPersonality", cost: 2 },
    "GroundedInReality": { category: "Damage", id: "GroundedInReality", cost: 2 },
    "LikeTheWind": { category: "Damage", id: "LikeTheWind", cost: 1 },
    "ImmovableObject": { category: "Damage", id: "ImmovableObject", cost: 2 },
    "LeastResistance": { category: "Damage", id: "LeastResistance", cost: 1 },
    "Sticky": { category: "Damage", id: "Sticky", cost: -1 },
    "Breathless": { category: "Damage", id: "Breathless", cost: -1 },
    "CommonMaid": { category: "Enemies", id: "CommonMaid", cost: -1, costGroup: "common" },
    "CommonLatex": { category: "Enemies", id: "CommonLatex", cost: -1, costGroup: "common" },
    "CommonLeather": { category: "Enemies", id: "CommonLeather", cost: -1, costGroup: "common" },
    "CommonExp": { category: "Enemies", id: "CommonExp", cost: -1, costGroup: "common" },
    "CommonDress": { category: "Enemies", id: "CommonDress", cost: -1, costGroup: "common" },
    "CommonWolf": { category: "Enemies", id: "CommonWolf", cost: -1, costGroup: "common" },
    "CommonKitty": { category: "Enemies", id: "CommonKitty", cost: -1, costGroup: "common" },
    "KeepOutfit": { category: "Kinky", id: "KeepOutfit", cost: 0 },
    "KinkyPrison": { category: "Map", id: "KinkyPrison", cost: -1 },
    "Doorknobs": { category: "Map", id: "Doorknobs", cost: -1 },
    "MapLarge": { category: "Map", id: "MapLarge", cost: 0, tags: ["start", "mapsize"], blocktags: ["mapsize"] },
    "MapHuge": { category: "Map", id: "MapHuge", cost: 0, tags: ["start", "mapsize"], blocktags: ["mapsize"] },
    "MapGigantic": { category: "Map", id: "MapGigantic", cost: 0, tags: ["start", "mapsize"], blocktags: ["mapsize"] },
};
function KDGetPerkCost(perk) {
    if (!perk)
        return 0;
    if (!perk.costGroup)
        return perk.cost;
    let costGroups = {};
    let first = false;
    for (let p of KinkyDungeonStatsChoice.keys()) {
        if (KinkyDungeonStatsPresets[p] && KinkyDungeonStatsPresets[p].costGroup) {
            if (!first) {
                first = true;
                if (KinkyDungeonStatsPresets[p].id == perk.id) {
                    return KinkyDungeonStatsPresets[p].cost;
                }
            }
            costGroups[KinkyDungeonStatsPresets[p].costGroup] = KinkyDungeonStatsPresets[p].cost;
        }
    }
    if (costGroups[perk.costGroup] != undefined && perk.cost >= costGroups[perk.costGroup])
        return 0;
    else
        return perk.cost;
}
function KinkyDungeonGetStatPoints(Stats) {
    let total = 0;
    for (let k of Stats.keys()) {
        if (Stats.get(k)) {
            if (KinkyDungeonStatsPresets[k]) {
                total -= KDGetPerkCost(KinkyDungeonStatsPresets[k]);
            }
        }
    }
    return total;
}
function KinkyDungeonCanPickStat(Stat, points) {
    let stat = KinkyDungeonStatsPresets[Stat];
    if (!stat)
        return false;
    if (KDGetPerkCost(stat) > 0 && (points != undefined ? points : KinkyDungeonGetStatPoints(KinkyDungeonStatsChoice)) < KDGetPerkCost(stat))
        return false;
    if (!KDValidatePerk(stat))
        return false;
    for (let k of KinkyDungeonStatsChoice.keys()) {
        if (KinkyDungeonStatsChoice.get(k)) {
            if (KinkyDungeonStatsPresets[k] && KinkyDungeonStatsPresets[k].block && KinkyDungeonStatsPresets[k].block.includes(Stat)) {
                return false;
            }
            if (KinkyDungeonStatsPresets[k] && stat.tags && KinkyDungeonStatsPresets[k].blocktags) {
                for (let t of KinkyDungeonStatsPresets[k].blocktags)
                    if (stat.tags.includes(t))
                        return false;
            }
        }
    }
    return true;
}
function KDValidatePerk(stat) {
    if (stat.requireArousal && !KinkyDungeonStatsChoice.get("arousalMode"))
        return false;
    if (stat.blockclass) {
        for (let t of stat.blockclass)
            if (KinkyDungeonClassMode == t)
                return false;
    }
    return true;
}
function KDPerkBlocked(perk1, perk2) {
    if (KinkyDungeonStatsPresets[perk2] && KinkyDungeonStatsPresets[perk1]) {
        if (!KDValidatePerk(KinkyDungeonStatsPresets[perk1]))
            return false;
        if (KinkyDungeonStatsPresets[perk2].block && KinkyDungeonStatsPresets[perk2].block.includes(perk1)) {
            return true;
        }
        if (KinkyDungeonStatsPresets[perk2] && KinkyDungeonStatsPresets[perk1].tags && KinkyDungeonStatsPresets[perk2].blocktags) {
            for (let t of KinkyDungeonStatsPresets[perk2].blocktags)
                if (KinkyDungeonStatsPresets[perk1].tags.includes(t))
                    return true;
        }
    }
    return false;
}
function KinkyDungeonCanUnPickStat(Stat) {
    let stat = KinkyDungeonStatsPresets[Stat];
    if (!stat)
        return false;
    if (KDGetPerkCost(stat) < 0 && KinkyDungeonGetStatPoints(KinkyDungeonStatsChoice) < -KDGetPerkCost(stat))
        return false;
    for (let k of KinkyDungeonStatsChoice.keys()) {
        if (KinkyDungeonStatsChoice.get(k)) {
            if (KinkyDungeonStatsPresets[k] && KinkyDungeonStatsPresets[k].require == Stat) {
                return false;
            }
        }
    }
    return true;
}
let KDPerkStart = {
    Studious: () => {
        KinkyDungeonSpellPoints += 3;
    },
    Submissive: () => {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("BasicCollar"), 0, true, "Red", false, undefined, undefined, undefined, true);
    },
    Pacifist: () => {
        KinkyDungeonInventoryAddWeapon("Rope");
    },
    Rigger: () => {
        KinkyDungeonInventoryAddWeapon("Rope");
        KinkyDungeonInventoryAddWeapon("Scissors");
    },
    Unchained: () => {
        KinkyDungeonRedKeys += 1;
    },
    FuukaCollar: () => {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true, undefined, false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoDress"), 0, true, undefined, false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoGag"), 0, true, undefined, false, undefined, undefined, undefined, true);
    },
    Prisoner: () => {
        KDGameData.PrisonerState = 'parole';
    },
    Slayer: () => {
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("Firebolt"));
        KinkyDungeonSpellChoices[0] = KinkyDungeonSpells.length - 1;
    },
    Conjurer: () => {
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("ChainBolt"));
        KinkyDungeonSpellChoices[0] = KinkyDungeonSpells.length - 1;
    },
    Magician: () => {
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("Dagger"));
        KinkyDungeonSpellChoices[0] = KinkyDungeonSpells.length - 1;
    },
    Brawler: () => {
        KinkyDungeonInventoryAddWeapon("Knife");
        KDSetWeapon("Knife");
        KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
    },
    StartLatex: () => {
        KinkyDungeonChangeRep("Latex", 10);
        KinkyDungeonAddRestraintIfWeaker("LatexCatsuit", 5, true, "Red", false, undefined, undefined, "Jail", true);
        for (let i = 0; i < 30; i++) {
            let r = KinkyDungeonGetRestraint({ tags: ["latexRestraints", "latexStart", "latexCollar", "latexRestraintsForced"] }, 12, "grv", true, "Red");
            if (r)
                KinkyDungeonAddRestraintIfWeaker(r, 0, true, r.Group == "ItemNeck" ? "Blue" : "Purple", undefined, undefined, undefined, "Jail", true);
        }
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("KiguMask"), 0, true, "Purple");
    },
    DollmakerVisor: () => {
        KinkyDungeonAddRestraintIfWeaker("DollmakerVisor", 5, true, "Gold", false, undefined, undefined, undefined, true);
    },
    StartCyberDoll: () => {
        KinkyDungeonChangeRep("Metal", 10);
        KinkyDungeonAddRestraintIfWeaker("ControlHarness", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("TrackingCollar", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberBelt", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberBra", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberHeels", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberPlugGag", 5, true, "Red", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberMuzzle", 5, true, "Red", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberArmCuffs", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberLegCuffs", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("CyberAnkleCuffs", 5, true, "Blue", false, undefined, undefined, undefined, true);
        KinkyDungeonSetDress("CyberDoll", "CyberDoll");
    },
    StartMaid: () => {
        KDChangeFactionRelation("Player", "Maidforce", 0.2 - KDFactionRelation("Player", "Maidforce"), true);
        for (let i = 0; i < 30; i++) {
            let r = KinkyDungeonGetRestraint({ tags: ["maidRestraints", "maidVibeRestraints", "noMaidJacket", "handcuffer"] }, 12, "grv", true, "Purple");
            if (r)
                KinkyDungeonAddRestraintIfWeaker(r, 0, true, r.Group == "ItemNeck" ? "Blue" : "Purple", undefined, undefined, undefined, undefined, true);
        }
        let outfit = { name: "Maid", id: KinkyDungeonGetItemID(), type: Outfit };
        if (!KinkyDungeonInventoryGet("Maid"))
            KinkyDungeonInventoryAdd(outfit);
        if (KinkyDungeonInventoryGet("Default"))
            KinkyDungeonInventoryRemove(KinkyDungeonInventoryGet("Default"));
        KinkyDungeonSetDress("Maid", "Maid");
    },
    StartWolfgirl: () => {
        KDChangeFactionRelation("Player", "Nevermere", 0.2 - KDFactionRelation("Player", "Nevermere"), true);
        for (let i = 0; i < 30; i++) {
            let r = KinkyDungeonGetRestraint({ tags: (i < (KinkyDungeonStatsChoice.has("NoWayOut") ? 3 : 1) ? ["wolfCuffs"] : ["wolfGear", "wolfRestraints"]) }, 12, "grv", true, "Red");
            if (r) {
                KinkyDungeonAddRestraintIfWeaker(r, 0, true, r.Group == "ItemNeck" ? "Blue" : "Red", undefined, undefined, undefined, undefined, true);
                if (r.Link) {
                    let newRestraint = KinkyDungeonGetRestraintByName(r.Link);
                    KinkyDungeonAddRestraintIfWeaker(newRestraint, 0, true, "Red", undefined, undefined, undefined, undefined, true);
                }
            }
        }
        KDAddQuest("WolfgirlHunters");
        let outfit = { name: "Wolfgirl", id: KinkyDungeonGetItemID(), type: Outfit };
        if (!KinkyDungeonInventoryGet("Wolfgirl"))
            KinkyDungeonInventoryAdd(outfit);
        if (KinkyDungeonInventoryGet("Default"))
            KinkyDungeonInventoryRemove(KinkyDungeonInventoryGet("Default"));
        KinkyDungeonSetDress("Wolfgirl", "Wolfgirl");
    },
    StartObsidian: () => {
        KDChangeFactionRelation("Player", "Elemental", 0.2 - KDFactionRelation("Player", "Elemental"), true);
        for (let i = 0; i < 30; i++) {
            let r = KinkyDungeonGetRestraint({ tags: ["obsidianRestraints", "ornateChastity", "genericToys"] }, 12, "grv", true, "Red");
            if (r) {
                KinkyDungeonAddRestraintIfWeaker(r, 0, true, r.Group == "ItemNeck" ? "Blue" : "Purple", false, undefined, undefined, undefined, true);
                let item = r;
                for (let j = 0; j < 2; j++) {
                    if (item && item.Link) {
                        let newRestraint = KinkyDungeonGetRestraintByName(item.Link);
                        KinkyDungeonAddRestraintIfWeaker(newRestraint, 0, true, "Purple", undefined, undefined, undefined, undefined, true);
                        item = newRestraint;
                    }
                }
            }
        }
        let outfit = { name: "Obsidian", id: KinkyDungeonGetItemID(), type: Outfit };
        if (!KinkyDungeonInventoryGet("Obsidian"))
            KinkyDungeonInventoryAdd(outfit);
        if (KinkyDungeonInventoryGet("Default"))
            KinkyDungeonInventoryRemove(KinkyDungeonInventoryGet("Default"));
        KinkyDungeonSetDress("Obsidian", "Obsidian");
    },
    Hogtied: () => {
        for (let i = 0; i < 30; i++) {
            let r = KinkyDungeonGetRestraint({ tags: ["ropeRestraints", "ropeRestraints2", "ropeRestraintsHogtie", "ropeRestraintsWrist", "tapeRestraints", "genericToys"] }, 24, "grv", true, undefined);
            if (r) {
                KinkyDungeonAddRestraintIfWeaker(r, 8, true, undefined, false, undefined, undefined, undefined, true);
                let item = r;
                for (let j = 0; j < 2; j++) {
                    if (item && item.Link) {
                        let newRestraint = KinkyDungeonGetRestraintByName(item.Link);
                        KinkyDungeonAddRestraintIfWeaker(newRestraint, 8, true, undefined, undefined, undefined, undefined, undefined, true);
                        item = newRestraint;
                    }
                }
            }
        }
        KinkyDungeonAddRestraintIfWeaker("TrapMittens", 5, true, undefined, false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("Stuffing", 5, true, undefined, false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("PanelGag", 5, true, undefined, false, undefined, undefined, undefined, true);
        KinkyDungeonAddRestraintIfWeaker("TrapBlindfold", 5, true, undefined, false, undefined, undefined, undefined, true);
        if (KinkyDungeonInventoryGet("Knife"))
            KinkyDungeonInventoryRemove(KinkyDungeonInventoryGet("Knife"));
        if (KinkyDungeonInventoryGet("Dirk"))
            KinkyDungeonInventoryRemove(KinkyDungeonInventoryGet("Dirk"));
    },
    Stranger: () => {
        for (let key of Object.keys(KinkyDungeonFactionTag)) {
            KDSetFactionRelation("Player", key, -1 + 0.45 * KDRandom() + 0.45 * KDRandom() + 0.45 * KDRandom());
        }
    },
    WrongNeighborhood: () => {
        for (let key of Object.keys(KinkyDungeonFactionTag)) {
            KDSetFactionRelation("Player", key, -1);
            for (let key2 of Object.keys(KinkyDungeonFactionTag)) {
                KDSetFactionRelation(key, key2, 0.5);
            }
        }
    },
    Cursed: () => {
        KinkyDungeonChangeFactionRep("Angel", -100);
    },
    MC_Trainee: () => {
        KinkyDungeonSpells.push(KinkyDungeonFindSpell("DistractionCast"));
    },
};
let KDPerksFilter = "";
let KDPerksButtonWidth = 298;
let KDPerksButtonWidthPad = 2;
let KDPerksButtonHeight = 44;
let KDPerksButtonHeightPad = 2;
let KDPerksXPad = 50;
let KDPerksYPad = 50;
let KDPerksYStart = 220;
let KDPerksXStart = 50;
let KDPerksMaxY = 900;
let KDPerksScroll = KDPerksButtonWidth * 2 + KDPerksButtonWidthPad * 2 + KDPerksXPad;
let KDPerksIndex = 0;
let KDPerksIndexUI = 0;
let KDPerksIndexUIWeight = 4;
let KDCategories = [];
function KinkyDungeonDrawPerks(NonSelectable) {
    let fadeColor = NonSelectable ? "#808080" : "#999999";
    let X = Math.round(KDPerksXStart - KDPerksScroll * KDPerksIndexUI);
    let Y = KDPerksYStart;
    let Y_alt = KDPerksYStart;
    if (CommonIsMobile)
        KDPerksIndexUIWeight = 1;
    KDPerksIndexUI = (KDPerksIndex + (KDPerksIndexUIWeight - 1) * KDPerksIndexUI) / KDPerksIndexUIWeight;
    let tooltip = false;
    let catsdrawn = 0;
    let catsdrawnStrict = 0;
    function inView() {
        return X > -2 * KDPerksButtonWidth - KDPerksButtonWidthPad && X < 2000 - KDPerksButtonWidth;
    }
    function inViewStrict() {
        return X > 0 && X < 2000 - KDPerksButtonWidth;
    }
    let indexX = 0;
    let indexList = {};
    let firstDrawn = "";
    let filled_x = {};
    for (let c of KDCategories) {
        Y = Math.max(Y, Y_alt);
        let height = KDPerksYPad + KDPerksButtonHeight * Math.max(c.buffs.length, c.debuffs.length);
        if (Y + height > KDPerksMaxY) {
            X += (KDPerksButtonWidth + KDPerksButtonWidthPad) * 2 + KDPerksXPad;
            indexX += 1;
            Y = KDPerksYStart;
        }
        Y += KDPerksYPad;
        Y_alt = Y;
        DrawTextFitKD(TextGet("KDCategory" + c.name), X + KDPerksButtonWidth + KDPerksButtonWidthPad / 2, Y - KDPerksButtonHeight / 2 - 5, KDPerksButtonWidth * 2, "#ffffff");
        if (inView()) {
            catsdrawn += 1;
        }
        if (inViewStrict()) {
            catsdrawnStrict += 1;
            if (!firstDrawn)
                firstDrawn = c.name;
        }
        for (let stat of c.buffs.concat(c.debuffs)) {
            if ((!stat[1].locked || KDUnlockedPerks.includes(stat[0]))
                && (NonSelectable || !KDPerksFilter || TextGet("KinkyDungeonStat" + ("" + stat[1].id)).toLocaleLowerCase().includes(KDPerksFilter.toLocaleLowerCase()))) {
                let YY = (!stat[1].buff && (stat[1].cost < 0 || stat[1].debuff)) ? Y_alt : Y;
                let XX = (!stat[1].buff && (stat[1].cost < 0 || stat[1].debuff)) ? X + KDPerksButtonWidth + KDPerksButtonWidthPad : X;
                if (inView()) {
                    let colorAvailable = NonSelectable ?
                        fadeColor :
                        KDGetPerkCost(stat[1]) > 0 ?
                            "#aaaacc" :
                            KDGetPerkCost(stat[1]) < 0 ?
                                "#ccaaaa" :
                                "#aaaacc";
                    let colorSelected = KDGetPerkCost(stat[1]) > 0 ? "#eeeeff" : KDGetPerkCost(stat[1]) < 0 ? "#ffeeee" : "#eeeeff";
                    let colorExpensive = KDGetPerkCost(stat[1]) > 0 ? "#555588" : KDGetPerkCost(stat[1]) < 0 ? "#885555" : "#555588";
                    DrawButtonKDEx(stat[0], (bdata) => {
                        if (!KinkyDungeonStatsChoice.get(stat[0]) && KinkyDungeonCanPickStat(stat[0])) {
                            KinkyDungeonStatsChoice.set(stat[0], true);
                            localStorage.setItem('KinkyDungeonStatsChoice' + KinkyDungeonPerksConfig, JSON.stringify(Array.from(KinkyDungeonStatsChoice.keys())));
                        }
                        else if (KinkyDungeonStatsChoice.get(stat[0])) {
                            KinkyDungeonStatsChoice.delete(stat[0]);
                            localStorage.setItem('KinkyDungeonStatsChoice' + KinkyDungeonPerksConfig, JSON.stringify(Array.from(KinkyDungeonStatsChoice.keys())));
                        }
                        return true;
                    }, !NonSelectable && (KinkyDungeonState == "Stats" || (KinkyDungeonDrawState == "Perks2" && KDDebugPerks)), XX, YY, KDPerksButtonWidth, KDPerksButtonHeight, TextGet("KinkyDungeonStat" + (stat[1].id)) + ` (${KDGetPerkCost(stat[1])})`, (!KinkyDungeonStatsChoice.get(stat[0]) && KinkyDungeonCanPickStat(stat[0])) ? colorAvailable : (KinkyDungeonStatsChoice.get(stat[0]) ? colorSelected : (NonSelectable ? colorAvailable : colorExpensive)), KinkyDungeonStatsChoice.get(stat[0]) ? (KinkyDungeonRootDirectory + "UI/TickPerk.png") : "", undefined, false, true, KinkyDungeonStatsChoice.get(stat[0]) ? "rgba(140, 140, 140, 0.5)" : KDButtonColor, undefined, undefined, {
                        noTextBG: true
                    });
                    if (MouseIn(XX, YY, KDPerksButtonWidth, KDPerksButtonHeight)) {
                        DrawTextFitKD(TextGet("KinkyDungeonStatDesc" + (stat[1].id)), 1000, 150, 1500, KDTextWhite, KDTextGray1);
                        DrawTextFitKD(TextGet("KinkyDungeonStatCost").replace("AMOUNT", KDGetPerkCost(stat[1]) + ""), 1000, 190, 1400, KDTextWhite, KDTextGray1);
                        tooltip = true;
                    }
                }
                if (!filled_x[X]) {
                    FillRectKD(kdcanvas, kdpixisprites, c.name, {
                        Left: X - KDPerksButtonWidthPad,
                        Top: KDPerksYStart,
                        Width: 2 * KDPerksButtonWidth + 3 * KDPerksButtonWidthPad,
                        Height: KDPerksMaxY - KDPerksYStart,
                        Color: KDTextGray0,
                        LineWidth: 1,
                        zIndex: 60,
                        alpha: 0.4,
                    });
                    filled_x[X] = X;
                }
                if (!stat[1].buff && (stat[1].cost < 0 || stat[1].debuff))
                    Y_alt += KDPerksButtonHeight + KDPerksButtonHeightPad;
                else
                    Y += KDPerksButtonHeight + KDPerksButtonHeightPad;
            }
        }
        indexList[c.name] = indexX;
    }
    DrawButtonKDEx("perks>", (bdata) => {
        var _a;
        if (catsdrawn > 2 && !(((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.id) == 'PerksFilter')) {
            KDPerksIndex += 1;
        }
        return true;
    }, true, 1750, 50, 100, 50, ">>", KDTextWhite);
    DrawButtonKDEx("perks<", (bdata) => {
        var _a;
        if (KDPerksIndex > 0 && !(((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.id) == 'PerksFilter')) {
            KDPerksIndex -= 1;
        }
        return true;
    }, true, 150, 50, 100, 50, "<<", KDTextWhite);
    let procList = KDCategoriesStart.map((e) => { return e.name; });
    let adjLists = GetAdjacentList(procList, procList.indexOf(firstDrawn), catsdrawnStrict);
    let left = adjLists.left;
    let right = adjLists.right;
    drawVertList(left.reverse(), 380, 85, 250, 25, 4, 18, (data) => {
        return (bdata) => {
            KDPerksIndex = indexList[data.name];
            return true;
        };
    }, "KDCategory");
    drawVertList(right, 1620, 85, 250, 25, 4, 18, (data) => {
        return (bdata) => {
            KDPerksIndex = Math.max(0, indexList[data.name] - 2);
            return true;
        };
    }, "KDCategory");
    if (catsdrawn < 3 && KDPerksIndex > 0)
        KDPerksIndex -= 1;
    return tooltip;
}
function drawVertList(list, x, y, w, h, max, fontSize, clickfnc, prefix) {
    for (let i = 0; i < list.length && i < max; i++) {
        let name = list[i];
        DrawButtonKDEx(name + x + "," + y, clickfnc({ name: name }), true, x - w / 2, y - (h + 1) * i, w, h, TextGet(prefix + name), KDTextWhite, undefined, undefined, undefined, true, undefined, fontSize);
    }
}
function KDGetRandomPerks(existing) {
    let poscandidates = [];
    let singlepointcandidates = [];
    let negcandidates = [];
    for (let p of Object.entries(KinkyDungeonStatsPresets)) {
        if (!existing[p[0]] && !KinkyDungeonStatsChoice.get(p[0]) && KinkyDungeonCanPickStat(p[0], 999)) {
            if ((!p[1].tags || !p[1].tags.includes("start"))) {
                if (!p[1].locked || KDUnlockedPerks.includes(p[0])) {
                    if (KDGetPerkCost(p[1]) > 0) {
                        poscandidates.push(p);
                        if (KDGetPerkCost(p[1]) == 1)
                            singlepointcandidates.push(p);
                    }
                    else if (KDGetPerkCost(p[1]) < 0) {
                        negcandidates.push(p);
                    }
                }
            }
        }
    }
    let poscandidate = poscandidates[Math.floor(poscandidates.length * KDRandom())];
    if (!poscandidate)
        return [];
    let netcost = KDGetPerkCost(poscandidate[1]);
    let perks = [poscandidate[0]];
    if (KDGetPerkCost(poscandidate[1]) > 1) {
        negcandidates = negcandidates.filter((p) => {
            return (KinkyDungeonCanPickStat(p[0], 999))
                && !KDPerkBlocked(p[0], poscandidate[0])
                && (-KDGetPerkCost(p[1])) >= (KDGetPerkCost(poscandidate[1]) - 1);
        });
        let negperk = null;
        if (negcandidates.length > 0) {
            negperk = negcandidates[Math.floor(negcandidates.length * KDRandom())];
            perks.push(negperk[0]);
            netcost += KDGetPerkCost(negperk[1]);
        }
        if (netcost < 0 && negperk) {
            singlepointcandidates = negcandidates.filter((p) => {
                return (KinkyDungeonCanPickStat(p[0], 999)
                    && p[0] != poscandidate[0]
                    && p[0] != negperk[0]
                    && !KDPerkBlocked(p[0], poscandidate[0])
                    && !KDPerkBlocked(p[0], negperk[0]));
            });
            let newperk = singlepointcandidates[Math.floor(singlepointcandidates.length * KDRandom())];
            perks = [perks[0], newperk[0], perks[1]];
        }
    }
    return perks;
}
const KinkyDungeonMapParams = {
    "grv": {
        "background": "RainyForstPathNight",
        "openness": 3,
        "density": 3,
        "crackchance": 0.07,
        "barchance": 0.2,
        "brightness": 7,
        "chestcount": 5,
        "shrinecount": 11,
        "shrinechance": 0.75,
        "ghostchance": 1,
        "doorchance": 0.67,
        "nodoorchance": 0.1,
        "doorlockchance": -0.1,
        "trapchance": 0.5,
        "grateChance": 0.4,
        "rubblechance": 0.4,
        "brickchance": 0.1,
        "cacheInterval": 1,
        "forbiddenChance": 0.7,
        "forbiddenGreaterChance": 0.33,
        "torchchance": 0.35,
        "torchchanceboring": 1.0,
        music: {
            "AREA1-GRAVEYARD.ogg": 10,
            "GENERIC-DOLLRACK.ogg": 4,
        },
        tagModifiers: {
            "temple": 0.4,
            "jungle": 0,
            "cavern": 0,
        },
        enemyTags: ["magical", "zombie", "leather", "tape", "ribbon"],
        "setpieces": [
            { Type: "Bedroom", Weight: 3 },
            { Type: "Graveyard", Weight: 6 },
            { Type: "Altar", Weight: 3 },
            { Type: "SmallAltar", Weight: 18 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
            { Type: "QuadCell", Weight: 3 },
            { Type: "Storage", Weight: 5 },
        ],
        "shortcuts": [
            { Level: 1, checkpoint: "tmb", chance: 1.0 },
            { Level: 3, checkpoint: "tmb", chance: 1.0 },
        ],
        "mainpath": [
            { Level: 4, checkpoint: "cat" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapCharmWeak", Level: 0, Power: 1, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapRopeWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLeatherWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLustCloud", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "SummonedSkeleton", strict: true, Level: 0, Power: 4, Weight: 10 },
            { Name: "SpawnEnemies", Enemy: "Bandit", strict: true, Level: 0, Power: 1, Weight: 10 },
        ],
        factionList: ["Bandit", "Apprentice", "Bountyhunter", "Elemental", "Dragon", "Maidforce"],
        "min_width": 5,
        "max_width": 7,
        "min_height": 5,
        "max_height": 6,
        "defeat_outfit": "Prisoner",
        "shrines": [
            { Type: "Latex", Weight: 3 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Leather", Weight: 5 },
            { Type: "Metal", Weight: 3 },
            { Type: "Rope", Weight: 2 },
            { Type: "Will", Weight: 7 },
        ]
    },
    "cat": {
        "background": "Dungeon",
        "openness": 0,
        "density": 2,
        "crackchance": 0.09,
        "barchance": 0.2,
        "brightness": 4,
        "chestcount": 7,
        "shrinecount": 12,
        "chargerchance": 0.5,
        "litchargerchance": 0.5,
        "chargercount": 7,
        "shrinechance": 0.6,
        "ghostchance": 0.5,
        "doorchance": 0.8,
        "nodoorchance": 0.05,
        "doorlockchance": -0.05,
        "trapchance": 0.65,
        "grateChance": 0.1,
        "rubblechance": 0.3,
        "brickchance": 0.4,
        "cacheInterval": 1,
        "forbiddenChance": 0.72,
        "forbiddenGreaterChance": 0.33,
        cageChance: 0.8,
        torchchance: 0.05,
        torchchanceboring: 0.7,
        music: {
            "GENERIC-DOLLRACK.ogg": 10,
            "AREA2-ANCIENTTOMBS.ogg": 2,
        },
        tagModifiers: {
            "narrow": 2,
            "dungeon": 2,
            "open": 0.5,
            "jungle": 0,
            "cavern": 0,
        },
        "setpieces": [
            { Type: "Bedroom", Weight: 2 },
            { Type: "Altar", Weight: 3 },
            { Type: "QuadCell", Weight: 8 },
            { Type: "Storage", Weight: 5 },
            { Type: "SmallAltar", Weight: 18 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
            { Type: "ExtraCell", Weight: 10 },
        ],
        "shortcuts": [
            { Level: 5, checkpoint: "lib", chance: 0.5 },
            { Level: 6, checkpoint: "lib", chance: 1.0 },
            { Level: 7, checkpoint: "lib", chance: 0.25 },
            { Level: 8, checkpoint: "lib", chance: 0.25 },
        ],
        "mainpath": [
            { Level: 8, checkpoint: "jng" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapShackleWeak", Level: 0, Power: 1, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapRopeWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLeatherWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLustCloud", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "SummonedSkeleton", strict: true, Level: 0, Power: 4, Weight: 10 },
            { Name: "SpawnEnemies", Enemy: "HeavySkeleton", extraTag: "Single", strict: true, Level: 0, Power: 2, Weight: 2 },
            { Name: "SpawnEnemies", Enemy: "Bandit", strict: true, Level: 0, Power: 2, Weight: 10 },
        ],
        "min_width": 5,
        "max_width": 7,
        "min_height": 5,
        "max_height": 6,
        factionList: ["AncientRobot", "Bandit", "Apprentice", "Bountyhunter", "Bast", "Dragon", "Maidforce", "Alchemist"],
        enemyTags: ["skeleton", "metal", "rope", "leather"],
        "defeat_outfit": "Dungeon",
        "shrines": [
            { Type: "Latex", Weight: 3 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Leather", Weight: 5 },
            { Type: "Metal", Weight: 3 },
            { Type: "Rope", Weight: 2 },
            { Type: "Will", Weight: 7 },
        ]
    },
    "jng": {
        "background": "DeepForest",
        noReplace: "b",
        "openness": 1,
        "density": 1,
        "crackchance": 0.15,
        "barchance": 0.05,
        "brightness": 6,
        "chestcount": 7,
        "shrinecount": 13,
        "shrinechance": 0.4,
        "ghostchance": 0.5,
        "doorchance": 0.2,
        "nodoorchance": 0.7,
        "doorlockchance": -0.05,
        "trapchance": 0.4,
        "grateChance": 0.1,
        "rubblechance": 0.25,
        "brickchance": 0.25,
        "cacheInterval": 1,
        "forbiddenChance": 0.72,
        "forbiddenGreaterChance": 0.33,
        torchchance: 0.2,
        torchchanceboring: 0.25,
        tagModifiers: {
            "open": 6,
            "door": 0.5,
            "jungle": 100,
            "cavern": 60,
        },
        music: {
            "AREA5-UNDERGROUNDJUNGLE.ogg": 10,
        },
        "setpieces": [
            { Type: "Altar", Weight: 6 },
            { Type: "SmallAltar", Weight: 20 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
            { Type: "JungleLight", Weight: 8 },
            { Type: "Fireflies", Weight: 40 },
        ],
        "shortcuts": [
            { Level: 9, checkpoint: "cry", chance: 1.0 },
            { Level: 10, checkpoint: "cry", chance: 1.0 },
        ],
        "mainpath": [
            { Level: 12, checkpoint: "tmp" },
        ],
        "traps": [
            { Name: "CustomVine", Level: 0, Power: 1, Weight: 30 },
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 10 },
            { Name: "SpecificSpell", Spell: "TrapSlimeWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapRopeWeak", Level: 0, Power: 3, Weight: 10 },
            { Name: "SpecificSpell", Spell: "TrapLeatherWeak", Level: 0, Power: 3, Weight: 10 },
            { Name: "SpecificSpell", Spell: "TrapLustCloud", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "Bandit", strict: true, Level: 0, Power: 3, Weight: 10 },
        ],
        "min_width": 5,
        "max_width": 6,
        "min_height": 5,
        "max_height": 5,
        factionList: ["AncientRobot", "Nevermere", "Bandit", "Bountyhunter", "Elf", "Bast", "Dragon", "Maidforce", "Alchemist"],
        enemyTags: ["plant", "jungle", "slime", "earth"],
        "defeat_outfit": "LatexPrisoner",
        "shrines": [
            { Type: "Latex", Weight: 5 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Leather", Weight: 5 },
            { Type: "Metal", Weight: 3 },
            { Type: "Rope", Weight: 5 },
            { Type: "Will", Weight: 5 },
        ]
    },
    "tmp": {
        "background": "SpookyForest",
        "openness": 2,
        "density": 2,
        "crackchance": 0.05,
        "barchance": 0.1,
        "brightness": 3,
        "chestcount": 7,
        "chargerchance": 0.9,
        "litchargerchance": 0.2,
        "chargercount": 10,
        "shrinecount": 10,
        "shrinechance": 0.5,
        "ghostchance": 0.5,
        "doorchance": 0.9,
        "nodoorchance": 0.25,
        "doorlockchance": -0.05,
        "trapchance": 0.5,
        "grateChance": 0.8,
        "rubblechance": 0.35,
        "brickchance": 0.1,
        "floodchance": 0.33,
        "gaschance": 0.5,
        "gasdensity": 0.1,
        "gastype": ']',
        "cacheInterval": 1,
        "forbiddenChance": 0.8,
        "forbiddenGreaterChance": 0.4,
        torchchance: 0.4,
        torchchanceboring: -0.4,
        torchlitchance: 0.15,
        torchreplace: {
            sprite: "Lantern",
            unlitsprite: "LanternUnlit",
            brightness: 6,
        },
        music: {
            "AREA7-LOSTTEMPLE.ogg": 14,
            "AREA9-BELLOWS.ogg": 2,
        },
        tagModifiers: {
            "jungle": 0,
            "cavern": 0,
            "temple": 3,
        },
        globalTags: {
            "temple": true,
        },
        shadowColor: 0x000703,
        "setpieces": [
            { Type: "Bedroom", Weight: 1 },
            { Type: "Altar", Weight: 6 },
            { Type: "SmallAltar", Weight: 20 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
            { Type: "Magicflies", Weight: 12 },
        ],
        "shortcuts": [
            { Level: 13, checkpoint: "ore", chance: 1.0 },
        ],
        "mainpath": [
            { Level: 17, checkpoint: "bel" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 20 },
            { Name: "SpecificSpell", Spell: "TrapSlimeWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapRopeWeak", Level: 0, Power: 3, Weight: 10 },
            { Name: "SpecificSpell", Spell: "TrapShackleWeak", Level: 0, Power: 3, Weight: 10 },
            { Name: "SpecificSpell", Spell: "TrapMagicChainsWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "GreaterSkeleton", strict: true, Level: 0, Power: 3, Weight: 10 },
            { Name: "SpawnEnemies", Enemy: "HeavySkeleton", strict: true, Level: 0, Power: 1, Weight: 10 },
        ],
        "min_width": 5,
        "max_width": 7,
        "min_height": 5,
        "max_height": 5,
        factionList: ["Apprentice", "Bandit", "Bountyhunter", "Elemental", "Dragon", "Maidforce", "Alchemist"],
        enemyTags: ["skeleton", "temple", "ghost", "magical"],
        "defeat_outfit": "LatexPrisoner",
        "shrines": [
            { Type: "Latex", Weight: 5 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Leather", Weight: 3 },
            { Type: "Metal", Weight: 5 },
            { Type: "Rope", Weight: 3 },
            { Type: "Will", Weight: 7 },
        ],
        "lockmult": 1.5,
    },
    "tmb": {
        "background": "EgyptianTomb",
        "openness": 1,
        "density": 3,
        "crackchance": 0.06,
        "barchance": 0.05,
        "brightness": 3,
        "chestcount": 9,
        "chargerchance": 0.8,
        "litchargerchance": 0.65,
        "chargercount": 6,
        "shrinecount": 13,
        "shrinechance": 0.5,
        "ghostchance": 0.5,
        "doorchance": 0.4,
        "nodoorchance": 0.25,
        "doorlockchance": -0.05,
        "trapchance": 0.65,
        "grateChance": 0.3,
        "rubblechance": 0.35,
        "brickchance": 0.4,
        "cacheInterval": 1,
        "forbiddenChance": 1.0,
        "forbiddenGreaterChance": 0.45,
        torchchance: 0.1,
        torchchanceboring: 0.1,
        music: {
            "AREA2-ANCIENTTOMBS.ogg": 10,
        },
        worldGenCode: () => {
            for (let X = 1; X < KinkyDungeonGridWidth - 1; X++) {
                for (let Y = 1; Y < KinkyDungeonGridHeight - 1; Y++) {
                    if (KinkyDungeonMapGet(X, Y) == 'X' && KDRandom() < 0.15 + 0.45 * Math.min(1, KinkyDungeonDifficulty / 30)) {
                        KinkyDungeonMapSet(X, Y, '3');
                        DialogueCreateEnemy(X, Y, "MummyCursed");
                    }
                }
            }
        },
        "setpieces": [
            { Type: "Altar", Weight: 6 },
            { Type: "SmallAltar", Weight: 20 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
            { Type: "Storage", Weight: 7 },
        ],
        tagModifiers: {
            "temple": 2,
            "jungle": 0,
            "cavern": 0,
        },
        globalTags: {
            "egyptian": true,
        },
        "shortcuts": [
            { Level: 3, checkpoint: "cry", chance: 1.0 },
        ],
        "mainpath": [
            { Level: 4, checkpoint: "cat" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 20 },
            { Name: "SpecificSpell", Spell: "TrapMummyWeak", Level: 0, Power: 1, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapMagicChainsWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLeatherWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLustCloud", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "SummonedSkeleton", strict: true, Level: 0, Power: 5, Weight: 10 },
            { Name: "SpawnEnemies", Enemy: "Bandit", strict: true, Level: 0, Power: 3, Weight: 10 },
        ],
        "min_width": 5,
        "max_width": 6,
        "min_height": 5,
        "max_height": 7,
        factionList: ["Bast", "Bandit", "AncientRobot", "Elemental", "Dragon"],
        enemyTags: ["mummy", "ghost", "tape", "ribbon", "nature"],
        "defeat_outfit": "Bast",
        "shrines": [
            { Type: "Latex", Weight: 3 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Metal", Weight: 3 },
            { Type: "Rope", Weight: 4 },
            { Type: "Leather", Weight: 6 },
            { Type: "Will", Weight: 7 },
        ]
    },
    "lib": {
        "background": "MagicSchoolLaboratory",
        noReplace: "Ddb",
        "openness": 5,
        "density": 6,
        "crackchance": 0.0,
        "wallRubblechance": 0.035,
        "barchance": 0.1,
        "brightness": 6,
        "chestcount": 10,
        "chargerchance": 0.8,
        "litchargerchance": 0.25,
        "chargercount": 6,
        "shrinecount": 15,
        "shrinechance": 0.5,
        "ghostchance": 0.5,
        "doorchance": 0.0,
        "nodoorchance": 1.0,
        "doorlockchance": -0.05,
        "trapchance": 0.3,
        "grateChance": 0.7,
        "rubblechance": 0.3,
        "brickchance": 0.01,
        "cacheInterval": 1,
        "forbiddenChance": 1.0,
        "forbiddenGreaterChance": 0.45,
        torchchance: 0.6,
        torchchanceboring: -0.4,
        torchreplace: {
            sprite: "TorchOrb",
            brightness: 4,
        },
        music: {
            "AREA4-MAGICLIBRARY.ogg": 10,
            "GENERIC-DOLLRACK.ogg": 4,
        },
        "setpieces": [
            { Type: "SmallAltar", Weight: 20 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
        ],
        tagModifiers: {
            "urban": 2,
            "jungle": 0,
            "cavern": 0,
        },
        "shortcuts": [
            { Level: 7, checkpoint: "cat", chance: 1.0 },
        ],
        "mainpath": [
            { Level: 8, checkpoint: "ore" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 20 },
            { Name: "SpecificSpell", Spell: "TrapRopeWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapRopeStrong", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLeatherWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapMagicChainsWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "Dressmaker", strict: true, Level: 0, Power: 2, Weight: 10 },
            { Name: "SpawnEnemies", Enemy: "Librarian", strict: true, Level: 4, Power: 1, Weight: 5 },
        ],
        "min_width": 5,
        "max_width": 5,
        "min_height": 5,
        "max_height": 5,
        factionList: ["Elf", "Bandit", "Apprentice", "Elemental", "Dragon", "Maidforce", "Alchemist"],
        enemyTags: ["book", "witch", "dressmaker", "magical"],
        "defeat_outfit": "Prisoner",
        "shrines": [
            { Type: "Latex", Weight: 3 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Metal", Weight: 3 },
            { Type: "Rope", Weight: 4 },
            { Type: "Leather", Weight: 6 },
            { Type: "Will", Weight: 7 },
        ]
    },
    "cry": {
        "background": "MagicSchoolEscape",
        "openness": 6,
        "density": 2,
        "crackchance": 0.11,
        "barchance": 0.03,
        "brightness": 5,
        "chargerchance": 1.0,
        "litchargerchance": 1.0,
        "chargercount": 4,
        "chestcount": 10,
        "shrinecount": 13,
        "shrinechance": 0.8,
        "ghostchance": 0.5,
        "doorchance": 0.05,
        "nodoorchance": 0.5,
        "doorlockchance": -0.05,
        "trapchance": 0.5,
        "grateChance": 0.7,
        "rubblechance": 0.45,
        "brickchance": 0.2,
        torchchance: 0.3,
        torchchanceboring: 0.1,
        music: {
            "AREA6-CRYSTALCAVE.ogg": 10,
            "AREA9-BELLOWS.ogg": 3,
        },
        shadowColor: 0x080311,
        "gaschance": 0.33,
        "gasdensity": 0.05,
        "gastype": '[',
        "floodchance": 0.25,
        "cacheInterval": 1,
        "forbiddenChance": 1.0,
        "forbiddenGreaterChance": 0.45,
        tagModifiers: {
            "open": 4,
            "jungle": 20,
            "cavern": 80,
            "urban": 0.5,
            "door": 0.5,
        },
        "setpieces": [
            { Type: "Altar", Weight: 6 },
            { Type: "SmallAltar", Weight: 20 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
            { Type: "Storage", Weight: 2 },
            { Type: "Magicflies", Weight: 40 },
        ],
        "shortcuts": [
            { Level: 9, checkpoint: "jng", chance: 0.33 },
            { Level: 10, checkpoint: "jng", chance: 0.4 },
            { Level: 11, checkpoint: "jng", chance: 1.0 },
        ],
        "mainpath": [
            { Level: 4, checkpoint: "cry" },
            { Level: 6, checkpoint: "cat" },
            { Level: 12, checkpoint: "ore" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 20 },
            { Name: "SpecificSpell", Spell: "TrapRopeWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLeatherWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapLustCloud", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "Bandit", strict: true, Level: 0, Power: 3, Weight: 10 },
        ],
        "min_width": 4,
        "max_width": 5,
        "min_height": 5,
        "max_height": 7,
        factionList: ["Nevermere", "Elf", "Bandit", "Apprentice", "Bountyhunter", "Elemental", "Dragon", "Maidforce", "Alchemist"],
        enemyTags: ["mushroom", "slimeBonus", "crystalline", "earth", "slime", "shadow"],
        "defeat_outfit": "Prisoner",
        "shrines": [
            { Type: "Latex", Weight: 3 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Metal", Weight: 3 },
            { Type: "Rope", Weight: 4 },
            { Type: "Leather", Weight: 6 },
            { Type: "Will", Weight: 7 },
        ]
    },
    "ore": {
        "background": "SpookyForest",
        "openness": 2,
        "density": 2,
        "crackchance": 0.05,
        "barchance": 0.1,
        "brightness": 1,
        "chestcount": 7,
        "chargerchance": 0.9,
        "litchargerchance": 0.2,
        "chargercount": 10,
        "shrinecount": 10,
        "shrinechance": 0.5,
        "ghostchance": 0.7,
        "doorchance": 0.9,
        "nodoorchance": 0.25,
        "doorlockchance": -0.05,
        "trapchance": 0.5,
        "grateChance": 0.8,
        "rubblechance": 0.35,
        "brickchance": 0.1,
        "cacheInterval": 1,
        "forbiddenChance": 1.0,
        "forbiddenGreaterChance": 0.45,
        torchlitchance: 0.2,
        torchchance: 1.0,
        torchchanceboring: -0.4,
        torchreplace: {
            sprite: "IllusOrb",
            unlitsprite: "IllusOrbDead",
            brightness: 2,
        },
        music: {
            "AREA8-ORRERY.ogg": 30,
        },
        factionList: ["Apprentice", "Elf", "Bandit", "Dressmaker", "Bountyhunter", "Elemental", "Dragon", "Maidforce", "Alchemist"],
        tagModifiers: {
            "jungle": 0,
            "cavern": 0,
            "temple": 3,
            "urban": 0.4,
            "dungeon": 0,
        },
        globalTags: {
            "temple": true,
            "orrery": true,
        },
        shadowColor: 0x000703,
        "setpieces": [
            { Type: "Bedroom", Weight: 1 },
            { Type: "Altar", Weight: 6 },
            { Type: "SmallAltar", Weight: 20 },
            { Type: "GuardedChest", Weight: 30 },
            { Type: "LargeGuardedChest", Weight: 20 },
        ],
        "shortcuts": [
            { Level: 14, checkpoint: "tmp", chance: 1.0 },
        ],
        "mainpath": [
            { Level: 17, checkpoint: "bel" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 20 },
            { Name: "SpecificSpell", Spell: "TrapRopeHoly", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpecificSpell", Spell: "TrapMagicChainsWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", Enemy: "ShadowHand", strict: true, Level: 0, Power: 3, Weight: 10 },
            { Name: "SpawnEnemies", Enemy: "TickleTerror", strict: true, Level: 0, Power: 1, Weight: 10 },
            { Name: "SpawnEnemies", Enemy: "HugHorror", strict: true, Level: 0, Power: 1, Weight: 10 },
        ],
        "min_width": 5,
        "max_width": 7,
        "min_height": 5,
        "max_height": 7,
        enemyTags: ["shadowcreature", "magical", "shadow", "elemental", "angel"],
        "defeat_outfit": "LatexPrisoner",
        "shrines": [
            { Type: "Latex", Weight: 5 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 10 },
            { Type: "Leather", Weight: 5 },
            { Type: "Metal", Weight: 3 },
            { Type: "Rope", Weight: 5 },
            { Type: "Will", Weight: 7 },
        ],
        "lockmult": 1.6,
    },
    "bel": {
        "background": "SpookyForest",
        "openness": 1,
        "density": 9,
        "crackchance": 0.12,
        "barchance": 0.1,
        "brightness": 1,
        "chestcount": 7,
        "chargerchance": 0.8,
        "litchargerchance": 0.2,
        "chargercount": 0,
        "shrinecount": 10,
        "shrinechance": 0.5,
        "ghostchance": 0.7,
        "doorchance": 0.9,
        "nodoorchance": 0.25,
        "doorlockchance": -0.05,
        "trapchance": 0.1,
        "grateChance": 0.8,
        "rubblechance": 0.35,
        "brickchance": 0.0,
        "cacheInterval": 1,
        "forbiddenChance": 1.0,
        "forbiddenGreaterChance": 0.45,
        torchlitchance: 0.45,
        torchchance: 1.0,
        torchchanceboring: -0.7,
        torchreplace: {
            sprite: "Lantern",
            unlitsprite: "LanternUnlit",
            brightness: 5,
        },
        music: {
            "AREA9-BELLOWS.ogg": 30,
        },
        tagModifiers: {
            "jungle": 0,
            "cavern": 0,
            "temple": 0.0,
            "urban": 0,
            "industrial": 2.0,
            "dungeon": 0,
            "factory": 2.0,
            "bellows": 3.0,
        },
        globalTags: {
            "factory": true,
            "bellows": true,
            "industrial": true,
        },
        shadowColor: 0x000703,
        "setpieces": [
            { Type: "Bedroom", Weight: 1 },
            { Type: "LargeGuardedChest", Weight: 20 },
        ],
        "shortcuts": [],
        "mainpath": [
            { Level: 21, checkpoint: "grv" },
        ],
        "traps": [
            { Name: "CustomSleepDart", Level: 0, Power: 1, Weight: 20 },
            { Name: "SpecificSpell", Spell: "TrapMagicChainsWeak", Level: 0, Power: 3, Weight: 30 },
            { Name: "SpawnEnemies", strict: true, Enemy: "Drone", Level: 0, Power: 3, Weight: 100 },
            { Name: "SpawnEnemies", strict: true, Enemy: "CaptureBot", Level: 0, Power: 2, Weight: 100 },
        ],
        "min_width": 6,
        "max_width": 8,
        "min_height": 4,
        "max_height": 4,
        factionList: ["Nevermere", "AncientRobot", "Bandit", "Dressmaker", "Bountyhunter", "Maidforce", "Alchemist"],
        enemyTags: ["dollsmith", "dollrare", "oldrobot", "oldrobotturret", "tech", "metal", "electric", "fire"],
        "defeat_outfit": "DollSuit",
        "shrines": [
            { Type: "Latex", Weight: 5 },
            { Type: "Commerce", Weight: 0 },
            { Type: "Elements", Weight: 5 },
            { Type: "Conjure", Weight: 5 },
            { Type: "Illusion", Weight: 5 },
            { Type: "Leather", Weight: 7 },
            { Type: "Metal", Weight: 10 },
            { Type: "Rope", Weight: 3 },
            { Type: "Will", Weight: 7 },
        ],
        "lockmult": 2.0,
    },
};
let KinkyDungeonSeeAll = false;
let KDVisionBlockers = new Map();
let KDLightBlockers = new Map();
function KinkyDungeonCheckProjectileClearance(xx, yy, x2, y2) {
    let tiles = KinkyDungeonTransparentObjects;
    let moveDirection = KinkyDungeonGetDirection(x2 - xx, y2 - yy);
    let x1 = xx + moveDirection.x;
    let y1 = yy + moveDirection.y;
    let dist = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    for (let d = 0; d < dist; d += 0.25) {
        let mult = d / dist;
        let xxx = x1 + mult * (x2 - x1);
        let yyy = y1 + mult * (y2 - y1);
        if (!tiles.includes(KinkyDungeonMapGet(Math.round(xxx), Math.round(yyy))))
            return false;
    }
    return true;
}
function KinkyDungeonCheckPath(x1, y1, x2, y2, allowBars, blockEnemies, maxFails, blockOnlyLOSBlock) {
    var _a, _b, _c;
    if (x1 == x2 && y1 == y2)
        return true;
    let length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    let obj = allowBars ? KinkyDungeonTransparentObjects : KinkyDungeonTransparentMovableObjects;
    let maxFailsAllowed = maxFails ? maxFails : 1;
    let fails = 0;
    for (let F = 0; F <= length; F++) {
        let xx = x1 + (x2 - x1) * F / length;
        let yy = y1 + (y2 - y1) * F / length;
        if ((Math.round(xx) != x1 || Math.round(yy) != y1) && (Math.round(xx) != x2 || Math.round(yy) != y2)) {
            let hits = 0;
            if (!obj.includes(KinkyDungeonMapGet(Math.floor(xx), Math.floor(yy)))
                || ((xx != x1 || yy != y1) && (blockEnemies && ((!blockOnlyLOSBlock && KinkyDungeonEnemyAt(Math.floor(xx), Math.floor(yy))) || (blockOnlyLOSBlock && ((_a = KinkyDungeonEnemyAt(Math.floor(xx), Math.floor(yy))) === null || _a === void 0 ? void 0 : _a.Enemy.blockVision)))))
                || ((xx != x1 || yy != y1) && (allowBars && KDVisionBlockers.get(Math.floor(xx) + "," + Math.floor(yy)))))
                hits += 1;
            if (!obj.includes(KinkyDungeonMapGet(Math.round(xx), Math.round(yy)))
                || ((xx != x1 || yy != y1) && (blockEnemies && ((!blockOnlyLOSBlock && KinkyDungeonEnemyAt(Math.round(xx), Math.round(yy))) || (blockOnlyLOSBlock && ((_b = KinkyDungeonEnemyAt(Math.round(xx), Math.round(yy))) === null || _b === void 0 ? void 0 : _b.Enemy.blockVision)))))
                || ((xx != x1 || yy != y1) && (allowBars && KDVisionBlockers.get(Math.round(xx) + "," + Math.round(yy)))))
                hits += 1;
            if (hits < 2 && !obj.includes(KinkyDungeonMapGet(Math.ceil(xx), Math.ceil(yy)))
                || ((xx != x1 || yy != y1) && (blockEnemies && ((!blockOnlyLOSBlock && KinkyDungeonEnemyAt(Math.ceil(xx), Math.ceil(yy))) || (blockOnlyLOSBlock && ((_c = KinkyDungeonEnemyAt(Math.ceil(xx), Math.ceil(yy))) === null || _c === void 0 ? void 0 : _c.Enemy.blockVision)))))
                || ((xx != x1 || yy != y1) && (allowBars && KDVisionBlockers.get(Math.ceil(xx) + "," + Math.ceil(yy)))))
                hits += 1;
            if (hits >= 2) {
                fails += 1;
                if (fails >= maxFailsAllowed)
                    return false;
            }
        }
    }
    return true;
}
let KDPlayerLight = 0;
let KDMapBrightnessMult = 0.2;
function KinkyDungeonResetFog() {
    KinkyDungeonFogGrid = [];
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++)
            KinkyDungeonFogGrid.push(0);
    }
}
function KinkyDungeonMakeBrightnessMap(width, height, mapBrightness, Lights, delta) {
    let flags = {
        SeeThroughWalls: 0,
    };
    KinkyDungeonSendEvent("brightness", { update: delta, flags: flags });
    let ShadowColor = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].shadowColor ? KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].shadowColor : 0x00001f;
    let LightColor = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].lightColor ? KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].lightColor : 0x000000;
    KinkyDungeonBlindLevelBase = 0;
    KinkyDungeonColorGrid = [];
    KinkyDungeonShadowGrid = [];
    KinkyDungeonBrightnessGrid = [];
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
            KinkyDungeonBrightnessGrid.push(0);
            KinkyDungeonShadowGrid.push(0);
            KinkyDungeonColorGrid.push(LightColor);
        }
    }
    let baseBrightness = mapBrightness * KDMapBrightnessMult;
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++)
            if (KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(X, Y))) {
                KinkyDungeonBrightnessSet(X, Y, baseBrightness);
            }
    }
    let maxPass = 0;
    KDLightBlockers = new Map();
    for (let EE of KinkyDungeonEntities) {
        let Enemy = EE.Enemy;
        if (Enemy && Enemy.blockVision || (Enemy.blockVisionWhileStationary && !EE.moved && EE.idle))
            KDLightBlockers.set(EE.x + "," + EE.y, true);
    }
    let LightsTemp = new Map();
    for (let location of Object.values(KinkyDungeonEffectTiles)) {
        for (let tile of Object.values(location)) {
            if (tile.duration > 0) {
                if (tile.lightColor) {
                    if (tile.brightness > KinkyDungeonBrightnessGet(tile.x, tile.y))
                        KinkyDungeonColorSet(tile.x, tile.y, tile.lightColor);
                }
                if (tile.tags.includes("brightnessblock")) {
                    KDLightBlockers.set(tile.x + "," + tile.y, true);
                }
                if (tile.tags.includes("darkarea")) {
                    KinkyDungeonBrightnessSet(tile.x, tile.y, 0);
                }
                if (tile.brightness) {
                    maxPass = Math.max(maxPass, tile.brightness);
                    KinkyDungeonBrightnessSet(tile.x, tile.y, tile.brightness, true);
                    if (!LightsTemp.get(tile.x + "," + tile.y) || tile.brightness > LightsTemp.get(tile.x + "," + tile.y))
                        LightsTemp.set(tile.x + "," + tile.y, tile.brightness);
                }
            }
        }
    }
    for (let light of Lights) {
        if (light.brightness > 0) {
            maxPass = Math.max(maxPass, light.brightness);
            if (light.brightness > KinkyDungeonBrightnessGet(light.x, light.y)) {
                if (light.color)
                    KinkyDungeonColorSet(light.x, light.y, light.color);
                else
                    KinkyDungeonColorSet(light.x, light.y, 0xffffff);
            }
            KinkyDungeonBrightnessSet(light.x, light.y, light.brightness, true);
            if (!(LightsTemp.get(light.x + "," + light.y) >= light.brightness)) {
                LightsTemp.set(light.x + "," + light.y, light.brightness);
            }
        }
    }
    let nextBrightness = [];
    for (let L = maxPass; L > 0; L--) {
        nextBrightness = [];
        for (let X = 1; X < KinkyDungeonGridWidth - 1; X++) {
            for (let Y = 1; Y < KinkyDungeonGridHeight - 1; Y++) {
                let tile = KinkyDungeonMapGet(X, Y);
                if ((KinkyDungeonTransparentObjects.includes(tile) && !KDLightBlockers.get(X + "," + Y)) || LightsTemp.get(X + "," + Y)) {
                    let brightness = KinkyDungeonBrightnessGet(X, Y);
                    let color = KinkyDungeonColorGet(X, Y);
                    let shadow = KinkyDungeonShadowGet(X, Y);
                    if (brightness > 0) {
                        let decay = 0.7;
                        let nearbywalls = 0;
                        for (let XX = X - 1; XX <= X + 1; XX++)
                            for (let YY = Y - 1; YY <= Y + 1; YY++)
                                if (!KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(XX, YY)) || KDLightBlockers.get(XX + "," + YY))
                                    nearbywalls += 1;
                        if (nearbywalls > 3 && brightness <= 9)
                            decay += nearbywalls * 0.15;
                        else if (nearbywalls > 1 && brightness <= 9)
                            decay += nearbywalls * 0.1;
                        if (brightness > 0) {
                            if (Number(KinkyDungeonBrightnessGet(X - 1, Y)) < brightness)
                                nextBrightness.push({ x: X - 1, y: Y, shadow: shadow, color: color, brightness: (brightness - decay) });
                            if (Number(KinkyDungeonBrightnessGet(X + 1, Y)) < brightness)
                                nextBrightness.push({ x: X + 1, y: Y, shadow: shadow, color: color, brightness: (brightness - decay) });
                            if (Number(KinkyDungeonBrightnessGet(X, Y - 1)) < brightness)
                                nextBrightness.push({ x: X, y: Y - 1, shadow: shadow, color: color, brightness: (brightness - decay) });
                            if (Number(KinkyDungeonBrightnessGet(X, Y + 1)) < brightness)
                                nextBrightness.push({ x: X, y: Y + 1, shadow: shadow, color: color, brightness: (brightness - decay) });
                            if (brightness > 0.5) {
                                if (Number(KinkyDungeonBrightnessGet(X - 1, Y - 1)) < brightness)
                                    nextBrightness.push({ x: X - 1, y: Y - 1, shadow: shadow, color: color, brightness: (brightness - decay) });
                                if (Number(KinkyDungeonBrightnessGet(X - 1, Y + 1)) < brightness)
                                    nextBrightness.push({ x: X - 1, y: Y + 1, shadow: shadow, color: color, brightness: (brightness - decay) });
                                if (Number(KinkyDungeonBrightnessGet(X + 1, Y - 1)) < brightness)
                                    nextBrightness.push({ x: X + 1, y: Y - 1, shadow: shadow, color: color, brightness: (brightness - decay) });
                                if (Number(KinkyDungeonBrightnessGet(X + 1, Y + 1)) < brightness)
                                    nextBrightness.push({ x: X + 1, y: Y + 1, shadow: shadow, color: color, brightness: (brightness - decay) });
                            }
                        }
                    }
                }
            }
        }
        for (let b of nextBrightness) {
            let brightness = KinkyDungeonBrightnessGet(b.x, b.y);
            if (b.brightness > brightness) {
                KinkyDungeonBrightnessSet(b.x, b.y, Math.max(Number(brightness), b.brightness));
                KinkyDungeonColorSet(b.x, b.y, KDAvgColor(b.color, KinkyDungeonColorGet(b.x, b.y), b.brightness, brightness));
            }
        }
    }
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
            let brightness = KinkyDungeonBrightnessGet(X, Y);
            KinkyDungeonShadowSet(X, Y, KDAvgColor(ShadowColor, 0x000000, 1, Math.max(0, brightness - baseBrightness)));
        }
    }
    KDPlayerLight = KinkyDungeonBrightnessGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
}
function KDAvgColor(color1, color2, w1, w2) {
    let r = (color1 & 0xFF0000) >> 16;
    let g = (color1 & 0x00FF00) >> 8;
    let b = (color1 & 0x0000FF);
    r = Math.floor((r * w1 + w2 * ((color2 & 0xFF0000) >> 16)) / (w1 + w2));
    g = Math.floor((g * w1 + w2 * ((color2 & 0x00FF00) >> 8)) / (w1 + w2));
    b = Math.floor((b * w1 + w2 * ((color2 & 0x0000FF))) / (w1 + w2));
    return (r << 16) + (g << 8) + b;
}
function KinkyDungeonMakeVisionMap(width, height, Viewports, Lights, delta, mapBrightness) {
    let flags = {
        SeeThroughWalls: 0,
    };
    KinkyDungeonSendEvent("vision", { update: delta, flags: flags });
    KinkyDungeonBlindLevelBase = 0;
    KinkyDungeonVisionGrid = [];
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++)
            KinkyDungeonVisionGrid.push(0);
    }
    let maxPass = 0;
    let brightestLight = 0;
    KDVisionBlockers = new Map();
    for (let EE of KinkyDungeonEntities) {
        let Enemy = EE.Enemy;
        if (Enemy && (Enemy.blockVision || (Enemy.blockVisionWhileStationary && !EE.moved && EE.idle)))
            KDVisionBlockers.set(EE.x + "," + EE.y, true);
    }
    let LightsTemp = new Map();
    for (let location of Object.values(KinkyDungeonEffectTiles)) {
        for (let tile of Object.values(location)) {
            if (tile.duration > 0 && tile.tags.includes("visionblock")) {
                KDVisionBlockers.set(tile.x + "," + tile.y, true);
            }
            if (tile.brightness) {
                LightsTemp.set(tile.x + "," + tile.y, tile.brightness);
            }
        }
    }
    for (let light of Lights) {
        if (light.brightness > 0) {
            if (!(LightsTemp.get(light.x + "," + light.y) >= light.brightness)) {
                LightsTemp.set(light.x + "," + light.y, light.brightness);
            }
            if (light.y_orig != undefined && !(LightsTemp.get(light.x + "," + light.y_orig) >= light.brightness)) {
                LightsTemp.set(light.x + "," + light.y_orig, light.brightness);
            }
        }
    }
    for (let light of Viewports) {
        if (light.brightness > 0) {
            maxPass = Math.max(maxPass, light.brightness);
            if (light.brightness > brightestLight)
                brightestLight = light.brightness;
            KinkyDungeonVisionSet(light.x, light.y, light.brightness);
        }
    }
    let bb = 0;
    let d = 1;
    let newL = 0;
    for (let X = 1; X < KinkyDungeonGridWidth - 1; X++) {
        for (let Y = 1; Y < KinkyDungeonGridHeight - 1; Y++)
            if (KinkyDungeonCheckPath(X, Y, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, true, true, flags.SeeThroughWalls ? flags.SeeThroughWalls + 1 : 1, true)
                && KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(X, Y))) {
                bb = KinkyDungeonBrightnessGet(X, Y);
                d = KDistChebyshev(X - KinkyDungeonPlayerEntity.x, Y - KinkyDungeonPlayerEntity.y);
                newL = bb + 2 - Math.min(1.5, d * 1.5);
                if (newL > KinkyDungeonVisionGet(X, Y)) {
                    KinkyDungeonVisionSet(X, Y, Math.max(0, newL));
                    maxPass = Math.max(maxPass, newL);
                }
            }
    }
    let nextBrightness = [];
    for (let L = maxPass; L > 0; L--) {
        nextBrightness = [];
        for (let X = 0; X < KinkyDungeonGridWidth; X++) {
            for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
                let tile = KinkyDungeonMapGet(X, Y);
                if ((LightsTemp.get(X + "," + Y) || (KinkyDungeonTransparentObjects.includes(tile) || (X == KinkyDungeonPlayerEntity.x && Y == KinkyDungeonPlayerEntity.y))) && !KDVisionBlockers.get(X + "," + Y)) {
                    let brightness = KinkyDungeonVisionGet(X, Y);
                    if (brightness > 0) {
                        let decay = KinkyDungeonDeaf ? 5 : 2;
                        if (!KinkyDungeonTransparentObjects.includes(tile))
                            decay += 3;
                        if (brightness > 0) {
                            if (Number(KinkyDungeonVisionGet(X - 1, Y)) < brightness)
                                nextBrightness.push({ x: X - 1, y: Y, brightness: (brightness - decay) });
                            if (Number(KinkyDungeonVisionGet(X + 1, Y)) < brightness)
                                nextBrightness.push({ x: X + 1, y: Y, brightness: (brightness - decay) });
                            if (Number(KinkyDungeonVisionGet(X, Y - 1)) < brightness)
                                nextBrightness.push({ x: X, y: Y - 1, brightness: (brightness - decay) });
                            if (Number(KinkyDungeonVisionGet(X, Y + 1)) < brightness)
                                nextBrightness.push({ x: X, y: Y + 1, brightness: (brightness - decay) });
                            if (brightness > 0.5) {
                                if (Number(KinkyDungeonVisionGet(X - 1, Y - 1)) < brightness)
                                    nextBrightness.push({ x: X - 1, y: Y - 1, brightness: (brightness - decay) });
                                if (Number(KinkyDungeonVisionGet(X - 1, Y + 1)) < brightness)
                                    nextBrightness.push({ x: X - 1, y: Y + 1, brightness: (brightness - decay) });
                                if (Number(KinkyDungeonVisionGet(X + 1, Y - 1)) < brightness)
                                    nextBrightness.push({ x: X + 1, y: Y - 1, brightness: (brightness - decay) });
                                if (Number(KinkyDungeonVisionGet(X + 1, Y + 1)) < brightness)
                                    nextBrightness.push({ x: X + 1, y: Y + 1, brightness: (brightness - decay) });
                            }
                        }
                    }
                }
            }
        }
        for (let b of nextBrightness) {
            KinkyDungeonVisionSet(b.x, b.y, Math.max(Number(KinkyDungeonVisionGet(b.x, b.y)), b.brightness));
        }
    }
    let vv = 0;
    for (let X = 1; X < KinkyDungeonGridWidth - 1; X++) {
        for (let Y = 1; Y < KinkyDungeonGridHeight - 1; Y++) {
            vv = KinkyDungeonVisionGet(X, Y);
            bb = KinkyDungeonBrightnessGet(X, Y);
            if (vv > 0 && KDLightCropValue + bb > vv && LightsTemp.get(X + "," + Y)) {
                KinkyDungeonVisionSet(X, Y, KDLightCropValue + bb);
            }
        }
    }
    let rad = KinkyDungeonGetVisionRadius();
    for (let X = 0; X < KinkyDungeonGridWidth; X++) {
        for (let Y = 0; Y < KinkyDungeonGridHeight; Y++) {
            let dd = KDistChebyshev(X - KinkyDungeonPlayerEntity.x, Y - KinkyDungeonPlayerEntity.y);
            if (dd > rad)
                KinkyDungeonVisionSet(X, Y, 0);
            else if (rad < KDMaxVisionDist && dd > 1.5) {
                KinkyDungeonVisionSet(X, Y, KinkyDungeonVisionGet(X, Y) * Math.min(1, Math.max(0, rad - dd) / 3));
            }
        }
    }
    if (KinkyDungeonSeeAll) {
        KinkyDungeonVisionGrid = [];
        for (let X = 0; X < KinkyDungeonGridWidth; X++) {
            for (let Y = 0; Y < KinkyDungeonGridHeight; Y++)
                KinkyDungeonVisionGrid.push(10);
        }
    }
    else {
        let dist = 0;
        let fog = true;
        for (let X = 0; X < KinkyDungeonGridWidth; X++) {
            for (let Y = 0; Y < KinkyDungeonGridHeight; Y++)
                if (X >= 0 && X <= width - 1 && Y >= 0 && Y <= height - 1) {
                    dist = KDistChebyshev(KinkyDungeonPlayerEntity.x - X, KinkyDungeonPlayerEntity.y - Y);
                    if (dist < 3) {
                        let distE = KDistEuclidean(KinkyDungeonPlayerEntity.x - X, KinkyDungeonPlayerEntity.y - Y);
                        if (fog && dist < 3
                            && distE < 2.9
                            && KinkyDungeonCheckPath(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, X, Y, true, true, flags.SeeThroughWalls ? flags.SeeThroughWalls + 1 : 1, true)) {
                            KinkyDungeonFogGrid[X + Y * (width)] = Math.max(KinkyDungeonFogGrid[X + Y * (width)], 3);
                        }
                        if (distE < (KinkyDungeonDeaf ? 1.5 : 2.3) && KinkyDungeonVisionGrid[X + Y * (width)] == 0
                            && KinkyDungeonCheckPath(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, X, Y, true, true, flags.SeeThroughWalls ? flags.SeeThroughWalls + 1 : 1, true)) {
                            KinkyDungeonVisionGrid[X + Y * (width)] = 1;
                        }
                    }
                    if (fog)
                        KinkyDungeonFogGrid[X + Y * (width)] = Math.max(KinkyDungeonFogGrid[X + Y * (width)], KinkyDungeonVisionGrid[X + Y * (width)] ? 2 : 0);
                }
        }
    }
}
let KDLightCropValue = 6;
function KDDrawFog(CamX, CamY, CamX_offset, CamY_offset) {
    kdgamefog.clear();
    let v_td = false;
    let v_tu = false;
    let v_tl = false;
    let v_tr = false;
    let v_tdl = false;
    let v_tdr = false;
    let RX = 0;
    let RY = 0;
    let allowFog = false;
    let visible = false;
    let fog = 0;
    let lightDiv = 0;
    let light = 0;
    let shadowColor = 0;
    let l = 0;
    let pad = 0;
    for (let R = -1; R <= KinkyDungeonGridHeightDisplay + 2; R++) {
        for (let X = -1; X <= KinkyDungeonGridWidthDisplay + 2; X++) {
            RY = R + CamY;
            RX = X + CamX;
            allowFog = KDAllowFog();
            if (RY >= 0 && RY < KinkyDungeonGridHeight && RX >= 0 && RX < KinkyDungeonGridWidth) {
                visible = (KinkyDungeonVisionGet(RX, RY) > 0 || (allowFog && KinkyDungeonFogGet(RX, RY) > 0));
                if (visible) {
                    fog = KinkyDungeonStatBlind > 0 ? 0 : Math.min(0.5, KinkyDungeonFogGet(RX, RY) / 10);
                    lightDiv = (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(RX, RY))) ? KDLightCropValue : KDLightCropValue * 0.7;
                    light = Math.max(KinkyDungeonVisionGrid[RX + RY * KinkyDungeonGridWidth] / lightDiv, fog);
                    shadowColor = KinkyDungeonShadowGrid[RX + RY * KinkyDungeonGridWidth];
                    if (KinkyDungeonVisionGrid[RX + RY * KinkyDungeonGridWidth] > 0 && KDistChebyshev(KinkyDungeonPlayerEntity.x - RX, KinkyDungeonPlayerEntity.y - RY) < 2) {
                        light = light + (1 - light) * 0.5;
                    }
                    l = Math.max(0, Math.min(1, (1 - light)));
                    kdgamefog.beginFill(light > 0 ? shadowColor : 0x000000, (KinkyDungeonVisionGrid[RX + RY * KinkyDungeonGridWidth] > 0) ? (0.9 * l * l) : l);
                    pad = light > 0 ? 0 : 1;
                    kdgamefog.drawRect((-CamX_offset + X) * KinkyDungeonGridSizeDisplay - pad, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay - pad, KinkyDungeonGridSizeDisplay + pad * 2, KinkyDungeonGridSizeDisplay + pad * 2);
                    kdgamefog.endFill();
                    if (KDToggles.FancyWalls && (KinkyDungeonWallTiles.includes(KinkyDungeonMapGet(RX, RY)) || RX == 0 || RY == 0)) {
                        if (KDWallVert(RX, RY) || KinkyDungeonGridHeight == RY + 1) {
                            v_tu = ((KinkyDungeonVisionGet(RX, RY - 1) > 0 || (allowFog && KinkyDungeonFogGet(RX, RY - 1) > 0)));
                            v_td = ((KinkyDungeonVisionGet(RX, RY + 1) > 0 || (allowFog && KinkyDungeonFogGet(RX, RY + 1) > 0)));
                            v_tl = ((KinkyDungeonVisionGet(RX - 1, RY) > 0 || (allowFog && KinkyDungeonFogGet(RX - 1, RY) > 0)));
                            v_tr = ((KinkyDungeonVisionGet(RX + 1, RY) > 0 || (allowFog && KinkyDungeonFogGet(RX + 1, RY) > 0)));
                            v_tdl = ((KinkyDungeonVisionGet(RX - 1, RY + 1) > 0 || (allowFog && KinkyDungeonFogGet(RX - 1, RY + 1) > 0)));
                            v_tdr = ((KinkyDungeonVisionGet(RX + 1, RY + 1) > 0 || (allowFog && KinkyDungeonFogGet(RX + 1, RY + 1) > 0)));
                            pad = 1;
                            if (!v_tl) {
                                kdgamefog.beginFill(0x000000, 1.0);
                                kdgamefog.drawRect((-CamX_offset + X) * KinkyDungeonGridSizeDisplay - pad, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay - pad, KinkyDungeonGridSizeDisplay / 2 + pad * 2, KinkyDungeonGridSizeDisplay + pad * 2);
                                kdgamefog.endFill();
                            }
                            if (!v_tr) {
                                kdgamefog.beginFill(0x000000, 1.0);
                                kdgamefog.drawRect((-CamX_offset + X + 0.5) * KinkyDungeonGridSizeDisplay - pad, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay - pad, KinkyDungeonGridSizeDisplay / 2 + pad * 2, KinkyDungeonGridSizeDisplay + pad * 2);
                                kdgamefog.endFill();
                            }
                            if (!v_tu && !v_tdl && !v_tdr) {
                                kdgamefog.beginFill(0x000000, 1.0);
                                kdgamefog.drawRect((-CamX_offset + X) * KinkyDungeonGridSizeDisplay - pad, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay - pad, KinkyDungeonGridSizeDisplay + pad * 2, KinkyDungeonGridSizeDisplay / 2 + pad * 2);
                                kdgamefog.endFill();
                            }
                            if (!v_td) {
                                kdgamefog.beginFill(0x000000, 1.0);
                                kdgamefog.drawRect((-CamX_offset + X) * KinkyDungeonGridSizeDisplay - pad, (-CamY_offset + R + 0.5) * KinkyDungeonGridSizeDisplay - pad, KinkyDungeonGridSizeDisplay + pad * 2, KinkyDungeonGridSizeDisplay / 2 + pad * 2);
                                kdgamefog.endFill();
                            }
                            if (v_td && v_tl && !v_tdl) {
                                kdgamefog.beginFill(0x000000, 1.0);
                                kdgamefog.drawRect((-CamX_offset + X) * KinkyDungeonGridSizeDisplay - pad, (-CamY_offset + R + 0.5) * KinkyDungeonGridSizeDisplay - pad, KinkyDungeonGridSizeDisplay / 2 + pad * 2, KinkyDungeonGridSizeDisplay / 2 + pad * 2);
                                kdgamefog.endFill();
                            }
                            if (v_td && v_tr && !v_tdr) {
                                kdgamefog.beginFill(0x000000, 1.0);
                                kdgamefog.drawRect((-CamX_offset + X + 0.5) * KinkyDungeonGridSizeDisplay - pad, (-CamY_offset + R + 0.5) * KinkyDungeonGridSizeDisplay - pad, KinkyDungeonGridSizeDisplay / 2 + pad * 2, KinkyDungeonGridSizeDisplay / 2 + pad * 2);
                                kdgamefog.endFill();
                            }
                        }
                    }
                }
            }
        }
    }
}
function KDAllowFog() {
    return !(KinkyDungeonStatsChoice.get("Forgetful") || (KinkyDungeonBlindLevel > 0 && KinkyDungeonStatsChoice.get("TotalBlackout")));
}
let QuestCompleteWeight = 1000;
let KDQuests = {
    "DressmakerQuest": {
        name: "DressmakerQuest",
        npc: "DressmakerQuest",
        worldgenstart: () => {
            if (KDGameData.RoomType == "" && !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel)) {
                for (let i = 0; i < 3; i++) {
                    let point = KinkyDungeonGetRandomEnemyPoint(true);
                    if (point) {
                        KinkyDungeonSummonEnemy(point.x, point.y, "Dressmaker", 1, 2.9);
                    }
                }
            }
        },
        weight: (RoomType, MapMod, data) => {
            if (RoomType == "Tunnel") {
                let weight = 15;
                if (KinkyDungeonPlayerTags.has("BindingDress")) {
                    return weight * QuestCompleteWeight;
                }
                return weight;
            }
            return 0;
        },
        prerequisite: (RoomType, MapMod, data) => {
            if (RoomType == "Tunnel") {
                return true;
            }
            return false;
        }
    },
    "ApprenticeQuest": {
        name: "ApprenticeQuest",
        npc: "ApprenticeQuest",
        worldgenstart: () => {
            if (KDGameData.RoomType == "" && !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel) && !KinkyDungeonFlags.get("ApprenticeQuestSpawn")) {
                let point = KinkyDungeonGetRandomEnemyPoint(true);
                if (point) {
                    KinkyDungeonSummonEnemy(point.x, point.y, "Librarian", 1, 2.9);
                }
                KinkyDungeonSetFlag("ApprenticeQuestSpawn", -1);
            }
        },
        weight: (RoomType, MapMod, data) => {
            if (RoomType == "Tunnel") {
                let weight = 30;
                if (KinkyDungeonInventoryGet("ScrollLegs")
                    || KinkyDungeonInventoryGet("ScrollArms")
                    || KinkyDungeonInventoryGet("ScrollVerbal")
                    || KinkyDungeonInventoryGet("ScrollPurity")) {
                    return weight * QuestCompleteWeight;
                }
                return weight;
            }
            return 0;
        },
        accept: (data) => {
            KinkyDungeonSetFlag("ApprenticeQuestSpawn", 0);
        },
        prerequisite: (RoomType, MapMod, data) => {
            if (KDHasQuest("ApprenticeQuest") && !(KinkyDungeonInventoryGet("ScrollLegs")
                || KinkyDungeonInventoryGet("ScrollArms")
                || KinkyDungeonInventoryGet("ScrollVerbal")
                || KinkyDungeonInventoryGet("ScrollPurity"))) {
                return false;
            }
            if (RoomType == "Tunnel") {
                return true;
            }
            return false;
        }
    },
    "DragonheartQuest": {
        name: "DragonheartQuest",
        npc: "DragonheartQuest",
        weight: (RoomType, MapMod, data) => {
            if (RoomType == "Tunnel") {
                let weight = 20;
                return weight;
            }
            return 0;
        },
        worldgenstart: () => {
            if (KDGameData.RoomType == "" && !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel)) {
                let point = KinkyDungeonGetRandomEnemyPoint(true);
                if (point) {
                    KinkyDungeonSummonEnemy(point.x, point.y, "DragonLeaderDuelist", 1, 2.9);
                }
                KDRemoveQuest("DragonheartQuest");
            }
        },
        prerequisite: (RoomType, MapMod, data) => {
            if (KDHasQuest("DragonheartQuest")) {
                return false;
            }
            if (KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel + 1))
                return false;
            if (RoomType == "Tunnel") {
                return true;
            }
            return false;
        }
    },
    "MaidforceQuest": {
        name: "MaidforceQuest",
        npc: "MaidforceQuest",
        weight: (RoomType, MapMod, data) => {
            if (RoomType == "Tunnel") {
                let weight = 20;
                return weight;
            }
            return 0;
        },
        worldgenstart: () => {
            if (KDGameData.RoomType == "" && !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel)) {
                let point = KinkyDungeonGetRandomEnemyPoint(true);
                if (point) {
                    let e = KinkyDungeonGetEnemy(["maid", "miniboss"], MiniGameKinkyDungeonLevel + 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["maid", "miniboss"], false, { "maid": { mult: 4, bonus: 10 } });
                    if (e) {
                        let epoint = KinkyDungeonGetNearbyPoint(point.x, point.y, true, undefined, false);
                        if (epoint) {
                            let ee = DialogueCreateEnemy(point.x, point.y, e.name);
                            if (ee) {
                                ee.faction = "Delinquent";
                                ee.factionrep = { "Maidforce": 0.01 };
                                ee.AI = "looseguard";
                            }
                        }
                    }
                    let count = 3 + KDRandom() * Math.min(4, KinkyDungeonDifficulty / 20);
                    for (let i = 0; i < count; i++) {
                        e = KinkyDungeonGetEnemy(["maid"], MiniGameKinkyDungeonLevel + 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["maid"], false, { "maid": { mult: 4, bonus: 10 } }, ["miniboss", "boss"]);
                        let epoint = KinkyDungeonGetNearbyPoint(point.x, point.y, true, undefined, false);
                        if (epoint) {
                            let ee = DialogueCreateEnemy(point.x, point.y, e.name);
                            if (ee) {
                                ee.faction = "Delinquent";
                                ee.factionrep = { "Maidforce": 0.0025 };
                                ee.AI = "looseguard";
                            }
                        }
                    }
                }
                KDRemoveQuest("MaidforceQuest");
            }
        },
        prerequisite: (RoomType, MapMod, data) => {
            if (KDHasQuest("MaidforceQuest")) {
                return false;
            }
            if (KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel + 1))
                return false;
            if (RoomType == "Tunnel") {
                return true;
            }
            return false;
        }
    },
    "WolfgirlHunters": {
        name: "WolfgirlHunters",
        npc: "MaidforceQuest",
        weight: (RoomType, MapMod, data) => {
            return 0;
        },
        worldgenstart: () => {
            if (KDGameData.RoomType == "" && !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel)) {
                let point = KinkyDungeonGetRandomEnemyPoint(true);
                if (point) {
                    let e = KinkyDungeonGetEnemy(["wolfgirl", "miniboss"], MiniGameKinkyDungeonLevel + 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["wolfgirl", "miniboss"], false, { "wolfgirl": { mult: 4, bonus: 10 } });
                    if (e) {
                        let epoint = KinkyDungeonGetNearbyPoint(point.x, point.y, true, undefined, false);
                        if (epoint) {
                            let ee = DialogueCreateEnemy(point.x, point.y, e.name);
                            if (ee) {
                                ee.faction = "Wolfhunter";
                                ee.AI = "looseguard";
                            }
                        }
                    }
                    let count = 3 + KDRandom() * Math.min(4, KinkyDungeonDifficulty / 20);
                    for (let i = 0; i < count; i++) {
                        e = KinkyDungeonGetEnemy(["nevermere"], MiniGameKinkyDungeonLevel + 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["nevermere"], false, { "wolfgirl": { mult: 4, bonus: 10 } }, ["miniboss", "boss"]);
                        let epoint = KinkyDungeonGetNearbyPoint(point.x, point.y, true, undefined, false);
                        if (epoint) {
                            let ee = DialogueCreateEnemy(point.x, point.y, e.name);
                            if (ee) {
                                ee.faction = "Wolfhunter";
                                ee.AI = "looseguard";
                            }
                        }
                    }
                }
            }
        },
        prerequisite: (RoomType, MapMod, data) => {
            return false;
        }
    },
    "BanditQuest": {
        name: "BanditQuest",
        npc: "BanditQuest",
        weight: (RoomType, MapMod, data) => {
            if (RoomType == "Tunnel") {
                let weight = 20;
                return weight;
            }
            return 0;
        },
        worldgenstart: () => {
            if (KDGameData.RoomType == "" && !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel)) {
                let point = KinkyDungeonGetRandomEnemyPoint(true);
                if (point) {
                    point = KinkyDungeonNearestJailPoint(point.x, point.y);
                    if (point) {
                        KinkyDungeonSummonEnemy(point.x, point.y, "PrisonerBandit", 1, 1.5);
                    }
                }
                KDRemoveQuest("BanditPrisoner");
            }
        },
        prerequisite: (RoomType, MapMod, data) => {
            if (KDHasQuest("BanditPrisoner")) {
                return false;
            }
            if (KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel + 1))
                return false;
            if (RoomType == "Tunnel") {
                return true;
            }
            return false;
        }
    },
    "BlacksmithQuest": {
        name: "BlacksmithQuest",
        npc: "BlacksmithQuest",
        weight: (RoomType, MapMod, data) => {
            return 100;
        },
        prerequisite: (RoomType, MapMod, data) => {
            if (RoomType == "Tunnel") {
                return true;
            }
            return false;
        }
    },
};
function KDQuestList(count, mods, RoomType, MapMod, data) {
    let ret = [];
    for (let i = 0; i < count; i++) {
        let genWeightTotal = 0;
        let genWeights = [];
        for (let mod of Object.values(mods)) {
            if (!ret.includes(mod) && mod.prerequisite(RoomType, MapMod, data)) {
                genWeights.push({ mod: mod, weight: genWeightTotal });
                genWeightTotal += mod.weight(RoomType, MapMod, data);
            }
        }
        let selection = KDRandom() * genWeightTotal;
        for (let L = genWeights.length - 1; L >= 0; L--) {
            if (selection > genWeights[L].weight) {
                ret.push(genWeights[L].mod);
                break;
            }
        }
    }
    return ret;
}
function KDQuestTick(quests) {
    if (quests) {
        for (let q of quests) {
            if (KDQuests[q] && KDQuests[q].worldgenstart) {
                KDQuests[q].worldgenstart();
            }
        }
    }
}
function KDRemoveQuest(quest) {
    if (!KDGameData.Quests)
        KDGameData.Quests = [];
    else
        KDGameData.Quests.splice(KDGameData.Quests.indexOf(quest), 1);
}
function KDAddQuest(quest) {
    var _a;
    if (!KDGameData.Quests)
        KDGameData.Quests = [];
    if (!KDGameData.Quests.includes(quest)) {
        if ((_a = KDQuests[quest]) === null || _a === void 0 ? void 0 : _a.accept) {
            KDQuests[quest].accept();
        }
        KDGameData.Quests.push(quest);
    }
}
function KDHasQuest(quest) {
    if (!KDGameData.Quests)
        return false;
    return KDGameData.Quests.includes(quest);
}
let KinkyDungeonLostItems = [];
let KDTightRestraintsMod = 6;
let KDTightRestraintsMult = 2;
function KinkyDungeonAddLostItems(list, excludeBound) {
    for (let item of list) {
        let unique = true;
        if (item.type && item.name == "Knife")
            unique = false;
        for (let item2 of KinkyDungeonLostItems) {
            if (item2.name == item.name) {
                unique = false;
                break;
            }
        }
        if (unique && (!excludeBound || item.type != Weapon || (KDWeapon(item).magic))) {
            KinkyDungeonLostItems.push(item);
            if (item.type == Consumable) {
                item.quantity = Math.min(item.quantity, 10);
            }
        }
        else if (!unique && item.type == Consumable && item.quantity) {
            for (let item2 of KinkyDungeonLostItems) {
                if (item2.name == item.name) {
                    item2.quantity = Math.min(item2.quantity + item.quantity, 10);
                    break;
                }
            }
        }
    }
}
let cursedRestraintCache = {};
let KinkyDungeonSpecialLoot = false;
let KinkyDungeonLockedLoot = false;
function KinkyDungeonLoot(Level, Index, Type, roll, tile, returnOnly, noTrap) {
    let lootWeightTotal = 0;
    let lootWeights = [];
    let lootType = KinkyDungeonLootTable[Type];
    for (let loot of lootType) {
        let effLevel = Level;
        if (loot.trap && KinkyDungeonStatsChoice.has("TightRestraints")) {
            effLevel *= KDTightRestraintsMult;
            effLevel += KDTightRestraintsMod;
        }
        if ((effLevel >= loot.minLevel || KinkyDungeonNewGame > 0) && (loot.allFloors || loot.floors[Index])) {
            let prereqs = true;
            if (loot.arousalMode && !KinkyDungeonStatsChoice.get("arousalMode"))
                prereqs = false;
            if (loot.prerequisites) {
                let maxlevel = 999;
                let minlevel = 0;
                let SpellList = null;
                if (prereqs && loot.prerequisites.includes("vibe") && KinkyDungeonPlayerTags.has("NoVibes"))
                    prereqs = false;
                if (prereqs && loot.prerequisites.includes("alreadyBelted") && KinkyDungeonChastityMult() < 0.9)
                    prereqs = false;
                if (prereqs && loot.prerequisites.includes("lowlevel"))
                    maxlevel = 2;
                if (prereqs && loot.prerequisites.includes("fewpick") && KinkyDungeonLockpicks > 3)
                    prereqs = false;
                if (prereqs && loot.prerequisites.includes("lowpotions") && (KinkyDungeonItemCount("PotionFrigid") + KinkyDungeonItemCount("PotionMana") + KinkyDungeonItemCount("PotionStamina") > 10))
                    prereqs = false;
                if (prereqs && loot.prerequisites.includes("lowmanapotions") && (KinkyDungeonItemCount("PotionMana") > 20))
                    prereqs = false;
                if (prereqs && loot.prerequisites.includes("lowwillpotions") && (KinkyDungeonItemCount("PotionWill") > 15))
                    prereqs = false;
                if (prereqs && loot.prerequisites.includes("UnlearnedElements"))
                    SpellList = KinkyDungeonSpellList.Elements;
                if (prereqs && loot.prerequisites.includes("UnlearnedConjure"))
                    SpellList = KinkyDungeonSpellList.Conjure;
                if (prereqs && loot.prerequisites.includes("UnlearnedIllusion"))
                    SpellList = KinkyDungeonSpellList.Illusion;
                if (prereqs && loot.prerequisites.includes("NoBoltCutters") && KinkyDungeonInventoryGet("BoltCutters"))
                    prereqs = false;
                else if (prereqs && loot.prerequisites.includes("LostItems") && KinkyDungeonLostItems.length < 1)
                    prereqs = false;
                else if (prereqs && loot.prerequisites.includes("LightRestraint") && KinkyDungeonAllRestraint().length < 1)
                    prereqs = false;
                else if (prereqs && loot.prerequisites.includes("ModerateRestraint") && KinkyDungeonAllRestraint().length < 4 && !(!KinkyDungeonIsHandsBound() && !KinkyDungeonCanTalk() && KinkyDungeonSlowLevel < 1))
                    prereqs = false;
                if (prereqs && loot.prerequisites.includes("pearlChest") && !KDPearlRequirement)
                    prereqs = false;
                if (prereqs)
                    for (let prereq of loot.prerequisites) {
                        if (prereq.startsWith("Group_")) {
                            let group = prereq.substring(6);
                            let item = KinkyDungeonGetRestraintItem(group);
                            let power = item && KDRestraint(item) && KDRestraint(item).power ? KinkyDungeonRestraintPower(item) : 0;
                            if (power && (power >= loot.power || KDRestraint(item).enchanted)) {
                                prereqs = false;
                                break;
                            }
                        }
                    }
                if (SpellList != null && KinkyDungeonGetUnlearnedSpells(minlevel, maxlevel, SpellList).length == 0) {
                    prereqs = false;
                }
            }
            if (KinkyDungeonGoddessRep.Ghost && loot.submissive && (KinkyDungeonGoddessRep.Ghost + 50 < loot.submissive))
                prereqs = false;
            if (loot.noweapon) {
                for (let w of loot.noweapon) {
                    if (KinkyDungeonInventoryGet(w)) {
                        prereqs = false;
                        break;
                    }
                }
            }
            if (loot.norestraint) {
                for (let r of loot.norestraint) {
                    if (KinkyDungeonInventoryGet(r)) {
                        prereqs = false;
                        break;
                    }
                }
            }
            if (loot.norestraintcursed) {
                let id = loot.norestraintcursed + `${loot.curselevelmin || 0},${loot.curselevelmax || 0}`;
                if (!cursedRestraintCache[id])
                    cursedRestraintCache[id] = [...KinkyDungeonGetCurses(loot.norestraintcursed, true, loot.curselevelmin, loot.curselevelmax)];
                for (let r of cursedRestraintCache[id]) {
                    if (KinkyDungeonInventoryGet(r)) {
                        prereqs = false;
                        break;
                    }
                }
            }
            if (prereqs) {
                let weightMult = 1.0;
                let weightBonus = 0;
                if (loot.goddess) {
                    let grep = KinkyDungeonGoddessRep[loot.goddess];
                    if (grep) {
                        weightBonus += loot.goddessWeight * grep / 50;
                    }
                }
                if (loot.playerTags)
                    for (let tag in loot.playerTags)
                        if (KinkyDungeonPlayerTags.get(tag))
                            weightBonus += loot.playerTags[tag];
                if (Type == "chest") {
                    if (tile && tile.Special && loot.special)
                        weightBonus += loot.special;
                    else if (tile && tile.Special)
                        weightMult = 0;
                    if (tile && tile.RedSpecial && loot.redspecial)
                        weightBonus += loot.redspecial;
                }
                let rep = (KinkyDungeonGoddessRep.Ghost + 50) / 100;
                if (loot.trap || loot.magic)
                    weightMult *= (1 + rep);
                if (loot.trap && KinkyDungeonCurrentMaxEnemies > 0) {
                    let nonSumEnemies = 0;
                    for (let e of KinkyDungeonEntities) {
                        if (!e.summoned)
                            nonSumEnemies++;
                    }
                    weightMult *= Math.max(0, 1 - 0.5 * nonSumEnemies / KinkyDungeonCurrentMaxEnemies);
                }
                if (loot.trap && noTrap)
                    weightMult = 0;
                lootWeights.push({ loot: loot, weight: lootWeightTotal });
                lootWeightTotal += Math.max(0, (loot.weight + weightBonus) * weightMult);
            }
        }
    }
    let selection = (roll ? roll : KDRandom()) * lootWeightTotal;
    for (let L = lootWeights.length - 1; L >= 0; L--) {
        if (selection > lootWeights[L].weight) {
            if (returnOnly)
                return lootWeights[L].loot;
            let replace = KinkyDungeonLootEvent(lootWeights[L].loot, Level, TextGet(lootWeights[L].loot.message), lootWeights[L].loot.lock);
            if (!KinkyDungeonSendActionMessage(8, replace, lootWeights[L].loot.messageColor, lootWeights[L].loot.messageTime || 2))
                KinkyDungeonSendTextMessage(8, replace, lootWeights[L].loot.messageColor, lootWeights[L].loot.messageTime || 2, true, true);
            break;
        }
    }
}
function KinkyDungeonGetUnlearnedSpells(minlevel, maxlevel, SpellList) {
    let SpellsUnlearned = [];
    for (let spell of SpellList) {
        if (spell.level >= minlevel && spell.level <= maxlevel && !spell.passive && KinkyDungeonCheckSpellPrerequisite(spell)) {
            SpellsUnlearned.push(spell);
        }
    }
    for (let spell of KinkyDungeonSpells) {
        for (let S = 0; S < SpellsUnlearned.length; S++) {
            if (spell.name == SpellsUnlearned[S].name) {
                SpellsUnlearned.splice(S, 1);
                S--;
            }
        }
    }
    return SpellsUnlearned;
}
function KinkyDungeonLootEvent(Loot, Floor, Replacemsg, Lock) {
    let value = 0;
    if (Loot.weapon) {
        KinkyDungeonInventoryAddWeapon(Loot.weapon);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("WeaponAcquired", TextGet("KinkyDungeonInventoryItem" + Loot.weapon));
    }
    else if (Loot.armor) {
        let armor = Loot.armor;
        let unlockcurse = null;
        if (Loot.curselevelmin != undefined || Loot.curselevelmax != undefined)
            armor = CommonRandomItemFromList("", KinkyDungeonGetCurses(Loot.armor, false, Loot.curselevelmin, Loot.curselevelmax));
        if (Loot.unlockcurse) {
            let curselist = [];
            for (let c of Loot.unlockcurse) {
                curselist.push(...KDCurseUnlockList[c]);
            }
            unlockcurse = CommonRandomItemFromList("", curselist);
        }
        KinkyDungeonInventoryAddLoose(armor, unlockcurse);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("ArmorAcquired", TextGet("Restraint" + Loot.armor));
    }
    else if (Loot.name == "spell_points") {
        let amount = 1;
        KinkyDungeonSpellPoints += amount;
        KinkyDungeonSendFloater({ x: 1100, y: 800 - KDRecentRepIndex * 40 }, `+${amount} Spell Points!!!`, "#8888ff", 5, true);
        KDRecentRepIndex += 1;
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("AMOUNT", "" + amount);
    }
    else if (Loot.name == "spell_illusion_low") {
        let SpellsUnlearned = KinkyDungeonGetUnlearnedSpells(0, 2, KinkyDungeonSpellList.Illusion);
        let spellIndex = Math.floor(KDRandom() * SpellsUnlearned.length);
        let spell = SpellsUnlearned[spellIndex];
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("SpellLearned", TextGet("KinkyDungeonSpell" + spell.name));
        KinkyDungeonSpells.push(spell);
    }
    else if (Loot.name == "spell_conjuration_low") {
        let SpellsUnlearned = KinkyDungeonGetUnlearnedSpells(0, 2, KinkyDungeonSpellList.Conjure);
        let spellIndex = Math.floor(KDRandom() * SpellsUnlearned.length);
        let spell = SpellsUnlearned[spellIndex];
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("SpellLearned", TextGet("KinkyDungeonSpell" + spell.name));
        KinkyDungeonSpells.push(spell);
    }
    else if (Loot.name == "spell_elemental_low") {
        let SpellsUnlearned = KinkyDungeonGetUnlearnedSpells(0, 2, KinkyDungeonSpellList.Elements);
        let spellIndex = Math.floor(KDRandom() * SpellsUnlearned.length);
        let spell = SpellsUnlearned[spellIndex];
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("SpellLearned", TextGet("KinkyDungeonSpell" + spell.name));
        KinkyDungeonSpells.push(spell);
    }
    else if (Loot.name == "pearlReward") {
        let rewardAvailable = [];
        for (let rep of Object.entries(KinkyDungeonGoddessRep)) {
            let rewards = KDBlessedRewards[rep[0]];
            if (rewards && rep[1] > 45) {
                for (let r of rewards) {
                    if (!KinkyDungeonInventoryGet(r)) {
                        rewardAvailable.push(r);
                    }
                }
            }
        }
        let reward = rewardAvailable[Math.floor(KDRandom() * rewardAvailable.length)];
        if (KinkyDungeonWeapons[reward]) {
            KinkyDungeonInventoryAddWeapon(reward);
            if (Replacemsg)
                Replacemsg = Replacemsg.replace("ITEMGET", TextGet("KinkyDungeonInventoryItem" + reward));
        }
        else if (KinkyDungeonFindSpell(reward, true)) {
            KinkyDungeonSpells.push(KinkyDungeonFindSpell(reward, true));
            if (Replacemsg)
                Replacemsg = Replacemsg.replace("ITEMGET", TextGet("KinkyDungeonSpell" + reward));
        }
        else if (KinkyDungeonConsumables[reward]) {
            KinkyDungeonChangeConsumable(KinkyDungeonConsumables[reward], 1);
            if (Replacemsg)
                Replacemsg = Replacemsg.replace("ITEMGET", TextGet("KinkyDungeonInventoryItem" + reward));
        }
        else {
            KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, 1);
            if (Replacemsg)
                Replacemsg = Replacemsg.replace("ITEMGET", TextGet("KinkyDungeonInventoryItemAncientPowerSource"));
        }
    }
    else if (Loot.name == "gold") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
    }
    else if (Loot.name == "biggold") {
        value = Math.ceil((250 + 100 * KDRandom()) * (1 + Floor / 40));
    }
    else if (Loot.name == "smallgold") {
        value = Math.ceil((25 + 15 * KDRandom()) * (1 + Floor / 35));
    }
    else if (Loot.name == "knife") {
        KinkyDungeonInventoryAddWeapon("Knife");
    }
    else if (Loot.name == "magicknife") {
        KinkyDungeonInventoryAddWeapon("EnchKnife");
    }
    else if (Loot.name == "pick") {
        KinkyDungeonLockpicks += 1;
    }
    else if (Loot.name == "redkey") {
        KinkyDungeonRedKeys += 1;
    }
    else if (Loot.name == "bluekey") {
        KinkyDungeonBlueKeys += 1;
    }
    else if (Loot.name == "grinder") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.EnchantedGrinder, 1);
    }
    else if (Loot.name == "bola") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.Bola, 2);
    }
    else if (Loot.name == "bomb") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.Bomb, 1);
    }
    else if (Loot.name == "MistressKey") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.MistressKey, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, 2);
    }
    else if (Loot.name == "Scrolls") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, 2);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollArms, 2 + Math.floor(KDRandom() * 3));
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollLegs, 2 + Math.floor(KDRandom() * 3));
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollVerbal, 2 + Math.floor(KDRandom() * 3));
    }
    else if (Loot.name == "scroll_legs") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollLegs, 1);
    }
    else if (Loot.name == "scroll_arms") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollArms, 1);
    }
    else if (Loot.name == "scroll_verbal") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollVerbal, 1);
    }
    else if (Loot.name == "scrolls_basic") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollArms, 1 + Math.floor(KDRandom() * 3));
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollLegs, 1 + Math.floor(KDRandom() * 3));
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollVerbal, 1 + Math.floor(KDRandom() * 3));
    }
    else if (Loot.name == "scrolls_purity") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollPurity, 1);
    }
    else if (Loot.name == "AncientCores") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, Loot.count ? Loot.count : 2);
    }
    else if (Loot.name == "EnchantedBelt" || Loot.name == "EnchantedBra" || Loot.name == "EnchantedHeels" || Loot.name == "EnchantedAnkleCuffs" || Loot.name == "EnchantedMuzzle" || Loot.name == "EnchantedBlindfold" || Loot.name == "EnchantedMittens" || Loot.name == "EnchantedBallGag" || Loot.name == "EnchantedArmbinder") {
        let restraint = KinkyDungeonGetRestraintByName(Loot.name);
        KinkyDungeonInventoryAdd({ name: Loot.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: Object.assign([], restraint.events) });
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, 1);
    }
    else if (Loot.name == "PotionCollar") {
        let restraint = KinkyDungeonGetRestraintByName("PotionCollar");
        KinkyDungeonInventoryAdd({ name: Loot.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: Object.assign([], restraint.events) });
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, 1);
    }
    else if (Loot.name == "weapon_boltcutters") {
        KinkyDungeonInventoryAddWeapon("BoltCutters");
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("WeaponAcquired", TextGet("KinkyDungeonInventoryItemBoltCutters"));
    }
    else if (Loot.name == "weapon_spear") {
        KinkyDungeonInventoryAddWeapon("Spear");
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("WeaponAcquired", TextGet("KinkyDungeonInventoryItemSpear"));
    }
    else if (Loot.name == "weapon_flail") {
        KinkyDungeonInventoryAddWeapon("Flail");
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("WeaponAcquired", TextGet("KinkyDungeonInventoryItemFlail"));
    }
    else if (Loot.name == "staff_flame") {
        KinkyDungeonInventoryAddWeapon("StaffFlame");
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("WeaponAcquired", TextGet("KinkyDungeonInventoryItemStaffFlame"));
    }
    else if (Loot.name == "staff_bind") {
        KinkyDungeonInventoryAddWeapon("StaffBind");
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("WeaponAcquired", TextGet("KinkyDungeonInventoryItemStaffBind"));
    }
    else if (Loot.name == "potions_mana") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 3 + Math.floor(KDRandom() * 2));
    }
    else if (Loot.name == "manaorb") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ManaOrb, 1);
    }
    else if (Loot.name == "manaorbmany") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ManaOrb, 3);
    }
    else if (Loot.name == "potions_will") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionWill, 2 + Math.floor(KDRandom() * 2));
    }
    else if (Loot.name == "potions_many") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 2 + Math.floor(KDRandom() * 2));
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionStamina, 1 + Math.floor(KDRandom() * 3));
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionFrigid, Math.floor(KDRandom() * 3));
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionWill, Math.floor(KDRandom() * 3));
    }
    else if (Loot.name == "potion_mana") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 1);
    }
    else if (Loot.name == "potion_stamina") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionStamina, 1);
    }
    else if (Loot.name == "potion_will") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionWill, 1);
    }
    else if (Loot.name == "potion_frigid") {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionFrigid, 1);
    }
    else if (Loot.name == "trap_armbinder") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapArmbinder"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "", undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapArmbinder"));
    }
    else if (Loot.name == "trap_armbinderHeavy") {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapArmbinder"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        let harness = KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapArmbinderHarness"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, KinkyDungeonGenerateLock(true));
        if (Replacemsg)
            if (!harness)
                Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapArmbinder"));
            else
                Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapArmbinderHarness"));
    }
    else if (Loot.name == "trap_cuffs") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapCuffs"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapCuffs"));
    }
    else if (Loot.name == "trap_harness") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapHarness"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapHarness"));
    }
    else if (Loot.name == "trap_gag") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapGag"));
    }
    else if (Loot.name == "trap_gagHeavy") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("PanelGag"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintPanelGag"));
    }
    else if (Loot.name == "trap_mithrilankle") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MithrilAnkleCuffs"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintMithrilAnkleCuffs"));
    }
    else if (Loot.name == "trap_mitts") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapMittens"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapMittens"));
    }
    else if (Loot.name == "trap_blindfold") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBlindfold"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapBlindfold"));
    }
    else if (Loot.name == "trap_boots") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBoots"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapBoots"));
    }
    else if (Loot.name == "trap_legirons") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapLegirons"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapLegirons"));
    }
    else if (Loot.name == "trap_belt") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapVibe"));
    }
    else if (Loot.name == "trap_protobelt") {
        value = Math.ceil((200 + 100 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibeProto"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBeltProto"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapVibe"));
    }
    else if (Loot.name == "trap_beltonly") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapBelt"));
    }
    else if (Loot.name == "trap_plug") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapPlug"));
    }
    else if (Loot.name == "trap_plug_tease") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug2"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapPlug2"));
    }
    else if (Loot.name == "trap_plug_torment") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug3"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapPlug3"));
    }
    else if (Loot.name == "trap_plug_thunder") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug4"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapPlug4"));
    }
    else if (Loot.name == "trap_nipple") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("NippleClamps"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBra"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, Lock ? Lock : KinkyDungeonGenerateLock(true, undefined, true), undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintNippleClamps"));
    }
    else if (Loot.name == "trap_plug2") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt2"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, (MiniGameKinkyDungeonLevel > 5 || KinkyDungeonNewGame > 0) ? "Gold" : "Red", undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapPlug"));
    }
    else if (Loot.name == "trap_plug2_torment") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug3"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt2"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, (MiniGameKinkyDungeonLevel > 5 || KinkyDungeonNewGame > 0) ? "Gold" : "Red", undefined, Loot.trap);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapPlug3"));
    }
    else if (Loot.name == "trap_nipple2") {
        value = Math.ceil((150 + 50 * KDRandom()) * (1 + Floor / 40));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("NippleClamps"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, "");
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBra2"), MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint, true, (MiniGameKinkyDungeonLevel > 5 || KinkyDungeonNewGame > 0) ? "Gold" : "Red", undefined, false);
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("RestraintType", TextGet("RestraintTrapBra2"));
    }
    else if (Loot.name == "trap_book") {
        let spell = null;
        if (KDRandom() < 0.33) {
            spell = KinkyDungeonFindSpell("TrapRopeStrong", true);
        }
        else if (KDRandom() < 0.5) {
            spell = KinkyDungeonFindSpell("TrapMagicChainsWeak", true);
        }
        else {
            spell = KinkyDungeonFindSpell("TrapRibbons", true);
        }
        if (spell) {
            KinkyDungeonCastSpell(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, spell, undefined, undefined, undefined);
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/MagicSlash.ogg");
        }
    }
    else if (Loot.name == "lost_items") {
        if (!KinkyDungeonInventoryGet("Default")) {
            KinkyDungeonInventoryAdd({ name: "Default", id: KinkyDungeonGetItemID(), type: Outfit });
        }
        for (let I = 0; I < KinkyDungeonLostItems.length; I++) {
            let lostitem = KinkyDungeonLostItems[I];
            if (lostitem) {
                let remove = false;
                let existingitem = KinkyDungeonGetInventoryItem(lostitem.name, lostitem.type);
                if (existingitem && existingitem.item) {
                    if (KDConsumable(existingitem.item)) {
                        if (lostitem.name != "MistressKey") {
                            if (!existingitem.item.quantity)
                                existingitem.item.quantity = lostitem.quantity;
                            else
                                existingitem.item.quantity += lostitem.quantity;
                            KinkyDungeonSendFloater({ x: KinkyDungeonPlayerEntity.x - 1 + 2 * KDRandom(), y: KinkyDungeonPlayerEntity.y - 1 + 2 * KDRandom() }, `+${lostitem.quantity} ${TextGet("KinkyDungeonInventoryItem" + lostitem.name)}`, "white", 5);
                        }
                        else
                            KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonMistressKeysTakenAway"), "orange", 2);
                    }
                }
                else {
                    if (lostitem.type == Consumable && KinkyDungeonFindConsumable(lostitem.name)) {
                        if (lostitem.name != "MistressKey")
                            KinkyDungeonSendFloater({ x: KinkyDungeonPlayerEntity.x - 1 + 2 * KDRandom(), y: KinkyDungeonPlayerEntity.y - 1 + 2 * KDRandom() }, `+${lostitem.quantity} ${TextGet("KinkyDungeonInventoryItem" + lostitem.name)}`, "white", 4);
                        else
                            KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonMistressKeysTakenAway"), "orange", 2);
                        remove = true;
                    }
                    if (lostitem.type == Weapon && KinkyDungeonFindWeapon(lostitem.name)) {
                        KinkyDungeonSendFloater({ x: KinkyDungeonPlayerEntity.x - 1 + 2 * KDRandom(), y: KinkyDungeonPlayerEntity.y - 1 + 2 * KDRandom() }, `+${TextGet("KinkyDungeonInventoryItem" + lostitem.name)}`, "white", 6);
                        remove = true;
                    }
                    else if (lostitem.type == Outfit && KinkyDungeonGetOutfit(lostitem.name)) {
                        KinkyDungeonSendFloater({ x: KinkyDungeonPlayerEntity.x - 1 + 2 * KDRandom(), y: KinkyDungeonPlayerEntity.y - 1 + 2 * KDRandom() }, `+${TextGet("KinkyDungeonInventoryItem" + lostitem.name)}`, "white", 7);
                        remove = true;
                    }
                    else if (lostitem.type == LooseRestraint && KinkyDungeonGetRestraintByName(lostitem.name)) {
                        KinkyDungeonSendFloater({ x: KinkyDungeonPlayerEntity.x - 1 + 2 * KDRandom(), y: KinkyDungeonPlayerEntity.y - 1 + 2 * KDRandom() }, `+ (loose) ${TextGet("Restraint" + lostitem.name)}`, "white", 5);
                        remove = true;
                    }
                }
                if (remove) {
                    if (lostitem.name != "MistressKey") {
                        KinkyDungeonInventoryAdd(lostitem);
                    }
                }
            }
        }
        KinkyDungeonLostItems = [];
    }
    if (KDLootEvents[Loot.name]) {
        let ret = KDLootEvents[Loot.name](Loot, Floor, Replacemsg, Lock);
        if (ret.value)
            value = ret.value;
        if (ret.Replacemsg)
            Replacemsg = ret.Replacemsg;
    }
    if (Loot.trap) {
        if (!Loot.noSmoke) {
            KDSmokePuff(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 2.9, 0.4);
        }
        KDSendStatus('bound', Loot.name, "chest");
    }
    if (value > 0) {
        if (Replacemsg)
            Replacemsg = Replacemsg.replace("XXX", "" + value);
        KinkyDungeonAddGold(value);
    }
    return Replacemsg;
}
function KinkyDungeonAddGold(value) {
    if (!isNaN(value)) {
        KinkyDungeonGold += value;
        if (ArcadeDeviousChallenge && KinkyDungeonDeviousDungeonAvailable())
            CharacterChangeMoney(Player, Math.round(value / 10));
        let pre = value >= 0 ? "+" : "";
        KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, pre + `${value} GP`, "white", 3.5);
    }
    else
        KinkyDungeonSendActionMessage(10, "Error, the thing you just did would have set your gold to infinity. Please report.", "white", 4);
}
function KDSpawnLootTrap(x, y, trap, mult, duration) {
    let spawned = 0;
    for (let tile of KDNearbyTiles(x, y, 2.5)) {
        if (tile.tile.lootTrapEnemy) {
            let etiles = Object.values(KDGetEffectTiles(tile.x, tile.y)).filter((etile) => {
                return etile.tags && etile.tags.includes("runesummon");
            });
            if ((etiles === null || etiles === void 0 ? void 0 : etiles.length) > 0) {
                let Enemy = KinkyDungeonGetEnemyByName(tile.tile.lootTrapEnemy);
                if (Enemy) {
                    if (KinkyDungeonSummonEnemy(tile.x, tile.y, Enemy.name, 1, 0.5, true, (duration || Enemy.tags.construct) ? (duration || 40) : undefined, undefined, false, "Ambush", true, undefined, true, undefined, duration > 300, false))
                        spawned += 1;
                    for (let et of etiles) {
                        et.duration = 0;
                    }
                    delete tile.tile.lootTrapEnemy;
                }
            }
        }
    }
    if (spawned > 0) {
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/MagicSlash.ogg");
        KinkyDungeonMakeNoise(12, x, y);
        KinkyDungeonSendTextMessage(10, TextGet("LootChestTrap"), "#ff8800", 2);
    }
}
function KDGenChestTrap(guaranteed, x, y, chestType, lock, noTrap) {
    let trap = undefined;
    if (chestType && chestType != "cache" && chestType != "chest" && chestType != "silver" && !KDTrapChestType[chestType])
        return undefined;
    if (lock && KDRandom() < 0.8)
        return undefined;
    if (guaranteed || KDRandom() < (noTrap ? 0.4 : 1.0)) {
        if (KDTrapChestType[chestType])
            return KDTrapChestType[chestType](guaranteed, x, y, chestType, lock, noTrap);
        else
            return KDTrapChestType.default(guaranteed, x, y, chestType, lock, noTrap);
    }
    return trap;
}
let KDTrapChestType = {
    "default": (guaranteed, x, y, chestType, lock, noTrap) => {
        if (KDRandom() < 0.33)
            return { trap: "metalTrap", mult: 1 };
        else if (KDRandom() < 0.34)
            return { trap: "leatherTrap", mult: 1.2 };
        else
            return { trap: "ropeTrap", mult: 1.4 };
    },
    "shadow": (guaranteed, x, y, chestType, lock, noTrap) => {
        return { trap: "shadowTrap", mult: 2.5, duration: 300 };
    },
};
function KDTriggerLoot(Loot, Type) {
    let lootobj = KinkyDungeonLootTable[Type].find((element) => { return element.name == Loot; });
    console.log(KinkyDungeonLootEvent(lootobj, KinkyDungeonMapIndex, lootobj.message));
}
let KDEnemiesCache = new Map();
let KinkyDungeonSummonCount = 2;
let KinkyDungeonEnemyAlertRadius = 2;
let KDStealthyMult = 0.75;
let KDConspicuousMult = 1.5;
let commentChance = 0.03;
let actionDialogueChance = 0.1;
let actionDialogueChanceIntense = 0.4;
function KinkyDungeonRefreshEnemiesCache() {
    KDEnemiesCache = new Map();
    for (let enemy of KinkyDungeonEnemies) {
        KDEnemiesCache.set(enemy.name, enemy);
    }
}
function KinkyDungeonGetEnemyByName(Name) {
    if (KDEnemiesCache.size > 0) {
        return KDEnemiesCache.get(Name);
    }
    else {
        KinkyDungeonRefreshEnemiesCache();
        return KDEnemiesCache.get(Name);
    }
}
function KinkyDungeonNearestJailPoint(x, y, filter, any, qualified) {
    let filt = filter ? filter : ["jail", "dropoff"];
    let dist = 100000;
    let point = null;
    let leash = KinkyDungeonGetRestraintItem("ItemNeckRestraints");
    let furniture = KinkyDungeonGetRestraintItem("ItemDevices");
    for (let p of KDGameData.JailPoints) {
        if (!any && p.type && !filt.includes(p.type))
            continue;
        if (qualified && p.requireLeash && !leash)
            continue;
        if (qualified && p.requireFurniture && !furniture)
            continue;
        let d = Math.max(Math.abs(x - p.x), Math.abs(y - p.y));
        if (d < dist) {
            dist = d;
            point = p;
        }
    }
    return point;
}
function KDLockNearbyJailDoors(x, y) {
    var _a;
    let jail = KinkyDungeonNearestJailPoint(x, y);
    if (jail) {
        let radius = jail.radius + 1;
        if (radius)
            for (let X = x - Math.ceil(radius); X <= x + Math.ceil(radius); X++)
                for (let Y = y - Math.ceil(radius); Y <= y + Math.ceil(radius); Y++)
                    if (((_a = KinkyDungeonTilesGet(X + ',' + Y)) === null || _a === void 0 ? void 0 : _a.Jail) && KinkyDungeonMapGet(X, Y) == 'd') {
                        KinkyDungeonMapSet(X, Y, 'D');
                        KinkyDungeonTilesGet(X + ',' + Y).Lock = "Red";
                    }
    }
}
function KinkyDungeonRandomJailPoint(filter, exclude) {
    let filt = filter ? filter : ["jail"];
    let points = [];
    for (let p of KDGameData.JailPoints) {
        if (p.type && !filt.includes(p.type))
            continue;
        if (!exclude || exclude.includes(p))
            continue;
        points.push(p);
    }
    if (points.length > 0)
        return points[Math.floor(KDRandom() * points.length)];
    return null;
}
function KinkyDungeonNearestPatrolPoint(x, y) {
    let dist = 100000;
    let point = -1;
    for (let p of KinkyDungeonPatrolPoints) {
        let d = Math.max(Math.abs(x - p.x), Math.abs(y - p.y));
        if (d < dist) {
            dist = d;
            point = KinkyDungeonPatrolPoints.indexOf(p);
        }
    }
    return point;
}
let KinkyDungeonFlags = new Map();
function KinkyDungeonSetFlag(Flag, Duration, Floors) {
    if (!KinkyDungeonFlags.get(Flag) || Duration <= 0 || (KinkyDungeonFlags.get(Flag) > 0 && KinkyDungeonFlags.get(Flag) < Duration)) {
        KinkyDungeonFlags.set(Flag, Duration);
        if (Duration == 0) {
            KinkyDungeonFlags.delete(Flag);
        }
        else if (Floors != undefined) {
            if (!KDGameData.TempFlagFloorTicks)
                KDGameData.TempFlagFloorTicks = {};
            if (!KDGameData.TempFlagFloorTicks[Flag] || KDGameData.TempFlagFloorTicks[Flag] < Floors) {
                KDGameData.TempFlagFloorTicks[Flag] = Floors;
            }
            if (Floors === 0) {
                delete KDGameData.TempFlagFloorTicks[Flag];
            }
        }
    }
}
function KinkyDungeonUpdateFlags(delta) {
    for (let f of KinkyDungeonFlags.keys()) {
        if (KinkyDungeonFlags.get(f) != -1) {
            if (KinkyDungeonFlags.get(f) > 0)
                KinkyDungeonFlags.set(f, KinkyDungeonFlags.get(f) - delta);
            if (KinkyDungeonFlags.get(f) <= 0 && KinkyDungeonFlags.get(f) != -1)
                KinkyDungeonFlags.delete(f);
        }
    }
}
function KinkyDungeonGetPatrolPoint(index, radius, Tiles) {
    let p = KinkyDungeonPatrolPoints[index];
    let t = Tiles ? Tiles : KinkyDungeonMovableTilesEnemy;
    if (p) {
        for (let i = 0; i < 8; i++) {
            let XX = p.x + Math.round(KDRandom() * 2 * radius - radius);
            let YY = p.y + Math.round(KDRandom() * 2 * radius - radius);
            if (t.includes(KinkyDungeonMapGet(XX, YY))) {
                return { x: XX, y: YY };
            }
        }
    }
    return p;
}
function KDHelpless(enemy) {
    return enemy && !enemy.player && (enemy.hp <= enemy.Enemy.maxhp * 0.1 || enemy.hp <= 0.52 || enemy.boundLevel > 10 * enemy.Enemy.maxhp) && KDBoundEffects(enemy) > 3;
}
function KinkyDungeonNearestPlayer(enemy, requireVision, decoy, visionRadius, AI_Data) {
    if (enemy && enemy.Enemy && !visionRadius) {
        visionRadius = enemy.Enemy.visionRadius;
        if (enemy.blind && !enemy.aware)
            visionRadius = 1.5;
    }
    if (decoy) {
        let pdist = Math.sqrt((KinkyDungeonPlayerEntity.x - enemy.x) * (KinkyDungeonPlayerEntity.x - enemy.x)
            + (KinkyDungeonPlayerEntity.y - enemy.y) * (KinkyDungeonPlayerEntity.y - enemy.y));
        let nearestVisible = undefined;
        if (enemy.Enemy.focusPlayer && KinkyDungeonCheckLOS(enemy, KinkyDungeonPlayerEntity, pdist, visionRadius, false, false) && !KinkyDungeonCheckPath(enemy.x, enemy.y, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, false, true))
            return KinkyDungeonPlayerEntity;
        let nearestDistance = (AI_Data && AI_Data.hostile) ? pdist - 0.1 : 100000;
        if ((enemy.Enemy.visionRadius || enemy.Enemy.blindSight) && !(enemy.Enemy.noAttack && !enemy.Enemy.spells))
            for (let e of KinkyDungeonEntities) {
                if (e == enemy)
                    continue;
                if (KDHelpless(e))
                    continue;
                if (KDGetFaction(e) == "Natural")
                    continue;
                if (enemy.Enemy.noTargetSilenced && e.silence > 0)
                    continue;
                if ((e.Enemy && !e.Enemy.noAttack && KDHostile(enemy, e))) {
                    let dist = Math.sqrt((e.x - enemy.x) * (e.x - enemy.x)
                        + (e.y - enemy.y) * (e.y - enemy.y));
                    let pdist_enemy = (KDGetFaction(enemy) == "Player"
                        && !KDEnemyHasFlag(enemy, "NoFollow")
                        && !KDEnemyHasFlag(enemy, "StayHere")
                        && (enemy.Enemy.allied || (!KDGameData.PrisonerState || KDGameData.PrisonerState == "chase")))
                        ? KDistChebyshev(e.x - KinkyDungeonPlayerEntity.x, e.y - KinkyDungeonPlayerEntity.y) :
                        -1;
                    if (pdist_enemy > 0 && pdist_enemy < 1.5 && AI_Data.hostile)
                        KinkyDungeonSetFlag("AIHelpPlayer", 4);
                    if (pdist_enemy > 0 && KinkyDungeonFlags.get("AIHelpPlayer") && dist > 2.5) {
                        if (pdist_enemy > 2.5)
                            dist += 2;
                        else
                            dist = Math.max(1.01 + dist / 4, dist / 3);
                    }
                    if (dist <= nearestDistance && (pdist_enemy <= 0 ||
                        ((KinkyDungeonVisionGet(e.x, e.y) > 0 || pdist_enemy < 5) && (pdist_enemy < 8 || enemy.Enemy.followRange > 1)))) {
                        if (KinkyDungeonCheckLOS(enemy, e, dist, visionRadius, true, true)
                            && (KinkyDungeonVisionGet(e.x, e.y) > 0 || KinkyDungeonVisionGet(enemy.x, enemy.y) > 0 || e.aware || enemy.aware)) {
                            if (enemy.rage || !e.Enemy.lowpriority
                                || (!KinkyDungeonCheckLOS(enemy, KinkyDungeonPlayerEntity, pdist, visionRadius, true, true) || !KinkyDungeonCheckPath(enemy.x, enemy.y, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, false, true))) {
                                nearestVisible = e;
                                nearestDistance = dist;
                            }
                        }
                    }
                }
            }
        if (nearestVisible)
            return nearestVisible;
    }
    return KinkyDungeonPlayerEntity;
}
function KinkyDungeonInDanger() {
    for (let b of KinkyDungeonBullets) {
        let bdist = 1.5;
        if (b.vx && b.vy)
            bdist = 2 * Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        if (KinkyDungeonVisionGet(Math.round(b.x), Math.round(b.y)) > 0 && Math.max(Math.abs(b.x - KinkyDungeonPlayerEntity.x), Math.abs(b.y - KinkyDungeonPlayerEntity.y)) < bdist) {
            return true;
        }
    }
    for (let enemy of KinkyDungeonEntities) {
        let playerDist = Math.max(Math.abs(enemy.x - KinkyDungeonPlayerEntity.x), Math.abs(enemy.y - KinkyDungeonPlayerEntity.y));
        if (KinkyDungeonVisionGet(enemy.x, enemy.y) > 0) {
            if (((enemy.revealed && !enemy.Enemy.noReveal) || !enemy.Enemy.stealth || KinkyDungeonSeeAll || playerDist <= enemy.Enemy.stealth + 0.1) && !(KinkyDungeonGetBuffedStat(enemy.buffs, "Sneak") > 0 && playerDist > 1.5)) {
                if (((!KDHelpless(enemy) && KinkyDungeonAggressive(enemy)) || playerDist < 1.5)) {
                    if ((KDHostile(enemy) || enemy.rage) && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0 &&
                        (!KDAmbushAI(enemy) || enemy.ambushtrigger)) {
                        return true;
                    }
                    if ((KDHostile(enemy) || enemy.rage) && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0 &&
                        (!KDAmbushAI(enemy) || enemy.ambushtrigger)) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
function KDAmbushAI(enemy) {
    let AI = enemy.AI ? enemy.AI : enemy.Enemy.AI;
    let AIType = KDAIType[AI];
    if (AIType)
        return AIType.ambush;
    return false;
}
let KinkyDungeonFastMoveSuppress = false;
let KinkyDungeonFastStruggleSuppress = false;
function KinkyDungeonDrawEnemies(canvasOffsetX, canvasOffsetY, CamX, CamY) {
    let reenabled = false;
    let reenabled2 = false;
    if (KinkyDungeonFastMoveSuppress) {
        KinkyDungeonFastMove = true;
        KinkyDungeonFastMovePath = [];
        KinkyDungeonFastMoveSuppress = false;
        reenabled = true;
    }
    if (KinkyDungeonFastStruggleSuppress) {
        KinkyDungeonFastStruggle = true;
        KinkyDungeonFastStruggleType = "";
        KinkyDungeonFastStruggleGroup = "";
        KinkyDungeonFastStruggleSuppress = false;
        reenabled2 = true;
    }
    for (let b of KinkyDungeonBullets) {
        let bdist = 1.5;
        if (b.vx && b.vy)
            bdist = 2 * Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        if (KinkyDungeonVisionGet(Math.round(b.x), Math.round(b.y)) > 0 && Math.max(Math.abs(b.x - KinkyDungeonPlayerEntity.x), Math.abs(b.y - KinkyDungeonPlayerEntity.y)) < bdist) {
            if (KinkyDungeonFastStruggle) {
                if (KinkyDungeonFastStruggle && !KinkyDungeonFastStruggleSuppress && !reenabled2)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Click.ogg");
                KinkyDungeonFastStruggle = false;
                KinkyDungeonFastStruggleGroup = "";
                KinkyDungeonFastStruggleType = "";
                reenabled2 = false;
                KinkyDungeonFastStruggleSuppress = true;
            }
            if (KinkyDungeonFastMove) {
                if (KinkyDungeonFastMove && !KinkyDungeonFastMoveSuppress && !reenabled)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Click.ogg");
                KinkyDungeonFastMove = false;
                KinkyDungeonFastMovePath = [];
                reenabled = false;
                KinkyDungeonFastMoveSuppress = true;
            }
        }
    }
    for (let enemy of KinkyDungeonEntities) {
        let sprite = enemy.Enemy.name;
        KinkyDungeonUpdateVisualPosition(enemy, KinkyDungeonDrawDelta);
        let tx = enemy.visual_x;
        let ty = enemy.visual_y;
        let playerDist = KDistChebyshev((enemy.x - KinkyDungeonPlayerEntity.x), (enemy.y - KinkyDungeonPlayerEntity.y));
        if (enemy.x >= CamX && enemy.y >= CamY && enemy.x < CamX + KinkyDungeonGridWidthDisplay && enemy.y < CamY + KinkyDungeonGridHeightDisplay
            && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0 && KDCanSeeEnemy(enemy, playerDist)) {
            if (((enemy.revealed && !enemy.Enemy.noReveal) || !enemy.Enemy.stealth || KDHelpless(enemy) || KinkyDungeonSeeAll || playerDist <= enemy.Enemy.stealth + 0.1) && !(KinkyDungeonGetBuffedStat(enemy.buffs, "Sneak", true) > 0 && playerDist > 1.5)) {
                enemy.revealed = true;
                if (((KinkyDungeonAggressive(enemy) && playerDist <= 6.9) || (playerDist < 1.5 && enemy.playWithPlayer))) {
                    if ((KDHostile(enemy) || enemy.rage) && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0 && KinkyDungeonFastMove &&
                        !enemy.Enemy.tags.harmless &&
                        (!KDAmbushAI(enemy) || enemy.ambushtrigger)) {
                        if (KinkyDungeonFastMove && !KinkyDungeonFastMoveSuppress && !reenabled)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Click.ogg");
                        KinkyDungeonFastMove = false;
                        KinkyDungeonFastMovePath = [];
                        reenabled = false;
                        if (!CommonIsMobile)
                            KinkyDungeonFastMoveSuppress = true;
                    }
                    if ((KDHostile(enemy) || enemy.rage) && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0 && KinkyDungeonFastStruggle &&
                        !enemy.Enemy.tags.harmless &&
                        (!KDAmbushAI(enemy) || enemy.ambushtrigger)) {
                        if (KinkyDungeonFastStruggle && !KinkyDungeonFastStruggleSuppress && !reenabled2)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Click.ogg");
                        KinkyDungeonFastStruggle = false;
                        KinkyDungeonFastStruggleGroup = "";
                        KinkyDungeonFastStruggleType = "";
                        reenabled2 = false;
                        if (!CommonIsMobile)
                            KinkyDungeonFastStruggleSuppress = true;
                    }
                }
                if (enemy.buffs) {
                    let aura_scale = 0;
                    let aura_scale_max = 0;
                    for (let b of Object.values(enemy.buffs)) {
                        if (b && b.aura && b.duration > 0) {
                            aura_scale_max += 1;
                        }
                    }
                    if (aura_scale_max > 0) {
                        let buffs = Object.values(enemy.buffs);
                        buffs = buffs.sort((a, b) => { return b.duration - a.duration; });
                        for (let b of buffs) {
                            if (b && b.aura && b.duration > 0 && (!b.hideHelpless || !KDHelpless(enemy))) {
                                aura_scale += 1 / aura_scale_max;
                                let s = aura_scale;
                                if (b.noAuraColor) {
                                    KDDraw(kdgameboard, kdpixisprites, enemy.id + "," + b.id, KinkyDungeonRootDirectory + "Aura/" + (b.aurasprite ? b.aurasprite : "Aura") + ".png", (tx - CamX) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s + KinkyDungeonGridSizeDisplay * (1 + s) * 0.167, (ty - CamY) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s + KinkyDungeonGridSizeDisplay * (1 + s) * 0.167, KinkyDungeonSpriteSize * (1 + s) * 0.67, KinkyDungeonSpriteSize * (1 + s) * 0.67, undefined, {
                                        zIndex: 2,
                                    });
                                }
                                else {
                                    KDDraw(kdgameboard, kdpixisprites, enemy.id + "," + b.id, KinkyDungeonRootDirectory + "Aura/" + (b.aurasprite ? b.aurasprite : "Aura") + ".png", (tx - CamX) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s + KinkyDungeonGridSizeDisplay * (1 + s) * 0.167, (ty - CamY) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s + KinkyDungeonGridSizeDisplay * (1 + s) * 0.167, KinkyDungeonSpriteSize * (1 + s) * 0.67, KinkyDungeonSpriteSize * (1 + s) * 0.67, undefined, {
                                        tint: string2hex(b.aura),
                                        zIndex: 2,
                                    });
                                }
                            }
                        }
                    }
                }
                let buffSprite = "";
                let buffSpritePower = 0;
                if (enemy.buffs) {
                    for (let b of Object.values(enemy.buffs)) {
                        if (b.replaceSprite && b.power > buffSpritePower) {
                            buffSpritePower = b.power;
                            buffSprite = b.replaceSprite;
                        }
                    }
                }
                if (buffSprite)
                    sprite = buffSprite;
                if (!enemy.Enemy.bound || (KDBoundEffects(enemy) < 4 && !KDHelpless(enemy))) {
                    let sp = sprite;
                    if (enemy.CustomSprite && !buffSprite)
                        sp = "CustomSprite/" + enemy.CustomSprite;
                    KDDraw(kdgameboard, kdpixisprites, "spr_" + enemy.id, KinkyDungeonRootDirectory + "Enemies/" + sp + ".png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                else {
                    let sp = buffSprite || enemy.Enemy.bound;
                    let dir = "EnemiesBound/";
                    if (enemy.CustomSprite && !buffSprite) {
                        dir = "Enemies/";
                        sp = "CustomSpriteBound/" + enemy.CustomSprite;
                    }
                    KDDraw(kdgameboard, kdpixisprites, "spr_" + enemy.id, KinkyDungeonRootDirectory + dir + sp + ".png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
            }
        }
    }
    if (reenabled && KinkyDungeonFastMove) {
        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Click.ogg");
    }
    else if (reenabled2 && KinkyDungeonFastStruggle) {
        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Click.ogg");
    }
}
function KDEnemyHasFlag(enemy, flag) {
    return (enemy.flags && (enemy.flags[flag] > 0 || enemy.flags[flag] == -1));
}
function KinkyDungeonDrawEnemiesStatus(canvasOffsetX, canvasOffsetY, CamX, CamY) {
    for (let enemy of KinkyDungeonEntities) {
        let tx = enemy.visual_x;
        let ty = enemy.visual_y;
        let helpless = KDHelpless(enemy);
        let playerDist = Math.max(Math.abs(enemy.x - KinkyDungeonPlayerEntity.x), Math.abs(enemy.y - KinkyDungeonPlayerEntity.y));
        if (enemy.x >= CamX && enemy.y >= CamY && enemy.x < CamX + KinkyDungeonGridWidthDisplay && enemy.y < CamY + KinkyDungeonGridHeightDisplay
            && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0 && KDCanSeeEnemy(enemy, playerDist)) {
            let bindLevel = KDBoundEffects(enemy);
            if (((enemy.revealed && !enemy.Enemy.noReveal) || !enemy.Enemy.stealth || KDHelpless(enemy) || KinkyDungeonSeeAll || playerDist <= enemy.Enemy.stealth + 0.1) && !(KinkyDungeonGetBuffedStat(enemy.buffs, "Sneak", true) > 0)) {
                if (enemy.stun > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "stun" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Stun.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                        zIndex: 2.1,
                    });
                }
                if (KDToggles.ShowNPCStatuses || MouseIn((tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay)) {
                    if (enemy.silence > 1 && !helpless) {
                        KDDraw(kdgameboard, kdpixisprites, "sil" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Silence.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (enemy.blind > 1 && !helpless) {
                        KDDraw(kdgameboard, kdpixisprites, "bli" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Blind.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (enemy.disarm > 1 && !helpless) {
                        KDDraw(kdgameboard, kdpixisprites, "dis" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Disarm.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (enemy.bind > 1 && bindLevel < 4) {
                        KDDraw(kdgameboard, kdpixisprites, "bind" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Bind.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.11,
                        });
                    }
                    if ((enemy.slow > 1 || KinkyDungeonGetBuffedStat(enemy.buffs, "MoveSpeed", true) < 0) && bindLevel < 4) {
                        KDDraw(kdgameboard, kdpixisprites, "spd" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Slow.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (KinkyDungeonGetBuffedStat(enemy.buffs, "AttackDmg", true) > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "atkb" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Buff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (KinkyDungeonGetBuffedStat(enemy.buffs, "AttackDmg", true) < 0 && bindLevel < 4) {
                        KDDraw(kdgameboard, kdpixisprites, "atkdb" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Debuff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (KinkyDungeonGetBuffedStat(enemy.buffs, "Armor") < 0 && enemy.Enemy.armor > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "armd" + enemy.id, KinkyDungeonRootDirectory + "Conditions/ArmorDebuff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    else if (KinkyDungeonGetBuffedStat(enemy.buffs, "Armor") > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "arm" + enemy.id, KinkyDungeonRootDirectory + "Conditions/ArmorBuff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (KinkyDungeonGetBuffedStat(enemy.buffs, "SpellResist") < 0 && enemy.Enemy.spellResist > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "spresd" + enemy.id, KinkyDungeonRootDirectory + "Conditions/ShieldDebuff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    else if (KinkyDungeonGetBuffedStat(enemy.buffs, "SpellResist") > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "spres" + enemy.id, KinkyDungeonRootDirectory + "Conditions/ShieldBuff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (KinkyDungeonGetBuffedStat(enemy.buffs, "Evasion") > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "evab" + enemy.id, KinkyDungeonRootDirectory + "Conditions/EvasionBuff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (KinkyDungeonGetBuffedStat(enemy.buffs, "DamageReduction") > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "shield" + enemy.id, KinkyDungeonRootDirectory + "Conditions/ShieldBuff.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                    if (KinkyDungeonGetBuffedStat(enemy.buffs, "DamageAmp", true) > 0) {
                        KDDraw(kdgameboard, kdpixisprites, "amp" + enemy.id, KinkyDungeonRootDirectory + "Conditions/DamageAmp.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 2.1,
                        });
                    }
                }
                if (enemy.freeze > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "frz" + enemy.id, KinkyDungeonRootDirectory + "Conditions/Freeze.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                        zIndex: 2.1,
                    });
                }
            }
        }
    }
}
function KinkyDungeonDrawEnemiesWarning(canvasOffsetX, canvasOffsetY, CamX, CamY) {
    for (let enemy of KinkyDungeonEntities) {
        if (enemy.warningTiles) {
            for (let t of enemy.warningTiles) {
                let tx = enemy.x + t.x;
                let ty = enemy.y + t.y;
                if (!KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(tx, ty)) && KinkyDungeonNoEnemy(tx, ty, true))
                    continue;
                let special = enemy.usingSpecial ? "Special" : "";
                let attackMult = KinkyDungeonGetBuffedStat(enemy.buffs, "AttackSlow", true);
                let attackPoints = enemy.attackPoints - attackMult + 1.1;
                let preHit = false;
                if (((enemy.usingSpecial && enemy.Enemy.specialAttackPoints) ? enemy.Enemy.specialAttackPoints : enemy.Enemy.attackPoints) > attackPoints) {
                    special = special + "Basic";
                    preHit = true;
                }
                if (tx >= CamX && ty >= CamY && tx < CamX + KinkyDungeonGridWidthDisplay && ty < CamY + KinkyDungeonGridHeightDisplay && !(tx == enemy.x && ty == enemy.y)) {
                    let color = enemy.Enemy.color ? string2hex(enemy.Enemy.color) : 0xff5555;
                    KDDraw(kdgameboard, kdpixisprites, tx + "," + ty + "_w" + enemy.id, KinkyDungeonRootDirectory + ((KDAllied(enemy)) ? "WarningAlly" : "WarningColor" + special) + ".png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                        tint: color,
                        zIndex: 2.22 + 0.001 * (enemy.Enemy.power ? enemy.Enemy.power : 0),
                    });
                    KDDraw(kdgameboard, kdpixisprites, tx + "," + ty + "_w_b" + enemy.id, KinkyDungeonRootDirectory + "WarningBacking" + ".png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                        tint: color,
                        zIndex: 0.2 + 0.001 * (enemy.Enemy.power ? enemy.Enemy.power : 0),
                        alpha: preHit ? 0.5 : 0.8,
                    });
                    KDDraw(kdgameboard, kdpixisprites, tx + "," + ty + "_w_h" + enemy.id, KinkyDungeonRootDirectory + ((KDAllied(enemy)) ? "WarningHighlightAlly" : "WarningHighlight" + special) + ".png", (tx - CamX) * KinkyDungeonGridSizeDisplay - 1, (ty - CamY) * KinkyDungeonGridSizeDisplay - 1, KinkyDungeonSpriteSize + 2, KinkyDungeonSpriteSize + 2, undefined, {
                        zIndex: 3.21,
                        alpha: 0.2,
                    });
                }
            }
        }
        let mp = enemy.Enemy.movePoints + KDBoundEffects(enemy) * 0.5;
        let ms = KinkyDungeonGetBuffedStat(enemy.buffs, "MoveSpeed") ? KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(enemy.buffs, "MoveSpeed")) : 1;
        if (enemy.fx && enemy.fy && enemy.movePoints >= mp - ms - 0.0001) {
            let tx = enemy.fx;
            let ty = enemy.fy;
            if (tx >= CamX && ty >= CamY && tx < CamX + KinkyDungeonGridWidthDisplay && ty < CamY + KinkyDungeonGridHeightDisplay
                && KDCanSeeEnemy(enemy, Math.max(Math.abs(enemy.x - KinkyDungeonPlayerEntity.x), Math.abs(enemy.y - KinkyDungeonPlayerEntity.y)))
                && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0) {
                let color = enemy.Enemy.color ? string2hex(enemy.Enemy.color) : 0xff5555;
                KDDraw(kdgameboard, kdpixisprites, tx + "," + ty + "_w_m" + enemy.id, KinkyDungeonRootDirectory + ("WarningMove") + ".png", (tx - CamX + 0.5) * KinkyDungeonGridSizeDisplay - 1, (ty - CamY + 0.5) * KinkyDungeonGridSizeDisplay - 1, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, Math.atan2(ty - enemy.y, tx - enemy.x) || 0, {
                    tint: color,
                    zIndex: -0.05,
                }, true);
            }
        }
        if (enemy.Enemy.spells && (enemy.Enemy.spellRdy && (!KDAmbushAI(enemy) || enemy.ambushtrigger)) && !(enemy.castCooldown > 1) && (!(enemy.silence > 0) && !(enemy.stun > 0) && !(enemy.freeze > 0) && !KDHelpless(enemy))) {
            let tx = enemy.visual_x;
            let ty = enemy.visual_y;
            if (tx >= CamX && ty >= CamY && tx < CamX + KinkyDungeonGridWidthDisplay && ty < CamY + KinkyDungeonGridHeightDisplay
                && KDCanSeeEnemy(enemy, Math.max(Math.abs(enemy.x - KinkyDungeonPlayerEntity.x), Math.abs(enemy.y - KinkyDungeonPlayerEntity.y)))
                && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0) {
                KDDraw(kdgameboard, kdpixisprites, enemy.id + "_sr", KinkyDungeonRootDirectory + "SpellReady.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, enemy.Enemy.color ? {
                    tint: string2hex(enemy.Enemy.color),
                    zIndex: -0.1,
                } : undefined);
            }
        }
        if (enemy.weakBinding) {
            let tx = enemy.visual_x;
            let ty = enemy.visual_y;
            let binder = KinkyDungeonFindID(enemy.boundTo);
            if (binder && tx >= CamX && ty >= CamY && tx < CamX + KinkyDungeonGridWidthDisplay && ty < CamY + KinkyDungeonGridHeightDisplay
                && KDCanSeeEnemy(enemy, Math.max(Math.abs(enemy.x - KinkyDungeonPlayerEntity.x), Math.abs(enemy.y - KinkyDungeonPlayerEntity.y)))
                && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0) {
                KDDraw(kdgameboard, kdpixisprites, enemy.id + "_sr", KinkyDungeonRootDirectory + "WeakBinding.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, binder.Enemy.color ? {
                    tint: string2hex(binder.Enemy.color),
                    zIndex: -0.1,
                } : undefined);
            }
        }
    }
}
function KinkyDungeonBar(x, y, w, h, value, foreground = "#66FF66", background = "#ff0000", orig = undefined, origColor = "#ff4444", notches = undefined, notchcolor = "#ffffff", notchbg = "#ffffff", zIndex = 55) {
    if (value < 0)
        value = 0;
    if (value > 100)
        value = 100;
    let id = x + "," + y + "," + w + "," + h + foreground;
    if (background != "none")
        FillRectKD(kdcanvas, kdpixisprites, id + '1', {
            Left: x + 1,
            Top: y + 1,
            Width: w - 2,
            Height: h - 2,
            Color: "#000000",
            LineWidth: 1,
            zIndex: zIndex + value * 0.0001,
        });
    FillRectKD(kdcanvas, kdpixisprites, id + '2', {
        Left: x + 2,
        Top: y + 2,
        Width: Math.floor((w - 4) * value / 100),
        Height: h - 4,
        Color: foreground,
        LineWidth: 1,
        zIndex: zIndex + .1,
    });
    if (background != "none")
        FillRectKD(kdcanvas, kdpixisprites, id + '3', {
            Left: Math.floor(x + 2 + (w - 4) * value / 100),
            Top: y + 2,
            Width: Math.floor((w - 4) * (100 - value) / 100),
            Height: h - 4,
            Color: background,
            LineWidth: 1,
            zIndex: zIndex + .2,
        });
    if (orig != undefined)
        FillRectKD(kdcanvas, kdpixisprites, id + '4', {
            Left: Math.min(Math.floor(x + 2 + (w - 4) * orig / 100), Math.floor(x + 2 + (w - 4) * value / 100)),
            Top: y + 2,
            Width: Math.floor((w - 4) * Math.abs(value - orig) / 100),
            Height: h - 4,
            Color: origColor,
            LineWidth: 1,
            zIndex: zIndex + .3,
        });
    if (notches) {
        for (let n of notches) {
            if (n > 0 && n < 1) {
                FillRectKD(kdcanvas, kdpixisprites, id + '5' + n, {
                    Left: x + Math.floor((w - 4) * n) - 1,
                    Top: y + 2,
                    Width: 3,
                    Height: h - h,
                    Color: notchbg,
                    LineWidth: 1,
                    zIndex: zIndex + .4,
                });
                FillRectKD(kdcanvas, kdpixisprites, id + '6' + n, {
                    Left: x + Math.floor((w - 4) * n),
                    Top: y + 2,
                    Width: 1,
                    Height: h - 4,
                    Color: notchcolor,
                    LineWidth: 1,
                    zIndex: zIndex + .5,
                });
            }
        }
    }
}
function KDCanSeeEnemy(enemy, playerDist) {
    if (playerDist == undefined)
        playerDist = KDistChebyshev(KinkyDungeonPlayerEntity.x - enemy.x, KinkyDungeonPlayerEntity.y - enemy.y);
    return (((enemy.revealed && !enemy.Enemy.noReveal) || !enemy.Enemy.stealth || KDHelpless(enemy) || KinkyDungeonSeeAll || playerDist <= enemy.Enemy.stealth + 0.1)
        && !(KinkyDungeonGetBuffedStat(enemy.buffs, "Sneak") > 0 && playerDist > 1.5)
        && playerDist <= KDMaxEnemyViewDist(enemy));
}
function KDMaxEnemyViewDist(enemy) {
    let data = {
        blindMult: (KinkyDungeonStatsChoice.get("Blackout") || KinkyDungeonStatsChoice.get("TotalBlackout")) ? 100 : 2,
    };
    if (enemy.hp < enemy.Enemy.maxhp || enemy.attackPoints > 0)
        return KDMaxVisionDist;
    if (KinkyDungeonBlindLevel < 2)
        return KDMaxVisionDist;
    else
        return Math.max(1.5, KDMaxVisionDist - KinkyDungeonBlindLevel * data.blindMult);
}
function KDGetEnemyStruggleMod(enemy) {
    let level = KDBoundEffects(enemy);
    let mult = 0.1;
    if (enemy.boundLevel > enemy.Enemy.maxhp * 10) {
        mult = 0;
    }
    if (mult > 0) {
        if (enemy.disarm > 0)
            mult *= 0.5;
        if (enemy.silence > 0)
            mult *= 0.75;
        if (enemy.blind > 0)
            mult *= 0.75;
        if (enemy.bind > 0)
            mult *= 0.5;
        else if (enemy.slow > 0)
            mult *= 0.75;
        if (level > 3)
            mult *= 3;
        if (enemy.vulnerable > 0 || enemy.attackPoints > 0)
            mult *= 0.5;
        if (enemy.boundLevel > 0) {
            mult *= Math.pow(1.5, -enemy.boundLevel / enemy.Enemy.maxhp);
        }
        if (enemy.distraction > 0)
            mult *= 1 / (1 + 2 * enemy.distraction / enemy.Enemy.maxhp);
    }
    if (!KDEnemyHasFlag(enemy, "imprisoned") && enemy.hp > 0.51 && KDNearbyEnemies(enemy.x, enemy.y, 1.5).some((en) => {
        return en != enemy && en.Enemy.bound && !KDHelpless(enemy) && KDBoundEffects(en) < 3 && !KDEnemyHasFlag(en, "imprisoned") && !KinkyDungeonIsDisabled(en) && KDFactionRelation(KDGetFaction(enemy), KDGetFaction(en)) >= Math.max(0.1, KDFactionRelation("Player", KDGetFaction(en)));
    })) {
        mult += 0.15;
    }
    if (mult > 0) {
        if (KinkyDungeonGetBuffedStat(enemy.buffs, "Lockdown"))
            mult *= KinkyDungeonGetBuffedStat(enemy.buffs, "Lockdown");
    }
    return mult;
}
function KDGetEnemyDistractRate(enemy, vibe) {
    if (vibe)
        return -(enemy.Enemy.maxhp ** 0.5) * (0.1 + 0.05 * vibe);
    let level = KDBoundEffects(enemy);
    let mult = enemy.distraction / enemy.Enemy.maxhp > 0.9 ? 0.02 : (enemy.distraction / enemy.Enemy.maxhp > 0.5 ? 0.04 : 0.06);
    if (KDStrictPersonalities.includes(enemy.personality))
        mult = mult * 2;
    else if (!KDLoosePersonalities.includes(enemy.personality))
        mult = mult * 1.5;
    return mult * enemy.Enemy.maxhp / (1 + level * 0.25);
}
function KDGetEnemyDistractionDamage(enemy, vibe) {
    if (vibe <= 0)
        return 0;
    let mult = Math.max(0.25, enemy.distraction / enemy.Enemy.maxhp) * 0.05 * vibe;
    if (enemy.hp <= 1 || enemy.hp <= enemy.Enemy.maxhp * 0.101)
        return 0;
    return Math.min(Math.max(0.2 * enemy.Enemy.maxhp ** 0.75, 1), mult * enemy.hp);
}
let KDMaxBindingBars = 3;
function KinkyDungeonDrawEnemiesHP(canvasOffsetX, canvasOffsetY, CamX, CamY) {
    var _a;
    let tooltip = false;
    for (let enemy of KinkyDungeonEntities) {
        let playerDist = Math.max(Math.abs(enemy.x - KinkyDungeonPlayerEntity.x), Math.abs(enemy.y - KinkyDungeonPlayerEntity.y));
        if (enemy.x >= CamX && enemy.y >= CamY && enemy.x < CamX + KinkyDungeonGridWidthDisplay && enemy.y < CamY + KinkyDungeonGridHeightDisplay
            && KinkyDungeonVisionGet(enemy.x, enemy.y) > 0) {
            let xx = enemy.visual_x ? enemy.visual_x : enemy.x;
            let yy = enemy.visual_y ? enemy.visual_y : enemy.y;
            let II = 0;
            if ((!enemy.Enemy.stealth || KDHelpless(enemy) || playerDist <= enemy.Enemy.stealth + 0.1) && !(KinkyDungeonGetBuffedStat(enemy.buffs, "Sneak") > 0 && playerDist > 1.5)) {
                if ((KDAllied(enemy) || enemy.distraction > 0 || ((enemy.lifetime != undefined || enemy.hp < enemy.Enemy.maxhp || enemy.boundTo || enemy.boundLevel))) && KDCanSeeEnemy(enemy, playerDist)) {
                    let spacing = 6;
                    let helpless = KDHelpless(enemy);
                    if (enemy.boundLevel != undefined && enemy.boundLevel > 0) {
                        if (!helpless) {
                            let bindingBars = Math.ceil(enemy.boundLevel / enemy.Enemy.maxhp);
                            let SM = KDGetEnemyStruggleMod(enemy);
                            let futureBound = KDPredictStruggle(enemy, SM, 1);
                            for (let i = 0; i < bindingBars && i < KDMaxBindingBars; i++) {
                                if (i > 0)
                                    II++;
                                let mod = enemy.boundLevel - futureBound.boundLevel;
                                KinkyDungeonBar(canvasOffsetX + (xx - CamX + 0.1) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay + 12 - 15 - spacing * II, KinkyDungeonGridSizeDisplay * 0.8, 7, Math.min(1, (enemy.boundLevel - i * enemy.Enemy.maxhp) / enemy.Enemy.maxhp) * 100, "#ffffff", "#52333f");
                                KinkyDungeonBar(1 + canvasOffsetX + (xx - CamX + 0.1) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay + 12 - 15 - spacing * II, KinkyDungeonGridSizeDisplay * 0.8, 7, Math.min(1, (enemy.boundLevel - mod - i * enemy.Enemy.maxhp) / enemy.Enemy.maxhp) * 100, "#444444", "none");
                            }
                            II -= Math.max(0, Math.min(bindingBars - 1, KDMaxBindingBars - 1));
                            let bb = 0;
                            let bcolor = "#ffae70";
                            let bondage = [];
                            if (futureBound.specialBoundLevel) {
                                for (let b of Object.entries(futureBound.specialBoundLevel)) {
                                    bondage.push({ name: b[0], amount: b[1], level: 0, pri: KDSpecialBondage[b[0]].priority });
                                }
                                bondage = bondage.sort((a, b) => {
                                    return b.pri - a.pri;
                                });
                            }
                            else {
                                bondage.push({ name: "Normal", amount: 0, level: futureBound.boundLevel, pri: 0 });
                            }
                            for (let b of bondage) {
                                if (!b.level) {
                                    b.level = bb + b.amount;
                                    bb = b.level;
                                }
                            }
                            for (let i = 0; i < bindingBars && i < KDMaxBindingBars; i++) {
                                if (i > 0)
                                    II++;
                                let bars = false;
                                for (let bi = bondage.length - 1; bi >= 0; bi--) {
                                    let b = bondage[bi];
                                    if (b.level > i * enemy.Enemy.maxhp) {
                                        bcolor = KDSpecialBondage[b.name] ? KDSpecialBondage[b.name].color : "#ffae70";
                                        KinkyDungeonBar(canvasOffsetX + (xx - CamX + 0.1) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay + 12 - 15 - spacing * II, KinkyDungeonGridSizeDisplay * 0.8, 7, Math.min(1, (Math.max(0, b.level - i * enemy.Enemy.maxhp)) / enemy.Enemy.maxhp) * 100, bcolor, "none", undefined, undefined, bars ? [0.25, 0.5, 0.75] : undefined, bars ? "#85522c" : undefined, bars ? "#85522c" : undefined, 57.5 + b.pri * 0.01);
                                        bars = true;
                                    }
                                }
                            }
                        }
                        else {
                        }
                    }
                    if (!helpless) {
                        if (enemy.hp < enemy.Enemy.maxhp || KDAllied(enemy) || enemy.boundTo) {
                            let fg = enemy.boundTo ? (KDAllied(enemy) ? "#77aaff" : "#dd88ff") : (KDAllied(enemy) ? "#00ff88" : "#ff5555");
                            let bg = KDAllied(enemy) ? "#aa0000" : "#000000";
                            KinkyDungeonBar(canvasOffsetX + (xx - CamX + (enemy.boundTo ? 0.1 : 0.05)) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - 15 - II * spacing, KinkyDungeonGridSizeDisplay * (enemy.boundTo ? 0.8 : 0.9), enemy.boundTo ? 7 : 9, enemy.hp / enemy.Enemy.maxhp * 100, fg, bg);
                            II++;
                        }
                        if (enemy.distraction > 0) {
                            KinkyDungeonBar(canvasOffsetX + (xx - CamX + 0.1) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - 15 - II * spacing, KinkyDungeonGridSizeDisplay * 0.8, 6, enemy.distraction / enemy.Enemy.maxhp * 100, "#fda1ff", "#9300ff");
                            KDDraw(kdcanvas, kdpixisprites, enemy.id + "_ar_heart", KinkyDungeonRootDirectory + (enemy.distraction >= 0.9 * enemy.Enemy.maxhp ? "UI/HeartExtreme.png" : "UI/Heart.png"), -7 + canvasOffsetX + (xx - CamX + enemy.distraction / enemy.Enemy.maxhp * 0.8 + 0.1) * KinkyDungeonGridSizeDisplay, -4 + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - 15 - II * spacing, 14, 14, undefined, {
                                zIndex: 63,
                            });
                            II++;
                        }
                        if (enemy.lifetime != undefined && enemy.maxlifetime > 0 && enemy.maxlifetime < 999 && ((!enemy.Enemy.hidetimerbar && !enemy.hideTimer) || KDAllied(enemy))) {
                            KinkyDungeonBar(canvasOffsetX + (xx - CamX + (enemy.boundTo ? 0.1 : 0.05)) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - 15 - II * spacing, KinkyDungeonGridSizeDisplay * (enemy.boundTo ? 0.8 : 0.9), 8, enemy.lifetime / enemy.maxlifetime * 100, "#cccccc", "#000000");
                            II++;
                        }
                    }
                }
            }
            if (KDCanSeeEnemy(enemy, playerDist)) {
                let yboost = II * -20;
                if (enemy.Enemy.specialdialogue || enemy.specialdialogue) {
                    KDDraw(kdcanvas, kdpixisprites, enemy.id + "_th", KinkyDungeonRootDirectory + "Conditions/Dialogue.png", canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 2 + yboost, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                        zIndex: 23,
                    });
                }
                let bb = false;
                if (enemy.Enemy.bound && KDThoughtBubbles.has(enemy.id)) {
                    let bubble = KDThoughtBubbles.get(enemy.id);
                    if (bubble.index + bubble.duration >= KinkyDungeonCurrentTick && (enemy.ambushtrigger || !((_a = KDAIType[KDGetAI(enemy)]) === null || _a === void 0 ? void 0 : _a.ambush))) {
                        bb = true;
                        let name = CommonTime() % 1000 < 500 ? "Thought" : bubble.name;
                        if (name != "Thought" || !((enemy.lifetime != undefined || enemy.hp < enemy.Enemy.maxhp || enemy.boundLevel)))
                            KDDraw(kdcanvas, kdpixisprites, enemy.id + "_th", KinkyDungeonRootDirectory + `Conditions/Thought/${name}.png`, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 2 + yboost, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                                zIndex: 4,
                            });
                    }
                }
                if (!KDHelpless(enemy)) {
                    if (!KinkyDungeonAggressive(enemy) && ((!KDAllied(enemy) && !enemy.Enemy.specialdialogue && !bb) || KDEnemyHasFlag(enemy, "Shop")) && !enemy.playWithPlayer && enemy.Enemy.movePoints < 90 && !KDAmbushAI(enemy)) {
                        KDDraw(kdcanvas, kdpixisprites, enemy.id + "_shop", KinkyDungeonRootDirectory + ((KDEnemyHasFlag(enemy, "Shop")) ? "Conditions/Shop.png" : (KDAllied(enemy) ? "Conditions/Heart.png" : "Conditions/Peace.png")), canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 2 + yboost, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                            zIndex: 22,
                        });
                    }
                    else if (!bb && enemy.aware && KDHostile(enemy) && enemy.vp > 0 && enemy.Enemy && !enemy.Enemy.noAlert && enemy.Enemy.movePoints < 90 && !KDAmbushAI(enemy)) {
                        KDDraw(kdcanvas, kdpixisprites, enemy.id + "_aw", KinkyDungeonRootDirectory + "Conditions/Aware.png", canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 2 + yboost, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                            zIndex: 22,
                        });
                    }
                    else if (!bb && enemy.vp > 0.01 && KDHostile(enemy) && enemy.Enemy && !enemy.Enemy.noAlert && enemy.Enemy.movePoints < 90 && !KDAmbushAI(enemy)) {
                        let sneakThreshold = enemy.Enemy.sneakThreshold ? enemy.Enemy.sneakThreshold : 2;
                        if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak"))
                            sneakThreshold = Math.max(0.1, sneakThreshold + KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak"));
                        if (enemy.vp > sneakThreshold / 2)
                            KDDraw(kdcanvas, kdpixisprites, enemy.id + "_vp", KinkyDungeonRootDirectory + "Conditions/vp.png", canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 2 + yboost, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                                zIndex: 22,
                            });
                    }
                    if (enemy.vulnerable > 0)
                        KDDraw(kdcanvas, kdpixisprites, enemy.id + "_vuln", KinkyDungeonRootDirectory + "Conditions/Vulnerable.png", canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 2 + yboost, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                            zIndex: 22,
                        });
                }
                if (!tooltip && (((!KDAmbushAI(enemy) || enemy.ambushtrigger)
                    && (MouseIn(canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay)
                        || MouseIn(canvasOffsetX + (enemy.x - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (enemy.y - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay))
                    || (KDGameData.CurrentDialog && KDGetSpeaker() == enemy)))) {
                    let faction = KDGetFaction(enemy);
                    if (faction && (!KinkyDungeonHiddenFactions.includes(faction) || KinkyDungeonTooltipFactions.includes(faction))) {
                        let tt = TextGet("KinkyDungeonFaction" + faction);
                        let ttlength = 10;
                        if (CJKcheck(tt, 2)) {
                            DrawTextFitKD(tt, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 3, 10 + tt.length * 8, "white", "black");
                            yboost += -2 * KinkyDungeonGridSizeDisplay / 7;
                        }
                        else {
                            let ttCJKcheck1 = CJKcheck(tt, 1);
                            let ttCJKcheck2 = CJKcheck(tt);
                            if (ttCJKcheck1) {
                                let i;
                                for (i in ttCJKcheck1) {
                                    ttlength += ttCJKcheck1[i].length * 8;
                                }
                            }
                            if (ttCJKcheck2) {
                                let i;
                                for (i in ttCJKcheck2) {
                                    ttlength += ttCJKcheck2[i].length * 16;
                                }
                            }
                            DrawTextFitKD(tt, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 3, ttlength, "white", "black");
                            yboost += -3 * KinkyDungeonGridSizeDisplay / 8;
                        }
                    }
                    let name = TextGet("Name" + enemy.Enemy.name);
                    let namelength = 10;
                    if (CJKcheck(name, 2)) {
                        DrawTextFitKD(name, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 3, 10 + name.length * 8, "white", "black");
                    }
                    else {
                        let nameCJKcheck1 = CJKcheck(name, 1);
                        let nameCJKcheck2 = CJKcheck(name);
                        if (nameCJKcheck1) {
                            let i;
                            for (i in nameCJKcheck1) {
                                namelength += nameCJKcheck1[i].length * 8;
                            }
                        }
                        if (nameCJKcheck2) {
                            let i;
                            for (i in nameCJKcheck2) {
                                namelength += nameCJKcheck2[i].length * 16;
                            }
                        }
                        DrawTextFitKD(name, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 3, namelength, "white", "black");
                    }
                    if (enemy.CustomName) {
                        DrawTextKD(enemy.CustomName, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 1.5, enemy.CustomNameColor, "black");
                    }
                    tooltip = true;
                }
                if (enemy.dialogue && !tooltip) {
                    let dialougelenth = 10;
                    if (CJKcheck(enemy.dialogue, 2)) {
                        DrawTextFitKD(enemy.dialogue, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 1.5, 10 + enemy.dialogue.length * 8, enemy.dialogueColor, "#000000", 18, undefined, 20);
                    }
                    else {
                        let dialougeCJKcheck1 = CJKcheck(enemy.dialogue, 1);
                        let dialougeCJKcheck2 = CJKcheck(enemy.dialogue);
                        if (dialougeCJKcheck1) {
                            let i;
                            for (i in dialougeCJKcheck1) {
                                dialougelenth += dialougeCJKcheck1[i].length * 8;
                            }
                        }
                        if (dialougeCJKcheck2) {
                            let i;
                            for (i in dialougeCJKcheck2) {
                                dialougelenth += dialougeCJKcheck2[i].length * 16;
                            }
                        }
                        DrawTextFitKD(enemy.dialogue, canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 1.5, dialougelenth, enemy.dialogueColor, "#000000", 18, undefined, 20);
                    }
                }
            }
        }
    }
}
function KDDrawEnemyTooltip(enemy, offset) {
    let analyze = KDHasSpell("ApprenticeKnowledge");
    let TooltipList = [];
    TooltipList.push({
        str: TextGet("Name" + enemy.Enemy.name),
        fg: enemy.Enemy.color || "#ff5555",
        bg: "#000000",
        size: 24,
        center: true,
    });
    TooltipList.push({
        str: TextGet("KDTooltipHP") + Math.round(enemy.hp * 10) + "/" + Math.round(enemy.Enemy.maxhp * 10),
        fg: "#ffffff",
        bg: "#000000",
        size: 20,
        center: true,
    });
    if (enemy.boundLevel) {
        TooltipList.push({
            str: TextGet("KDTooltipBinding") + Math.round(enemy.boundLevel / enemy.Enemy.maxhp * 100) + "%",
            fg: "#ffae70",
            bg: "#000000",
            size: 20,
            center: true,
        });
    }
    if (enemy.boundTo) {
        TooltipList.push({
            str: TextGet(enemy.weakBinding ? "KDTooltipWeakBinding" : "KDTooltipNormalBinding"),
            fg: KDHostile(enemy) ? "#88ff88" : "#ff5555",
            bg: "#000000",
            size: 14,
            center: true,
        });
        let caster = KinkyDungeonFindID(enemy.boundTo);
        if (caster)
            TooltipList.push({
                str: TextGet("KDTooltipBoundTo").replace("ENEMYNAME", TextGet("Name" + caster.Enemy.name)),
                fg: KDHostile(enemy) ? "#88ff88" : "#ff5555",
                bg: "#000000",
                size: 14,
                center: true,
            });
        else
            TooltipList.push({
                str: TextGet("KDTooltipDisappearing"),
                fg: "#ff5555",
                bg: "#000000",
                size: 14,
                center: true,
            });
    }
    let statuses = [];
    if (enemy.vulnerable)
        statuses.push({ name: "Vulnerable", count: undefined });
    if (KDEntityBuffedStat(enemy, "Vibration"))
        statuses.push({ name: "Vibed", count: undefined });
    if (enemy.stun)
        statuses.push({ name: "Stunned", count: enemy.stun });
    if (enemy.bind)
        statuses.push({ name: "Bind", count: enemy.bind });
    if (enemy.slow)
        statuses.push({ name: "Slow", count: enemy.slow });
    if (enemy.silence)
        statuses.push({ name: "Silence", count: enemy.silence });
    if (enemy.disarm)
        statuses.push({ name: "Disarm", count: enemy.disarm });
    if (enemy.blind)
        statuses.push({ name: "Blind", count: enemy.blind });
    if (enemy.slow || KDEntityBuffedStat(enemy, "MoveSpeed") < 0)
        statuses.push({ name: "Slow", count: enemy.slow });
    if (KDBoundEffects(enemy))
        statuses.push({ name: "Bound" + (KDHelpless(enemy) ? 10 : KDBoundEffects(enemy)) });
    if (KDEntityBuffedStat(enemy, "Plug"))
        statuses.push({ name: "Plug", count: undefined });
    if (KDEntityBuffedStat(enemy, "Chastity"))
        statuses.push({ name: "Belt", count: undefined });
    if (statuses.length > 0) {
        let strings = [""];
        let strr = "";
        let count = 0;
        let maxcount = 4;
        for (let stat of statuses) {
            count += 1;
            if (count > maxcount) {
                strr = "";
                strings.push("");
            }
            if (strr)
                strr = strr + ", ";
            strr = strr + `${TextGet("KDStatusTooltipEnemy" + stat.name)}`;
            if (stat.count)
                strr = strr + ` (${stat.count})`;
            strings[strings.length - 1] = strr;
        }
        for (let stringlisted of strings)
            TooltipList.push({
                str: stringlisted,
                fg: "#dddddd",
                bg: "#000000",
                size: 14,
                center: true,
            });
    }
    TooltipList.push({
        str: "",
        fg: "#ffaa55",
        bg: "#000000",
        size: 12,
    });
    let opinion = Math.max(-3, Math.min(3, Math.round(KDGetModifiedOpinion(enemy) / 10)));
    let str = TextGet("KDTooltipOpinion" + opinion);
    TooltipList.push({
        str: str,
        fg: "#ffffff",
        bg: KDTextGray0,
        size: 20,
    });
    let ttt = KDGetAwareTooltip(enemy);
    TooltipList.push({
        str: TextGet("KDTooltipAware" + ttt.suff),
        fg: ttt.color,
        bg: "#000000",
        size: 20,
    });
    if (enemy.Enemy.armor) {
        let st = TextGet("KinkyDungeonTooltipArmor").replace("AMOUNT", "" + Math.round(10 * enemy.Enemy.armor));
        TooltipList.push({
            str: st,
            fg: "#ffffff",
            bg: KDTextGray0,
            size: 20,
        });
    }
    if (enemy.Enemy.spellResist) {
        let st = TextGet("KinkyDungeonTooltipSpellResist").replace("AMOUNT", "" + Math.round(10 * enemy.Enemy.spellResist));
        TooltipList.push({
            str: st,
            fg: "#ffffff",
            bg: KDTextGray0,
            size: 20,
        });
    }
    if (enemy.Enemy.evasion) {
        let st = TextGet("KinkyDungeonTooltipEvasion").replace("AMOUNT", "" + Math.round(100 - 100 * KinkyDungeonMultiplicativeStat(enemy.Enemy.evasion)));
        TooltipList.push({
            str: st,
            fg: "#ffffff",
            bg: KDTextGray0,
            size: 20,
        });
    }
    if (analyze) {
        if (enemy.Enemy.disarm) {
            let dt = KinkyDungeonDamageTypes[enemy.Enemy.dmgType];
            if (dt) {
                let st = TextGet("KDTooltipDisarm").replace("DISARMCHANCE", "" + Math.round(enemy.Enemy.disarm * 100));
                TooltipList.push({
                    str: st,
                    fg: "#ffaa55",
                    bg: "#000000",
                    size: 20,
                });
            }
        }
        if (enemy.Enemy.dmgType) {
            let dt = KinkyDungeonDamageTypes[enemy.Enemy.dmgType];
            if (dt) {
                let st = TextGet("KinkyDungeonTooltipDealsDamage").replace("DAMAGETYPE", TextGet("KinkyDungeonDamageType" + enemy.Enemy.dmgType));
                TooltipList.push({
                    str: st,
                    fg: dt.color,
                    bg: dt.bg,
                    size: 20,
                });
            }
        }
    }
    if (enemy.items && enemy.items.length > 0) {
        TooltipList.push({
            str: "",
            fg: "#ffaa55",
            bg: "#000000",
            size: 8,
        });
        TooltipList.push({
            str: TextGet("KDTooltipInventory"),
            fg: "#ffffff",
            bg: "#000000",
            size: 20,
        });
        for (let i = 0; i < 6 && i < enemy.items.length; i++) {
            TooltipList.push({
                str: TextGet(KinkyDungeonGetRestraintByName(enemy.items[i]) ? "Restraint" + enemy.items[i] : "KinkyDungeonInventoryItem" + enemy.items[i]),
                fg: "#ffffff",
                bg: "#000000",
                size: 18,
            });
        }
        if (enemy.items.length > 6) {
            TooltipList.push({
                str: TextGet("KDTooltipInventoryFull").replace("NUMBER", "" + (enemy.items.length - 6)),
                fg: "#ffffff",
                bg: "#000000",
                size: 18,
            });
        }
        TooltipList.push({
            str: "",
            fg: "#ffaa55",
            bg: "#000000",
            size: 8,
        });
    }
    if (analyze) {
        let list = Array.from(Object.keys(enemy.Enemy.tags));
        if (enemy.Enemy.spellResist)
            list.push("magic");
        let magic = false;
        let repeats = {};
        for (let t of list) {
            for (let dt of Object.values(KinkyDungeonDamageTypes)) {
                if ((t == dt.name + "resist" || t == dt.name + "weakness" || t == dt.name + "immune" || t == dt.name + "severeweakness")
                    || (dt.name == "magic" && t.includes("magic") && enemy.Enemy.spellResist)) {
                    let mult = 1.0;
                    if (t == dt.name + "resist")
                        mult = 0.5;
                    else if (t == dt.name + "weakness")
                        mult = 1.5;
                    else if (t == dt.name + "immune")
                        mult = 0;
                    else if (t == dt.name + "severeweakness")
                        mult = 2.0;
                    if (dt.name == "magic" && !magic && enemy.Enemy.spellResist) {
                        magic = true;
                        mult *= KinkyDungeonMultiplicativeStat(enemy.Enemy.spellResist);
                    }
                    let st = TextGet("KinkyDungeonTooltipWeakness").replace("MULTIPLIER", "" + Math.round(mult * 100) / 100).replace("DAMAGETYPE", TextGet("KinkyDungeonDamageType" + dt.name));
                    if (!repeats.DR) {
                        TooltipList.push({
                            str: "",
                            fg: "#ffffff",
                            bg: "#000000",
                            size: 10,
                        });
                        TooltipList.push({
                            str: TextGet("KDTooltipDamageResists"),
                            fg: "#ffffff",
                            bg: "#000000",
                            size: 20,
                        });
                        repeats.DR = true;
                    }
                    if (!repeats[st])
                        TooltipList.push({
                            str: st,
                            fg: dt.color,
                            bg: dt.bg,
                            size: 18,
                        });
                    repeats[st] = true;
                }
            }
        }
    }
    return KDDrawTooltip(TooltipList, offset);
}
function KDGetColor(enemy) {
    return "#ffffff";
}
let KDChampionMax = 10;
function KinkyDungeonCapture(enemy) {
    let msg = "KinkyDungeonCapture";
    let goddessCapture = false;
    if (enemy.lifetime != undefined && enemy.lifetime < 999) {
        msg = "KinkyDungeonCaptureBasic";
    }
    else if (KDGameData.Champion) {
        if (KDGameData.ChampionCurrent < KDChampionMax) {
            msg = "KinkyDungeonCaptureGoddess";
            let disapproval = 0;
            goddessCapture = true;
            let spell = KinkyDungeonFindSpell("Summon", true);
            if (spell) {
                KinkyDungeonCastSpell(enemy.x, enemy.y, spell, undefined, undefined, undefined);
            }
            if (KinkyDungeonStatsChoice.has("BoundCrusader")) {
                let uniform = ["Rope", "Leather", "Metal", "Latex"];
                if (uniform.includes(KDGameData.Champion))
                    uniform = [KDGameData.Champion];
                let restraints = [];
                for (let u of uniform) {
                    for (let r of KinkyDungeonGetRestraintsWithShrine(u, true)) {
                        restraints.push(r);
                    }
                }
                let minAmount = 1;
                if (KinkyDungeonGoddessRep[KDGameData.Champion] > 10)
                    minAmount = 2;
                if (KinkyDungeonGoddessRep[KDGameData.Champion] > 30)
                    minAmount = 3;
                if (restraints.length < minAmount) {
                    msg = "KinkyDungeonCaptureGoddess" + (minAmount == 1 ? "Low" : "None") + (uniform.includes(KDGameData.Champion) ? "Uniform" : "Restraint");
                    if (minAmount == 1)
                        disapproval = 1;
                    else
                        disapproval = 2;
                }
            }
            if (disapproval == 0) {
                KinkyDungeonChangeRep(KDGameData.Champion, KinkyDungeonGoddessRep[KDGameData.Champion] < -10 ? 1 :
                    (KinkyDungeonGoddessRep[KDGameData.Champion] > 30 ? 0.25 : 0.5));
                KDGameData.ChampionCurrent += 1;
            }
            else
                goddessCapture = false;
        }
        else
            msg = "KinkyDungeonCaptureMax";
    }
    else
        msg = "KinkyDungeonCaptureBasic";
    KinkyDungeonSendEvent("capture", { enemy: enemy });
    KinkyDungeonSendActionMessage(6, TextGet(msg).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)).replace("GODDESS", TextGet("KinkyDungeonShrine" + KDGameData.Champion)), "lightgreen", 2);
    return goddessCapture;
}
function KDDropStolenItems(enemy) {
    if (enemy.items) {
        for (let name of enemy.items) {
            if (!enemy.tempitems || !enemy.tempitems.includes(name)) {
                let item = { x: enemy.x, y: enemy.y, name: name };
                KinkyDungeonGroundItems.push(item);
            }
        }
        enemy.items = [];
        enemy.tempitems = undefined;
    }
}
function KinkyDungeonEnemyCheckHP(enemy, E) {
    var _a;
    if (enemy.hp <= 0) {
        let noRepHit = false;
        KinkyDungeonSendEvent("death", {});
        KDSpliceIndex(E, 1);
        KinkyDungeonSendEvent("kill", { enemy: enemy });
        if (KDBoundEffects(enemy) > 3 && enemy.boundLevel > 0 && KDHostile(enemy) && !enemy.Enemy.tags.nocapture && enemy.playerdmg) {
            KDDropStolenItems(enemy);
            if (!KinkyDungeonCapture(enemy))
                noRepHit = true;
        }
        else {
            KDDropStolenItems(enemy);
            if (enemy == KinkyDungeonKilledEnemy) {
                if (KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 10)
                    KinkyDungeonSendActionMessage(4, TextGet("Kill" + enemy.Enemy.name), "orange", 2);
                KinkyDungeonKilledEnemy = null;
            }
        }
        if (!(enemy.lifetime < 9000)) {
            if (enemy.playerdmg && !(!KinkyDungeonAggressive(enemy) && KDHelpless(enemy) && KDCanDom(enemy))) {
                if (enemy.Enemy && enemy.Enemy.tags && enemy.Enemy.tags.boss)
                    KinkyDungeonChangeRep("Ghost", -3);
                else if (enemy.Enemy && enemy.Enemy.tags && enemy.Enemy.tags.miniboss)
                    KinkyDungeonChangeRep("Ghost", -1);
                else if (enemy.Enemy && enemy.Enemy.tags && enemy.Enemy.tags.elite && KDRandom() < 0.33)
                    KinkyDungeonChangeRep("Ghost", -1);
                if (enemy.rep)
                    for (let rep of Object.keys(enemy.rep))
                        KinkyDungeonChangeRep(rep, enemy.rep[rep]);
                if (enemy.factionrep)
                    for (let rep of Object.keys(enemy.factionrep))
                        KinkyDungeonChangeFactionRep(rep, enemy.factionrep[rep]);
                if (enemy.Enemy.rep && !KDEnemyHasFlag(enemy, "norep"))
                    for (let rep of Object.keys(enemy.Enemy.rep))
                        KinkyDungeonChangeRep(rep, enemy.Enemy.rep[rep]);
                if (enemy.Enemy.factionrep && !KDEnemyHasFlag(enemy, "norep"))
                    for (let rep of Object.keys(enemy.Enemy.factionrep))
                        KinkyDungeonChangeFactionRep(rep, enemy.Enemy.factionrep[rep]);
                if (KinkyDungeonStatsChoice.has("Vengeance")) {
                    KinkyDungeonChangeDistraction(Math.max(0, Math.ceil(Math.pow(enemy.Enemy.maxhp, 0.7))), false, 0.75);
                }
                let faction = KDGetFaction(enemy);
                let amount = 0;
                if (!KinkyDungeonHiddenFactions.includes(faction)) {
                    if (enemy.Enemy && enemy.Enemy.tags && enemy.Enemy.tags.boss)
                        amount = 0.04;
                    else if (enemy.Enemy && enemy.Enemy.tags && enemy.Enemy.tags.miniboss)
                        amount = 0.02;
                    else if (enemy.Enemy && enemy.Enemy.tags && enemy.Enemy.tags.elite)
                        amount = 0.01;
                    if (enemy.Enemy && enemy.Enemy.tags && !enemy.Enemy.tags.minor)
                        amount = 0.004;
                    if (enemy.Enemy && enemy.Enemy.tags && enemy.Enemy.tags.minor)
                        amount = KDRandom() < 0.33 ? 0.004 : 0.001;
                }
                if (amount && !noRepHit && !((_a = enemy.Enemy.Reputation) === null || _a === void 0 ? void 0 : _a.noRepLoss)) {
                    KinkyDungeonChangeFactionRep(faction, -amount);
                    let boostfactions = [];
                    let hurtfactions = [];
                    for (let e of KinkyDungeonEntities) {
                        let dist = KDistChebyshev(e.x - enemy.x, e.y - enemy.y);
                        if (dist < 10) {
                            let faction2 = KDGetFaction(e);
                            if (!KinkyDungeonHiddenFactions.includes(faction2)) {
                                if (KDFactionRelation(faction, faction2) < -0.1 && !boostfactions.includes(faction2)) {
                                    boostfactions.push(faction2);
                                    let mult = 1.0;
                                    if (amount > 0) {
                                        if (KDFactionRelation("Player", faction2) > 0.5)
                                            mult *= 0.05;
                                        else if (KDFactionRelation("Player", faction2) > 0.25)
                                            mult *= 0.5;
                                    }
                                    KinkyDungeonChangeFactionRep(faction2, 0.5 * amount * mult * -KDFactionRelation(faction, faction2));
                                    KDAddFavor(faction2, amount);
                                }
                                else if (KDFactionRelation(faction, faction2) > 0.1 && !hurtfactions.includes(faction2)) {
                                    hurtfactions.push(faction2);
                                    KinkyDungeonChangeFactionRep(faction2, 0.5 * amount * -KDFactionRelation(faction, faction2));
                                }
                            }
                        }
                    }
                }
            }
            else if (!enemy.summoned && !KDIsImmobile(enemy) && !enemy.Enemy.tags.temporary) {
                if (!KDGameData.RespawnQueue)
                    KDGameData.RespawnQueue = [];
                KDGameData.RespawnQueue.push({ enemy: enemy.Enemy.name, faction: KDGetFaction(enemy) });
            }
        }
        if (enemy.ondeath) {
            for (let o of enemy.ondeath) {
                KDOndeath[o.type](enemy, o);
            }
        }
        if (enemy.Enemy.ondeath) {
            for (let o of enemy.Enemy.ondeath) {
                KDOndeath[o.type](enemy, o);
            }
        }
        KDDropItems(enemy);
        return true;
    }
    else if (KDHelpless(enemy)) {
        KDDropStolenItems(enemy);
        if (!enemy.droppedItems)
            KDDropItems(enemy);
    }
    return false;
}
function KDDropItems(enemy) {
    if (!enemy.noDrop && (enemy.playerdmg || !enemy.summoned) && !enemy.droppedItems) {
        KinkyDungeonItemDrop(enemy.x, enemy.y, enemy.Enemy.dropTable, enemy.summoned);
        enemy.droppedItems = true;
        let dropped = null;
        if (enemy.data && enemy.data.shop && KDShops[enemy.data.shop] && KDShops[enemy.data.shop].items) {
            for (let i of KDShops[enemy.data.shop].items) {
                if (!enemy.tempitems || !enemy.tempitems.includes(i)) {
                    dropped = { x: enemy.x, y: enemy.y, name: i };
                    KinkyDungeonGroundItems.push(dropped);
                }
            }
        }
        if (KDEnemyHasFlag(enemy, "Shop")) {
            dropped = { x: enemy.x, y: enemy.y, name: "Gold", amount: 100 };
            KinkyDungeonGroundItems.push(dropped);
        }
    }
}
function KDFavorNPC(Enemy) {
    return Enemy && !Enemy.allied && !Enemy.Enemy.allied;
}
function KDGetFavor(Enemy) {
    if (KDGameData.Favors)
        return KDGameData.Favors[KDGetFactionOriginal(Enemy)] ? KDGameData.Favors[KDGetFactionOriginal(Enemy)] : 0;
    return 0;
}
function KDChangeFavor(Enemy, Amount) {
    KDModFavor(KDGetFactionOriginal(Enemy), Amount);
}
function KDAddFavor(Faction, Amount) {
    KDModFavor(Faction, Math.abs(Amount));
}
function KDModFavor(Faction, Amount) {
    if (!KDGameData.Favors)
        KDGameData.Favors = {};
    if (!KDGameData.Favors[Faction])
        KDGameData.Favors[Faction] = 0;
    KDGameData.Favors[Faction] = Math.max(KDGameData.Favors[Faction] + Amount, 0);
}
function KinkyDungeonCheckLOS(enemy, player, distance, maxdistance, allowBlind, allowBars) {
    let bs = (enemy && enemy.Enemy && enemy.Enemy.blindSight) ? enemy.Enemy.blindSight : 0;
    if (KinkyDungeonStatsChoice.get("KillSquad"))
        bs += 20;
    if (player.player && enemy.Enemy && (enemy.Enemy.playerBlindSight || KDAllied(enemy.Enemy)))
        bs = enemy.Enemy.playerBlindSight;
    return distance <= maxdistance && ((allowBlind && bs >= distance) || KinkyDungeonCheckPath(enemy.x, enemy.y, player.x, player.y, allowBars));
}
function KinkyDungeonTrackSneak(enemy, delta, player, darkmult) {
    if (!enemy.vp)
        enemy.vp = 0;
    if (!player.player)
        return true;
    let sneakThreshold = enemy.Enemy.sneakThreshold ? enemy.Enemy.sneakThreshold : 2;
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak"))
        sneakThreshold = Math.max(0.1, sneakThreshold + KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak"));
    let deltaMult = 0.7 / Math.max(1, (1 + KinkyDungeonSubmissiveMult));
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowDetection"))
        deltaMult *= KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowDetection"));
    if (KDGameData.Outfit) {
        let outfit = KinkyDungeonGetOutfit(KDGameData.Outfit);
        if (outfit && outfit.visibility)
            deltaMult *= outfit.visibility;
    }
    if (KinkyDungeonStatsChoice.get("Conspicuous"))
        deltaMult *= KDConspicuousMult;
    else if (KinkyDungeonStatsChoice.get("Stealthy"))
        deltaMult *= KDStealthyMult;
    if (darkmult) {
        deltaMult *= KDPlayerLight / (darkmult + KDPlayerLight);
    }
    enemy.vp = Math.min(sneakThreshold * 2, enemy.vp + delta * deltaMult);
    return (enemy.vp > sneakThreshold);
}
function KinkyDungeonMultiplicativeStat(Stat) {
    if (Stat > 0) {
        return 1 / (1 + Stat);
    }
    if (Stat < 0) {
        return 1 - Stat;
    }
    return 1;
}
function KDNearbyEnemies(x, y, dist, hostileEnemy) {
    let cache = KDGetEnemyCache();
    let list = [];
    if (!cache) {
        for (let e of KinkyDungeonEntities) {
            if (KDistEuclidean(x - e.x, y - e.y) <= dist && (!hostileEnemy || KDHostile(e, hostileEnemy)))
                list.push(e);
        }
    }
    else {
        let e = null;
        for (let X = Math.floor(x - dist); X < Math.ceil(x + dist); X++)
            for (let Y = Math.floor(y - dist); Y < Math.ceil(y + dist); Y++)
                if (KDistEuclidean(X - x, Y - y) <= dist) {
                    e = cache.get(X + "," + Y);
                    if (e && (!hostileEnemy || KDHostile(e, hostileEnemy)))
                        list.push(e);
                }
    }
    return list;
}
function KDNearbyTiles(x, y, dist) {
    let list = [];
    for (let X = Math.floor(x - dist); X < Math.ceil(x + dist); X++)
        for (let Y = Math.floor(y - dist); Y < Math.ceil(y + dist); Y++)
            if (KDistEuclidean(X - x, Y - y) <= dist) {
                if (KinkyDungeonTilesGet(X + ',' + Y))
                    list.push({ x: X, y: Y, tile: KinkyDungeonTilesGet(X + ',' + Y) });
            }
    return list;
}
function KDNearbyNeutrals(x, y, dist, neutralEnemy) {
    let cache = KDGetEnemyCache();
    let list = [];
    if (!cache) {
        for (let e of KinkyDungeonEntities) {
            if (KDistEuclidean(x - e.x, y - e.y) <= dist && (!neutralEnemy || !KDHostile(e, neutralEnemy)))
                list.push(e);
        }
    }
    else {
        let e = null;
        for (let X = Math.floor(x - dist); X < Math.ceil(x + dist); X++)
            for (let Y = Math.floor(y - dist); Y < Math.ceil(y + dist); Y++)
                if (KDistEuclidean(X - x, Y - y) <= dist) {
                    e = cache.get(X + "," + Y);
                    if (e && (!neutralEnemy || !KDHostile(e, neutralEnemy)))
                        list.push(e);
                }
    }
    return list;
}
function KinkyDungeonGetRandomEnemyPoint(avoidPlayer, onlyPlayer, Enemy, playerDist = 6, minDist = 6) {
    return KinkyDungeonGetRandomEnemyPointCriteria(undefined, avoidPlayer, onlyPlayer, Enemy, playerDist, minDist);
}
function KinkyDungeonGetRandomEnemyPointCriteria(criteria, avoidPlayer, onlyPlayer, Enemy, playerDist = 6, minDist = 6) {
    let tries = 0;
    while (tries < 100) {
        let points = Object.values(KinkyDungeonRandomPathablePoints);
        let point = points[Math.floor(points.length * KDRandom())];
        if (point) {
            let X = point.x;
            let Y = point.y;
            let PlayerEntity = KinkyDungeonNearestPlayer({ x: X, y: Y });
            if (((!avoidPlayer || Math.sqrt((X - PlayerEntity.x) * (X - PlayerEntity.x) + (Y - PlayerEntity.y) * (Y - PlayerEntity.y)) > minDist)
                && (!onlyPlayer || Math.sqrt((X - PlayerEntity.x) * (X - PlayerEntity.x) + (Y - PlayerEntity.y) * (Y - PlayerEntity.y)) <= playerDist))
                && (!KinkyDungeonPointInCell(X, Y)) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(X, Y))
                && (!Enemy || KinkyDungeonNoEnemyExceptSub(X, Y, true, Enemy))
                && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits)
                && (!criteria || criteria(X, Y))) {
                return { x: X, y: Y };
            }
        }
        tries += 1;
    }
    return undefined;
}
function KinkyDungeonGetNearbyPoint(x, y, allowNearPlayer = false, Enemy, Adjacent, ignoreOffLimits, callback) {
    let slots = [];
    for (let X = -Math.ceil(1); X <= Math.ceil(1); X++)
        for (let Y = -Math.ceil(1); Y <= Math.ceil(1); Y++) {
            if ((X != 0 || Y != 0) && KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(x + X, y + Y))) {
                slots.push({ x: x + X, y: y + Y });
                slots.push({ x: x + X, y: y + Y });
                slots.push({ x: x + X, y: y + Y });
                if (!Adjacent)
                    for (let XX = -Math.ceil(1); XX <= Math.ceil(1); XX++)
                        for (let YY = -Math.ceil(1); YY <= Math.ceil(1); YY++) {
                            if ((Math.abs(X + XX) > 1 || Math.abs(Y + YY) > 1) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(x + XX + X, y + YY + Y))) {
                                slots.push({ x: x + XX + X, y: y + YY + Y });
                                slots.push({ x: x + XX + X, y: y + YY + Y });
                                for (let XXX = -Math.ceil(1); XXX <= Math.ceil(1); XXX++)
                                    for (let YYY = -Math.ceil(1); YYY <= Math.ceil(1); YYY++) {
                                        if ((Math.abs(X + XX + XXX) > 2 || Math.abs(Y + YY + YYY) > 2) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(x + XX + XXX + X, y + YYY + YY + Y))) {
                                            slots.push({ x: x + XXX + XX + X, y: y + YYY + YY + Y });
                                        }
                                    }
                            }
                        }
            }
        }
    let foundslot = undefined;
    for (let C = 0; C < 100; C++) {
        let slot = slots[Math.floor(KDRandom() * slots.length)];
        if (slot && KinkyDungeonNoEnemyExceptSub(slot.x, slot.y, false, Enemy) && (ignoreOffLimits || !KinkyDungeonTilesGet(slot.x + "," + slot.y) || (!KinkyDungeonTilesGet(slot.x + "," + slot.y).NoWander && !KinkyDungeonTilesGet(slot.x + "," + slot.y).OffLimits))
            && (allowNearPlayer || Math.max(Math.abs(KinkyDungeonPlayerEntity.x - slot.x), Math.abs(KinkyDungeonPlayerEntity.y - slot.y)) > 1.5)
            && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(slot.x, slot.y))
            && (!callback || callback(slot.x, slot.y))) {
            foundslot = { x: slot.x, y: slot.y };
            C = 100;
        }
        else
            slots.splice(C, 1);
    }
    return foundslot;
}
function KinkyDungeonSetEnemyFlag(enemy, flag, duration) {
    if (!enemy.flags)
        enemy.flags = {};
    if (enemy.flags[flag]) {
        if (duration == 0) {
            delete enemy.flags[flag];
            return;
        }
        if (enemy.flags[flag] == -1)
            return;
        if (enemy.flags[flag] < duration)
            enemy.flags[flag] = duration;
    }
    else if (duration)
        enemy.flags[flag] = duration;
}
function KinkyDungeonTickFlagsEnemy(enemy, delta) {
    if (enemy.flags) {
        for (let f of Object.entries(enemy.flags)) {
            if (f[1] == -1)
                continue;
            if (f[1] <= delta)
                delete enemy.flags[f[0]];
            if (f[1] > 0)
                enemy.flags[f[0]] = f[1] - delta;
        }
    }
}
let KinkyDungeonDamageTaken = false;
let KinkyDungeonTorsoGrabCD = 0;
let KinkyDungeonHuntDownPlayer = false;
function KinkyDungeonHasStatus(enemy) {
    return enemy && (enemy.bind > 0 || enemy.slow > 0 || enemy.stun > 0 || enemy.freeze > 0 || enemy.silence > 0 || KinkyDungeonIsSlowed(enemy) || KDBoundEffects(enemy) > 0);
}
function KinkyDungeonIsDisabled(enemy) {
    return enemy && (enemy.stun > 0 || enemy.freeze > 0 || KDBoundEffects(enemy) > 3);
}
function KinkyDungeonIsSlowed(enemy) {
    return enemy && ((KDBoundEffects(enemy) > 0 && KDBoundEffects(enemy) < 4) || enemy.slow > 0 || KinkyDungeonGetBuffedStat(enemy.buffs, "MoveSpeed") < 0);
}
function KinkyDungeonCanCastSpells(enemy) {
    return enemy && !(KinkyDungeonIsDisabled(enemy) || enemy.silence > 0);
}
function KDCanBind(enemy) {
    var _a;
    return (((_a = enemy === null || enemy === void 0 ? void 0 : enemy.Enemy) === null || _a === void 0 ? void 0 : _a.bound) != undefined);
}
function KDBoundEffects(enemy) {
    if (!enemy.Enemy.bound)
        return 0;
    if (!enemy.boundLevel)
        return 0;
    let boundLevel = enemy.boundLevel ? enemy.boundLevel : 0;
    let bindAmp = KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BindAmp"));
    boundLevel *= bindAmp;
    if (boundLevel > enemy.Enemy.maxhp || (enemy.hp <= 0.1 * enemy.Enemy.maxhp && boundLevel > enemy.hp))
        return 4;
    if (boundLevel > enemy.Enemy.maxhp * 0.75)
        return 3;
    if (boundLevel > enemy.Enemy.maxhp * 0.5)
        return 2;
    if (boundLevel > enemy.Enemy.maxhp * 0.25)
        return 1;
    return 0;
}
function KinkyDungeonUpdateEnemies(delta, Allied) {
    var _a, _b;
    let tickAlertTimer = false;
    let tickAlertTimerFactions = [];
    let visionMod = 1.0;
    let defeat = false;
    if (Allied) {
        KinkyDungeonUpdateDialogue(KinkyDungeonPlayerEntity, delta);
        let KinkyDungeonSummons = 0;
        for (let i = KinkyDungeonEntities.length - 1; i >= 0; i--) {
            let enemy = KinkyDungeonEntities[i];
            KinkyDungeonUpdateDialogue(enemy, delta);
            if (KDAllied(enemy) && enemy.summoned && enemy.Enemy.allied && enemy.Enemy.CountLimit && (!enemy.lifetime || enemy.lifetime > 999)) {
                KinkyDungeonSummons += 1;
                if (KinkyDungeonSummons > KinkyDungeonSummonCount) {
                    enemy.hp -= Math.max(0.1 * enemy.hp) + 1;
                }
            }
        }
    }
    else {
        if (KinkyDungeonTorsoGrabCD > 0)
            KinkyDungeonTorsoGrabCD -= 1;
        if (KDGameData.KinkyDungeonLeashedPlayer > 0) {
            KDGameData.KinkyDungeonLeashedPlayer -= 1;
            let nearestJail = KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
            if (nearestJail) {
                let xx = nearestJail.x;
                let yy = nearestJail.y;
                let jaildoor = KDGetJailDoor(xx, yy).tile;
                if (jaildoor && jaildoor.Type == "Door") {
                    jaildoor.Lock = undefined;
                }
            }
        }
        KinkyDungeonUpdateFlags(delta);
    }
    KDGameData.DollCount = 0;
    for (let enemy of KinkyDungeonEntities) {
        if ((Allied && KDAllied(enemy)) || (!Allied && !KDAllied(enemy))) {
            let tile = KinkyDungeonTilesGet(enemy.x + "," + enemy.y);
            if (tile === null || tile === void 0 ? void 0 : tile.OffLimits) {
                KinkyDungeonSetEnemyFlag(enemy, "wander", 0);
            }
            if (enemy.Enemy.tags.doll)
                KDGameData.DollCount += 1;
            let master = KinkyDungeonFindMaster(enemy).master;
            if (master && enemy.aware)
                master.aware = true;
            if (master && master.aware)
                enemy.aware = true;
            if (enemy.Enemy.master && enemy.Enemy.master.dependent && !master)
                enemy.hp = -10000;
            else if ((_a = enemy.Enemy.master) === null || _a === void 0 ? void 0 : _a.dependent)
                enemy.boundTo = master.id;
            if (!enemy.castCooldown)
                enemy.castCooldown = 0;
            if (enemy.castCooldown > 0) {
                let cdmult = enemy.distraction ? 1 / (1 + enemy.distraction / enemy.Enemy.maxhp) : 1;
                cdmult = cdmult * KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(enemy.buffs, "CastSpeed"));
                enemy.castCooldown = Math.max(0, enemy.castCooldown - delta * cdmult);
                if (enemy.castCooldown <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "specialCD" });
            }
            if (!enemy.castCooldownSpecial)
                enemy.castCooldownSpecial = 0;
            if (enemy.castCooldownSpecial > 0) {
                enemy.castCooldownSpecial = Math.max(0, enemy.castCooldownSpecial - delta);
                if (enemy.castCooldownSpecial <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "castCooldownSpecial" });
            }
            if (enemy.Enemy.specialCharges && enemy.specialCharges <= 0)
                enemy.specialCD = 999;
            KinkyDungeonTickFlagsEnemy(enemy, delta);
            if (enemy.specialCD > 0) {
                enemy.specialCD -= delta;
                if (enemy.specialCD <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "specialCD" });
            }
            if (enemy.slow > 0) {
                enemy.slow -= delta;
                if (enemy.slow <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "slow" });
            }
            if (enemy.boundLevel > 0 && !(enemy.stun > 0 || enemy.freeze > 0) && (enemy.hp > enemy.Enemy.maxhp * 0.1)) {
                let SM = KDGetEnemyStruggleMod(enemy);
                let newBound = KDPredictStruggle(enemy, SM, delta);
                enemy.boundLevel = newBound.boundLevel;
                enemy.specialBoundLevel = newBound.specialBoundLevel;
                let SR = SM * (10 + Math.pow(Math.max(0.01, enemy.hp), 0.75));
                if (SR <= 0 || KDRandom() < 0.1) {
                    KDAddThought(enemy.id, "GiveUp", 5, SR <= 0 ? 4 : 1);
                }
                else {
                    if (KDLoosePersonalities.includes(enemy.personality)) {
                        KDAddThought(enemy.id, "Embarrassed", 2, 4);
                    }
                    else if (KDStrictPersonalities.includes(enemy.personality)) {
                        KDAddThought(enemy.id, "Struggle", 2, 2);
                    }
                    else {
                        KDAddThought(enemy.id, "Annoyed", 2, 2);
                    }
                }
                if (enemy.boundLevel <= 0) {
                    KDAddThought(enemy.id, "Annoyed", 5, 1);
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "boundLevel" });
                }
            }
            let vibe = KDEntityBuffedStat(enemy, "Vibration");
            if (enemy.distraction > 0 || vibe) {
                let DD = KDGetEnemyDistractionDamage(enemy, vibe);
                if (DD > 0) {
                    KinkyDungeonDamageEnemy(enemy, {
                        damage: DD,
                        type: "charm",
                    }, true, true);
                }
                let DR = KDGetEnemyDistractRate(enemy, vibe);
                if (enemy.distraction > enemy.Enemy.maxhp) {
                    enemy.distraction = enemy.Enemy.maxhp;
                    KDAddThought(enemy.id, "Embarrassed", 7, 1);
                }
                else {
                    if (DR <= 0 || KDRandom() < 0.1) {
                        KDAddThought(enemy.id, "GiveUp", 5, DR <= 0 ? 4 : 1);
                    }
                    else {
                        if (KDLoosePersonalities.includes(enemy.personality)) {
                            KDAddThought(enemy.id, "Play", 1, 4);
                        }
                        else if (KDStrictPersonalities.includes(enemy.personality)) {
                            KDAddThought(enemy.id, "Annoyed", 1, 3);
                        }
                        else {
                            KDAddThought(enemy.id, "Embarrassed", 1, 2);
                        }
                    }
                }
                enemy.distraction = Math.max(0, Math.min((enemy.distraction || 0) - delta * DR, enemy.Enemy.maxhp));
                if (enemy.distraction <= 0) {
                    KDAddThought(enemy.id, "Annoyed", 5, 1);
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "boundLevel" });
                }
            }
            let bindLevel = KDBoundEffects(enemy);
            let statusBonus = 1;
            if (enemy.Enemy.tags.unstoppable)
                statusBonus *= 4;
            else if (enemy.Enemy.tags.unflinching)
                statusBonus *= 2;
            if (enemy.Enemy.rage)
                enemy.rage = 9999;
            if (enemy.bind > 0) {
                enemy.bind -= delta;
                if (enemy.bind <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "bind" });
            }
            if (enemy.rage > 0) {
                enemy.rage -= delta;
                if (enemy.rage <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "rage" });
            }
            if (enemy.hostile > 0) {
                enemy.hostile -= delta;
                if (enemy.hostile <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "hostile" });
            }
            if (enemy.allied > 0 && enemy.allied < 9000) {
                enemy.allied -= delta;
                if (enemy.allied <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "allied" });
            }
            if (enemy.ceasefire > 0 && enemy.ceasefire < 9000) {
                enemy.ceasefire -= delta;
                if (enemy.ceasefire <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "ceasefire" });
            }
            if (enemy.blind > 0 && bindLevel < 4) {
                enemy.blind -= delta * statusBonus / (1 + 1 * bindLevel);
                if (enemy.blind <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "blind" });
            }
            if (enemy.disarm > 0 && bindLevel < 4) {
                enemy.disarm -= delta * statusBonus / (1 + 1 * bindLevel);
                if (enemy.disarm <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "disarm" });
            }
            if (enemy.playWithPlayer > 0) {
                enemy.playWithPlayer -= delta;
                if (enemy.playWithPlayer <= 0) {
                    if (!KinkyDungeonAggressive(enemy)) {
                        KDResetIntent(enemy, AIData);
                        KDAddThought(enemy.id, "Happy", 5, 1);
                    }
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "playWithPlayer" });
                }
            }
            else
                enemy.playWithPlayer = 0;
            if (enemy.playWithPlayerCD > 0) {
                enemy.playWithPlayerCD -= delta;
                if (enemy.playWithPlayerCD <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "playWithPlayerCD" });
            }
            if (enemy.silence > 0 && bindLevel < 4) {
                enemy.silence -= delta * statusBonus / (1 + 1 * bindLevel);
                if (enemy.silence <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "silence" });
            }
            if (enemy.disarmflag > 0 && enemy.Enemy.disarm && KinkyDungeonLastAction != "Attack") {
                enemy.disarmflag = Math.max(0, enemy.disarmflag - enemy.Enemy.disarm);
                if (enemy.disarmflag <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "disarmflag" });
            }
            if (enemy.stun > 0 || enemy.freeze > 0) {
                enemy.warningTiles = [];
                enemy.disarmflag = 0;
                enemy.fx = undefined;
                enemy.fy = undefined;
                if (enemy.stun > 0 && enemy.stun <= delta)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "stun" });
                if (enemy.freeze > 0 && enemy.freeze <= delta)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "freeze" });
                let smult = 1 - 0.167 * KDBoundEffects(enemy);
                let fmult = KDHelpless(enemy) ? 0.1 : 1 - 0.2 * KDBoundEffects(enemy);
                if (enemy.stun > 0)
                    enemy.stun = Math.max(enemy.stun - delta * smult, 0);
                if (enemy.freeze > 0)
                    enemy.freeze = Math.max(enemy.freeze - delta * fmult, 0);
            }
            else if (enemy.channel > 0) {
                enemy.warningTiles = [];
                if (enemy.channel > 0)
                    enemy.channel -= delta;
                if (enemy.channel <= 0)
                    KinkyDungeonSendEvent("enemyStatusEnd", { enemy: enemy, status: "channel" });
            }
        }
    }
    KDGameData.otherPlaying = 0;
    for (let E = 0; E < KinkyDungeonEntities.length; E++) {
        let enemy = KinkyDungeonEntities[E];
        if ((Allied && KDAllied(enemy)) || (!Allied && !KDAllied(enemy))) {
            if (enemy.vulnerable > 0)
                enemy.vulnerable -= delta;
            else
                enemy.vulnerable = 0;
            if (enemy.Enemy.tags.nonvulnerable && enemy.vulnerable)
                enemy.vulnerable = 0;
            if (!(KDGameData.KinkyDungeonPenance && KinkyDungeonAngel()) || enemy == KinkyDungeonAngel()) {
                if (KinkyDungeonEnemyCheckHP(enemy, E)) {
                    E -= 1;
                    continue;
                }
                let player = (!KinkyDungeonAngel()) ? KinkyDungeonNearestPlayer(enemy, false, true, enemy.Enemy.visionRadius ? (enemy.Enemy.visionRadius + ((enemy.lifetime > 0 && enemy.Enemy.visionSummoned) ? enemy.Enemy.visionSummoned : 0)) : 0, AIData) : KinkyDungeonPlayerEntity;
                if (enemy.Enemy.convertTiles) {
                    let tile = KinkyDungeonMapGet(enemy.x, enemy.y);
                    for (let c of enemy.Enemy.convertTiles) {
                        if (c.from == tile && c.to) {
                            KinkyDungeonMapSet(enemy.x, enemy.y, c.to);
                        }
                    }
                }
                KinkyDungeonHandleTilesEnemy(enemy, delta);
                if (enemy.Enemy.triggersTraps) {
                    KinkyDungeonHandleTraps(enemy, enemy.x, enemy.y, true);
                }
                let idle = true;
                if (!(KinkyDungeonIsDisabled(enemy)
                    || KDHelpless(enemy)
                    || enemy.channel > 0)) {
                    let start = performance.now();
                    let playerItems = [];
                    for (let inv of KinkyDungeonAllWeapon()) {
                        if (inv.name != "Unarmed")
                            playerItems.push(inv);
                    }
                    for (let inv of KinkyDungeonAllConsumable()) {
                        playerItems.push(inv);
                    }
                    let ret = KinkyDungeonEnemyLoop(enemy, player, delta, visionMod, playerItems);
                    if (enemy.playWithPlayer)
                        KDGameData.otherPlaying += 1;
                    idle = ret.idle;
                    if (ret.defeat) {
                        defeat = true;
                    }
                    if (enemy.items && !KDEnemyHasFlag(enemy, "shop")) {
                        let light = KinkyDungeonVisionGet(enemy.x, enemy.y);
                        if (light == 0 && !enemy.aware && KDRandom() < 0.2) {
                            KDRestockRestraints(enemy, ((_b = enemy.Enemy.RestraintFilter) === null || _b === void 0 ? void 0 : _b.restockPercent) || 0.5);
                        }
                    }
                    if (idle && enemy.hp > 0) {
                        if (enemy == KinkyDungeonJailGuard())
                            KDCaptureNearby(enemy);
                    }
                    let end = performance.now();
                    if (KDDebug)
                        console.log(`Took ${end - start} milliseconds to run loop for enemy ${enemy.Enemy.name}`);
                }
                else {
                    enemy.disarmflag = 0;
                    enemy.fx = undefined;
                    enemy.fy = undefined;
                }
                if (KDHelpless(enemy))
                    enemy.playWithPlayer = 0;
                if (idle) {
                    enemy.movePoints = 0;
                    enemy.attackPoints = 0;
                    enemy.warningTiles = [];
                }
                KinkyDungeonHandleTilesEnemy(enemy, delta);
                if (enemy.vp > 0 && (!enemy.path || enemy.path.length < 4)) {
                    let sneakThreshold = enemy.Enemy.sneakThreshold ? enemy.Enemy.sneakThreshold : 2;
                    if (enemy.vp > sneakThreshold * 2 && !enemy.aware) {
                        let sneak = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak");
                        if (sneak > 0)
                            enemy.vp = Math.max(sneakThreshold + 1, Math.max(Math.min(enemy.vp, sneakThreshold), enemy.vp * 0.7 - 0.1));
                    }
                    enemy.vp = Math.max(0, enemy.vp - 0.1);
                }
                if (KinkyDungeonEnemyCheckHP(enemy, E)) {
                    E -= 1;
                }
                else {
                    if (enemy.aware && (enemy.lifetime == undefined || enemy.lifetime > 9000) && !enemy.Enemy.tags.temporary && !enemy.Enemy.tags.peaceful) {
                        if (enemy.hostile > 0 && enemy.hostile < 9000 && (KDGameData.PrisonerState == 'parole' || KDGameData.PrisonerState == 'jail')) {
                            if (!(enemy.silence > 0)) {
                                tickAlertTimer = true;
                                if (KDistChebyshev(KinkyDungeonPlayerEntity.x - enemy.x, KinkyDungeonPlayerEntity.y - enemy.y) < 9 && !tickAlertTimerFactions.includes(KDGetFaction(enemy))) {
                                    tickAlertTimerFactions.push(KDGetFaction(enemy));
                                }
                            }
                        }
                        else if (KinkyDungeonAggressive(enemy)) {
                            if (!(enemy.silence > 0)) {
                                tickAlertTimer = true;
                                if (KDistChebyshev(KinkyDungeonPlayerEntity.x - enemy.x, KinkyDungeonPlayerEntity.y - enemy.y) < 9 && !tickAlertTimerFactions.includes(KDGetFaction(enemy))) {
                                    tickAlertTimerFactions.push(KDGetFaction(enemy));
                                }
                            }
                        }
                    }
                }
                if (enemy.Enemy.regen && (enemy.hp > 0.01 || enemy.Enemy.regen < 0))
                    enemy.hp = Math.min(enemy.Enemy.maxhp, enemy.hp + enemy.Enemy.regen * delta);
                if (enemy.Enemy.lifespan || enemy.lifetime != undefined) {
                    if (enemy.lifetime == undefined)
                        enemy.lifetime = enemy.Enemy.lifespan;
                    if (enemy.lifetime <= 9000)
                        enemy.lifetime -= delta;
                    if (enemy.lifetime <= 0)
                        enemy.hp = -10000;
                }
                if (enemy.boundTo) {
                    if (enemy.boundTo == -1) {
                        if (KDPlayerIsDefeated())
                            enemy.hp = 0;
                        if (enemy.weakBinding && KDPlayerIsStunned())
                            enemy.hp = 0;
                    }
                    else if (!KinkyDungeonFindID(enemy.boundTo) || KDHelpless(KinkyDungeonFindID(enemy.boundTo)) || (enemy.weakBinding && KinkyDungeonIsDisabled(KinkyDungeonFindID(enemy.boundTo))))
                        enemy.hp = 0;
                }
            }
        }
    }
    if (!Allied) {
        for (let i = KinkyDungeonEntities.length - 1; i >= 0; i--) {
            let enemy = KinkyDungeonEntities[i];
            KDCheckVulnerableBackstab(enemy);
            if (!KDAllied(enemy) && !(enemy.ceasefire > 0)) {
                if (!(enemy.hostile > 0) && tickAlertTimerFactions.length > 0 && !KinkyDungeonAggressive(enemy) && !enemy.Enemy.tags.peaceful && (enemy.vp > 0.5 || enemy.lifetime < 900 || (!KDHostile(enemy) && KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 7))) {
                    for (let f of tickAlertTimerFactions) {
                        if ((KDGetFaction(enemy) != "Player") && ((KDFactionRelation(f, KDGetFaction(enemy)) > 0.15 && KDFactionRelation(f, KDGetFaction(enemy)) < 0.5 &&
                            KDFactionRelation("Player", KDGetFaction(enemy)) < 0.2)
                            || (KDFactionRelation(f, KDGetFaction(enemy)) >= 0.5 &&
                                KDFactionRelation("Player", KDGetFaction(enemy)) < 0.4))) {
                            KDMakeHostile(enemy, KDMaxAlertTimer);
                        }
                    }
                }
            }
        }
        let alertingFaction = false;
        for (let f of tickAlertTimerFactions) {
            if (KDFactionRelation("Jail", f) > -0.01 && KDFactionRelation("Chase", f) > -0.01) {
                alertingFaction = true;
            }
        }
        if (tickAlertTimer && (KDGameData.PrisonerState == 'parole' || KDGameData.PrisonerState == 'jail') && alertingFaction) {
            if (KDGameData.AlertTimer < 3 * KDMaxAlertTimer)
                KDGameData.AlertTimer += delta;
        }
        else if (KDGameData.AlertTimer > 0) {
            KDGameData.AlertTimer -= delta * 3;
        }
        if (KDGameData.AlertTimer >= KDMaxAlertTimer) {
            KinkyDungeonStartChase(undefined, "Alert");
        }
        KinkyDungeonHandleJailSpawns(delta);
        KinkyDungeonHandleWanderingSpawns(delta);
        KinkyDungeonAlert = 0;
    }
    if (defeat) {
        KinkyDungeonDefeat(KinkyDungeonFlags.has("LeashToPrison"));
    }
}
function KDMakeHostile(enemy, timer) {
    if (!timer)
        timer = KDMaxAlertTimerAggro;
    if (!enemy.hostile)
        enemy.hostile = timer;
    else
        enemy.hostile = Math.max(enemy.hostile, timer);
}
function KDCheckVulnerableBackstab(enemy) {
    if (KinkyDungeonAggressive(enemy) && enemy != KinkyDungeonLeashingEnemy()) {
        if (enemy.fx && enemy.fy && KDistChebyshev(enemy.fx - enemy.x, enemy.fy - enemy.y) < 1.5 && !enemy.Enemy.tags.noflank) {
            if (enemy.x * 2 - enemy.fx == KinkyDungeonPlayerEntity.x && enemy.y * 2 - enemy.fy == KinkyDungeonPlayerEntity.y) {
                KDAddThought(enemy.id, "Annoyed", 4, 1);
                enemy.vulnerable = Math.max(enemy.vulnerable, 1);
                return true;
            }
        }
    }
    return false;
}
function KDGetAI(enemy) {
    if (enemy.AI)
        return enemy.AI;
    else
        return enemy.Enemy.AI;
}
let KDThoughtBubbles = new Map();
function KDAddThought(id, name, priority, duration) {
    let pri = -1;
    let n = "";
    let i = 0;
    let d = 1;
    if (KDThoughtBubbles.has(id)) {
        pri = KDThoughtBubbles.get(id).priority;
        n = KDThoughtBubbles.get(id).name;
        d = KDThoughtBubbles.get(id).duration;
        i = KDThoughtBubbles.get(id).index;
    }
    if (priority > pri || (n != name && KinkyDungeonCurrentTick > d + i) || (n != name && priority >= pri)) {
        KDThoughtBubbles.set(id, {
            name: name,
            priority: priority,
            duration: duration,
            index: KinkyDungeonCurrentTick,
        });
    }
}
function KDEnemyCanTalk(enemy) {
    return enemy.Enemy && !enemy.Enemy.gagged && (enemy.Enemy.tags.jailer || enemy.Enemy.tags.jail || enemy.Enemy.playLine) && !(enemy.silence > 0);
}
let AIData = {};
function KinkyDungeonEnemyLoop(enemy, player, delta, visionMod, playerItems) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    AIData = {};
    AIData.defeat = false;
    AIData.idle = true;
    AIData.moved = false;
    AIData.ignore = false;
    AIData.visionMod = visionMod;
    AIData.followRange = enemy.Enemy.followRange == 1 ? 1.5 : enemy.Enemy.followRange;
    AIData.visionRadius = enemy.Enemy.visionRadius ? (enemy.Enemy.visionRadius + ((enemy.lifetime > 0 && enemy.Enemy.visionSummoned) ? enemy.Enemy.visionSummoned : 0)) : 0;
    let AIType = KDAIType[enemy.AI ? enemy.AI : enemy.Enemy.AI];
    if (AIData.visionMod && AIData.visionRadius > 1.5)
        AIData.visionRadius = Math.max(1.5, AIData.visionRadius * AIData.visionMod);
    AIData.chaseRadius = (((_a = enemy.Enemy.Awareness) === null || _a === void 0 ? void 0 : _a.chaseradius) != undefined) ? enemy.Enemy.Awareness.chaseradius
        : 10 + 1.5 * (Math.max(AIData.followRange, 0)) + 1.5 * Math.max(AIData.visionRadius ? AIData.visionRadius : 0, enemy.Enemy.blindSight ? enemy.Enemy.blindSight : 0);
    AIData.blindSight = (enemy && enemy.Enemy && enemy.Enemy.blindSight) ? enemy.Enemy.blindSight : 0;
    if (KinkyDungeonStatsChoice.get("KillSquad")) {
        AIData.visionRadius *= 2;
        AIData.chaseRadius *= 2;
        AIData.blindSight += 20;
        if (AIData.blindSight > AIData.visionRadius) {
            AIData.visionRadius = AIData.blindSight;
        }
        if (AIData.blindSight > AIData.chaseRadius) {
            AIData.chaseRadius = AIData.blindSight;
        }
    }
    AIData.ignoreLocks = enemy.Enemy.keys || enemy.keys || enemy == KinkyDungeonJailGuard() || (KDEnemyHasFlag(enemy, "keys"));
    AIData.harmless = (KinkyDungeonPlayerDamage.dmg <= enemy.Enemy.armor || !KinkyDungeonHasWill(0.1)) && !KinkyDungeonFlags.has("PlayerCombat") && !KinkyDungeonCanTalk() && !KinkyDungeonCanUseWeapon() && KinkyDungeonSlowLevel > 1;
    AIData.playerDist = Math.sqrt((enemy.x - player.x) * (enemy.x - player.x) + (enemy.y - player.y) * (enemy.y - player.y));
    AIData.hostile = KDHostile(enemy);
    AIData.aggressive = KinkyDungeonAggressive(enemy);
    AIData.domMe = (player.player && AIData.aggressive) ? false : KDCanDom(enemy);
    AIData.leashing = enemy.Enemy.tags.leashing && KDFactionRelation(KDGetFaction(enemy), "Jail") > -0.1;
    AIData.highdistraction = enemy.distraction > 0 && enemy.distraction >= enemy.Enemy.maxhp * 0.9;
    AIData.distracted = AIData.highdistraction && KDLoosePersonalities.includes(enemy.personality);
    if (player.player && !KDAllied(enemy)) {
        if (AIData.playerDist < 1.5 && KinkyDungeonAllRestraint().some((r) => { return KDRestraint(r).ignoreNear; }))
            AIData.ignore = true;
        if (!AIData.leashing && !KinkyDungeonHasWill(0.1) && KinkyDungeonAllRestraint().some((r) => { return KDRestraint(r).ignoreIfNotLeash; }))
            AIData.ignore = true;
        if (!KinkyDungeonFlags.has("PlayerCombat") || enemy.Enemy.tags.ignorebrat) {
            if (enemy.Enemy.tags.ignorenoSP && !KinkyDungeonHasWill(0.1))
                AIData.ignore = true;
            if ((KDGetFaction(enemy) == "Ambush" || enemy.Enemy.tags.ignoreharmless) && (!enemy.warningTiles || enemy.warningTiles.length == 0)
                && AIData.harmless && (!enemy.Enemy.ignorechance || KDRandom() < enemy.Enemy.ignorechance || !KinkyDungeonHasWill(0.1)))
                AIData.ignore = true;
            if (enemy.Enemy.tags.ignoretiedup && (!enemy.warningTiles || enemy.warningTiles.length == 0) && enemy.lifetime == undefined
                && KinkyDungeonCanUseWeapon() && !KinkyDungeonCanTalk() && KinkyDungeonCanUseWeapon() && KinkyDungeonSlowLevel > 1
                && (!enemy.Enemy.ignorechance || KDRandom() < enemy.Enemy.ignorechance || !KinkyDungeonHasWill(0.1)))
                AIData.ignore = true;
            if (enemy.Enemy.tags.ignoregagged && (!enemy.warningTiles || enemy.warningTiles.length == 0) && enemy.lifetime == undefined
                && !KinkyDungeonCanTalk()
                && (!enemy.Enemy.ignorechance || KDRandom() < enemy.Enemy.ignorechance || !KinkyDungeonHasWill(0.1)))
                AIData.ignore = true;
            if (enemy.Enemy.tags.ignoreboundhands && (!enemy.warningTiles || enemy.warningTiles.length == 0) && enemy.lifetime == undefined
                && (KinkyDungeonPlayerDamage.dmg <= enemy.Enemy.armor || !KinkyDungeonHasWill(0.1)) && KinkyDungeonCanUseWeapon()
                && (!enemy.Enemy.ignorechance || KDRandom() < enemy.Enemy.ignorechance || !KinkyDungeonHasWill(0.1)))
                AIData.ignore = true;
        }
        if (enemy.Enemy.ignoreflag) {
            for (let f of enemy.Enemy.ignoreflag) {
                if (KinkyDungeonFlags.get(f))
                    AIData.ignore = true;
            }
        }
        if (enemy.Enemy.tags.leashing && !AIData.leashing && !KinkyDungeonHasWill(0.1) && KinkyDungeonCanUseWeapon()) {
            AIData.ignore = true;
        }
        if (!AIData.aggressive && !(enemy.rage > 0) && !enemy.Enemy.alwaysHostile && (!enemy.playWithPlayer || !player.player))
            AIData.ignore = true;
        if (AIData.distracted)
            AIData.ignore = true;
        if (KinkyDungeonFlags.get("PlayerDommed") && !KDPlayerDeservesPunishment(enemy, player))
            AIData.ignore = true;
    }
    AIData.MovableTiles = KinkyDungeonMovableTilesEnemy;
    AIData.AvoidTiles = "" + KDDefaultAvoidTiles;
    if (enemy.Enemy.tags && enemy.Enemy.tags.opendoors)
        AIData.MovableTiles = KinkyDungeonMovableTilesSmartEnemy;
    if (enemy.Enemy.ethereal) {
        AIData.AvoidTiles = "";
        AIData.MovableTiles = AIData.MovableTiles + "1X";
    }
    else if (enemy.Enemy.squeeze && KDGameData.KinkyDungeonLeashingEnemy != enemy.id) {
        AIData.MovableTiles = AIData.MovableTiles + 'b';
        AIData.AvoidTiles = "";
    }
    AIData.attack = enemy.Enemy.attack;
    AIData.range = enemy.Enemy.attackRange == 1 ? 1.5 : enemy.Enemy.attackRange;
    AIData.width = enemy.Enemy.attackWidth;
    AIData.bindLevel = KDBoundEffects(enemy);
    AIData.accuracy = enemy.Enemy.accuracy ? enemy.Enemy.accuracy : 1.0;
    if (enemy.distraction)
        AIData.accuracy = AIData.accuracy / (1 + 1.5 * enemy.distraction / enemy.Enemy.maxhp);
    if (AIData.bindLevel)
        AIData.accuracy = AIData.accuracy / (1 + 0.5 * AIData.bindLevel);
    if (enemy.blind > 0)
        AIData.accuracy = 0;
    AIData.vibe = false;
    AIData.damage = enemy.Enemy.dmgType;
    AIData.power = enemy.Enemy.power;
    AIData.targetRestraintLevel = 0.25 + (enemy.aggro && !enemy.playWithPlayer ? enemy.aggro : 0) + 0.004 * (KinkyDungeonGoddessRep.Prisoner + 50);
    if (enemy.aggro > 0 && delta > 0)
        enemy.aggro = enemy.aggro * 0.95;
    if (KinkyDungeonStatsChoice.has("NoWayOut") || KinkyDungeonCanPlay(enemy) || enemy.hp < enemy.Enemy.maxhp * 0.5)
        AIData.targetRestraintLevel = 999;
    if ((_b = enemy.Enemy.Behavior) === null || _b === void 0 ? void 0 : _b.thorough)
        AIData.targetRestraintLevel = Math.max(AIData.targetRestraintLevel, (_c = enemy.Enemy.Behavior) === null || _c === void 0 ? void 0 : _c.thorough);
    AIData.addLeash = AIData.leashing && KDBoundPowerLevel >= AIData.targetRestraintLevel && (!KinkyDungeonGetRestraintItem("ItemNeck") || !KinkyDungeonGetRestraintItem("ItemNeckRestraints"));
    if (!AIData.addLeash && AIData.leashing && enemy.IntentLeashPoint && (!KinkyDungeonGetRestraintItem("ItemNeck") || !KinkyDungeonGetRestraintItem("ItemNeckRestraints")))
        AIData.addLeash = true;
    if (enemy.Enemy.tags && AIData.leashing && (!KinkyDungeonHasWill(0.1) || AIData.addLeash)) {
        AIData.followRange = 1.5;
        if (!AIData.attack.includes("Bind"))
            AIData.attack = "Bind" + AIData.attack;
    }
    AIData.refreshWarningTiles = false;
    AIData.hitsfx = (enemy.Enemy && enemy.Enemy.hitsfx) ? enemy.Enemy.hitsfx : "";
    if (KinkyDungeonAlert && AIData.playerDist < KinkyDungeonAlert) {
        if (KDPlayerLight < 1.5 && AIData.playerDist < KinkyDungeonAlert * 0.5) {
            if (!enemy.aware && AIData.aggressive)
                KDAddThought(enemy.id, "Blind", 3, 3);
        }
        else {
            if (!enemy.aware && AIData.aggressive)
                KDAddThought(enemy.id, "Aware", 3, 3);
            enemy.aware = true;
            if (!enemy.aggro)
                enemy.aggro = 0;
            enemy.aggro += 0.1;
        }
    }
    let specialCondition = enemy.Enemy.specialAttack != undefined && (!enemy.specialCD || enemy.specialCD <= 0) && (!enemy.Enemy.specialMinrange || AIData.playerDist > enemy.Enemy.specialMinrange);
    let specialConditionSpecial = (enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialCondition) ? KDSpecialConditions[enemy.Enemy.specialCondition].criteria(enemy, AIData) : true;
    if (!enemy.attackPoints && specialCondition && specialConditionSpecial) {
        AIData.attack = AIData.attack + enemy.Enemy.specialAttack;
        AIData.refreshWarningTiles = !enemy.usingSpecial;
        enemy.usingSpecial = true;
        if (enemy.Enemy && enemy.Enemy.hitsfxSpecial)
            AIData.hitsfx = enemy.Enemy.hitsfxSpecial;
        if (enemy.Enemy.specialRemove)
            AIData.attack = AIData.attack.replace(enemy.Enemy.specialRemove, "");
        if (enemy.Enemy.specialRange && enemy.usingSpecial) {
            AIData.range = enemy.Enemy.specialRange == 1 ? 1.5 : enemy.Enemy.specialRange;
        }
        if (enemy.Enemy.specialWidth && enemy.usingSpecial) {
            AIData.width = enemy.Enemy.specialWidth;
        }
        if (enemy.Enemy.specialPower && enemy.usingSpecial) {
            AIData.power = enemy.Enemy.specialPower;
        }
        if (enemy.Enemy.specialDamage && enemy.usingSpecial) {
            AIData.damage = enemy.Enemy.specialDamage;
        }
    }
    if (enemy.usingSpecial && !specialConditionSpecial) {
        enemy.usingSpecial = false;
        if (KDSpecialConditions[enemy.Enemy.specialCondition].resetCD)
            enemy.specialCD = enemy.Enemy.specialCD;
    }
    AIData.addMoreRestraints = KinkyDungeonStatsChoice.has("NoWayOut") || !AIData.leashing || (AIData.attack.includes("Bind")
        && (KDBoundPowerLevel < AIData.targetRestraintLevel
            || (enemy.Enemy.Behavior && (((_d = enemy.Enemy.Behavior.ensureGroupTied) === null || _d === void 0 ? void 0 : _d.some((group) => { return KinkyDungeonGetRestraintItem(group) != undefined; }))
                || ((_e = enemy.Enemy.Behavior.ensurePlayerTag) === null || _e === void 0 ? void 0 : _e.some((tag) => { return KinkyDungeonPlayerTags.has(tag); }))
                || (KinkyDungeonStatsChoice.get("arousalMode") &&
                    (((_f = enemy.Enemy.Behavior.ensureGroupTied) === null || _f === void 0 ? void 0 : _f.some((group) => { return KinkyDungeonGetRestraintItem(group) != undefined; }))
                        || ((_g = enemy.Enemy.Behavior.ensurePlayerTag) === null || _g === void 0 ? void 0 : _g.some((tag) => { return KinkyDungeonPlayerTags.has(tag); }))))))
            || !KinkyDungeonIsArmsBound()));
    if (!enemy.Enemy.attackWhileMoving && AIData.range > AIData.followRange) {
        AIData.followRange = AIData.range;
    }
    if (player.player && enemy.Enemy && enemy.Enemy.playerFollowRange)
        AIData.followRange = enemy.Enemy.playerFollowRange == 1.5 ? 1.5 : enemy.Enemy.playerFollowRange;
    if (!enemy.warningTiles)
        enemy.warningTiles = [];
    AIData.canSensePlayer = !AIData.distracted && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.visionRadius, true, true);
    AIData.canSeePlayer = !AIData.distracted && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.visionRadius, false, false);
    AIData.canSeePlayerChase = !AIData.distracted && (enemy.aware ? KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.chaseRadius, false, false) : false);
    AIData.canSeePlayerMedium = !AIData.distracted && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.visionRadius / 1.4, false, true);
    AIData.canSeePlayerClose = !AIData.distracted && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.visionRadius / 2, false, true);
    AIData.canSeePlayerVeryClose = !AIData.distracted && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.visionRadius / 3, false, true);
    AIData.canShootPlayer = !AIData.distracted && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.visionRadius, false, true);
    if (KinkyDungeonLastTurnAction && AIData.canSeePlayer) {
        if (!enemy.aggro)
            enemy.aggro = 0;
        enemy.aggro += KinkyDungeonLastTurnAction == "Struggle" ? 0.1 :
            (KinkyDungeonLastTurnAction == "Spell" ? 0.3 :
                (KinkyDungeonAlert ? 0.1 :
                    0.01));
    }
    if ((enemy.Enemy.projectileAttack || enemy.Enemy.projectileTargeting) && (!AIData.canShootPlayer || !KinkyDungeonCheckProjectileClearance(enemy.x, enemy.y, player.x, player.y)))
        AIData.followRange = 1.5;
    if (!AIData.aggressive && !enemy.Enemy.alwaysHostile && !(enemy.rage > 0) && AIData.canSeePlayer && player.player && !KDAllied(enemy)
        && ((!KinkyDungeonFlags.has("nojailbreak") && !KinkyDungeonPlayerInCell(true, true)) || KinkyDungeonLastTurnAction == "Struggle" || KinkyDungeonLastAction == "Struggle")) {
        if (enemy.Enemy.tags.jailer || enemy.Enemy.tags.jail || enemy.Enemy.tags.leashing) {
            if (KDGameData.PrisonerState == 'parole' && !KinkyDungeonIsArmsBound() && !KDEnemyHasFlag(enemy, "Shop"))
                KinkyDungeonAggroAction('unrestrained', { enemy: enemy });
            else if ((KDGameData.PrisonerState == 'parole' || KDGameData.PrisonerState == 'jail') && (KinkyDungeonLastTurnAction == "Struggle" || KinkyDungeonLastAction == "Struggle"))
                KinkyDungeonAggroAction('struggle', { enemy: enemy });
            else if ((!KinkyDungeonFlags.has("nojailbreak") && !KinkyDungeonPlayerInCell(true, true))
                && KDGameData.PrisonerState == 'jail'
                && !KDIsPlayerTethered(KinkyDungeonPlayerEntity)
                && KinkyDungeonSlowLevel < 9)
                KinkyDungeonAggroAction('jailbreak', { enemy: enemy });
        }
        AIData.ignore = !AIData.aggressive && (!enemy.playWithPlayer || !player.player);
    }
    let sneakThreshold = enemy.Enemy.sneakThreshold ? enemy.Enemy.sneakThreshold : 2;
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak"))
        sneakThreshold = Math.max(0.1, sneakThreshold + KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak"));
    AIData.playAllowed = false;
    AIData.startedDialogue = false;
    AIData.playChance = 0.1;
    if (KDGameData.JailKey)
        AIData.playChance += 0.25;
    if (AIData.playerDist < 1.5)
        AIData.playChance += 0.1;
    if (!enemy.personality)
        enemy.personality = KDGetPersonality(enemy);
    if (AIData.playerDist < enemy.Enemy.visionRadius / 2)
        AIData.playChance += 0.1;
    if (AIData.playerDist < 1.5)
        AIData.playChance += 0.3;
    if (KDAllied(enemy) || (!AIData.hostile && KDGameData.PrisonerState != "jail" && KDGameData.PrisonerState != "parole" && !KinkyDungeonStatsChoice.has("Submissive")))
        AIData.playChance *= 0.07;
    else {
        if (KinkyDungeonPlayerDamage && !KinkyDungeonPlayerDamage.unarmed) {
            AIData.playChance += 0.25;
        }
        if ((playerItems === null || playerItems === void 0 ? void 0 : playerItems.length) > 0 || KinkyDungeonRedKeys > 0) {
            AIData.playChance += 0.2;
            if (playerItems.length > 6) {
                AIData.playChance += 0.5;
            }
        }
    }
    if (AIData.domMe) {
        AIData.playChance += 0.2;
    }
    else if (!KDPlayerIsTied()) {
        AIData.playChance *= 0.4;
    }
    if (KinkyDungeonFlags.get("PlayerCombat"))
        AIData.playChance *= 0.2;
    if (!KinkyDungeonFlags.get("wander"))
        AIData.playChance *= 0.75;
    if (((_h = enemy.path) === null || _h === void 0 ? void 0 : _h.length) > 2)
        AIData.playChance *= 0.1;
    if (KDGameData.otherPlaying > 0)
        AIData.playChance *= Math.max(0.05, 1 - 0.35 * KDGameData.otherPlaying);
    if (KDEnemyHasFlag(enemy, "Shop"))
        AIData.playChance = 0;
    if (KinkyDungeonFlags.get("playLikely"))
        AIData.playChance += 0.5;
    if (KinkyDungeonStatsChoice.get("Undeniable")) {
        if (AIData.playChance < 0.1)
            AIData.playChance = 0.1;
        else
            AIData.playChance = 0.9;
    }
    let aware = (enemy.vp > sneakThreshold || enemy.aware);
    let playData = {
        playChance: AIData.playChance,
        AIData: AIData,
        enemy: enemy,
        player: player,
    };
    KinkyDungeonSendEvent("calcPlayChance", playData);
    AIData.playChance = playData.playChance;
    if (KinkyDungeonCanPlay(enemy) && enemy != KinkyDungeonJailGuard() && !KinkyDungeonFlags.get("NPCCombat") && !enemy.Enemy.alwaysHostile && !(enemy.rage > 0) && !(enemy.hostile > 0) && player.player && AIData.canSeePlayer && (aware) && KDEnemyCanTalk(enemy) && !KinkyDungeonInJail(KDJailFilters)) {
        AIData.playAllowed = true;
        if (!(enemy.playWithPlayerCD > 0) && !(enemy.playWithPlayer > 0) && KDRandom() < AIData.playChance && !KDAllied(enemy)) {
            AIData.playEvent = true;
        }
    }
    if (enemy.vp < 0.01 && !KDEnemyHasFlag(enemy, "noResetIntent")) {
        KDResetIntent(enemy, AIData);
    }
    if (player.player && AIData.canSeePlayer && aware && !enemy.IntentAction) {
        let event = KDGetIntentEvent(enemy, AIData, AIData.playEvent, KDAllied(enemy), AIData.hostile, AIData.aggressive);
        if (event)
            event(enemy, AIData);
    }
    if (KinkyDungeonCanPutNewDialogue() && AIData.playerDist <= KinkyDungeonMaxDialogueTriggerDist && player.player) {
        let WeightTotal = 0;
        let Weights = [];
        for (let e of Object.entries(KDDialogueTriggers)) {
            let trigger = e[1];
            let weight = 0;
            if ((!trigger.blockDuringPlaytime || enemy.playWithPlayer < 1 || !enemy.playWithPlayer)
                && (!trigger.noAlly || !KDAllied(enemy))
                && (!trigger.playRequired || AIData.playAllowed)
                && (!trigger.noCombat || !KinkyDungeonFlags.get("NPCCombat"))
                && (!trigger.nonHostile || !AIData.aggressive)
                && (!trigger.allowedPrisonStates || trigger.allowedPrisonStates.includes(KDGameData.PrisonerState))
                && (!trigger.allowedPersonalities || trigger.allowedPersonalities.includes(enemy.personality))
                && (!trigger.onlyDuringPlay || enemy.playWithPlayer > 0
                    || (trigger.allowPlayExceptionSub && KDIsSubmissiveEnough(enemy)))) {
                let end = false;
                if (trigger.excludeTags) {
                    for (let tt of trigger.excludeTags) {
                        if (enemy.Enemy.tags[tt]) {
                            end = true;
                            break;
                        }
                    }
                }
                if (!end && trigger.requireTags) {
                    for (let tt of trigger.requireTags) {
                        if (!enemy.Enemy.tags[tt]) {
                            end = true;
                            break;
                        }
                    }
                }
                let hastag = !trigger.requireTagsSingle;
                if (!end && trigger.requireTagsSingle) {
                    for (let tt of trigger.requireTagsSingle) {
                        if (enemy.Enemy.tags[tt]) {
                            hastag = true;
                            break;
                        }
                    }
                }
                if (!hastag)
                    end = true;
                if (!end && (!trigger.prerequisite || trigger.prerequisite(enemy, AIData.playerDist, AIData))) {
                    weight = trigger.weight(enemy, AIData.playerDist);
                }
            }
            if (weight > 0) {
                Weights.push({ t: trigger, weight: WeightTotal });
                WeightTotal += weight;
            }
        }
        let selection = KDRandom() * WeightTotal;
        for (let L = Weights.length - 1; L >= 0; L--) {
            if (selection > Weights[L].weight) {
                KDStartDialog(Weights[L].t.dialogue, enemy.Enemy.name, true, enemy.personality, enemy);
                AIData.startedDialogue = true;
            }
        }
    }
    let intentAction = enemy.IntentAction && KDIntentEvents[enemy.IntentAction] ? KDIntentEvents[enemy.IntentAction] : null;
    if (!AIData.aggressive && player.player && (enemy.playWithPlayer || (intentAction && intentAction.forceattack)))
        AIData.ignore = false;
    AIData.sneakMult = 0.25;
    if (AIData.canSeePlayerMedium)
        AIData.sneakMult += 0.45;
    if (AIData.canSeePlayerClose)
        AIData.sneakMult += 0.25;
    if (AIData.canSeePlayerVeryClose)
        AIData.sneakMult += 0.5;
    if (KinkyDungeonAlert > 0)
        AIData.sneakMult += 1;
    if ((AIData.canSensePlayer || AIData.canSeePlayer || AIData.canShootPlayer || AIData.canSeePlayerChase) && KinkyDungeonTrackSneak(enemy, delta * (AIData.sneakMult), player, (AIData.canSensePlayer) ? 0 : (enemy.Enemy.tags.darkvision ? 0.5 : 1.5))) {
        if (!KDEnemyHasFlag(enemy, "StayHere")) {
            if (KDEnemyHasFlag(enemy, "Defensive")) {
                enemy.gx = KinkyDungeonPlayerEntity.x;
                enemy.gy = KinkyDungeonPlayerEntity.y;
            }
            else if (!AIData.ignore && (AIData.aggressive || enemy.playWithPlayer || !KDEnemyHasFlag(enemy, "NoFollow"))) {
                let pp = KinkyDungeonGetNearbyPoint(player.x, player.y, true, undefined, true);
                if (pp) {
                    enemy.gx = pp.x;
                    enemy.gy = pp.y;
                }
                else {
                    enemy.gx = player.x;
                    enemy.gy = player.y;
                }
            }
        }
        if (AIData.canSensePlayer || AIData.canSeePlayer || AIData.canShootPlayer) {
            if (!enemy.aware && AIData.aggressive)
                KDAddThought(enemy.id, "Aware", 3, 3);
            enemy.aware = true;
            if (AIData.hostile && AIData.aggressive && !enemy.rage && !enemy.Enemy.tags.minor && (!(enemy.silence > 0 || enemy.Enemy.tags.gagged) || enemy.Enemy.tags.alwaysAlert)) {
                for (let e of KinkyDungeonEntities) {
                    if (KDHostile(e) && KinkyDungeonAggressive(e) && !enemy.rage && e != enemy && KDistChebyshev(e.x - enemy.x, e.y - enemy.y) <= KinkyDungeonEnemyAlertRadius) {
                        if (player.player && KDPlayerLight < 1.5) {
                            if (!e.aware) {
                                KDAddThought(e.id, "Blind", 3, 3);
                                e.path = null;
                                let pp = KinkyDungeonGetNearbyPoint(player.x, player.y, true, undefined, true);
                                if (pp) {
                                    e.gx = pp.x;
                                    e.gy = pp.y;
                                }
                                else {
                                    e.gx = player.x;
                                    e.gy = player.y;
                                }
                            }
                        }
                        else {
                            if (!e.aware)
                                KDAddThought(e.id, "Confused", 3, 3);
                            e.aware = true;
                        }
                    }
                }
            }
        }
    }
    AIData.ignoreRanged = AIData.canShootPlayer && KinkyDungeonAllRestraint().some((r) => { return KDRestraint(r).ignoreSpells; });
    if ((AIData.ignoreRanged || (!enemy.Enemy.alwaysKite && AIData.harmless)) && AIData.leashing)
        AIData.followRange = 1.5;
    if (enemy == KinkyDungeonJailGuard())
        AIData.followRange = 1.5;
    AIData.kite = false;
    AIData.kiteChance = enemy.Enemy.kiteChance ? enemy.Enemy.kiteChance : 0.75;
    if (AIData.canSeePlayer && (!player.player || AIData.aggressive) && enemy.Enemy && enemy.Enemy.kite && !enemy.usingSpecial && (!player.player || KinkyDungeonHasWill(0.1)) && (enemy.attackPoints <= 0 || enemy.Enemy.attackWhileMoving) && AIData.playerDist <= enemy.Enemy.kite && (AIData.hostile || !player.player)) {
        if (!enemy.Enemy.dontKiteWhenDisabled || !(KDPlayerIsDisabled()))
            if (!enemy.Enemy.noKiteWhenHarmless || !AIData.harmless)
                if (AIData.kiteChance >= 1 || KDRandom() < AIData.kiteChance)
                    if (!AIData.ignoreRanged)
                        AIData.kite = true;
    }
    if (!AIData.aggressive && player.player && (enemy.playWithPlayer || KDAllied(enemy))) {
        if (AIData.domMe && KDIsBrat(enemy)) {
            AIData.followRange = 3.9;
            AIData.kite = true;
        }
        else
            AIData.followRange = 1.5;
    }
    if ((AIType.resetguardposition(enemy, player, AIData)) && (!enemy.gxx || !enemy.gyy)) {
        enemy.gxx = enemy.gx;
        enemy.gyy = enemy.gy;
    }
    let flanked = KDCheckVulnerableBackstab(enemy);
    if (player.player && flanked && !enemy.stun && !enemy.Enemy.tags.nosurpriseflank && !KDIsPlayerTethered(KinkyDungeonPlayerEntity)) {
        enemy.stun = 1;
    }
    if (!AIData.startedDialogue) {
        if (!AIType.beforemove(enemy, player, AIData)
            && ((enemy.Enemy.attackWhileMoving && enemy != KinkyDungeonLeashingEnemy())
                || AIData.ignore
                || !(KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.followRange, enemy.attackPoints < 1 || !(enemy.Enemy.projectileTargeting || enemy.Enemy.projectileAttack), false) && enemy.aware)
                || AIData.kite)) {
            if (!enemy.gx)
                enemy.gx = enemy.x;
            if (!enemy.gy)
                enemy.gy = enemy.y;
            AIData.idle = true;
            AIData.patrolChange = false;
            AIData.followPlayer = false;
            AIData.dontFollow = false;
            if (AIType.follower(enemy, player, AIData)) {
                if (KDAllied(enemy) && player.player) {
                    if (!KDEnemyHasFlag(enemy, "NoFollow") && !KDEnemyHasFlag(enemy, "StayHere")) {
                        AIData.followPlayer = true;
                    }
                    else {
                        AIData.dontFollow = true;
                        if (enemy.gx == player.x && enemy.gy == player.y && !KDEnemyHasFlag(enemy, "StayHere")) {
                        }
                    }
                }
                else {
                    if (KDEnemyHasFlag(enemy, "Defensive") && !KDEnemyHasFlag(enemy, "StayHere")) {
                        enemy.gx = KinkyDungeonPlayerEntity.x;
                        enemy.gy = KinkyDungeonPlayerEntity.y;
                    }
                    if (KDEnemyHasFlag(enemy, "StayHere") || KDEnemyHasFlag(enemy, "Defensive"))
                        AIData.dontFollow = true;
                    if (AIData.hostile) {
                        KinkyDungeonSetEnemyFlag(enemy, "StayHere", 0);
                        KinkyDungeonSetEnemyFlag(enemy, "Defensive", 0);
                    }
                    else if (!KDAllied(enemy)) {
                        KinkyDungeonSetEnemyFlag(enemy, "Defensive", 0);
                    }
                }
            }
            if (!KDIsImmobile(enemy) &&
                AIType.chase(enemy, player, AIData)
                && !AIData.ignore
                && !AIData.dontFollow
                && (enemy.aware || AIData.followPlayer)
                && AIData.playerDist <= AIData.chaseRadius
                && (enemy.gx != enemy.x || enemy.gy != enemy.y || enemy.path || enemy.fx || enemy.fy)) {
                for (let T = 0; T < 12; T++) {
                    let dir = KDGetDir(enemy, player);
                    let splice = false;
                    if (T > 2 && T < 8)
                        dir = KinkyDungeonGetDirectionRandom(dir.x * 10, dir.y * 10);
                    if (T >= 8 || (enemy.path && !AIData.canSeePlayer) || (!AIData.canSeePlayer && !(enemy.Enemy.stopToCast && AIData.canShootPlayer))) {
                        if (!enemy.path && (KinkyDungeonAlert || (enemy.vp > 0 && enemy.aware) || AIData.canSeePlayer)) {
                            if (!AIData.canSeePlayer) {
                                if (AIData.canShootPlayer) {
                                    KDAddThought(enemy.id, "Shoot", 4, 2);
                                }
                                else if (AIData.canSensePlayer) {
                                    KDAddThought(enemy.id, "Sense", 2, 6);
                                }
                                else {
                                    KDAddThought(enemy.id, "Search", 2, 6);
                                }
                            }
                            enemy.path = KinkyDungeonFindPath(enemy.x, enemy.y, player.x, player.y, KDEnemyHasFlag(enemy, "blocked"), KDEnemyHasFlag(enemy, "blocked"), enemy == KinkyDungeonLeashingEnemy() || AIData.ignoreLocks, AIData.MovableTiles, undefined, undefined, undefined, enemy, enemy != KinkyDungeonJailGuard() && !KDEnemyHasFlag(enemy, "longPath"));
                        }
                        if (enemy.path && enemy.path.length > 0 && Math.max(Math.abs(enemy.path[0].x - enemy.x), Math.abs(enemy.path[0].y - enemy.y)) < 1.5) {
                            dir = { x: enemy.path[0].x - enemy.x, y: enemy.path[0].y - enemy.y, delta: KDistChebyshev(enemy.path[0].x - enemy.x, enemy.path[0].y - enemy.y) };
                            if (!KinkyDungeonNoEnemyExceptSub(enemy.x + dir.x, enemy.y + dir.y, false, enemy)
                                || !AIData.MovableTiles.includes(KinkyDungeonMapGet(enemy.path[0].x, enemy.path[0].y))) {
                                enemy.path = undefined;
                                KinkyDungeonSetEnemyFlag(enemy, "failpath", enemy == KinkyDungeonJailGuard() ? 2 : 20);
                                KinkyDungeonSetEnemyFlag(enemy, "blocked", 24);
                            }
                            splice = true;
                        }
                        else {
                            enemy.path = undefined;
                            KinkyDungeonSetEnemyFlag(enemy, "failpath", enemy == KinkyDungeonJailGuard() ? 2 : 20);
                            if (!AIData.canSensePlayer) {
                                if (enemy.aware)
                                    KDAddThought(enemy.id, "Lose", 1, 4);
                                enemy.aware = false;
                            }
                        }
                    }
                    if (dir.delta > 1.5) {
                        enemy.path = undefined;
                        KinkyDungeonSetEnemyFlag(enemy, "failpath", 20);
                    }
                    else if (KinkyDungeonEnemyCanMove(enemy, dir, AIData.MovableTiles, AIData.AvoidTiles, AIData.ignoreLocks, T)) {
                        if (KinkyDungeonEnemyTryMove(enemy, dir, delta, enemy.x + dir.x, enemy.y + dir.y))
                            AIData.moved = true;
                        if (AIData.moved && splice && enemy.path)
                            enemy.path.splice(0, 1);
                        AIData.idle = false;
                        if (AIData.moved) {
                            dir = KDGetDir(enemy, player);
                            if (KinkyDungeonEnemyCanMove(enemy, dir, AIData.MovableTiles, AIData.AvoidTiles, AIData.ignoreLocks, T)) {
                                enemy.fx = enemy.x + dir.x;
                                enemy.fy = enemy.y + dir.y;
                            }
                        }
                        break;
                    }
                    else {
                        enemy.fx = undefined;
                        enemy.fy = undefined;
                    }
                }
            }
            else if (!KDIsImmobile(enemy) && AIType.move(enemy, player, AIData) && (Math.abs(enemy.x - enemy.gx) > 0 || Math.abs(enemy.y - enemy.gy) > 0)) {
                if (enemy.aware) {
                    enemy.path = undefined;
                }
                enemy.aware = false;
                for (let T = 0; T < 8; T++) {
                    let dir = KDGetDir(enemy, { x: enemy.gx, y: enemy.gy });
                    let splice = false;
                    if (T > 2 && T < 8)
                        dir = KinkyDungeonGetDirectionRandom(dir.x * 10, dir.y * 10);
                    if (T >= 8 || enemy.path || !KinkyDungeonCheckPath(enemy.x, enemy.y, enemy.gx, enemy.gy)) {
                        if (!enemy.path && !KDEnemyHasFlag(enemy, "genpath")) {
                            enemy.path = KinkyDungeonFindPath(enemy.x, enemy.y, enemy.gx, enemy.gy, enemy == KinkyDungeonJailGuard() || KDEnemyHasFlag(enemy, "blocked"), KDEnemyHasFlag(enemy, "blocked"), enemy == KinkyDungeonLeashingEnemy() || AIData.ignoreLocks, AIData.MovableTiles, undefined, undefined, undefined, enemy, enemy != KinkyDungeonJailGuard() && !KDEnemyHasFlag(enemy, "longPath"));
                            KinkyDungeonSetEnemyFlag(enemy, "genpath", enemy == KinkyDungeonJailGuard() ? 1 : 100);
                        }
                        if (enemy.path && enemy.path.length > 0 && Math.max(Math.abs(enemy.path[0].x - enemy.x), Math.abs(enemy.path[0].y - enemy.y)) < 1.5) {
                            dir = { x: enemy.path[0].x - enemy.x, y: enemy.path[0].y - enemy.y, delta: KDistChebyshev(enemy.path[0].x - enemy.x, enemy.path[0].y - enemy.y) };
                            if (!KinkyDungeonNoEnemyExceptSub(enemy.x + dir.x, enemy.y + dir.y, false, enemy)
                                || !AIData.MovableTiles.includes(KinkyDungeonMapGet(enemy.path[0].x, enemy.path[0].y))) {
                                enemy.path = undefined;
                                KinkyDungeonSetEnemyFlag(enemy, "failpath", enemy == KinkyDungeonJailGuard() ? 2 : 20);
                                KinkyDungeonSetEnemyFlag(enemy, "blocked", 24);
                            }
                            splice = true;
                        }
                        else {
                            enemy.path = undefined;
                            KinkyDungeonSetEnemyFlag(enemy, "failpath", enemy == KinkyDungeonJailGuard() ? 2 : 20);
                        }
                    }
                    if (dir.delta > 1.5) {
                        enemy.path = undefined;
                    }
                    else if (KinkyDungeonEnemyCanMove(enemy, dir, AIData.MovableTiles, AIData.AvoidTiles, AIData.ignoreLocks, T)) {
                        if (KinkyDungeonEnemyTryMove(enemy, dir, delta, enemy.x + dir.x, enemy.y + dir.y))
                            AIData.moved = true;
                        if (AIData.moved && splice && enemy.path)
                            enemy.path.splice(0, 1);
                        AIData.idle = false;
                        if (AIData.moved) {
                            dir = KDGetDir(enemy, { x: enemy.gx, y: enemy.gy });
                            if (KinkyDungeonEnemyCanMove(enemy, dir, AIData.MovableTiles, AIData.AvoidTiles, AIData.ignoreLocks, T)) {
                                enemy.fx = enemy.x + dir.x;
                                enemy.fy = enemy.y + dir.y;
                            }
                        }
                        break;
                    }
                    else {
                        enemy.fx = undefined;
                        enemy.fy = undefined;
                        if (KinkyDungeonPlayerEntity.x == enemy.x + dir.x && KinkyDungeonPlayerEntity.y == enemy.y + dir.y)
                            enemy.path = undefined;
                    }
                }
            }
            else if (Math.abs(enemy.x - enemy.gx) < 2 || Math.abs(enemy.y - enemy.gy) < 2)
                AIData.patrolChange = true;
            if (!KDIsImmobile(enemy) && !AIType.aftermove(enemy, player, AIData)) {
                if (AIType.resetguardposition(enemy, player, AIData) && !AIData.followPlayer && Math.max(Math.abs(enemy.x - enemy.gx), Math.abs(enemy.y - enemy.gy)) < 1.5 && enemy.gxx && enemy.gyy) {
                    enemy.gx = enemy.gxx;
                    enemy.gy = enemy.gyy;
                }
                let wanderfar = AIType.wander_far(enemy, player, AIData);
                let wandernear = AIType.wander_near(enemy, player, AIData);
                if ((wanderfar || wandernear) && !AIData.followPlayer && (!enemy.Enemy.allied && !KDEnemyHasFlag(enemy, "StayHere")) && !KDEnemyHasFlag(enemy, "StayHere") && enemy.movePoints < 1 && (!enemy.aware || !AIData.aggressive)) {
                    if ((Math.max(Math.abs(enemy.x - enemy.gx), Math.abs(enemy.y - enemy.gy)) < 1.5 || (KDRandom() < 0.02 && KDEnemyHasFlag(enemy, "failpath"))) || (!(enemy.vp > 0.05) && (!enemy.path || KDRandom() < 0.1))) {
                        AIData.master = KinkyDungeonFindMaster(enemy).master;
                        if (!KDEnemyHasFlag(enemy, "wander")) {
                            if (!AIData.master && wanderfar) {
                                if (!AIType.wanderfar_func || !AIType.wanderfar_func(enemy, player, AIData)) {
                                    let newPoint = KinkyDungeonGetRandomEnemyPoint(false, enemy.tracking && KinkyDungeonHuntDownPlayer && KDGameData.PrisonerState != "parole" && KDGameData.PrisonerState != "jail");
                                    if (newPoint) {
                                        enemy.gx = newPoint.x;
                                        enemy.gy = newPoint.y;
                                    }
                                }
                                KinkyDungeonSetEnemyFlag(enemy, "wander", AIType.wanderDelay_long(enemy) || 50);
                            }
                            else if (wandernear) {
                                KinkyDungeonSetEnemyFlag(enemy, "wander", AIType.wanderDelay_short(enemy) || 20);
                                if (!AIType.wandernear_func || !AIType.wandernear_func(enemy, player, AIData)) {
                                    if (KinkyDungeonAlert && AIData.playerDist < Math.max(4, AIData.visionRadius)) {
                                        enemy.gx = KinkyDungeonPlayerEntity.x;
                                        enemy.gy = KinkyDungeonPlayerEntity.y;
                                    }
                                    else {
                                        let ex = enemy.x;
                                        let ey = enemy.y;
                                        let cohesion = enemy.Enemy.cohesion ? enemy.Enemy.cohesion : 0.5;
                                        let masterCloseness = enemy.Enemy.cohesion ? enemy.Enemy.cohesion : 0.7;
                                        if (AIData.master && KDRandom() < masterCloseness) {
                                            ex = AIData.master.x;
                                            ey = AIData.master.y;
                                        }
                                        else if (KDRandom() < cohesion) {
                                            let minDist = enemy.Enemy.cohesionRange ? enemy.Enemy.cohesionRange : AIData.visionRadius;
                                            for (let e of KinkyDungeonEntities) {
                                                if (e == enemy)
                                                    continue;
                                                if (['guard', 'ambush'].includes(KDGetAI(enemy)))
                                                    continue;
                                                if (!((enemy.Enemy.clusterWith && !e.Enemy.tags[enemy.Enemy.clusterWith])
                                                    || e.Enemy.clusterWith && !enemy.Enemy.tags[enemy.Enemy.clusterWith]))
                                                    continue;
                                                if (KDGetFaction(e) != KDGetFaction(enemy))
                                                    continue;
                                                if (KinkyDungeonTilesGet(e.x + "," + e.y) && KinkyDungeonTilesGet(e.x + "," + e.y).OffLimits)
                                                    continue;
                                                let dist = KDistEuclidean(e.x - enemy.x, e.y - enemy.y);
                                                if (dist < minDist) {
                                                    minDist = dist;
                                                    let ePoint = KinkyDungeonGetNearbyPoint(ex, ey, false);
                                                    if (ePoint) {
                                                        ex = ePoint.x;
                                                        ey = ePoint.y;
                                                    }
                                                }
                                            }
                                        }
                                        let newPoint = KinkyDungeonGetNearbyPoint(ex, ey, false);
                                        if (newPoint && (KDGetFaction(enemy) != "Player" || !KinkyDungeonPointInCell(newPoint.x, newPoint.y))) {
                                            if (!AIType.strictwander || KinkyDungeonCheckPath(enemy.x, enemy.y, newPoint.x, newPoint.y)) {
                                                enemy.gx = newPoint.x;
                                                enemy.gy = newPoint.y;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (enemy.usingSpecial && !enemy.specialCD)
        enemy.specialCD = 0;
    let minRange = enemy.Enemy.attackMinRange || 0;
    if (enemy.usingSpecial && enemy.Enemy.specialMinRange != undefined)
        minRange = enemy.Enemy.specialMinRange;
    AIData.playerDist = Math.sqrt((enemy.x - player.x) * (enemy.x - player.x) + (enemy.y - player.y) * (enemy.y - player.y));
    let canAttack = !(enemy.disarm > 0)
        && (!enemy.Enemy.followLeashedOnly || KDPlayerDeservesPunishment(enemy, player) || KDGameData.KinkyDungeonLeashedPlayer < 1 || KDGameData.KinkyDungeonLeashingEnemy == enemy.id)
        && ((AIData.hostile || (enemy.playWithPlayer && player.player && !AIData.domMe)) || (!player.player && (!player.Enemy || KDHostile(player) || enemy.rage)))
        && ((enemy.aware && KDCanDetect(enemy, player)) || (!KDAllied(enemy) && !AIData.hostile))
        && !AIData.ignore
        && (!minRange || (AIData.playerDist > minRange))
        && (AIData.attack.includes("Melee") || (enemy.Enemy.tags && AIData.leashing && !KinkyDungeonHasWill(0.1)))
        && (!AIData.ignoreRanged || AIData.playerDist < 1.5)
        && AIType.attack(enemy, player, AIData)
        && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.range, !enemy.Enemy.projectileAttack, !enemy.Enemy.projectileAttack);
    if (canAttack) {
        AIData.idle = false;
        enemy.revealed = true;
        let dir = KinkyDungeonGetDirection(player.x - enemy.x, player.y - enemy.y);
        if (enemy.usingSpecial && !specialConditionSpecial) {
            enemy.usingSpecial = false;
            if (KDSpecialConditions[enemy.Enemy.specialCondition].resetCD)
                enemy.specialCD = enemy.Enemy.specialCD;
        }
        if (!AIData.moved || enemy.Enemy.attackWhileMoving) {
            let moveMult = KDBoundEffects(enemy) * 0.5;
            let attackMult = KinkyDungeonGetBuffedStat(enemy.buffs, "AttackSlow");
            let attackTiles = enemy.warningTiles ? enemy.warningTiles : [dir];
            let ap = (KinkyDungeonMovePoints < 0 && !KinkyDungeonHasWill(0.1) && KDGameData.KinkyDungeonLeashingEnemy == enemy.id) ? enemy.Enemy.movePoints + moveMult + 1 : enemy.Enemy.attackPoints + attackMult;
            if (!KinkyDungeonEnemyTryAttack(enemy, player, attackTiles, delta, enemy.x + dir.x, enemy.y + dir.y, (enemy.usingSpecial && enemy.Enemy.specialAttackPoints) ? enemy.Enemy.specialAttackPoints : ap, undefined, undefined, enemy.usingSpecial, AIData.refreshWarningTiles, AIData.attack, AIData.MovableTiles)) {
                if (enemy.warningTiles.length == 0 || (AIData.refreshWarningTiles && enemy.usingSpecial)) {
                    let minrange = enemy.Enemy.tilesMinRange ? enemy.Enemy.tilesMinRange : 1;
                    if (enemy.usingSpecial && enemy.Enemy.tilesMinRangeSpecial)
                        minrange = enemy.Enemy.tilesMinRangeSpecial;
                    if ((!enemy.usingSpecial && enemy.attackPoints > 0) || enemy.specialCD < 1) {
                        enemy.fx = player.x;
                        enemy.fy = player.y;
                        enemy.warningTiles = KinkyDungeonGetWarningTiles(player.x - enemy.x, player.y - enemy.y, AIData.range, AIData.width, minrange);
                        let playerIn = false;
                        for (let tile of enemy.warningTiles) {
                            if (KinkyDungeonPlayerEntity.x == enemy.x + tile.x && KinkyDungeonPlayerEntity.y == enemy.y + tile.y) {
                                playerIn = true;
                                break;
                            }
                        }
                        if (!playerIn) {
                            enemy.fx = player.x;
                            enemy.fy = player.y;
                        }
                    }
                    if (AIData.refreshWarningTiles && enemy.usingSpecial)
                        enemy.attackPoints = Math.min(enemy.attackPoints, delta);
                }
                else {
                    let playerIn = false;
                    for (let tile of enemy.warningTiles) {
                        if (player.x == enemy.x + tile.x && player.y == enemy.y + tile.y) {
                            playerIn = true;
                            break;
                        }
                    }
                    if (!playerIn) {
                        if (enemy.Enemy.specialRange && enemy.usingSpecial && enemy.Enemy.specialCDonAttack) {
                            enemy.specialCD = enemy.Enemy.specialCD;
                            if (enemy.Enemy.stunOnSpecialCD)
                                enemy.stun = enemy.Enemy.stunOnSpecialCD;
                            if (AIData.attack.includes("Dash") && enemy.Enemy.dashOnMiss) {
                                KDDash(enemy, player, AIData.MovableTiles);
                            }
                        }
                        if (enemy.Enemy.specialWidth && enemy.usingSpecial && enemy.Enemy.specialCDonAttack) {
                            enemy.specialCD = enemy.Enemy.specialCD;
                            if (enemy.Enemy.stunOnSpecialCD)
                                enemy.stun = enemy.Enemy.stunOnSpecialCD;
                            if (AIData.attack.includes("Dash") && enemy.Enemy.dashOnMiss) {
                                KDDash(enemy, player, AIData.MovableTiles);
                            }
                        }
                    }
                }
                let playerEvasion = (player.player) ? KinkyDungeonPlayerEvasion()
                    : KinkyDungeonMultiplicativeStat(((player.Enemy && player.Enemy.evasion) ? player.Enemy.evasion : 0)) * KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(player.buffs, "Evasion"));
                if (AIData.playerDist < 1.5 && player.player && AIData.attack.includes("Bind") && enemy.Enemy.bound && KDRandom() * AIData.accuracy <= playerEvasion && KinkyDungeonMovePoints > -1 && KinkyDungeonTorsoGrabCD < 1 && KinkyDungeonLastAction == "Move") {
                    let caught = false;
                    for (let tile of enemy.warningTiles) {
                        if (enemy.x + tile.x == player.x && enemy.y + tile.y == player.y) {
                            caught = true;
                            break;
                        }
                    }
                    if (caught) {
                        let harnessChance = 0;
                        let harnessRestraintName = "";
                        let list = KinkyDungeonAllRestraint();
                        let list2 = [];
                        for (let restraint of list) {
                            if (KDRestraint(restraint) && KDRestraint(restraint).harness) {
                                harnessChance += 1;
                                list2.push(KDRestraint(restraint).name);
                            }
                        }
                        let rest = list2[Math.floor(KDRandom() * list2.length)];
                        if (rest)
                            harnessRestraintName = rest;
                        if (harnessChance > 0) {
                            let roll = KDRandom();
                            let bonus = 0;
                            if (!KinkyDungeonCanStand())
                                bonus += KinkyDungeonTorsoGrabChanceBonus;
                            if (KinkyDungeonStatWill < 0.01)
                                bonus += KinkyDungeonTorsoGrabChanceBonus;
                            for (let T = 0; T < harnessChance; T++) {
                                roll = Math.min(roll, KDRandom());
                            }
                            if (roll < KinkyDungeonTorsoGrabChance + bonus) {
                                KinkyDungeonMovePoints = -1;
                                let msg = TextGet("KinkyDungeonTorsoGrab").replace("RestraintName", TextGet("Restraint" + harnessRestraintName)).replace("EnemyName", TextGet("Name" + enemy.Enemy.name));
                                KinkyDungeonSendTextMessage(5, msg, "yellow", 1);
                                if (KDRandom() < actionDialogueChance)
                                    KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Grab").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 2, 4);
                                KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Grab.ogg", enemy);
                                KinkyDungeonTorsoGrabCD = 2;
                            }
                        }
                    }
                }
            }
            else {
                enemy.revealed = true;
                let hit = ((enemy.usingSpecial && enemy.Enemy.specialAttackPoints) ? enemy.Enemy.specialAttackPoints : ap) <= 1;
                for (let tile of enemy.warningTiles) {
                    if (enemy.x + tile.x == player.x && enemy.y + tile.y == player.y) {
                        hit = true;
                        break;
                    }
                }
                let playerEvasion = (player.player) ? KinkyDungeonPlayerEvasion()
                    : KinkyDungeonMultiplicativeStat(((player.Enemy && player.Enemy.evasion) ? player.Enemy.evasion : 0)) * KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(player.buffs, "Evasion"));
                if (hit) {
                    if (player.player) {
                        KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "incomingHit", 1);
                    }
                    else
                        KinkyDungeonTickBuffTag(player.buffs, "incomingHit", 1);
                }
                let missed = KDRandom() > playerEvasion * AIData.accuracy;
                let preData = {
                    attack: AIData.attack,
                    enemy: enemy,
                    damagetype: AIData.damage,
                    attacker: enemy,
                    target: player,
                    missed: missed,
                    hit: hit,
                };
                KinkyDungeonSendEvent("beforeAttack", preData);
                if (hit && missed) {
                    if (player.player) {
                        KinkyDungeonSendEvent("miss", { enemy: enemy, player: player });
                        KinkyDungeonSendTextMessage(2, TextGet("KinkyDungeonAttackMiss").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "lightgreen", 1);
                        if (KDRandom() < actionDialogueChance)
                            KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Miss").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 4, 4);
                    }
                    KDAddThought(enemy.id, "Annoyed", 4, 1);
                    enemy.vulnerable = Math.max(enemy.vulnerable, 1);
                    hit = false;
                }
                if (hit) {
                    if (KDRandom() < actionDialogueChanceIntense)
                        KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "HitPlayer").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 3, 5);
                    let replace = [];
                    let restraintAdd = [];
                    let restraintFromInventory = [];
                    let willpowerDamage = 0;
                    let msgColor = "#ffff00";
                    let Locked = false;
                    let Stun = false;
                    let Blind = false;
                    let priorityBonus = 0;
                    let addedRestraint = false;
                    let happened = 0;
                    let bound = 0;
                    if (player.player) {
                        if (player.player && AIData.playerDist < AIData.range && (AIData.aggressive || AIData.attack.includes("Pull") || enemy.IntentLeashPoint) && (((!enemy.Enemy.noLeashUnlessExhausted || !KinkyDungeonHasWill(0.1)) && enemy.Enemy.tags && AIData.leashing && KDGetFaction(enemy) != "Ambush") || AIData.attack.includes("Pull") || enemy.IntentLeashPoint) && (KDGameData.KinkyDungeonLeashedPlayer < 1 || KDGameData.KinkyDungeonLeashingEnemy == enemy.id)) {
                            AIData.intentToLeash = true;
                            let wearingLeash = false;
                            if (!wearingLeash && !AIData.attack.includes("Pull"))
                                wearingLeash = KinkyDungeonIsWearingLeash();
                            AIData.leashed = wearingLeash || AIData.attack.includes("Pull");
                            if (AIData.leashed) {
                                let leashToExit = AIData.leashing && !KinkyDungeonHasWill(0.1) && AIData.playerDist < 1.5;
                                AIData.nearestJail = KinkyDungeonNearestJailPoint(enemy.x, enemy.y);
                                if (KinkyDungeonFlags.has("LeashToPrison"))
                                    AIData.nearestJail = Object.assign({ type: "jail", radius: 1 }, KinkyDungeonStartPosition);
                                let leashPos = AIData.nearestJail;
                                let findMaster = undefined;
                                if (!leashToExit && enemy.Enemy.pullTowardSelf && (Math.abs(player.x - enemy.x) > 1.5 || Math.abs(player.y - enemy.y) > 1.5)) {
                                    findMaster = enemy;
                                    if (findMaster)
                                        leashPos = { x: findMaster.x, y: findMaster.y, type: "", radius: 1 };
                                }
                                else {
                                    if (AIData.attack.includes("Pull") && enemy.Enemy.master) {
                                        let fm = KinkyDungeonFindMaster(enemy);
                                        findMaster = fm.master;
                                        if (findMaster)
                                            leashPos = { x: findMaster.x, y: findMaster.y, type: "", radius: 1 };
                                    }
                                }
                                if (enemy.IntentLeashPoint)
                                    leashPos = enemy.IntentLeashPoint;
                                if (AIData.playerDist < 1.5 || !KinkyDungeonGetRestraintItem("ItemDevices"))
                                    AIData.leashPos = leashPos;
                            }
                        }
                        if (AIData.attack.includes("Lock") && KinkyDungeonPlayerGetLockableRestraints().length > 0) {
                            let Lockable = KinkyDungeonPlayerGetLockableRestraints();
                            let Lstart = 0;
                            let Lmax = Lockable.length - 1;
                            if (!enemy.Enemy.attack.includes("LockAll")) {
                                Lstart = Math.floor(Lmax * KDRandom());
                            }
                            for (let L = Lstart; L <= Lmax; L++) {
                                let l = enemy.Enemy.attackLock ? KDProcessLock(enemy.Enemy.attackLock) : KinkyDungeonGenerateLock(true);
                                KinkyDungeonLock(Lockable[L], l);
                                priorityBonus += KDRestraint(Lockable[L]).power;
                            }
                            Locked = true;
                            happened += 1;
                            if (enemy.usingSpecial && Locked && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Lock")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            if (KDRandom() < actionDialogueChanceIntense)
                                KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Lock").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 2, 4);
                        }
                        else if (AIData.attack.includes("Bind")
                            && ((!enemy.usingSpecial && !enemy.Enemy.bindOnDisable) || (enemy.usingSpecial && !enemy.Enemy.bindOnDisableSpecial) || !KinkyDungeonHasWill(0.01) || !KinkyDungeonHasStamina(2.5) || KinkyDungeonPlayer.Pose.includes("Kneel") || KinkyDungeonPlayer.Pose.includes("Hogtie"))) {
                            if (AIData.addMoreRestraints || AIData.addLeash || enemy.usingSpecial) {
                                if (!AIData.intentToLeash && !KinkyDungeonFlags.get("Released") && enemy.Enemy.bound
                                    && KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y) && KDGameData.KinkyDungeonLeashedPlayer < 1
                                    && KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y).Furniture
                                    && !KinkyDungeonPlayerTags.has("Furniture")
                                    && KDFurniture[KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y).Furniture]) {
                                    let furn = KDFurniture[KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y).Furniture];
                                    if (furn) {
                                        let rest = KinkyDungeonGetRestraint({ tags: [furn.restraintTag] }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], true, "", true, false, false);
                                        replace.push({ keyword: "RestraintAdded", value: TextGet("Restraint" + rest.name) });
                                        restraintAdd.push(rest);
                                        addedRestraint = true;
                                    }
                                }
                                else {
                                    let numTimes = 1;
                                    if (enemy.Enemy.multiBind)
                                        numTimes = enemy.Enemy.multiBind;
                                    for (let times = 0; times < numTimes; times++) {
                                        let rThresh = ((_j = enemy.Enemy.RestraintFilter) === null || _j === void 0 ? void 0 : _j.powerThresh) || KDDefaultRestraintThresh;
                                        let rest = KinkyDungeonGetRestraint({ tags: KDGetTags(enemy, enemy.usingSpecial) }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], enemy.Enemy.bypass, enemy.Enemy.useLock ? enemy.Enemy.useLock : "", !(enemy.Enemy.ignoreStaminaForBinds || (enemy.usingSpecial && enemy.Enemy.specialIgnoreStam)) && !AIData.attack.includes("Suicide"), !AIData.addMoreRestraints && !enemy.usingSpecial && AIData.addLeash, !(KinkyDungeonStatsChoice.has("TightRestraints") || enemy.Enemy.tags.miniboss || enemy.Enemy.tags.boss), KDGetExtraTags(enemy, enemy.usingSpecial), false, {
                                            looseLimit: true,
                                            require: ((_k = enemy.Enemy.RestraintFilter) === null || _k === void 0 ? void 0 : _k.unlimitedRestraints) ? undefined : enemy.items,
                                        }, enemy);
                                        if (!rest) {
                                            rest = KinkyDungeonGetRestraint({ tags: KDGetTags(enemy, enemy.usingSpecial) }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], enemy.Enemy.bypass, enemy.Enemy.useLock ? enemy.Enemy.useLock : "", !(enemy.Enemy.ignoreStaminaForBinds || (enemy.usingSpecial && enemy.Enemy.specialIgnoreStam)) && !AIData.attack.includes("Suicide"), !AIData.addMoreRestraints && !enemy.usingSpecial && AIData.addLeash, !(KinkyDungeonStatsChoice.has("TightRestraints") || enemy.Enemy.tags.miniboss || enemy.Enemy.tags.boss), KDGetExtraTags(enemy, enemy.usingSpecial), false, {
                                                maxPower: rThresh + 0.01,
                                                looseLimit: true,
                                                onlyUnlimited: true,
                                                ignore: enemy.items,
                                            }, enemy);
                                        }
                                        else {
                                            restraintFromInventory.push(rest.name);
                                        }
                                        if (rest) {
                                            replace.push({ keyword: "RestraintAdded", value: TextGet("Restraint" + rest.name) });
                                            restraintAdd.push(rest);
                                            addedRestraint = true;
                                        }
                                    }
                                    if (enemy.usingSpecial && addedRestraint && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Bind")) {
                                        enemy.specialCD = enemy.Enemy.specialCD;
                                    }
                                    if (!addedRestraint && enemy.Enemy.fullBoundBonus) {
                                        willpowerDamage += enemy.Enemy.fullBoundBonus;
                                    }
                                }
                            }
                            else if (enemy.Enemy.fullBoundBonus) {
                                willpowerDamage += enemy.Enemy.fullBoundBonus;
                            }
                        }
                    }
                    if (AIData.attack.includes("Bind") && KDGameData.KinkyDungeonLeashedPlayer < 1 && !enemy.Enemy.nopickpocket && player.player && enemy.Enemy.bound && !KDGameData.JailKey && KDCanPickpocket(enemy)) {
                        let item = playerItems.length > 0 ? playerItems[Math.floor(KDRandom() * playerItems.length)] : undefined;
                        let picked = false;
                        if (item && playerItems.length > 0
                            && KinkyDungeonIsArmsBound() && ((!KinkyDungeonPlayerDamage || item.name != KinkyDungeonPlayerDamage.name) || KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax * 0.05) && KDRandom() < 0.5) {
                            if (item.type == Weapon) {
                                KinkyDungeonInventoryRemove(item);
                                if (!enemy.items)
                                    enemy.items = [item.name];
                                else if (!enemy.items.includes(item.name))
                                    enemy.items.push(item.name);
                            }
                            else if (item.type == Consumable) {
                                KinkyDungeonChangeConsumable(KinkyDungeonConsumables[item.name], -1);
                                let item2 = Object.assign({}, item);
                                item2.quantity = 1;
                                if (!enemy.items)
                                    enemy.items = [item.name];
                                enemy.items.push(item.name);
                            }
                            if (item) {
                                KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStealItem").replace("ITEMSTOLEN", TextGet("KinkyDungeonInventoryItem" + item.name)), "yellow", 2);
                                picked = true;
                            }
                        }
                        else if (KinkyDungeonLockpicks > 0 && KDRandom() < 0.5) {
                            KinkyDungeonLockpicks -= 1;
                            KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonStealPick"), "yellow", 2);
                            if (!enemy.items)
                                enemy.items = ["Pick"];
                            enemy.items.push("Pick");
                            picked = true;
                        }
                        else if (KinkyDungeonRedKeys > 0) {
                            KinkyDungeonRedKeys -= 1;
                            KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonStealRedKey"), "yellow", 2);
                            if (!enemy.items)
                                enemy.items = ["RedKey"];
                            enemy.items.push("RedKey");
                            picked = true;
                        }
                        else if (KinkyDungeonBlueKeys > 0) {
                            KinkyDungeonBlueKeys -= 1;
                            KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonStealBlueKey"), "yellow", 2);
                            if (!enemy.items)
                                enemy.items = ["BlueKey"];
                            enemy.items.push("BlueKey");
                            picked = true;
                        }
                        if (picked) {
                            KinkyDungeonSetFlag("pickpocket", 4);
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Miss.ogg", enemy);
                            if (KDRandom() < actionDialogueChanceIntense)
                                KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Pickpocket").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 2, 1);
                        }
                    }
                    if (AIData.attack.includes("Suicide")) {
                        if ((!enemy.Enemy.suicideOnAdd && !enemy.Enemy.suicideOnLock)
                            || (enemy.Enemy.suicideOnAdd && addedRestraint) || (enemy.Enemy.suicideOnLock && Locked) || (!player.player && AIData.attack.includes("Bind") && enemy.Enemy.suicideOnAdd)) {
                            enemy.hp = 0;
                        }
                        else if ((!KinkyDungeonHasWill(0.1) || ((_l = enemy.Enemy.Attack) === null || _l === void 0 ? void 0 : _l.mustBindorFail)) && enemy.Enemy.failAttackflag) {
                            for (let f of enemy.Enemy.failAttackflag) {
                                KinkyDungeonSetFlag(f, enemy.Enemy.failAttackflagDuration || 12);
                            }
                        }
                    }
                    if (AIData.attack.includes("Vibe")) {
                        AIData.vibe = true;
                    }
                    if (AIData.intentToLeash) {
                        let leashPos = AIData.leashPos;
                        if (AIData.leashPos) {
                            if (leashPos && leashPos == enemy.IntentLeashPoint && Math.abs(enemy.x - leashPos.x) <= 1.5 && Math.abs(enemy.y - leashPos.y) <= 1.5) {
                                if (enemy.IntentAction && KDIntentEvents[enemy.IntentAction] && KDIntentEvents[enemy.IntentAction].arrive) {
                                    KDIntentEvents[enemy.IntentAction].arrive(enemy, AIData);
                                }
                                else {
                                    KDResetIntent(enemy, AIData);
                                }
                            }
                            else if (enemy.Enemy.tags.leashing && AIData.nearestJail && leashPos == AIData.nearestJail && Math.abs(enemy.x - leashPos.x) <= 1 && Math.abs(enemy.y - leashPos.y) <= 1) {
                                AIData.defeat = true;
                                KDGameData.KinkyDungeonLeashedPlayer = 3 + ap * 2;
                                KDGameData.KinkyDungeonLeashingEnemy = enemy.id;
                                KDBreakTether();
                            }
                            else if (leashPos && ((AIData.attack.includes("Pull") && enemy.x == leashPos.x && enemy.y == leashPos.y) || Math.abs(enemy.x - leashPos.x) > 1.5 || Math.abs(enemy.y - leashPos.y) > 1.5)) {
                                if (!KinkyDungeonHasWill(0.1) && KDRandom() < 0.25)
                                    KinkyDungeonMovePoints = -1;
                                if (AIData.playerDist < 1.5) {
                                    let path = KinkyDungeonFindPath(enemy.x, enemy.y, leashPos.x, leashPos.y, false, false, true, KinkyDungeonMovableTilesSmartEnemy, undefined, undefined, undefined, enemy);
                                    if (path && path.length > 0) {
                                        let leashPoint = path[0];
                                        let enemySwap = KinkyDungeonEnemyAt(leashPoint.x, leashPoint.y);
                                        if ((!enemySwap || !enemySwap.Enemy.noDisplace) && Math.max(Math.abs(leashPoint.x - enemy.x), Math.abs(leashPoint.y - enemy.y)) <= 1.5) {
                                            KDGameData.KinkyDungeonLeashedPlayer = 3 + ap * 2;
                                            KDGameData.KinkyDungeonLeashingEnemy = enemy.id;
                                            if (enemySwap) {
                                                enemySwap.x = KinkyDungeonPlayerEntity.x;
                                                enemySwap.y = KinkyDungeonPlayerEntity.y;
                                                enemySwap.warningTiles = [];
                                            }
                                            if (AIData.leashing)
                                                KinkyDungeonAttachTetherToEntity(2.5, enemy);
                                            KDMovePlayer(enemy.x, enemy.y, false);
                                            KinkyDungeonTargetTile = null;
                                            KinkyDungeonTargetTileLocation = "";
                                            KDMoveEntity(enemy, leashPoint.x, leashPoint.y, true, false, undefined, true);
                                            AIData.hitsfx = "Struggle";
                                            for (let inv of KinkyDungeonAllRestraint()) {
                                                if (KDRestraint(inv).removeOnLeash) {
                                                    KinkyDungeonRemoveRestraint(KDRestraint(inv).Group, false);
                                                    if (KDRestraint(inv).Group == "ItemDevices") {
                                                        KinkyDungeonSetFlag("Released", 24);
                                                        KinkyDungeonSetFlag("nojailbreak", 10);
                                                    }
                                                }
                                            }
                                            if (!KinkyDungeonHasWill(0.1)) {
                                                KDStunTurns(enemy.Enemy.movePoints + moveMult - 1);
                                                KinkyDungeonSleepTime = CommonTime() + 200;
                                            }
                                            KinkyDungeonSetFlag("nojailbreak", KDGameData.KinkyDungeonLeashedPlayer);
                                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Pull")) {
                                                enemy.specialCD = enemy.Enemy.specialCD;
                                            }
                                            if (KinkyDungeonMapGet(enemy.x, enemy.y) == 'D') {
                                                KinkyDungeonMapSet(enemy.x, enemy.y, 'd');
                                                if (KinkyDungeonTilesGet(enemy.x + ',' + enemy.y) && KinkyDungeonTilesGet(enemy.x + ',' + enemy.y).Type == "Door")
                                                    KinkyDungeonTilesGet(enemy.x + ',' + enemy.y).Lock = undefined;
                                            }
                                            if (KDRandom() < actionDialogueChanceIntense)
                                                KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Leash").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 2, 3);
                                            if (!KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonLeashGrab").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "yellow", 1))
                                                KinkyDungeonSendActionMessage(1, TextGet("KinkyDungeonLeashGrab").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "yellow", 1);
                                        }
                                    }
                                }
                                else {
                                    let path = KinkyDungeonFindPath(player.x, player.y, leashPos.x, leashPos.y, true, false, false, KinkyDungeonMovableTilesEnemy, undefined, undefined, undefined, enemy);
                                    let pullDist = enemy.Enemy.pullDist ? enemy.Enemy.pullDist : 1;
                                    if (path && path.length > 0) {
                                        let leashPoint = path[Math.min(Math.max(0, path.length - 2), Math.floor(Math.max(0, pullDist - 1)))];
                                        if (!KinkyDungeonEnemyAt(leashPoint.x, leashPoint.y)
                                            && Math.sqrt((leashPoint.x - enemy.x) * (leashPoint.x - enemy.x) + (leashPoint.y - enemy.y) * (leashPoint.y - enemy.y)) < AIData.playerDist
                                            && Math.sqrt((leashPoint.x - player.x) * (leashPoint.x - player.x) + (leashPoint.y - player.y) * (leashPoint.y - player.y)) <= pullDist * 1.45) {
                                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Pull")) {
                                                enemy.specialCD = enemy.Enemy.specialCD;
                                            }
                                            KDGameData.KinkyDungeonLeashedPlayer = 2;
                                            KDGameData.KinkyDungeonLeashingEnemy = enemy.id;
                                            player.x = leashPoint.x;
                                            player.y = leashPoint.y;
                                            let msg = "KinkyDungeonLeashGrab";
                                            if (enemy.Enemy.pullMsg)
                                                msg = "Attack" + enemy.Enemy.name + "Pull";
                                            if (KDRandom() < actionDialogueChanceIntense)
                                                KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Pull").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 2, 3);
                                            if (!KinkyDungeonSendTextMessage(8, TextGet(msg).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "yellow", 1))
                                                KinkyDungeonSendActionMessage(3, TextGet(msg).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "yellow", 1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    let Dash = false;
                    let data = {};
                    if (AIData.attack.includes("Dash") && (enemy.Enemy.dashThruWalls || AIData.canSeePlayer)) {
                        let d = KDDash(enemy, player, AIData.MovableTiles);
                        Dash = d.Dash;
                        happened += d.happened;
                    }
                    if (AIData.attack.includes("Will") || willpowerDamage > 0) {
                        if (willpowerDamage == 0)
                            willpowerDamage += AIData.power;
                        let buffdmg = KinkyDungeonGetBuffedStat(enemy.buffs, "AttackDmg");
                        if (buffdmg)
                            willpowerDamage = Math.max(0, willpowerDamage + buffdmg);
                        msgColor = "#ff5555";
                        if (enemy.usingSpecial && willpowerDamage > 0 && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Will")) {
                            enemy.specialCD = enemy.Enemy.specialCD;
                        }
                    }
                    if (player.player) {
                        KinkyDungeonTickBuffTag(enemy.buffs, "hit", 1);
                        if (restraintAdd && restraintAdd.length > 0) {
                            msgColor = "#ff5555";
                            let restraintblock = KinkyDungeonGetPlayerStat("RestraintBlock");
                            let restraintpower = 0;
                            for (let r of restraintAdd) {
                                restraintpower += r.power;
                            }
                            let blocked = () => {
                                KDDamageQueue.push({ floater: TextGet("KDBlockedRestraint"), Entity: { x: enemy.x - 0.5, y: enemy.y - 0.5 }, Color: "white", Time: 2, Delay: 0 });
                                for (let rep of replace) {
                                    if (rep.keyword == "RestraintAdded")
                                        rep.value = TextGet("KDRestraintBlockedItem");
                                }
                                msgColor = "#ff8800";
                                bound += 1;
                                if (willpowerDamage == 0)
                                    willpowerDamage += AIData.power;
                            };
                            restraintblock = KDRestraintBlockPower(restraintblock, restraintpower + (enemy.Enemy.power || 0));
                            if (!restraintblock || KDRandom() < restraintblock) {
                                let protection = 0;
                                let multiPower = restraintAdd.length;
                                let targetGroups = {};
                                for (let r of restraintAdd) {
                                    targetGroups[r.Group] = true;
                                }
                                let protectRestraints = KinkyDungeonAllRestraint().filter((r) => { return KDRestraint(r).protection > 0; });
                                for (let r of protectRestraints) {
                                    if (r && KDRestraint(r).protection && (!KDRestraint(r).protectionCursed || targetGroups[KDRestraint(r).Group])) {
                                        protection += KDRestraint(r).protection;
                                    }
                                }
                                let count = 0;
                                if (protection >= multiPower) {
                                    for (let r of protectRestraints) {
                                        if (count < multiPower) {
                                            KinkyDungeonRemoveRestraint(KDRestraint(r).Group, true);
                                            KinkyDungeonSendTextMessage(5, TextGet("KDArmorBlock")
                                                .replace("ArmorName", TextGet("Restraint" + r.name))
                                                .replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "#ffff00", 1);
                                        }
                                        count += KDRestraint(r).protection;
                                    }
                                    blocked();
                                }
                                else {
                                    for (let r of restraintAdd) {
                                        let bb = 0;
                                        if (count >= protection) {
                                            bb = KinkyDungeonAddRestraintIfWeaker(r, AIData.power, KinkyDungeonStatsChoice.has("MagicHands") ? true : enemy.Enemy.bypass, enemy.Enemy.useLock ? enemy.Enemy.useLock : undefined, undefined, undefined, undefined, KDGetFaction(enemy), KinkyDungeonStatsChoice.has("MagicHands") ? true : undefined, undefined, enemy) * 2;
                                            if (bb) {
                                                if (KDGroupBlocked(r.Group) && !enemy.Enemy.bypass) {
                                                    KinkyDungeonSendTextMessage(5, TextGet("KDBypasses")
                                                        .replace("RestraintName", TextGet("Restraint" + r.name))
                                                        .replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "#ffff00", 1);
                                                }
                                                if (restraintFromInventory.includes(r.name)) {
                                                    restraintFromInventory.splice(restraintFromInventory.indexOf(r.name), 1);
                                                    if ((_m = enemy.items) === null || _m === void 0 ? void 0 : _m.includes(r.name)) {
                                                        enemy.items.splice(enemy.items.indexOf(r.name), 1);
                                                    }
                                                }
                                                KDSendStatus('bound', r.name, "enemy_" + enemy.Enemy.name);
                                            }
                                        }
                                        bound += bb;
                                        count += 1;
                                    }
                                }
                            }
                            else {
                                blocked();
                            }
                        }
                        if (AIData.attack.includes("Slow")) {
                            KinkyDungeonMovePoints = Math.max(KinkyDungeonMovePoints - 2, -1);
                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Slow")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                        }
                        if (AIData.attack.includes("Effect") && enemy.Enemy.effect) {
                            let affected = KinkyDungeonPlayerEffect(KinkyDungeonPlayerEntity, enemy.Enemy.effect.damage, enemy.Enemy.effect.effect, enemy.Enemy.effect.spell, KDGetFaction(enemy));
                            if (affected && enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Effect")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                        }
                        if (AIData.attack.includes("Stun")) {
                            let time = enemy.Enemy.stunTime ? enemy.Enemy.stunTime : 1;
                            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, time);
                            KinkyDungeonMovePoints = Math.max(Math.min(-1, -time + 1), KinkyDungeonMovePoints - time);
                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Stun")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                            priorityBonus += 3 * time;
                            Stun = true;
                            if (KDRandom() < actionDialogueChanceIntense)
                                KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Stun").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 2, 3);
                        }
                        if (AIData.attack.includes("Blind")) {
                            let time = enemy.Enemy.blindTime ? enemy.Enemy.blindTime : 1;
                            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, time);
                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Blind")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                            priorityBonus += 3 * time;
                            Blind = true;
                        }
                        happened += bound;
                        data = {
                            attack: AIData.attack,
                            enemy: enemy,
                            bound: bound,
                            damage: willpowerDamage,
                            damagetype: AIData.damage,
                            restraintsAdded: restraintAdd,
                            attacker: enemy,
                            target: player,
                            happened: happened,
                        };
                        KinkyDungeonSendEvent("beforeDamage", data);
                        KDDelayedActionPrune(["Hit"]);
                        let dmg = KinkyDungeonDealDamage({ damage: data.damage, type: data.damagetype });
                        data.happened += dmg.happened;
                        if (!enemy.playWithPlayer)
                            KinkyDungeonSetFlag("NPCCombat", 3);
                        happened = data.happened;
                        replace.push({ keyword: "DamageTaken", value: dmg.string });
                    }
                    else {
                        if (AIData.attack.includes("Slow")) {
                            if (player.movePoints)
                                player.movePoints = Math.max(player.movePoints - 1, 0);
                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Slow")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                        }
                        if (AIData.attack.includes("Stun")) {
                            let time = enemy.Enemy.stunTime ? enemy.Enemy.stunTime : 1;
                            if (!player.stun)
                                player.stun = time;
                            else
                                player.stun = Math.max(time, player.stun);
                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Stun")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                        }
                        if (AIData.attack.includes("Blind")) {
                            let time = enemy.Enemy.blindTime ? enemy.Enemy.blindTime : 1;
                            if (!player.blind)
                                player.blind = time;
                            else
                                player.blind = Math.max(time, player.blind);
                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Blind")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                        }
                        if (AIData.attack.includes("Silence")) {
                            let time = enemy.Enemy.silenceTime ? enemy.Enemy.silenceTime : 1;
                            KDSilenceEnemy(player, time);
                            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Blind")) {
                                enemy.specialCD = enemy.Enemy.specialCD;
                            }
                            happened += 1;
                        }
                        let dmg = AIData.power;
                        let buffdmg = KinkyDungeonGetBuffedStat(enemy.buffs, "AttackDmg");
                        if (buffdmg)
                            dmg = Math.max(0, dmg + buffdmg);
                        if (enemy.Enemy.fullBoundBonus) {
                            dmg += enemy.Enemy.fullBoundBonus;
                        }
                        happened += KinkyDungeonDamageEnemy(player, { type: enemy.Enemy.dmgType, damage: dmg }, false, true, undefined, undefined, enemy);
                        KinkyDungeonSetFlag("NPCCombat", 3);
                        KinkyDungeonTickBuffTag(enemy.buffs, "hit", 1);
                        if (happened > 0) {
                            if (enemy.playWithPlayer) {
                                KDAddOpinion(enemy, 10);
                                enemy.playWithPlayer = Math.max(0, enemy.playWithPlayer - (!KinkyDungeonPlayerTags.has("Furniture") ? 2 : 1) * Math.max(1, ((enemy.usingSpecial && enemy.Enemy.specialAttackPoints) ? enemy.Enemy.specialAttackPoints : enemy.Enemy.attackPoints)));
                                if (enemy.playWithPlayer == 0)
                                    KDResetIntent(enemy, AIData);
                            }
                            let sfx = (AIData.hitsfx) ? AIData.hitsfx : "DealDamage";
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg", enemy);
                        }
                    }
                    if (enemy.usingSpecial && enemy.specialCD > 0 && enemy.Enemy.specialCharges) {
                        if (enemy.specialCharges == undefined)
                            enemy.specialCharges = enemy.Enemy.specialCharges - 1;
                        else
                            enemy.specialCharges -= 1;
                    }
                    if (happened > 0 && player.player) {
                        let suffix = "";
                        if (Stun)
                            suffix = "Stun";
                        else if (Blind)
                            suffix = "Blind";
                        else if (Locked)
                            suffix = "Lock";
                        else if (bound > 0)
                            suffix = "Bind";
                        if (Dash)
                            suffix = "Dash";
                        if (enemy.usingSpecial && enemy.Enemy.specialMsg)
                            suffix = "Special";
                        let sfx = (AIData.hitsfx) ? AIData.hitsfx : (data.damage > 1 ? "Damage" : "DamageWeak");
                        if (enemy.usingSpecial && enemy.Enemy.specialsfx)
                            sfx = enemy.Enemy.specialsfx;
                        KinkyDungeonSendEvent("hit", data);
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg", enemy);
                        let text = TextGet("Attack" + enemy.Enemy.name + suffix);
                        if (replace)
                            for (let R = 0; R < replace.length; R++)
                                text = text.replace(replace[R].keyword, "" + replace[R].value);
                        KinkyDungeonSendTextMessage(happened + priorityBonus, text, msgColor, 1);
                        if (!enemy.Enemy.tags.temporary && AIData.attack.includes("Bind") && KDCanPickpocket(enemy))
                            KinkyDungeonLoseJailKeys(true, undefined, enemy);
                    }
                }
                else {
                    let sfx = (enemy.Enemy && enemy.Enemy.misssfx) ? enemy.Enemy.misssfx : "Miss";
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg", enemy);
                    if (player.player) {
                        KinkyDungeonSendEvent("miss", { enemy: enemy, player: player });
                        KinkyDungeonSendTextMessage(2, TextGet("KinkyDungeonAttackMiss").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "lightgreen", 1);
                        if (KDRandom() < actionDialogueChance)
                            KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJail" + (enemy.Enemy.playLine ? enemy.Enemy.playLine : "") + "Miss").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 4, 4);
                    }
                    KDAddThought(enemy.id, "Annoyed", 4, 1);
                    enemy.vulnerable = Math.max(enemy.vulnerable, 1);
                    if (AIData.attack.includes("Dash") && enemy.Enemy.dashOnMiss) {
                        KDDash(enemy, player, AIData.MovableTiles);
                    }
                }
                KinkyDungeonTickBuffTag(enemy.buffs, "damage", 1);
                enemy.warningTiles = [];
                if (enemy.usingSpecial)
                    enemy.usingSpecial = false;
            }
        }
        else {
            enemy.warningTiles = [];
            enemy.attackPoints = 0;
            if (enemy.usingSpecial)
                enemy.usingSpecial = false;
            enemy.fx = enemy.x + dir.x;
            enemy.fy = enemy.y + dir.y;
        }
    }
    else {
        enemy.warningTiles = [];
        enemy.attackPoints = 0;
    }
    enemy.moved = (AIData.moved || enemy.movePoints > 0);
    enemy.idle = AIData.idle && !(AIData.moved || enemy.attackPoints > 0);
    if (enemy.idle) {
        enemy.fx = undefined;
        enemy.fy = undefined;
    }
    if (!AIType.afteridle || !AIType.afteridle(enemy, player, AIData)) {
        if ((!enemy.Enemy.enemyCountSpellLimit || KinkyDungeonEntities.length < enemy.Enemy.enemyCountSpellLimit)
            && ((!player.player || (AIData.aggressive || (KDGameData.PrisonerState == 'parole' && enemy.Enemy.spellWhileParole))))
            && (!enemy.silence || enemy.silence < 0.01)
            && (!enemy.blind || enemy.blind < 0.01 || AIData.playerDist < 2.99)
            && (!enemy.Enemy.noSpellDuringAttack || enemy.attackPoints < 1)
            && (!enemy.Enemy.noSpellsWhenHarmless || !AIData.harmless)
            && (!enemy.Enemy.noSpellsLowSP || KinkyDungeonHasWill(0.1) || KinkyDungeonFlags.has("PlayerCombat"))
            && (!enemy.Enemy.noSpellLeashing || KDGameData.KinkyDungeonLeashingEnemy != enemy.id || KDGameData.KinkyDungeonLeashedPlayer < 1)
            && (!enemy.Enemy.followLeashedOnly || (KDGameData.KinkyDungeonLeashedPlayer < 1 || KDGameData.KinkyDungeonLeashingEnemy == enemy.id))
            && (AIData.hostile || (!player.player && (KDHostile(player) || enemy.rage)))
            && ((enemy.aware && (KDCanDetect(enemy, player))) || (!KDAllied(enemy) && !AIData.hostile))
            && !AIData.ignore && (!AIData.moved || enemy.Enemy.castWhileMoving) && enemy.Enemy.attack.includes("Spell")
            && !AIData.ignoreRanged
            && AIType.spell(enemy, player, AIData)
            && KinkyDungeonCheckLOS(enemy, player, AIData.playerDist, AIData.visionRadius, false, true) && enemy.castCooldown <= 0) {
            AIData.idle = false;
            let spellchoice = null;
            let spell = null;
            let spelltarget = undefined;
            for (let tries = 0; tries < 6; tries++) {
                spelltarget = null;
                spellchoice = enemy.Enemy.spells[Math.floor(KDRandom() * enemy.Enemy.spells.length)];
                spell = KinkyDungeonFindSpell(spellchoice, true);
                if (spell && (enemy.blind > 0 && (spell.projectileTargeting)))
                    spell = null;
                if (spell && ((!spell.castRange && AIData.playerDist > spell.range) || (spell.castRange && AIData.playerDist > spell.castRange)))
                    spell = null;
                if (spell && spell.specialCD && enemy.castCooldownSpecial > 0)
                    spell = null;
                if (spell && spell.noFirstChoice && tries <= 2)
                    spell = null;
                if (spell && spell.projectileTargeting && !KinkyDungeonCheckProjectileClearance(enemy.x, enemy.y, player.x, player.y))
                    spell = null;
                if (spell && spell.buff) {
                    if (enemy.Enemy.buffallies || spell.buffallies) {
                        let nearAllies = [];
                        for (let e of KinkyDungeonEntities) {
                            if ((e != enemy || spell.selfbuff) && (!spell.heal || e.hp < e.Enemy.maxhp - spell.power * 0.5)
                                && e.aware && !KinkyDungeonHasBuff(e.buffs, spell.name)
                                && !e.rage
                                && ((KDAllied(enemy) && KDAllied(e)) || (KDHostile(enemy) && KDHostile(e) || KDFactionRelation(KDGetFaction(e), KDGetFaction(enemy)) >= 0.1))
                                && Math.sqrt((enemy.x - e.x) * (enemy.x - e.x) + (enemy.y - e.y) * (enemy.y - e.y)) < spell.range
                                && (!spell.castCondition || KDCastConditions[spell.castCondition](enemy, e, spell))) {
                                let allow = !spell.filterTags;
                                if (spell.filterTags && KDMatchTags(spell.filterTags, e))
                                    allow = true;
                                if (allow)
                                    nearAllies.push(e);
                            }
                        }
                        if (nearAllies.length > 0) {
                            let e = nearAllies[Math.floor(KDRandom() * nearAllies.length)];
                            if (e) {
                                spelltarget = e;
                                KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonSpellCast" + spell.name).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "white", 2);
                                break;
                            }
                        }
                        else
                            spell = null;
                    }
                    else {
                        spelltarget = enemy;
                        if (spell.castCondition && !KDCastConditions[spell.castCondition](enemy, enemy, spell))
                            spell = null;
                    }
                }
                else if ((spell === null || spell === void 0 ? void 0 : spell.castCondition) && !KDCastConditions[spell.castCondition](enemy, player, spell))
                    spell = null;
                let minSpellRange = (spell && spell.minRange != undefined) ? spell.minRange : ((spell && (spell.selfcast || spell.buff || (spell.range && spell.range < 1.6))) ? 0 : 1.5);
                if (spell && spell.heal && spelltarget.hp >= spelltarget.Enemy.maxhp)
                    spell = null;
                if (spell && !(!minSpellRange || (AIData.playerDist > minSpellRange)))
                    spell = null;
                if (spell && !(!spell.minRange || (AIData.playerDist > spell.minRange)))
                    spell = null;
                if (spell)
                    break;
            }
            if (spell && enemy.distraction && !enemy.Enemy.noMiscast && KDRandom() < enemy.distraction / enemy.Enemy.maxhp * 0.8) {
                if (player == KinkyDungeonPlayerEntity)
                    KinkyDungeonSendTextMessage(4, TextGet(enemy.Enemy.miscastmsg || "KDEnemyMiscast").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "#88ff88", 2);
                KinkyDungeonCastSpell(enemy.x, enemy.y, KinkyDungeonFindSpell("EnemyMiscast", true), enemy, player);
                KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + (enemy.Enemy.miscastsfx || "SoftShield") + ".ogg", enemy);
            }
            else if (spell) {
                if (spell.channel && !enemy.Enemy.noChannel)
                    enemy.channel = spell.channel;
                enemy.castCooldown = spell.manacost * enemy.Enemy.spellCooldownMult + enemy.Enemy.spellCooldownMod + 1;
                if (spell.specialCD)
                    enemy.castCooldownSpecial = spell.specialCD;
                let xx = player.x;
                let yy = player.y;
                if (spelltarget) {
                    xx = spelltarget.x;
                    yy = spelltarget.y;
                }
                if (spell && spell.selfcast) {
                    xx = enemy.x;
                    yy = enemy.y;
                    if (!spell.noCastMsg)
                        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonSpellCast" + spell.name).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "white", 4, undefined, undefined, enemy);
                }
                else if (spell && spell.msg) {
                    if (!spell.noCastMsg)
                        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonSpellCast" + spell.name).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), "white", 4, undefined, undefined, enemy);
                }
                if (spell && KinkyDungeonCastSpell(xx, yy, spell, enemy, player).result == "Cast" && spell.sfx) {
                    if (enemy.Enemy.suicideOnSpell)
                        enemy.hp = 0;
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + spell.sfx + ".ogg", enemy);
                }
            }
        }
        if (AIData.vibe || (((_o = enemy.Enemy.RemoteControl) === null || _o === void 0 ? void 0 : _o.remote) && AIData.playerDist < ((_p = enemy.Enemy.RemoteControl) === null || _p === void 0 ? void 0 : _p.remote))) {
            KinkyDungeonSendEvent("remoteVibe", { enemy: enemy.Enemy.name, power: ((_q = enemy.Enemy.RemoteControl) === null || _q === void 0 ? void 0 : _q.remoteAmount) ? (_r = enemy.Enemy.RemoteControl) === null || _r === void 0 ? void 0 : _r.remoteAmount : 5, overcharge: AIData.vibe, noSound: AIData.vibe });
        }
        if (AIData.aggressive && AIData.canSensePlayer && ((_s = enemy.Enemy.RemoteControl) === null || _s === void 0 ? void 0 : _s.punishRemote) && AIData.playerDist < ((_t = enemy.Enemy.RemoteControl) === null || _t === void 0 ? void 0 : _t.punishRemote)) {
            KinkyDungeonSendEvent("remotePunish", { enemy });
        }
    }
    if (enemy.IntentAction && KDIntentEvents[enemy.IntentAction] && KDIntentEvents[enemy.IntentAction].maintain) {
        KDIntentEvents[enemy.IntentAction].maintain(enemy, delta);
    }
    if (enemy.playWithPlayer > 0 && !AIData.aggressive) {
        KinkyDungeonApplyBuffToEntity(enemy, KDEager);
        if (AIData.domMe)
            KinkyDungeonApplyBuffToEntity(enemy, KDMasochist);
    }
    if (enemy.usingSpecial && (AIData.idle || (AIData.moved && !enemy.Enemy.attackWhileMoving)) && enemy.Enemy.specialCDonAttack) {
        enemy.specialCD = enemy.Enemy.specialCD;
    }
    if (enemy.specialCD > 0)
        enemy.usingSpecial = false;
    if (AIData.idle)
        KDAddThought(enemy.id, "Idle", 0.5, 3);
    return { idle: AIData.idle, defeat: AIData.defeat };
}
function KinkyDungeonGetEnemyID() {
    if (KinkyDungeonEnemyID > 100000000)
        KinkyDungeonEnemyID = 0;
    return KinkyDungeonEnemyID++;
}
function KinkyDungeonGetItemID() {
    if (KDGameData.ItemID > 100000000 || KDGameData.ItemID == undefined)
        KDGameData.ItemID = 0;
    return KDGameData.ItemID++;
}
let KinkyDungeonEnemyID = 1;
function KinkyDungeonNoEnemy(x, y, Player) {
    if (KinkyDungeonEnemyAt(x, y))
        return false;
    if (Player)
        for (let player of KinkyDungeonPlayers)
            if ((player.x == x && player.y == y))
                return false;
    return true;
}
function KDIsImmobile(enemy) {
    var _a;
    return enemy && (enemy.Enemy.immobile || ((_a = enemy.Enemy.tags) === null || _a === void 0 ? void 0 : _a.immobile) || KDEnemyHasFlag(enemy, "imprisoned"));
}
function KinkyDungeonCanSwapWith(e, Enemy) {
    if (KDIsImmobile(e))
        return false;
    if (e && KDEnemyHasFlag(e, "noswap"))
        return false;
    if (KinkyDungeonTilesGet(e.x + "," + e.y) && KinkyDungeonTilesGet(e.x + "," + e.y).OffLimits && Enemy != KinkyDungeonJailGuard() && !KinkyDungeonAggressive(Enemy))
        return false;
    if (Enemy && Enemy.Enemy && Enemy.Enemy.ethereal && e && e.Enemy && !e.Enemy.ethereal)
        return false;
    if (Enemy && Enemy.Enemy && Enemy.Enemy.squeeze && e && e.Enemy && !e.Enemy.squeeze)
        return false;
    if (Enemy == KinkyDungeonLeashingEnemy())
        return true;
    if (Enemy == KinkyDungeonJailGuard())
        return true;
    if (KDBoundEffects(e) > 3)
        return true;
    if (!e.Enemy.tags || (e.Enemy.tags.minor && !Enemy.Enemy.tags.minor))
        return true;
    else if (Enemy && Enemy.Enemy && Enemy.Enemy.tags && Enemy.Enemy.tags.elite) {
        if (!e.Enemy.tags || (!e.Enemy.tags.elite && !e.Enemy.tags.miniboss && !e.Enemy.tags.boss))
            return true;
    }
    else if (Enemy && Enemy.Enemy && Enemy.Enemy.tags && Enemy.Enemy.tags.miniboss) {
        if (!e.Enemy.tags || (!e.Enemy.tags.miniboss && !e.Enemy.tags.boss))
            return true;
    }
    else if (Enemy && Enemy.Enemy && Enemy.Enemy.tags && Enemy.Enemy.tags.boss) {
        if (!e.Enemy.tags || (!e.Enemy.tags.boss))
            return true;
    }
    return false;
}
function KinkyDungeonNoEnemyExceptSub(x, y, Player, Enemy) {
    let e = KinkyDungeonEnemyAt(x, y);
    if (e && e.Enemy) {
        if (e.Enemy.master && Enemy && Enemy.Enemy && e.Enemy.master.type == Enemy.Enemy.name)
            return true;
        let seniority = Enemy ? KinkyDungeonCanSwapWith(e, Enemy) : false;
        return seniority;
    }
    if (Player)
        for (let pp of KinkyDungeonPlayers)
            if ((pp.x == x && pp.y == y))
                return false;
    return true;
}
function KinkyDungeonEnemyAt(x, y) {
    let cache = KDGetEnemyCache();
    if (cache)
        return cache.get(x + "," + y);
    for (let enemy of KinkyDungeonEntities) {
        if (enemy.x == x && enemy.y == y)
            return enemy;
    }
    return null;
}
function KinkyDungeonEntityAt(x, y, requireVision, vx, vy) {
    if (KinkyDungeonPlayerEntity.x == x && KinkyDungeonPlayerEntity.y == y)
        return KinkyDungeonPlayerEntity;
    let cache = KDGetEnemyCache();
    if (!requireVision && cache)
        return cache.get(x + "," + y);
    else if (cache) {
        let enemy = cache.get(x + "," + y);
        if (KDCanSeeEnemy(enemy, KDistEuclidean(x - vx, y - vy)))
            return enemy;
    }
    for (let enemy of KinkyDungeonEntities) {
        if (enemy.x == x && enemy.y == y && (!requireVision || KDCanSeeEnemy(enemy, KDistEuclidean(x - vx, y - vy))))
            return enemy;
    }
    return null;
}
function KinkyDungeonEnemyTryMove(enemy, Direction, delta, x, y) {
    let speedMult = KinkyDungeonGetBuffedStat(enemy.buffs, "MoveSpeed") ? KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(enemy.buffs, "MoveSpeed")) : 1;
    if (enemy.bind > 0)
        enemy.movePoints += speedMult * delta / 10;
    else if (enemy.slow > 0)
        enemy.movePoints += speedMult * delta / 2;
    else
        enemy.movePoints += KDGameData.SleepTurns > 0 ? 4 * delta * speedMult : delta * speedMult;
    let moveMult = KDBoundEffects(enemy) * 0.5;
    if (enemy.movePoints > 0) {
        enemy.fx = enemy.x + Direction.x;
        enemy.fy = enemy.y + Direction.y;
    }
    if (enemy.movePoints >= enemy.Enemy.movePoints + moveMult) {
        enemy.movePoints = Math.max(0, enemy.movePoints - enemy.Enemy.movePoints + moveMult);
        let dist = Math.abs(x - KinkyDungeonPlayerEntity.x) + Math.abs(y - KinkyDungeonPlayerEntity.y);
        let ee = KinkyDungeonEnemyAt(enemy.x + Direction.x, enemy.y + Direction.y);
        if (!ee && KinkyDungeonMapGet(enemy.x, enemy.y) == 'd' && enemy.Enemy && enemy.Enemy.tags.closedoors && !(KDGameData.KinkyDungeonLeashedPlayer > 0 || KinkyDungeonFlags.has("noclosedoors"))
            && ((dist > 5) ||
                (KinkyDungeonTilesGet(enemy.x + "," + enemy.y) && KDHostile(enemy) && (KinkyDungeonTilesGet(enemy.x + "," + enemy.y).Jail || KinkyDungeonTilesGet(enemy.x + "," + enemy.y).ReLock) && !KinkyDungeonFlags.has("nojailbreak")))) {
            KinkyDungeonMapSet(enemy.x, enemy.y, 'D');
            if (KDGameData.PrisonerState == 'jail' && KinkyDungeonTilesGet(enemy.x + "," + enemy.y) && KDHostile(enemy) && (KinkyDungeonTilesGet(enemy.x + "," + enemy.y).Jail || KinkyDungeonTilesGet(enemy.x + "," + enemy.y).ReLock)
                && !KinkyDungeonFlags.has("nojailbreak")) {
                KinkyDungeonTilesGet(enemy.x + "," + enemy.y).Lock = "Red";
                KDUpdateDoorNavMap();
            }
            if (dist < 10) {
                KinkyDungeonSendTextMessage(2, TextGet("KinkyDungeonHearDoorCloseNear"), "#dddddd", 4);
            }
            else if (dist < 20)
                KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonHearDoorCloseFar"), "#999999", 4);
        }
        if (ee && KinkyDungeonCanSwapWith(ee, enemy)) {
            KDMoveEntity(ee, enemy.x, enemy.y, false, undefined, undefined, true);
            ee.warningTiles = [];
            ee.movePoints = 0;
            ee.stun = 1;
        }
        if (!ee || !KinkyDungeonEnemyAt(enemy.x + Direction.x, enemy.y + Direction.y))
            KDMoveEntity(enemy, enemy.x + Direction.x, enemy.y + Direction.y, true, undefined, undefined, true);
        if (KinkyDungeonMapGet(x, y) == 'D' && enemy.Enemy && enemy.Enemy.tags.opendoors) {
            KinkyDungeonMapSet(x, y, 'd');
            if (KinkyDungeonTilesGet(x + ',' + y) && KinkyDungeonTilesGet(x + ',' + y).Type == "Door")
                KinkyDungeonTilesGet(x + ',' + y).Lock = undefined;
            if (dist < 5) {
                KinkyDungeonSendTextMessage(2, TextGet("KinkyDungeonHearDoorOpenNear"), "#dddddd", 4);
            }
            else if (dist < 15)
                KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonHearDoorOpenFar"), "#999999", 4);
        }
        return true;
    }
    return false;
}
function KinkyDungeonEnemyTryAttack(enemy, player, Tiles, delta, x, y, points, replace, msgColor, usingSpecial, refreshWarningTiles, attack, MovableTiles) {
    if (!enemy.Enemy.noCancelAttack && !refreshWarningTiles && points > 1) {
        let playerIn = false;
        for (let T = 0; T < Tiles.length; T++) {
            let ax = enemy.x + Tiles[T].x;
            let ay = enemy.y + Tiles[T].y;
            if (player.x == ax && player.y == ay && (!enemy.Enemy.strictAttackLOS || KinkyDungeonCheckProjectileClearance(enemy.x, enemy.y, player.x, player.y))) {
                playerIn = true;
                break;
            }
        }
        if (!playerIn && Tiles.length > 0) {
            if (enemy.Enemy.specialRange && enemy.usingSpecial && enemy.Enemy.specialCDonAttack) {
                enemy.specialCD = enemy.Enemy.specialCD;
                enemy.attackPoints = 0;
                enemy.warningTiles = [];
                enemy.usingSpecial = false;
                if (enemy.Enemy.stunOnSpecialCD)
                    enemy.stun = enemy.Enemy.stunOnSpecialCD;
                if (attack.includes("Dash") && enemy.Enemy.dashOnMiss) {
                    KDDash(enemy, player, MovableTiles);
                }
                return false;
            }
            if (enemy.Enemy.specialWidth && enemy.usingSpecial && enemy.Enemy.specialCDonAttack) {
                enemy.specialCD = enemy.Enemy.specialCD;
                enemy.attackPoints = 0;
                enemy.warningTiles = [];
                enemy.usingSpecial = false;
                if (enemy.Enemy.stunOnSpecialCD)
                    enemy.stun = enemy.Enemy.stunOnSpecialCD;
                if (attack.includes("Dash") && enemy.Enemy.dashOnMiss) {
                    KDDash(enemy, player, MovableTiles);
                }
                return false;
            }
        }
    }
    enemy.attackPoints += delta * KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(enemy.buffs, "AttackSpeed"));
    if (!enemy.playWithPlayer)
        KinkyDungeonSetFlag("NPCCombat", 3);
    if (enemy.attackPoints >= points) {
        enemy.attackPoints = enemy.attackPoints - points;
        return true;
    }
    return false;
}
function KinkyDungeonGetWarningTilesAdj() {
    let arr = [];
    arr.push({ x: 1, y: 1 });
    arr.push({ x: 0, y: 1 });
    arr.push({ x: 1, y: 0 });
    arr.push({ x: -1, y: -1 });
    arr.push({ x: -1, y: 1 });
    arr.push({ x: 1, y: -1 });
    arr.push({ x: -1, y: 0 });
    arr.push({ x: 0, y: -1 });
    return arr;
}
function KDCanPickpocket(enemy) {
    if (KinkyDungeonFlags.has("pickpocket"))
        return false;
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv).enclose)
            return false;
    }
    return KDHostile(enemy) || ((KDGameData.PrisonerState == 'jail' || KDGameData.PrisonerState == 'parole') && KinkyDungeonPlayerTags.has("Furniture"));
}
function KinkyDungeonGetWarningTiles(dx, dy, range, width, forwardOffset = 1) {
    if (range == 1 && width == 8)
        return KinkyDungeonGetWarningTilesAdj();
    let arr = [];
    let dist = Math.sqrt(dx * dx + dy * dy);
    let radius = Math.ceil(width / 2);
    if (dist > 0) {
        let x_step = dx / dist;
        let y_step = dy / dist;
        for (let d = forwardOffset; d <= range; d++) {
            let xx = x_step * d;
            let yy = y_step * d;
            for (let X = Math.floor(xx - radius); X <= Math.ceil(xx + radius); X++)
                for (let Y = Math.floor(yy - radius); Y <= Math.ceil(yy + radius); Y++) {
                    let dd = Math.sqrt((X - xx) * (X - xx) + (Y - yy) * (Y - yy));
                    let dd2 = Math.sqrt(X * X + Y * Y);
                    if (dd < width * 0.49 && dd2 < range + 0.5) {
                        let dupe = false;
                        for (let a of arr) {
                            if (a.x == X && a.y == Y) {
                                dupe = true;
                                break;
                            }
                        }
                        if (!dupe)
                            arr.push({ x: X, y: Y });
                    }
                }
        }
    }
    return arr;
}
function KinkyDungeonFindMaster(enemy) {
    let findMaster = undefined;
    let masterDist = 1000;
    if (enemy.Enemy.master) {
        for (let e of KinkyDungeonEntities) {
            if (e.Enemy.name == enemy.Enemy.master.type) {
                let dist = Math.sqrt((e.x - enemy.x) * (e.x - enemy.x) + (e.y - enemy.y) * (e.y - enemy.y));
                if ((!enemy.Enemy.master.maxDist || dist < enemy.Enemy.master.maxDist)
                    && dist < masterDist
                    && (!enemy.Enemy.master.loose || KinkyDungeonCheckLOS(enemy, e, dist, 100, false, false))) {
                    masterDist = Math.sqrt((e.x - enemy.x) * (e.x - enemy.x) + (e.y - enemy.y) * (e.y - enemy.y));
                    findMaster = e;
                }
            }
        }
    }
    return { master: findMaster, dist: masterDist };
}
function KinkyDungeonEnemyCanMove(enemy, dir, MovableTiles, AvoidTiles, ignoreLocks, Tries) {
    if (!dir)
        return false;
    let master = enemy.Enemy.master;
    let xx = enemy.x + dir.x;
    let yy = enemy.y + dir.y;
    if (master && (!enemy.Enemy.master.aggressive || !enemy.aware)) {
        let fm = KinkyDungeonFindMaster(enemy);
        let findMaster = fm.master;
        let masterDist = fm.dist;
        if (findMaster) {
            if (Math.sqrt((xx - findMaster.x) * (xx - findMaster.x) + (yy - findMaster.y) * (yy - findMaster.y)) > master.range
                && Math.sqrt((xx - findMaster.x) * (xx - findMaster.x) + (yy - findMaster.y) * (yy - findMaster.y)) > masterDist)
                return false;
        }
    }
    return MovableTiles.includes(KinkyDungeonMapGet(xx, yy)) && ((Tries && Tries > 5) || !AvoidTiles.includes(KinkyDungeonMapGet(enemy.x + dir.x, enemy.y + dir.y)))
        && (ignoreLocks || !KinkyDungeonTilesGet((xx) + "," + (yy)) || !(KinkyDungeonTilesGet((xx) + "," + (yy)).Lock))
        && KinkyDungeonNoEnemyExceptSub(xx, yy, true, enemy);
}
function KinkyDungeonFindID(id) {
    for (let e of KinkyDungeonEntities) {
        if (e.id == id)
            return e;
    }
    return null;
}
function KDDash(enemy, player, MovableTiles) {
    let happened = 0;
    let Dash = false;
    let tiles = [];
    for (let X = player.x - 1; X <= player.x + 1; X++)
        for (let Y = player.y - 1; Y <= player.y + 1; Y++) {
            let tile = KinkyDungeonMapGet(X, Y);
            if ((X != 0 || Y != 0) && !(!KinkyDungeonNoEnemy(X, Y, true) || !MovableTiles.includes(tile) || (tile == 'D' && !enemy.Enemy.ethereal))) {
                tiles.push({ x: X, y: Y });
            }
        }
    if (tiles.length > 0) {
        let tile = tiles[Math.floor(KDRandom() * tiles.length)];
        if (enemy.Enemy.dashThrough) {
            let tiled = 0;
            for (let t of tiles) {
                let dist = Math.sqrt((enemy.x - t.x) * (enemy.x - t.x) + (enemy.y - t.y) * (enemy.y - t.y));
                if (dist > tiled) {
                    tile = t;
                    tiled = dist;
                }
            }
        }
        else {
            let tiled = Math.sqrt((enemy.x - tile.x) * (enemy.x - tile.x) + (enemy.y - tile.y) * (enemy.y - tile.y));
            for (let t of tiles) {
                let dist = Math.sqrt((enemy.x - t.x) * (enemy.x - t.x) + (enemy.y - t.y) * (enemy.y - t.y));
                if (dist < tiled) {
                    tile = t;
                    tiled = dist;
                }
            }
        }
        if (tile && (tile.x != player.x || tile.y != player.y) && (tile.x != KinkyDungeonPlayerEntity.x || tile.y != KinkyDungeonPlayerEntity.y) && MovableTiles.includes(KinkyDungeonMapGet(tile.x, tile.y))) {
            Dash = true;
            KDMoveEntity(enemy, tile.x, tile.y, true);
            enemy.path = undefined;
            happened += 1;
            if (enemy.usingSpecial && enemy.Enemy.specialAttack != undefined && enemy.Enemy.specialAttack.includes("Dash")) {
                enemy.specialCD = enemy.Enemy.specialCD;
            }
        }
    }
    return { happened: happened, Dash: Dash };
}
function KinkyDungeonSendEnemyEvent(Event, data) {
    if (!KDMapHasEvent(KDEventMapEnemy, Event))
        return;
    for (let enemy of KinkyDungeonEntities) {
        if (enemy.Enemy.events) {
            for (let e of enemy.Enemy.events) {
                if (e.trigger === Event) {
                    KinkyDungeonHandleEnemyEvent(Event, e, enemy, data);
                }
            }
        }
    }
}
function KDGetIntentEvent(enemy, data, play, allied, hostile, aggressive) {
    let eventWeightTotal = 0;
    let eventWeights = [];
    for (let event of Object.values(KDIntentEvents)) {
        if (((event.aggressive && aggressive) || (event.nonaggressive && !aggressive))
            && (!event.play || play)
            && (!event.noplay || !play)) {
            eventWeights.push({ event: event, weight: eventWeightTotal });
            eventWeightTotal += event.weight(enemy, data, allied, hostile, aggressive);
        }
    }
    let selection = KDRandom() * eventWeightTotal;
    for (let L = eventWeights.length - 1; L >= 0; L--) {
        if (selection > eventWeights[L].weight) {
            return eventWeights[L].event.trigger;
        }
    }
    return (e, a) => { };
}
function KDAddEntity(entity) {
    KinkyDungeonEntities.push(entity);
    KDSetLoadout(entity, null);
    if (!entity.data && entity.Enemy.data)
        entity.data = entity.Enemy.data;
    KDUpdateEnemyCache = true;
}
function KDSpliceIndex(index, num = 1) {
    KinkyDungeonEntities.splice(index, num);
    KDUpdateEnemyCache = true;
}
function KDGetDir(enemy, target) {
    return (enemy.fx && enemy.fy) ?
        AIData.kite ? KinkyDungeonGetDirectionRandom(enemy.x - target.x, enemy.y - target.y) : { x: Math.max(-1, Math.min(1, enemy.fx - enemy.x)), y: Math.max(-1, Math.min(1, enemy.fy - enemy.y)), delta: 1 } :
        (AIData.kite ? KinkyDungeonGetDirectionRandom(enemy.x - target.x, enemy.y - target.y) : KinkyDungeonGetDirectionRandom(target.x - enemy.x, target.y - enemy.y));
}
function KDPullResistance(enemy) {
    var _a;
    let tags = (_a = enemy === null || enemy === void 0 ? void 0 : enemy.Enemy) === null || _a === void 0 ? void 0 : _a.tags;
    if (!tags)
        return;
    return tags.unstoppable ? 0.25 : (tags.unflinching ? 0.5 : 1.0);
}
function KDPushModifier(power, enemy, allowNeg = false) {
    let pushPower = power;
    if (KinkyDungeonIsSlowed(enemy) || enemy.bind > 0)
        pushPower += 1;
    if (KDEntityHasBuff(enemy, "Chilled"))
        pushPower += 1;
    if (enemy.Enemy.tags.stunimmune)
        pushPower -= 2;
    else if (enemy.Enemy.tags.stunresist)
        pushPower -= 1;
    if (enemy.Enemy.tags.unstoppable)
        pushPower -= 3;
    else if (enemy.Enemy.tags.unflinching || enemy.Enemy.tags.slowresist || enemy.Enemy.tags.slowimmune)
        pushPower -= 1;
    if (allowNeg)
        return pushPower;
    return Math.max(0, pushPower);
}
function KDTieUpEnemy(enemy, amount, type = "Leather", Damage) {
    if (!enemy)
        return 0;
    let data = {
        amount: amount,
        specialAmount: amount,
        type: type,
        Damage: Damage,
    };
    KinkyDungeonSendEvent("bindEnemy", data);
    if (data.amount) {
        enemy.boundLevel = (enemy.boundLevel || 0) + data.amount;
    }
    if (data.type) {
        if (!enemy.specialBoundLevel)
            enemy.specialBoundLevel = {};
        enemy.specialBoundLevel[type] = (enemy.specialBoundLevel[type] || 0) + data.specialAmount;
    }
    return data;
}
function KDPredictStruggle(enemy, struggleMod, delta) {
    let data = {
        enemy: enemy,
        struggleMod: struggleMod,
        delta: delta,
        boundLevel: enemy.boundLevel || 0,
        specialBoundLevel: enemy.specialBoundLevel ? Object.assign({}, enemy.specialBoundLevel) : {},
    };
    let minLevel = (enemy.buffs && KinkyDungeonGetBuffedStat(enemy.buffs, "MinBoundLevel")) ? KinkyDungeonGetBuffedStat(enemy.buffs, "MinBoundLevel") : 0;
    if (Object.keys(data.specialBoundLevel).length < 1) {
        data.struggleMod *= (10 + Math.pow(Math.max(0.01, enemy.hp), 0.75));
        data.boundLevel = Math.max(Math.min(Math.max(0, data.boundLevel), minLevel), data.boundLevel - data.delta * data.struggleMod);
    }
    else {
        let bondage = Object.entries(data.specialBoundLevel);
        bondage = bondage.sort((a, b) => {
            return KDSpecialBondage[a[0]].priority - KDSpecialBondage[b[0]].priority;
        });
        data.struggleMod *= 2;
        let i = 0;
        while (i < bondage.length
            && data.struggleMod > 0
            && data.boundLevel > 0) {
            let layer = bondage[i];
            let type = KDSpecialBondage[layer[0]];
            let hBoost = type.healthStruggleBoost;
            let pBoost = type.powerStruggleBoost;
            let sr = type.struggleRate;
            if (sr <= 0) {
                i = bondage.length;
            }
            let totalCost = layer[1] / sr;
            if (enemy.hp > 1)
                totalCost *= 10 / (10 + hBoost * Math.pow(enemy.hp, 0.75));
            totalCost *= 3 / (3 + pBoost * enemy.Enemy.power || 0);
            let effect = Math.min(data.struggleMod, totalCost);
            let difference = layer[1] * (effect / totalCost);
            let origBL = data.boundLevel;
            data.boundLevel = Math.max(minLevel, data.boundLevel - difference);
            data.specialBoundLevel[layer[0]] -= Math.max(0, origBL - data.boundLevel);
            if (data.specialBoundLevel[layer[0]] <= 0)
                delete data.specialBoundLevel[layer[0]];
            data.struggleMod -= effect;
            if (data.struggleMod <= 0)
                data.struggleMod = 0;
            i++;
        }
    }
    return data;
}
let KDDomThresh_Loose = 0.5;
let KDDomThresh_Normal = 0.0;
let KDDomThresh_Strict = -0.4;
let KDDomThresh_Variance = 0.15;
let KDDomThresh_PerkMod = -0.5;
function KDCanDom(enemy) {
    var _a;
    if (enemy == KinkyDungeonJailGuard())
        return false;
    if (KDGameData.KinkyDungeonLeashedPlayer > 0)
        return false;
    if (!enemy.Enemy.bound)
        return false;
    if (KDEnemyHasFlag(enemy, "isSubbing"))
        return true;
    if (KDEnemyHasFlag(enemy, "isDomming"))
        return false;
    if (enemy.Enemy.tags.nosub)
        return false;
    if (enemy.domVariance == undefined)
        enemy.domVariance = (((_a = KDEnemyPersonalities[enemy.personality]) === null || _a === void 0 ? void 0 : _a.domVariance) || KDDomThresh_Variance) * (2 * KDRandom() - 1);
    let modifier = (KinkyDungeonGoddessRep.Ghost + 50) / 100 + enemy.domVariance;
    if (KinkyDungeonStatsChoice.get("Dominant"))
        modifier += KDDomThresh_PerkMod;
    if (KDEnemyPersonalities[enemy.personality] && KDEnemyPersonalities[enemy.personality].domThresh)
        return modifier <= KDEnemyPersonalities[enemy.personality].domThresh;
    if (KDLoosePersonalities.includes(enemy.personality))
        return modifier <= KDDomThresh_Loose;
    if (KDStrictPersonalities.includes(enemy.personality))
        return modifier <= KDDomThresh_Strict;
    if (KDPlayerIsNotDom())
        return false;
    return modifier <= KDDomThresh_Normal;
}
function KDPlayerIsNotDom() {
    return KDGameData.KinkyDungeonLeashedPlayer > 1 || KinkyDungeonStatsChoice.get("Submissive") || KDPlayerIsTied();
}
function KDPlayerIsTied() {
    return KinkyDungeonSlowLevel > 1 || KinkyDungeonGagTotal() > 0.25 || KinkyDungeonIsArmsBound() || KinkyDungeonIsHandsBound();
}
function KDIsBrat(enemy) {
    var _a;
    if (KinkyDungeonStatsChoice.get("OnlyBrats"))
        return true;
    if (KinkyDungeonStatsChoice.get("NoBrats"))
        return false;
    if (!((_a = KDEnemyPersonalities[enemy.personality]) === null || _a === void 0 ? void 0 : _a.brat) && !KDEnemyHasFlag(enemy, "forcebrat"))
        return false;
    if (KDPlayerIsNotDom())
        return false;
    return true;
}
function KDCaptureNearby(enemy) {
    let enemies = KDNearbyEnemies(enemy.x, enemy.y, 1.5, enemy);
    for (let en of enemies) {
        if (KDHelpless(en) && en.hp < 0.52) {
            en.hp = 0;
        }
    }
}
function KinkyDungeonGetLoadoutForEnemy(enemy, guaranteed) {
    if (enemy.Enemy.tags.noshop)
        return "";
    let loadout_list = [];
    for (let s of Object.values(KDLoadouts)) {
        let end = false;
        if (s.tags) {
            for (let t of s.tags) {
                if (!enemy.Enemy.tags[t]) {
                    end = true;
                    break;
                }
            }
        }
        if (s.forbidtags) {
            for (let t of s.forbidtags) {
                if (enemy.Enemy.tags[t]) {
                    end = true;
                    break;
                }
            }
        }
        let hasTag = !s.singletag;
        if (!end && s.singletag) {
            for (let t of s.singletag) {
                if (enemy.Enemy.tags[t]) {
                    hasTag = true;
                    break;
                }
            }
        }
        let hasTag2 = !s.singletag2;
        if (!end && s.singletag2) {
            for (let t of s.singletag2) {
                if (enemy.Enemy.tags[t]) {
                    hasTag = true;
                    break;
                }
            }
        }
        if (!hasTag)
            end = true;
        if (!hasTag2)
            end = true;
        if (!end && (guaranteed || !s.chance || KDRandom() < s.chance)) {
            for (let i = 0; i < (s.multiplier || 1); i++)
                loadout_list.push(s.name);
        }
    }
    if (loadout_list.length > 0)
        return loadout_list[Math.floor(KDRandom() * loadout_list.length)];
    return "";
}
function KinkyDungeonGetTextForEnemy(key, enemy, useName = false) {
    const enemyKey = `${key}${useName ? enemy.Enemy.name : enemy.Enemy.faction}`;
    let text = TextGet(enemyKey);
    if (!text || text.endsWith(enemyKey)) {
        text = TextGet(key);
    }
    return text;
}
function KDPlayerIsDefeated() {
    return KinkyDungeonFlags.get("playerDefeated");
}
function KDPlayerIsDisabled() {
    return KinkyDungeonFlags.get("playerDisabled")
        || (KinkyDungeonStatBlind > 0 || KinkyDungeonStatBind > 0 || KinkyDungeonStatFreeze > 0 || (KinkyDungeonSlowMoveTurns > 0 && !KinkyDungeonFlags.get("channeling")) || KDGameData.SleepTurns > 0);
}
function KDPlayerIsStunned() {
    return KDPlayerIsDisabled() || KinkyDungeonFlags.get("playerStun")
        || (KinkyDungeonMovePoints < 0 || KDGameData.KneelTurns > 0 || KinkyDungeonSleepiness > 0);
}
function KDGetAwareTooltip(enemy) {
    if (KDGameData.CurrentDialog && KDGetSpeaker() == enemy && (enemy.aware || enemy.vp > 2))
        return {
            suff: "Talking",
            color: "#ffffff",
        };
    if (enemy.aware) {
        if (KDHostile(enemy)) {
            return {
                suff: "Aware",
                color: "#ff5555",
            };
        }
        else
            return {
                suff: "AwareFriendly",
                color: "#ffffff",
            };
    }
    if (enemy.vp > 2)
        return {
            suff: "DangerHigh",
            color: "#ff5555",
        };
    if (enemy.vp > 0.5)
        return {
            suff: "Danger",
            color: "#ffaa55",
        };
    if (enemy.vp > 0)
        return {
            suff: "Suspicious",
            color: "#ffff00",
        };
    return {
        suff: "Unnoticed",
        color: "#88ff88",
    };
}
function KDProcessLock(lock) {
    if (lock == "Red")
        return KDRandomizeRedLock();
    else
        return lock;
}
let KDDefaultRestraintThresh = 3;
function KDRestockRestraints(enemy, restMult) {
    var _a, _b, _c, _d, _e, _f, _g;
    if ((((_a = enemy.Enemy.attack) === null || _a === void 0 ? void 0 : _a.includes("Bind")) || ((_b = enemy.Enemy.specialAttack) === null || _b === void 0 ? void 0 : _b.includes("Bind"))) && !((_c = enemy.Enemy.RestraintFilter) === null || _c === void 0 ? void 0 : _c.noRestock) && !KDEnemyHasFlag(enemy, "restocked")) {
        let rCount = KDDetermineBaseRestCount(enemy, restMult);
        if ((((_d = enemy.items) === null || _d === void 0 ? void 0 : _d.length) || 0) < rCount) {
            KDStockRestraints(enemy, restMult, rCount - (((_e = enemy.items) === null || _e === void 0 ? void 0 : _e.length) || 0));
            KinkyDungeonSetEnemyFlag(enemy, "restocked", 200);
        }
        if ((_f = enemy.Enemy.RestraintFilter) === null || _f === void 0 ? void 0 : _f.requiredItems) {
            if (!enemy.items)
                enemy.items = [];
            for (let item of (_g = enemy.Enemy.RestraintFilter) === null || _g === void 0 ? void 0 : _g.requiredItems) {
                if (!enemy.items.includes(item))
                    enemy.items.unshift(item);
            }
        }
    }
}
function KDDetermineBaseRestCount(enemy, restMult) {
    var _a, _b;
    let rCount = 1;
    if (enemy.Enemy.tags.boss)
        rCount += 6;
    else if (enemy.Enemy.tags.miniboss)
        rCount += 3;
    else if (enemy.Enemy.tags.elite)
        rCount += 2;
    else if (!enemy.Enemy.tags.minor)
        rCount += 1;
    if ((_a = enemy.Enemy.RestraintFilter) === null || _a === void 0 ? void 0 : _a.bonusRestraints)
        rCount += (_b = enemy.Enemy.RestraintFilter) === null || _b === void 0 ? void 0 : _b.bonusRestraints;
    if (KinkyDungeonStatsChoice.has("TightRestraints")) {
        rCount *= 2;
        rCount += 1;
    }
    return Math.ceil(rCount * restMult);
}
function KDStockRestraints(enemy, restMult, count) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!enemy.items)
        enemy.items = [];
    let rCount = count || KDDetermineBaseRestCount(enemy, restMult);
    let rThresh = ((_a = enemy.Enemy.RestraintFilter) === null || _a === void 0 ? void 0 : _a.powerThresh) || KDDefaultRestraintThresh;
    if (rCount > 0)
        enemy.items = enemy.items || [];
    for (let i = 0; i < rCount; i++) {
        let rest = KinkyDungeonGetRestraint({ tags: KDGetTags(enemy, false) }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], enemy.Enemy.bypass, enemy.Enemy.useLock ? enemy.Enemy.useLock : "", false, false, false, KDGetExtraTags(enemy, true), true, {
            minPower: rThresh,
            noUnlimited: !((_b = enemy.Enemy.RestraintFilter) === null || _b === void 0 ? void 0 : _b.limitedRestraintsOnly),
            onlyLimited: (_c = enemy.Enemy.RestraintFilter) === null || _c === void 0 ? void 0 : _c.limitedRestraintsOnly,
            looseLimit: !((_d = enemy.Enemy.RestraintFilter) === null || _d === void 0 ? void 0 : _d.limitedRestraintsOnly),
            ignore: enemy.items.concat(((_e = enemy.Enemy.RestraintFilter) === null || _e === void 0 ? void 0 : _e.ignoreInitial) || []),
            ignoreTags: (_f = enemy.Enemy.RestraintFilter) === null || _f === void 0 ? void 0 : _f.ignoreInitialTag,
        });
        if (rest) {
            enemy.items.push(rest.name);
            if (KDEnemyIsTemporary(enemy)) {
                if (!enemy.tempitems)
                    enemy.tempitems = [];
                enemy.tempitems.push(rest.name);
            }
        }
    }
    if ((_g = enemy.Enemy.RestraintFilter) === null || _g === void 0 ? void 0 : _g.requiredItems) {
        if (!enemy.items)
            enemy.items = [];
        for (let item of (_h = enemy.Enemy.RestraintFilter) === null || _h === void 0 ? void 0 : _h.requiredItems) {
            if (!enemy.items.includes(item))
                enemy.items.unshift(item);
        }
    }
}
function KDSetLoadout(enemy, loadout) {
    var _a, _b, _c, _d;
    if (loadout) {
        let temp = enemy.Enemy.startingItems ? Object.assign([], enemy.Enemy.startingItems) : [];
        enemy.items = Object.assign(temp, KDLoadouts[loadout].items);
    }
    if (!((_a = enemy.Enemy.RestraintFilter) === null || _a === void 0 ? void 0 : _a.unlimitedRestraints) && (((_b = enemy.Enemy.attack) === null || _b === void 0 ? void 0 : _b.includes("Bind")) || ((_c = enemy.Enemy.specialAttack) === null || _c === void 0 ? void 0 : _c.includes("Bind")))) {
        let restMult = ((_d = KDLoadouts[loadout]) === null || _d === void 0 ? void 0 : _d.restraintMult) || 1;
        KDStockRestraints(enemy, restMult);
    }
}
function KDClearItems(enemy) {
    if (enemy.items) {
        for (let item of enemy.items) {
            if (KinkyDungeonFindWeapon(item)) {
                KinkyDungeonAddLostItems([{ name: item, type: Weapon, id: KinkyDungeonGetItemID() }], false);
            }
            else if (KinkyDungeonGetRestraintByName(item) && KinkyDungeonGetRestraintByName(item).showInQuickInv) {
                KinkyDungeonAddLostItems([{ name: item, type: LooseRestraint, quantity: 1, id: KinkyDungeonGetItemID() }], false);
            }
            else if (KinkyDungeonFindConsumable(item)) {
                KinkyDungeonAddLostItems([{ name: item, type: Consumable, quantity: 1, id: KinkyDungeonGetItemID() }], false);
            }
        }
        enemy.items = undefined;
    }
}
function KDCanDetect(enemy, player) {
    return (KinkyDungeonTrackSneak(enemy, 0, player) || (AIData.playerDist < Math.max(1.5, AIData.blindSight) && enemy.aware));
}
function KDGetSecurity(enemy, type) {
    var _a;
    let security = KDBaseSecurity[type] != undefined ? KDBaseSecurity[type] : -100;
    if (((_a = enemy === null || enemy === void 0 ? void 0 : enemy.Enemy) === null || _a === void 0 ? void 0 : _a.Security) && enemy.Enemy.Security[type])
        security = enemy.Enemy.Security[type];
    let faction = KDGetFactionOriginal(enemy);
    if (KDFactionSecurityMod[faction] && KDFactionSecurityMod[faction][type] != undefined)
        security = Math.max(security + KDFactionSecurityMod[faction][type], KDFactionSecurityMod[faction][type]);
    if (security >= -10) {
        if (enemy.Enemy.tags.boss)
            security += 4;
        else if (enemy.Enemy.tags.miniboss)
            security += 3;
        else if (enemy.Enemy.tags.elite)
            security += 2;
        else if (!enemy.Enemy.tags.minor)
            security += 1;
    }
    return security;
}
function KDReduceBinding(enemy, bonus) {
    let bindingPercent = enemy.boundLevel > 0 ? (((Math.max(0, enemy.boundLevel - bonus)) / enemy.boundLevel) || 0) : 0;
    enemy.boundLevel = Math.max(0, enemy.boundLevel - bonus);
    if (enemy.specialBoundLevel)
        for (let key of Object.keys(enemy.specialBoundLevel)) {
            enemy.specialBoundLevel[key] *= bindingPercent;
        }
}
function KDPlayerDeservesPunishment(enemy, player) {
    if (player.player) {
        if (KinkyDungeonFlags.get("PlayerCombat"))
            return true;
    }
    else {
        return true;
    }
}
function KDPlugEnemy(enemy) {
    let plugAmount = KDEntityBuffedStat(enemy, "Plug");
    if (!plugAmount)
        KDApplyGenBuffs(enemy, "Plugged", 9999);
    else if (plugAmount == 1) {
        KinkyDungeonExpireBuff(enemy.buffs, "Plugged");
        KDApplyGenBuffs(enemy, "DoublePlugged", 9998);
    }
}
function KDGetTags(enemy, removeSpecial) {
    let addOn = enemy.Enemy.bound ? KDExtraEnemyTags : undefined;
    let tags = Object.assign({}, enemy.Enemy.tags);
    if (addOn)
        Object.assign(tags, addOn);
    if (removeSpecial && enemy.Enemy.specialRemoveTags) {
        for (let t of enemy.Enemy.specialRemoveTags) {
            delete tags[t];
        }
    }
    return tags;
}
function KDGetExtraTags(enemy, useSpecial) {
    let addOn = enemy.Enemy.bound ? KDExtraEnemyTags : undefined;
    let tags = addOn ? Object.assign({}, addOn) : {};
    if (useSpecial && enemy.Enemy.specialExtraTags) {
        for (let t of enemy.Enemy.specialExtraTags) {
            tags[t] = 0;
        }
    }
    return tags;
}
let KDJailPersonalities = {
    "Robot": true,
    "Dom": true,
    "Sub": true,
};
let KDStrictPersonalities = [
    "Dom",
];
let KDLoosePersonalities = [
    "Sub",
];
let KDEnemyPersonalities = {
    "": { weight: 10,
        loose: false,
        strict: false,
        brat: false,
        domVariance: 0.4,
        tags: {
            "robot": -100,
        },
    },
    "Robot": { weight: -100,
        loose: false,
        strict: false,
        brat: false,
        tags: {
            "robot": 200,
        },
    },
    "Dom": { weight: 1,
        loose: false,
        strict: true,
        brat: false,
        tags: {
            "minor": -3,
            "alchemist": 2,
            "elite": 3,
            "boss": 3,
            "robot": -100,
        },
    },
    "Sub": { weight: 0,
        loose: true,
        strict: false,
        brat: false,
        tags: {
            "minor": 3,
            "human": 1,
            "elite": -2,
            "boss": -10,
            "robot": -100,
        },
    },
    "Brat": { weight: 0,
        loose: true,
        strict: false,
        brat: true,
        domMod: 0.7,
        tags: {
            "minor": 3,
            "human": 1,
            "boss": -3,
            "robot": -100,
        },
    },
};
function KDGetPersonality(enemy) {
    let WeightTotal = 0;
    let Weights = [];
    for (let p of Object.entries(KDEnemyPersonalities)) {
        let weight = p[1].weight;
        Weights.push({ p: p[0], weight: WeightTotal });
        if (p[1].tags)
            for (let tag of Object.entries(p[1].tags)) {
                if (enemy.Enemy.tags[tag[0]])
                    weight += tag[1];
            }
        WeightTotal += Math.max(weight, 0);
    }
    let selection = KDRandom() * WeightTotal;
    for (let L = Weights.length - 1; L >= 0; L--) {
        if (selection > Weights[L].weight) {
            if (Weights[L].p != undefined) {
                return Weights[L].p;
            }
            return "";
        }
    }
    return "";
}
function KDJailPersonality(enemy) {
    return (enemy.personality && KDJailPersonalities[enemy.personality]) ? enemy.personality : "";
}
let KinkyDungeonEnemies = [
    { name: "PrisonerBandit", tags: KDMapInit(["prisoner", "bandit", "human", "peaceful", "noshop"]), faction: "Prisoner", immobile: true, lowpriority: true, evasion: -100, armor: 0, followRange: 100, AI: "wander", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "PrisonerBandit",
        Behavior: { noPlay: true },
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "FactoryDoll", bound: "FactoryDoll", playLine: "Gagged", tags: KDMapInit(["prisoner", "dollmakerconvert", "doll", "human", "minor", "peaceful", "noshop"]), faction: "Prisoner", lowpriority: true, evasion: -100, armor: 0, followRange: 100, AI: "wander", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -10, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0,
        Behavior: { noPlay: true },
        terrainTags: { "bellowsDoll": 20 }, allFloors: true },
    { name: "DollmakerTarget", bound: "FactoryDoll", playLine: "Gagged", tags: KDMapInit(["prisoner", "escapeddoll", "doll", "human", "minor", "peaceful", "noshop"]),
        faction: "Prisoner", lowpriority: true, evasion: -100, armor: 0, followRange: 100, AI: "wander", regen: 0.01,
        visionRadius: 0, maxhp: 8, minLevel: 0, weight: -10, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0,
        Behavior: { noPlay: true },
        ondeath: [{ type: "dollID" }],
        terrainTags: {}, allFloors: true },
    { name: "ShopkeeperRescue", tags: KDMapInit(["human", "peaceful", "alwayshelp", "noshop", "opendoors"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "guard",
        visionRadius: 0, maxhp: 120, regen: 10, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "ShopkeeperRescueChatter",
        Behavior: { noPlay: true },
        noDisplace: true, keys: true,
        events: [
            { type: "ShopkeeperRescueAI", trigger: "afterEnemyTick" },
        ],
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "ShopkeeperStart", tags: KDMapInit(["human", "peaceful", "alwayshelp", "noshop", "opendoors"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "guard",
        visionRadius: 0, maxhp: 120, regen: 10, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "ShopkeeperStart",
        Behavior: { noPlay: true },
        noDisplace: true, keys: true,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "DressmakerQuest", tags: KDMapInit(["dressmaker", "human", "peaceful", "noshop"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "hunt", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "DressmakerQuest",
        Behavior: { noPlay: true },
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "ApprenticeQuest", tags: KDMapInit(["apprentice", "human", "peaceful", "noshop"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "hunt", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "ApprenticeQuest",
        Behavior: { noPlay: true },
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "BlacksmithQuest", tags: KDMapInit(["human", "peaceful", "alwayshelp", "noshop"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "hunt", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "BlacksmithShop", data: { "shop": "BlacksmithShop" },
        Behavior: { noPlay: true },
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "DragonheartQuest", tags: KDMapInit(["dragon", "peaceful", "alwayshelp", "noshop"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "hunt", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "DragonheartQuest",
        Behavior: { noPlay: true },
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "MaidforceQuest", tags: KDMapInit(["maid", "peaceful", "alwayshelp", "noshop"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "hunt", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "MaidforceQuest",
        Behavior: { noPlay: true },
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "DragonLeaderDuelist", faction: "Enemy", bound: "DragonLeader", color: "#F92900", tags: KDMapInit(["opendoors", "fire", "ignorenoSP", "noshop", "dragon", "melee", "elite", "dragonRestraints", "unflinching", "handcuffer", "leatherRestraints", "leatherRestraintsHeavy", "fireimmune"]),
        ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", focusPlayer: true,
        specialCD: 3, specialAttack: "Dash", specialRemove: "BindLockWill", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 3, specialMinrange: 1.5, dashThrough: true, specialsfx: "Miss",
        visionRadius: 7, maxhp: 28, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 2, attack: "MeleeBindLockWill", attackWidth: 1, attackRange: 1, power: 4, dmgType: "crush", fullBoundBonus: 2,
        terrainTags: {}, shrines: ["Leather"], allFloors: true,
        dropTable: [], factionrep: { "Dragon": 0.015 }, ondeath: [{ type: "removeQuest", quest: "DragonheartQuest" }] },
    { name: "BanditQuest", tags: KDMapInit(["bandit", "peaceful", "alwayshelp", "noshop"]), faction: "Prisoner", lowpriority: true, armor: 0, followRange: 100, AI: "hunt", regen: 0.1,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 4, attackPoints: 0, attack: "", attackRange: 0, specialdialogue: "BanditQuest",
        Behavior: { noPlay: true },
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "ChainWall", tags: KDMapInit(["construct", "flying", "poisonmmune", "soulimmune", "player", "noknockback", "melee", "temporary", "notalk", "nonvulnerable", "nobrain", "immobile"]),
        faction: "Witch", immobile: true, spellResist: 4, lowpriority: true, evasion: -100, armor: 2, followRange: 100, AI: "wander", regen: -0.25,
        visionRadius: 0, maxhp: 5, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 0, attack: "", attackRange: 0,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "ForceField", tags: KDMapInit(["construct", "flying", "poisonmmune", "soulimmune", "player", "noknockback", "melee", "temporary", "notalk", "nonvulnerable", "nobrain", "immobile"]),
        faction: "Enemy", immobile: true, spellResist: 3, lowpriority: true, evasion: -100, armor: 0, followRange: 100, AI: "wander", regen: -0.6,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 0, attack: "", attackRange: 0,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "DoorLock",
        tags: KDMapInit(["construct", "soulimmune", "melee", "noknockback", "unstoppable", "temporary", "nonvulnerable", "nobrain", "immobile", "poisonimmune",
            "soulimmune",
        ]), faction: "KinkyConstruct", immobile: true, lowpriority: true, spellResist: 1.5, evasion: -100, armor: 3, followRange: 100, AI: "wander", regen: -1.0,
        visionRadius: 0, maxhp: 30, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 0, attack: "", attackRange: 0,
        terrainTags: {}, floors: KDMapInit([]),
        events: [
            { trigger: "duringDamageEnemy", type: "damageThreshold", power: 1, chance: 1.0 },
        ],
    },
    { name: "EarthenMonolith", tags: KDMapInit(["construct", "poisonimmune", "soulimmune", "player", "playerinstakill", "noknockback", "melee", "temporary", "notalk", "immobile", "summonedRock", "fireresist", "nonvulnerable", "nobrain"]), immobile: true, spellResist: 1.0, faction: "Rock", lowpriority: true, evasion: -100, armor: 2.5, followRange: 100, AI: "wander", regen: -0.25,
        visionRadius: 0, maxhp: 5, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 0, attack: "", attackRange: 0,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "Wall", tags: KDMapInit(["construct", "poisonimmune", "soulimmune", "player", "playerinstakill", "noknockback", "melee", "temporary", "notalk", "nonvulnerable", "immobile", "nobrain"]), immobile: true, spellResist: 4, allied: true, lowpriority: true, evasion: -100, armor: 1, followRange: 100, AI: "wander", regen: -1.0,
        visionRadius: 0, maxhp: 25, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 0, attack: "", attackRange: 0,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "StaticSphere", tags: KDMapInit(["construct", "flying", "poisonimmune", "soulimmune", "player", "playerinstakill", "noknockback", "melee", "electricImmune", "nowet", "immobile", "temporary", "notalk", "nonvulnerable", "nobrain"]), immobile: true, spellResist: 4, allied: true, lowpriority: true, evasion: -100, armor: 1, followRange: 100, AI: "wander",
        visionRadius: 0, maxhp: 20, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 0, attack: "", attackRange: 0,
        terrainTags: {}, floors: KDMapInit([]),
        events: [
            { type: "CastSpellNearbyEnemy", trigger: "afterEnemyTick", spell: "StaticSphereStrike", aoe: 1.5, player: false },
            { type: "ApplyConductionAoE", trigger: "afterEnemyTick", aoe: 1.5 },
            { trigger: "getLights", type: "enemyTorch", power: 5, color: "#ffffff" },
        ],
    },
    { name: "Decoy", tags: KDMapInit(["construct", "poisonimmune", "soulimmune", "player", "temporary", "notalk"]), noblockplayer: true, allied: true, evasion: 2, armor: 0, followRange: 100, AI: "wander", triggersTraps: true,
        visionRadius: 0, maxhp: 12, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 0, attack: "", attackRange: 0,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "Ally", tags: KDMapInit(["ghost", "flying", "player", "melee"]), keepLevel: true, allied: true, armor: 0, followRange: 1, AI: "hunt", evasion: 0.33, accuracy: 1.5,
        visionRadius: 20, playerBlindSight: 100, maxhp: 8, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 1, attack: "MeleeWill", attackRange: 1, attackWidth: 3, power: 1, dmgType: "slash", CountLimit: true,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "AllyDoll", bound: "AllyDoll", color: "#9c2a70", tags: KDMapInit(["human", "player", "gagged", "blindfold", "melee", "glueimmune", "tickleweakness", "nohelp"]), allied: true, armor: 0, followRange: 1, AI: "hunt",
        visionRadius: 20, playerBlindSight: 100, maxhp: 8, regen: -0.1, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 2, attack: "MeleeWill", attackRange: 1, attackWidth: 1, power: 1.5, dmgType: "glue",
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "PetChastity", bound: "AllyDoll", color: "#8888ff", tags: KDMapInit(["human", "player", "gagged", "blindfold", "melee", "charmresist", "soulweakness", "tickleweakness", "nohelp"]), armor: 1.0, followRange: 1, AI: "hunt",
        visionRadius: 6, maxhp: 8, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 2, attack: "MeleeWill", attackRange: 1, attackWidth: 1, power: 2, dmgType: "charm",
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "Pet", color: "#8888ff", tags: KDMapInit(["human", "player", "gagged", "melee", "tickleweakness", "nohelp"]), allied: true, armor: 0, followRange: 4, AI: "hunt",
        events: [
            { trigger: "calcManaPool", type: "PetManaRegen", power: 0.01, dist: 1.5 },
        ],
        visionRadius: 20, playerBlindSight: 100, maxhp: 10, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 2, attack: "", attackRange: 0, power: 1.5, dmgType: "tickle", focusPlayer: true,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "PetDisplay", color: "#8888ff", tags: KDMapInit(["human", "player", "gagged", "melee", "meleeresist", "nohelp"]), immobile: true, allied: true, armor: 1.5, followRange: 4, AI: "hunt",
        events: [
            { trigger: "calcManaPool", type: "PetManaRegen", power: 0.04, dist: 3.99 },
            { trigger: "tick", type: "DisplayAura", power: 0.5, dist: 3.99 },
        ],
        visionRadius: 0, playerBlindSight: 100, maxhp: 15, minLevel: 0, weight: -1000, movePoints: 9999, attackPoints: 2, attack: "", attackRange: 0, power: 1.5, dmgType: "tickle", focusPlayer: true,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "PlayerGag", tags: KDMapInit(["construct", "poisonresist", "soulimmune", "player", "melee", "temporary", "notalk"]), noblockplayer: true, allied: true, armor: 0, followRange: 1, AI: "guard", accuracy: 1.5, noTargetSilenced: true,
        visionRadius: 20, playerBlindSight: 100, maxhp: 4, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 1, attack: "MeleeWillSilenceSuicideStun", silenceTime: 9, stunTime: 1, attackRange: 1, attackWidth: 1, power: 3.5, dmgType: "grope",
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "ShadowWarrior", tags: KDMapInit(["ghost", "player", "flying", "melee", "tickleimmune", "glueimmune", "temporary", "notalk"]), noblockplayer: true, allied: true, armor: 0, followRange: 1, AI: "hunt", evasion: 1,
        spells: ["AllyShadowStrike"], spellCooldownMult: 1, spellCooldownMod: 0,
        visionRadius: 20, playerBlindSight: 100, maxhp: 11, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 1, attack: "Spell", attackRange: 0, power: 1,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "FireElemental", color: "#FF6200", tags: KDMapInit(["elemental", "flying", "fire", "player", "ranged", "charmimmune", "fireimmune", "coldweakness", "acidweakness", "icesevereweakness", "stunweakness", "nohelp"]), keepLevel: true, allied: true, armor: 0, kite: 1.5, followRange: 3, playerFollowRange: 1, AI: "hunt",
        spells: ["AllyFirebolt"], spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true, spellRdy: true, evasion: 0.5, CountLimit: true,
        visionRadius: 20, playerBlindSight: 100, maxhp: 8, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 1, attack: "Spell", attackRange: 0, power: 1,
        terrainTags: {}, floors: KDMapInit([]),
        events: [
            { trigger: "afterEnemyTick", type: "createEffectTile", kind: "Ember", time: 3, power: 2, chance: 0.2, aoe: 1.5 },
            { trigger: "getLights", type: "enemyTorch", power: 5.5, color: "#ff8933" },
        ],
    },
    { name: "WaterMote", color: "#73efe8", tags: KDMapInit(["elemental", "flying", "water", "player", "melee", "charmimmune", "fireresist", "iceweakness", "acidimmune", "electricsevereweakness", "nohelp"]), keepLevel: true, allied: true, armor: 0, followRange: 1, playerFollowRange: 1, AI: "hunt",
        evasion: 1.0, CountLimit: true, specialAttack: "Stun", specialCD: 7,
        visionRadius: 20, playerBlindSight: 100, maxhp: 8, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 2, attack: "MeleeWill", attackRange: 1, attackWidth: 1, power: 2, stunTime: 3, dmgType: "acid",
        terrainTags: {}, floors: KDMapInit([]),
        events: [{ trigger: "afterEnemyTick", type: "createWater", power: 1, chance: 0.5, aoe: 0.5 }], },
    { name: "EarthMote", color: "#e64539", tags: KDMapInit(["elemental", "flying", "earth", "player", "melee", "charmimmune", "fireresist", "electricresist", "tickleresist", "nohelp"]), keepLevel: true, allied: true, followRange: 1, playerFollowRange: 1, AI: "hunt",
        evasion: -0.4, armor: 2.0, spellResist: 0.5, CountLimit: true,
        visionRadius: 20, playerBlindSight: 100, maxhp: 8, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 4, attack: "MeleeWillSlow", attackRange: 1, attackWidth: 1, power: 6, dmgType: "crush",
        terrainTags: {}, floors: KDMapInit([]),
        events: [{ trigger: "death", type: "createEffectTile", kind: "Cracked", power: 1, chance: 1, aoe: 0.5, time: 40, variance: 10 }], },
    { name: "AirMote", color: "#ffffff", tags: KDMapInit(["elemental", "flying", "air", "nowet", "player", "ranged", "charmimmune", "fireweakness", "electricresist", "stunimmune", "painresist", "tickleweakness", "groperesist", "nohelp"]), keepLevel: true, allied: true, followRange: 3, kite: 1.5, playerFollowRange: 1, AI: "hunt",
        spells: ["AllyWindBlast"], spellCooldownMult: 1, spellCooldownMod: 0, spellRdy: true, evasion: 1.0, CountLimit: true, castWhileMoving: true,
        visionRadius: 20, playerBlindSight: 100, maxhp: 8, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 1, attack: "Spell", attackRange: 0, power: 1,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "Golem", tags: KDMapInit(["construct", "poisonimmune", "soulimmune", "player", "melee", "fireresist", "unstoppable", "tickleresist", "groperesist", "electricresist", "notalk"]), keepLevel: true, allied: true, armor: 2.0, spellResist: 0.4, followRange: 1, AI: "hunt",
        visionRadius: 20, playerBlindSight: 100, maxhp: 18, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 3, attack: "MeleeWill", attackRange: 1, attackWidth: 1, power: 4.5, accuracy: 0.7, CountLimit: true,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "StormCrystal", tags: KDMapInit(["construct", "flying", "poisonimmune", "soulimmune", "player", "ranged", "unstoppable", "meleeresist", "tickleimmune", "electricimmune", "soulimmune", "temporary", "notalk", "nonvulnerable", "immobile", "nobrain"]), immobile: true, noblockplayer: true, allied: true, armor: 1.5, followRange: 1, AI: "wander", evasion: -10,
        spells: ["AllyCrackle"], spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true,
        visionRadius: 6, maxhp: 30, regen: -1, minLevel: 0, weight: -1000, movePoints: 1000, attackPoints: 1, attack: "Spell", attackRange: 0, power: 1,
        terrainTags: {}, floors: KDMapInit([]),
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 8, color: "#8888ff" },
        ],
    },
    { name: "HolyConstruct", faction: "Angel", clusterWith: "angel", color: "#ffffaa", tags: KDMapInit(["opendoors", "minor", "holy", "construct", "ranged", "soulimmune", "meleeresist", "unstoppable", "celestialRopes", "coldsevereweakness", "flying"]),
        cohesion: 0.7, cohesionRange: 10,
        spellResist: 3,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 3, AI: "hunt", buffallies: true,
        spells: ["OrbHeal", "CelestialBolt"], spellCooldownMult: 2, spellCooldownMod: 0, tilesMinRange: 1, stopToCast: true, kite: 1.5, kiteChance: 0.9,
        visionRadius: 10, maxhp: 7, minLevel: 0, weight: -1, movePoints: 3, attackPoints: 4, attack: "SpellMeleeBlindBind", blindTime: 3, attackWidth: 8, attackRange: 1, power: 4, dmgType: "fire",
        terrainTags: { "goddessRage": 7, "willPleased": 2, "willFriendly": 2, "angel": 6 }, shrines: ["Will"], allFloors: true, dropTable: [{ name: "Ectoplasm", weight: 9 }, { name: "ElfCrystal", weight: 3 }],
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffff44" }
        ],
    },
    { name: "Angel", bound: "Angel", faction: "Angel", color: "#ffffaa", tags: KDMapInit(["angel", "flying", "ranged", "divineRestraints", "meleeresist", "unflinching"]),
        followRange: 0, AI: "hunt", evasion: 0.25, attackWhileMoving: true,
        spells: ["HeatBolt", "WitchElectrify", "EnemyCorona"], spellCooldownMult: 0, spellCooldownMod: 4, castWhileMoving: true, noSpellsLowSP: true, spellRdy: true,
        visionRadius: 10, maxhp: 25, spellResist: 3, minLevel: 4, movePoints: 1.7, attackPoints: 3, attack: "SpellMeleeBindLock", attackRange: 1, attackWidth: 3, power: 2, fullBoundBonus: 4, dmgType: "tickle",
        attackLock: "Blue",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 6, color: "#ffff44" },
        ],
        terrainTags: { "goddessRage": 0.4, "increasingWeight": 0.2, "goddessAnger": 0.6, "angel": 3, }, allFloors: true, weight: -0.5,
        dropTable: [{ name: "MagicSword", weight: 1, ignoreInInventory: true }, { name: "MagicSpear", weight: 1, ignoreInInventory: true }, { name: "MagicAxe", weight: 1, ignoreInInventory: true }, { name: "MagicFlail", weight: 1, ignoreInInventory: true }, { name: "MagicHammer", weight: 1, ignoreInInventory: true }],
        rep: { "Will": -1, "Elements": -1, "Conjure": -1, "Illusion": -1 } },
    { name: "BlindZombie", bound: "Zombie", playLine: "Zombie", clusterWith: "zombie", tags: KDMapInit(["ignoreharmless", "minor", "zombie", "melee", "fireweakness", "ribbonRestraints", "meleeweakness", "jail"]), evasion: -1, ignorechance: 0.33, armor: 0, followRange: 1, AI: "wander",
        visionRadius: 2.5, maxhp: 8, minLevel: 0, weight: 14, movePoints: 3, attackPoints: 4, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "increasingWeight": -1.5 }, floors: KDMapInit(["grv"]), dropTable: [], difficulty: 0.9 },
    { name: "FastZombie", bound: "Zombie", playLine: "Zombie", clusterWith: "zombie", tags: KDMapInit(["ignoreharmless", "zombie", "melee", "fireweakness", "ribbonRestraints", "meleeweakness", "jail"]), evasion: -1, ignorechance: 0.33, armor: 1, followRange: 1, AI: "hunt",
        visionRadius: 5, maxhp: 10, minLevel: 1, weight: 9, movePoints: 3, attackPoints: 4, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 10, "lastthird": 14 }, floors: KDMapInit(["grv"]), dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }] },
    { name: "SummonedZombie", bound: "Zombie", playLine: "Zombie", regen: -0.7, clusterWith: "zombie", tags: KDMapInit(["ignoreharmless", "zombie", "melee", "fireweakness", "ribbonRestraints", "meleeweakness", "temporary"]), evasion: -1, ignorechance: 0.33, armor: 1, followRange: 1, AI: "hunt",
        visionRadius: 5, maxhp: 10, minLevel: 1, weight: -1000, movePoints: 3, attackPoints: 3, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 10, "lastthird": 14 }, floors: KDMapInit([]) },
    { name: "MageZombie", bound: "MageZombie", playLine: "Zombie", clusterWith: "zombie", tags: KDMapInit(["leashing", "zombie", "ranged", "fireweakness", "ribbonRestraints", "meleeweakness", "hunter", "jail"]), spellResist: 0.5, evasion: -1, armor: 0, followRange: 2, AI: "hunt",
        spells: ["ZombieOrb", "ZombieOrbIce"], spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true, projectileAttack: true,
        visionRadius: 6, maxhp: 13, minLevel: 2, weight: 14, movePoints: 3, attackPoints: 4, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2,
        attackLock: "Purple",
        terrainTags: {}, floors: KDMapInit(["grv", "tmb"]), dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10 }] },
    { name: "TalismanZombie", bound: "TalismanZombie", playLine: "Zombie", clusterWith: "zombie", tags: KDMapInit(["leashing", "zombie", "ranged", "fireweakness", "ribbonRestraints", "meleeweakness", "hunter", "jail"]), spellResist: 0.5, evasion: -1, armor: 0, followRange: 3, AI: "hunt",
        spells: ["ZombieOrb", "ZombieBuff", "OrbHeal", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true, buffallies: true, kite: 1.5, projectileAttack: true,
        visionRadius: 6, maxhp: 20, minLevel: 3, weight: 14, movePoints: 3, attackPoints: 4, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2,
        attackLock: "Purple",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffff44" },
        ],
        terrainTags: { "mummy": 3 }, floors: KDMapInit(["grv", "tmb"]), dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10 }] },
    { name: "SamuraiZombie", bound: "SamuraiZombie", playLine: "Zombie", clusterWith: "zombie", tags: KDMapInit(["leashing", "zombie", "melee", "elite", "fireweakness", "unflinching", "ropeRestraints", "jail", "ropeRestraints2", "meleeweakness", "hunter"]), evasion: -1, armor: 2, followRange: 1, AI: "hunt",
        stunTime: 2, specialCD: 6, specialAttack: "Stun", specialRemove: "BindLock", specialPower: 5, specialDamage: "pain",
        specialCDonAttack: false, visionRadius: 6, maxhp: 20, minLevel: 4, weight: 9, movePoints: 3, attackPoints: 3, attack: "MeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3, specialWidth: 5, specialRange: 1,
        terrainTags: { "secondhalf": 5, "lastthird": 5 }, shrines: ["Will"], floors: KDMapInit(["grv", "tmb"]), dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "Sword", weight: 3.5, ignoreInInventory: true },] },
    { name: "NawashiZombie", bound: "NawashiZombie", playLine: "Zombie", clusterWith: "zombie", tags: KDMapInit(["leashing", "zombie", "melee", "elite", "fireweakness", "unflinching", "ropeRestraints", "jail", "ropeRestraints2", "meleeweakness", "hunter"]), evasion: -1, armor: 0, followRange: 1, AI: "hunt",
        visionRadius: 8, maxhp: 12, minLevel: 0, weight: 2, movePoints: 2, attackPoints: 2, attack: "MeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2, difficulty: 1.4,
        terrainTags: { "secondhalf": 1, "lastthird": 2 }, shrines: [], floors: KDMapInit(["grv", "tmb"]), dropTable: [{ name: "Gold", amountMin: 5, amountMax: 15, weight: 10 }, { name: "Rope", weight: 3.5, ignoreInInventory: true }, { name: "Scissors", weight: 0.5, ignoreInInventory: true },] },
    { name: "Ninja", playLine: "Hunter", faction: "Bountyhunter", bound: "Ninja", clusterWith: "human", color: "#814BB7", tags: KDMapInit(["leashing", "opendoors", "human", "guardCall", "imprisonable", "bountyhunter", "ninja", "melee", "ropeRestraints", "ropeRestraints2", "jailer", "unarmedresist", "slashresist", "glueweakness", "chainweakness", "search"]), followLeashedOnly: true, blindSight: 5, followRange: 1, AI: "hunt", projectileAttack: true,
        stunTime: 4, specialCD: 6, specialCharges: 6, specialAttack: "Stun", specialRemove: "BindLock", specialCDonAttack: true, strictAttackLOS: true, focusPlayer: true,
        visionRadius: 7, maxhp: 12, minLevel: 4, weight: 5, movePoints: 1, attackPoints: 3, attack: "MeleeBindLock", attackWidth: 1, attackRange: 1, power: 1.5, dmgType: "crush", fullBoundBonus: 1.5, specialWidth: 1, specialAttackPoints: 3, specialRange: 4, specialMinrange: 1.5,
        terrainTags: { "secondhalf": 3, "lastthird": 7, "ropeAnger": 2, "bountyhunter": 8, "rope": 5 }, shrines: ["Illusion", "Rope"], floors: KDMapInit(["cat", "tmb", "tmp", "cry"]),
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }] },
    { name: "Deputy", playLine: "Officer", color: "#1451f1", faction: "Bountyhunter", bound: "Ninja", clusterWith: "human", tags: KDMapInit(["leashing", "opendoors", "human", "police", "guardCall", "bountyhunter", "handcuffer", "steelCuffs", "police", "melee", "search", "jail", "jailer"]), followLeashedOnly: true, blindSight: 5, followRange: 1, AI: "hunt", projectileAttack: true,
        stunTime: 5, specialCD: 11, specialCharges: 4, specialAttack: "Stun", specialRemove: "BindLock", specialCDonAttack: true, strictAttackLOS: true, specialWidth: 2, specialAttackPoints: 4, specialRange: 5, specialMinrange: 1.5,
        visionRadius: 8, maxhp: 12, minLevel: 2, weight: 1, movePoints: 1.5, attackPoints: 3, attack: "MeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 2, "lastthird": 4, "leatherAnger": 2, "metalAnger": 2, "bountyhunter": 8, "metal": 2 }, shrines: ["Leather", "Metal"], floors: KDMapInit(["grv", "jng", "lib", "cry"]),
        dropTable: [{ name: "Donut", weight: 1 }] },
    { name: "NinjaStalker", playLine: "Hunter", faction: "Bountyhunter", bound: "NinjaStalker", clusterWith: "human", color: "#814BB7", tags: KDMapInit(["leashing", "opendoors", "ninja", "human", "bountyhunter", "melee", "ropeRestraints", "ropeRestraints2", "unarmedresist", "slashresist", "glueweakness", "chainweakness", "search"]), blindSight: 5, followRange: 1, AI: "ambush", stealth: 1, noReveal: true,
        ambushRadius: 1.9, wanderTillSees: true, visionRadius: 7, maxhp: 12, minLevel: 4, weight: 4, movePoints: 1, attackPoints: 3, focusPlayer: true,
        attack: "MeleeBindLock", attackWidth: 1, attackRange: 1, power: 3, dmgType: "crush", fullBoundBonus: 2, specialWidth: 1, specialAttackPoints: 3, specialRange: 4, specialMinrange: 1.5,
        terrainTags: { "secondhalf": 3, "lastthird": 7, "ropeAnger": 2, "bountyhunter": 8, "rope": 5 }, shrines: ["Illusion", "Rope"], floors: KDMapInit(["cat", "tmb", "tmp", "cry"]),
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }] },
    { name: "Nawashi", playLine: "Hunter", faction: "Bountyhunter", bound: "Nawashi", clusterWith: "construct", color: "#5261ff", tags: KDMapInit(["leashing", "opendoors", "guardCall", "human", "bountyhunter", "elite", "melee", "ropeRestraints", "ropeRestraints2", "ropeRestraintsWrist", "ropeAuxiliary", "jail", "jailer", "ropeRestraintsHogtie"]),
        spells: ["RopeAttack"], spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true, stealth: 2, noReveal: true, focusPlayer: true,
        followLeashedOnly: true, blindSight: 10, followRange: 1, kite: 3, AI: "hunt", evasion: 0.5, dontKiteWhenDisabled: true,
        visionRadius: 7, maxhp: 22, minLevel: 8, weight: 1, movePoints: 1.5, attackPoints: 2, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "crush", fullBoundBonus: 1, specialWidth: 1, specialAttackPoints: 3, specialRange: 4, specialMinrange: 1.5,
        terrainTags: { "secondhalf": 1, "lastthird": 2, "ropeAnger": 1, "ropeRage": 1, "bountyhunter": 4, "rope": 5 }, shrines: ["Rope"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 20, amountMax: 30, weight: 10 }, { name: "Scissors", ignoreInInventory: true, weight: 10 }, { name: "EnchKnife", ignoreInInventory: true, weight: 1 }, { name: "Rope", weight: 100, ignoreInInventory: true },] },
    { name: "Maidforce", faction: "Maidforce", bound: "Maid", clusterWith: "maid", playLine: "SubMaid", color: "#814BB7", tags: KDMapInit(["leashing", "submissive", "tickleweakness", "imprisonable", "opendoors", "human", "maid", "melee", "ropeRestraints", "ropeRestraints2", "handcuffer", "maidVibeRestraintsLimited", "maidRestraintsLight", "jail", "search"]), blindSight: 3, followRange: 1, AI: "hunt",
        stealth: 4, noReveal: true, bindOnDisableSpecial: true, bindOnDisable: true, hitsfx: "Tickle",
        specialCD: 3, specialAttack: "BindLock", specialCDonAttack: true,
        visionRadius: 6, maxhp: 8, minLevel: 0, weight: -2, movePoints: 2, attackPoints: 2, attack: "MeleeWill", attackWidth: 1, attackRange: 1, power: 2, dmgType: "tickle", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 1, "lastthird": 1, "illusionAnger": 22, "illusionRage": 12, "increasingWeight": -1, "maid": 9 }, shrines: ["Illusion"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }] },
    { name: "MaidforcePara", faction: "Maidforce", bound: "MaidforcePara", clusterWith: "maid", playLine: "DomMaid", color: "#814BB7", tags: KDMapInit(["leashing", "opendoors", "tickleweakness", "guardCall", "human", "miniboss", "maid", "ranged", "ropeRestraints", "ropeRestraints2", "handcuffer", "maidVibeRestraintsLimited", "maidRestraintsLight", "hunter"]), followLeashedOnly: true, blindSight: 5, followRange: 4, AI: "hunt", guardChance: 0.6, projectileAttack: true,
        spells: ["ParasolBuff", "Hairpin", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, spellCooldownMult: 1, spellCooldownMod: 0, buffallies: true, kite: 2.5,
        stealth: 3, disarm: 0.5, spellRdy: true,
        visionRadius: 8, maxhp: 10, minLevel: 0, weight: -2, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope",
        terrainTags: { "secondhalf": 1, "lastthird": 1, "illusionAnger": 17, "illusionRage": 11, "maid": 6 }, shrines: ["Illusion"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 },] },
    { name: "MaidforceStalker", faction: "Maidforce", bound: "MaidforceStalker", clusterWith: "maid", playLine: "DomMaid", color: "#814BB7",
        tags: KDMapInit(["leashing", "opendoors", "human", "maid", "melee", "maidRestraints", "handcuffer", "maidVibeRestraintsLimited", "unarmedresist", "tickleweakness", "slashresist", "glueweakness", "chainweakness", "jail", "jailer", "hunter"]),
        followLeashedOnly: true, blindSight: 5, followRange: 1, AI: "hunt", guardChance: 0.6, projectileAttack: true, evasion: 0.33,
        spells: ["FlashBomb", "MirrorImage"], spellCooldownMult: 1, spellCooldownMod: 0, kite: 2, dontKiteWhenDisabled: true, castWhileMoving: true,
        stealth: 1,
        visionRadius: 7, maxhp: 12, minLevel: 4, weight: -2, movePoints: 1, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 1, "lastthird": 1, "illusionAnger": 15, "illusionRage": 10, "increasingWeight": 0.5, "maid": 5 }, shrines: ["Illusion"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "PotionInvisibility", weight: 3 }] },
    { name: "MaidforceStalkerImage", faction: "Maidforce", color: "#814BB7", tags: KDMapInit(["ghost", "maid", "melee"]), followLeashedOnly: true, blindSight: 12, followRange: 2, AI: "hunt", guardChance: 0.6, projectileAttack: true, evasion: -10,
        kite: 2, dontKiteWhenDisabled: true,
        stealth: 1,
        visionRadius: 7, maxhp: 1, minLevel: 0, weight: -10, movePoints: 1.25, attackPoints: 2, attack: "MeleeWill", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 1, dmgType: "grope",
        terrainTags: {}, shrines: ["Illusion"], floors: KDMapInit([]), },
    { name: "MaidforceMafia", faction: "Maidforce", bound: "MaidforceMafia", clusterWith: "maid", color: "#814BB7", playLine: "DomMaid", tags: KDMapInit(["leashing", "opendoors", "tickleweakness", "human", "elite", "maid", "ranged", "maidRestraints", "handcuffer", "maidVibeRestraintsLimited", "jail", "jailer", "hunter"]), followLeashedOnly: true, followRange: 4, AI: "hunt", guardChance: 0.6, projectileAttack: true, evasion: -0.25,
        spells: ["RubberBullets"], spellCooldownMult: 1, spellCooldownMod: 0, kite: 3, noKiteWhenHarmless: true, noSpellsWhenHarmless: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffaa00" },
        ],
        visionRadius: 7, maxhp: 14, minLevel: 4, weight: -9, movePoints: 3, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 1, dmgType: "pain", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "lastthird": 1, "open": 6, "illusionAnger": 12, "illusionRage": 5, "latexAnger": 4, "maid": 5 }, shrines: ["Illusion"], allFloors: true, attackLock: "Red",
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }] },
    { name: "MaidforceHead", faction: "Maidforce", bound: "MaidforceHead", clusterWith: "maid", color: "#814BB7", playLine: "HeadMaid", tags: KDMapInit(["leashing", "guardCall", "tickleweakness", "opendoors", "human", "maid", "unflinching", "boss", "ranged", "maidRestraintsNonChastity", "maidVibeRestraints", "handcuffer", "jailer", "hunter"]), followLeashedOnly: true, followRange: 3.5, AI: "hunt", guardChance: 0.6, projectileAttack: true,
        spells: ["AmpuleGreen", "Hairpin", "RestrainingDevice"], spellCooldownMult: 1, spellCooldownMod: 0, hitsfx: "Tickle", disarm: 1, ignoreStaminaForBinds: true, sneakThreshold: 1, focusPlayer: true,
        useLock: "Red", kite: 2.5,
        RestraintFilter: {
            ignoreInitialTag: ["maidVibeRestraints"],
        },
        RemoteControl: {
            remote: 5, remoteAmount: 4,
        }, bypass: true, noLeashUnlessExhausted: true, evasion: 0.15,
        events: [
            { trigger: "afterEnemyTick", type: "maidforceHeadAura", dist: 1.5 },
        ],
        visionRadius: 8, maxhp: 28, minLevel: 6, weight: -14, movePoints: 2, attackPoints: 2, attack: "SpellMeleeBindLockAllVibe", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 1.5, dmgType: "tickle", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 1, "lastthird": 1, "open": 4, "illusionAnger": 10, "illusionRage": 4, "maid": 12 }, shrines: ["Illusion"], allFloors: true, attackLock: "Red",
        dropTable: [{ name: "Gold", amountMin: 30, amountMax: 40, weight: 20 }, { name: "EnchKnife", ignoreInInventory: true, weight: 1 }] },
    { name: "Skeleton", bound: "Skeleton", playLine: "Skeleton", clusterWith: "skeleton", tags: KDMapInit(["nosub", "leashing", "skeleton", "gagged", "melee", "ropeRestraints", "leatherRestraints", "clothRestraints", "coldresist", "crushweakness", "search"]), ignorechance: 0, armor: 0, followRange: 1, AI: "hunt",
        visionRadius: 4, maxhp: 5, minLevel: 1, weight: 8, movePoints: 2, attackPoints: 3, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1.0,
        terrainTags: { "secondhalf": 4, "increasingWeight": -0.5 }, shrines: ["Leather"], floors: KDMapInit(["cat", "tmb"]), dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }] },
    { name: "SummonedSkeleton", bound: "Skeleton", playLine: "Skeleton", clusterWith: "skeleton", tags: KDMapInit(["nosub", "leashing", "skeleton", "gagged", "melee", "coldresist", "ropeRestraints", "leatherRestraints", "clothRestraints", "crushweakness"]), ignorechance: 0, armor: 0, followRange: 1, AI: "guard",
        visionRadius: 5, maxhp: 5, minLevel: 1, weight: 8, movePoints: 2, attackPoints: 3, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 0.5, dmgType: "grope", fullBoundBonus: 0.5,
        terrainTags: { "lastthird": -8 }, shrines: [], floors: KDMapInit([]) },
    { name: "LesserSkeleton", bound: "Skeleton", playLine: "Skeleton", noChaseUnrestrained: true, clusterWith: "skeleton", tags: KDMapInit(["nosub", "leashing", "ignorenoSP", "skeleton", "gagged", "melee", "coldresist", "crushweakness"]), ignorechance: 0, armor: 0, followRange: 1, AI: "wander", evasion: -2,
        visionRadius: 1, maxhp: 2.5, minLevel: 0, weight: 10, movePoints: 2, attackPoints: 3, attack: "MeleeWillSlow", attackWidth: 1, attackRange: 1, power: 0.5, dmgType: "grope", fullBoundBonus: 0.5,
        terrainTags: { "secondhalf": -8, "lastthird": -8, "increasingWeight": -1 }, floors: KDMapInit(["cat", "tmb"]) },
    { name: "GreaterSkeleton", bound: "GreaterSkeleton", playLine: "Skeleton", clusterWith: "skeleton", tags: KDMapInit(["nosub", "leashing", "skeleton", "gagged", "melee", "unflinching", "elite", "coldresist", "crushweakness", "hunter"]), ignorechance: 0, armor: 1, followRange: 1.5, AI: "hunt", guardChance: 0.6, disarm: 0.5,
        visionRadius: 4, maxhp: 10, minLevel: 9, weight: 5, movePoints: 3, attackPoints: 3, attack: "MeleeWillSlow", attackWidth: 3, attackRange: 1, power: 5, dmgType: "crush", fullBoundBonus: 0,
        terrainTags: { "secondhalf": 4, "lastthird": 6, "increasingWeight": 0.5 }, floors: KDMapInit(["cat", "tmb", "tmp"]), dropTable: [{ name: "PotionStamina", weight: 3 }, { name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "Hammer", weight: 50, ignoreInInventory: true }] },
    { name: "HeavySkeleton", bound: "HeavySkeleton", playLine: "Skeleton", clusterWith: "skeleton", color: "#aaaaaa", tags: KDMapInit(["nosub", "leashing", "skeleton", "gagged", "melee", "unflinching", "elite", "coldresist", "crushweakness", "hunter", "obsidianRestraints"]), ignorechance: 0, armor: 2, followRange: 1.5, AI: "hunt", guardChance: 0.6, disarm: 0.5,
        visionRadius: 6, maxhp: 16, minLevel: 15, weight: 4, movePoints: 3, attackPoints: 3, attack: "MeleeWillSlowBind", attackWidth: 3.6, attackRange: 1, power: 5, dmgType: "crush", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "lastthird": 4, "increasingWeight": 1 }, floors: KDMapInit(["cat", "tmb", "tmp"]),
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "Axe", weight: 50, ignoreInInventory: true }] },
    { name: "Ghost", color: "#FFFFFF", faction: "Ghost", clusterWith: "ghost", tags: KDMapInit(["ignorenoSP", "ghost", "flying", "spooky", "melee", "glueimmune", "chainimmune"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", guardChance: 0.6, hitsfx: "Tickle",
        visionRadius: 6, blindSight: 3, evasion: 9.0, alwaysEvade: true, maxhp: 1, minLevel: 0, weight: 0.1, movePoints: 3, attackPoints: 2, attack: "MeleeWill", attackWidth: 3, attackRange: 1, power: 1, dmgType: "tickle", fullBoundBonus: 0,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffffff" },
        ],
        terrainTags: { "ghost": 4.9 }, shrines: ["Illusion"], allFloors: true,
        dropTable: [{ name: "Ectoplasm", weight: 1 }] },
    { name: "TickleTerror", faction: "Ghost", color: "#FFFFFF", tags: KDMapInit(["chestTrap", "ignorenoSP", "comfyRestraints", "spooky", "ghost", "flying", "melee", "glueimmune", "chainimmune", "meleeresist"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", noAlert: true, hitsfx: "Tickle",
        visionRadius: 8, blindSight: 8, evasion: 0.5, maxhp: 12, minLevel: 4, weight: 0.1, movePoints: 2, attackPoints: 2, attack: "MeleeWillBind", attackWidth: 3, attackRange: 1, power: 3, dmgType: "tickle", fullBoundBonus: 3,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffffff" },
        ],
        terrainTags: { "ghost": 1.9, "increasingWeight": 0.2, "chestTrap": 50, "goddessRage": 4 }, shrines: ["Illusion"], allFloors: true,
        dropTable: [{ name: "Ectoplasm", weight: 1 }] },
    { name: "HugHorror", faction: "Ghost", color: "#FFFFFF", tags: KDMapInit(["chestTrap", "ignorenoSP", "ghostRestraints", "spooky", "ghost", "flying", "melee", "glueimmune", "chainimmune", "meleeresist"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", noAlert: true,
        visionRadius: 8, blindSight: 8, evasion: 0.2, maxhp: 20, minLevel: 4, weight: 0.1, movePoints: 3, attackPoints: 2, attack: "MeleeWillBindSlow", attackWidth: 3, attackRange: 1, power: 2, dmgType: "crush", fullBoundBonus: 2,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffffff" },
        ],
        terrainTags: { "ghost": 1.9, "increasingWeight": 0.2, "chestTrap": 50, "goddessRage": 4 }, shrines: ["Illusion"], allFloors: true,
        dropTable: [{ name: "Ectoplasm", weight: 1 }] },
    { name: "GreedyGhast", faction: "Ghost", color: "#FFFFFF", tags: KDMapInit(["chestTrap", "ignorenoSP", "ghost", "flying", "melee", "spooky", "glueimmune", "chainimmune", "meleeresist"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", noAlert: true,
        visionRadius: 6, blindSight: 4, evasion: 0.5, maxhp: 7, minLevel: 2, weight: 0.1, movePoints: 2, attackPoints: 2, attack: "MeleeWill", attackWidth: 3, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffffff" },
        ],
        terrainTags: { "ghost": 1.9, "increasingWeight": 0.05, "chestTrap": 100, "goddessRage": 5 }, shrines: ["Illusion"], allFloors: true,
        dropTable: [{ name: "Ectoplasm", weight: 1 }] },
    { name: "OrbGuardian", faction: "Ghost", alwaysHostile: true, clusterWith: "ghost", tags: KDMapInit(["divine", "melee", "flying", "glueimmune", "chainimmune"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt",
        spells: ["ShadowStrike"], spellCooldownMult: 1, spellCooldownMod: 0,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 5, color: "#440099" },
        ],
        visionRadius: 100, blindSight: 100, evasion: 0.5, alwaysEvade: true, maxhp: 12, minLevel: 0, weight: -10, movePoints: 2, attackPoints: 1, attack: "Spell", attackWidth: 3,
        attackRange: 1, power: 4, dmgType: "cold", fullBoundBonus: 0,
        terrainTags: {}, shrines: [], floors: KDMapInit([]),
        dropTable: [{ name: "Ectoplasm", weight: 1 }] },
    { name: "TickleHand", hidetimerbar: true, faction: "Witch", clusterWith: "ghost", color: "#FFFFFF", tags: KDMapInit(["ignorenoSP", "ghost", "flying", "melee", "glueimmune", "chainimmune"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", regen: -0.1, noAlert: true, hitsfx: "Tickle",
        visionRadius: 10, blindSight: 3, evasion: 9.0, alwaysEvade: true, maxhp: 1, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 1, attack: "MeleeWill", attackWidth: 3, attackRange: 1, power: 3, dmgType: "tickle", fullBoundBonus: 0,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffffff" },
        ],
        terrainTags: {}, shrines: [], allFloors: true },
    { name: "TickleHandSlave", faction: "Witch", color: "#FFFFFF", tags: KDMapInit(["ignorenoSP", "ghost", "flying", "melee", "glueimmune", "chainimmune"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt",
        master: { type: "ConjurerTickler", range: 3, dependent: true }, noAlert: true, hitsfx: "Tickle",
        visionRadius: 10, blindSight: 3, evasion: 9.0, alwaysEvade: true, maxhp: 1, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 1, attack: "MeleeWill", attackWidth: 3, attackRange: 1, power: 3, dmgType: "tickle", fullBoundBonus: 0,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffffff" },
        ],
        terrainTags: {}, shrines: [], allFloors: true,
        Reputation: {
            noRepLoss: true,
        },
        dropTable: [{ name: "Ectoplasm", weight: 1 }] },
    { name: "Frog", faction: "Witch", clusterWith: "beast", color: "#00FF44", tags: KDMapInit(["summoned", "beast", "ranged", "pierceweakness", "electricsevereweakness", "acidresist"]), followLeashedOnly: true, armor: 1, followRange: 1, AI: "hunt",
        pullTowardSelf: true, pullDist: 3, master: { type: "Conjurer", range: 3 }, projectileAttack: true, projectileTargeting: true,
        visionRadius: 8, maxhp: 19, minLevel: 0, weight: 0, movePoints: 1.5, attackPoints: 2, attack: "MeleePullWill", attackRange: 4, attackWidth: 1, power: 4, strictAttackLOS: true, dmgType: "tickle",
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "Conjurer", faction: "Witch", clusterWith: "construct", bound: "Conjurer", playLine: "Witch", tags: KDMapInit(["leashing", "opendoors", "conjurer", "closedoors", "witch", "ranged", "boss", "elite", "unflinching", "dressRestraints", "latexRestraints", "handcuffer"]), followRange: 1, summon: [{ enemy: "Frog", range: 2.5, count: 1, strict: true }],
        spells: ["SummonTickleHand", "EnemyCM1"], unlockCommandLevel: 2, unlockCommandCD: 9, spellCooldownMult: 2, spellCooldownMod: 1, AI: "guard", visionRadius: 8, maxhp: 30, minLevel: 9, weight: -31, movePoints: 3, spellRdy: true,
        spellResist: 0.5, attackLock: "Purple",
        attackPoints: 4, attack: "MeleeLockAllWillSpellBind", attackWidth: 1, attackRange: 1, power: 3, dmgType: "tickle",
        terrainTags: { "secondhalf": 16, "lastthird": 5, "boss": -80, "open": 20, "passage": -60, "conjureAnger": 20, "conjureRage": 70, "increasingWeight": 0.5, "witch": 30 },
        allFloors: true, shrines: ["Conjure"],
        dropTable: [{ name: "MagicSword", weight: 1, ignoreInInventory: true }, { name: "MagicSpear", weight: 1, ignoreInInventory: true }, { name: "MagicAxe", weight: 1, ignoreInInventory: true }, { name: "MagicFlail", weight: 1, ignoreInInventory: true }, { name: "MagicHammer", weight: 1, ignoreInInventory: true }, { name: "BlueKey", weight: 2 }] },
    { name: "ConjurerTickler", faction: "Witch", clusterWith: "construct", bound: "ConjurerTickler", playLine: "Witch", tags: KDMapInit(["leashing", "opendoors", "conjurer", "closedoors", "witch", "ranged", "boss", "elite", "unflinching", "dressRestraints", "latexRestraints", "handcuffer"]), followRange: 1, summon: [{ enemy: "TickleHandSlave", range: 2.5, count: 3, strict: true }],
        spells: ["SummonBookChain", "EnemyCM1"], unlockCommandLevel: 2, unlockCommandCD: 9, spellCooldownMult: 2, spellCooldownMod: 1, AI: "guard", visionRadius: 8, maxhp: 30, minLevel: 5, weight: -31, movePoints: 3, spellRdy: true,
        spellResist: 0.5, attackLock: "Purple",
        attackPoints: 4, attack: "MeleeLockAllWillSpellBind", attackWidth: 1, attackRange: 1, power: 3, dmgType: "tickle",
        terrainTags: { "secondhalf": 16, "lastthird": 5, "boss": -80, "open": 20, "passage": -60, "conjureAnger": 20, "conjureRage": 70, "increasingWeight": 0.5, "witch": 30 },
        allFloors: true, shrines: ["Conjure"],
        dropTable: [{ name: "MagicSword", weight: 1, ignoreInInventory: true }, { name: "MagicSpear", weight: 1, ignoreInInventory: true }, { name: "MagicAxe", weight: 1, ignoreInInventory: true }, { name: "MagicFlail", weight: 1, ignoreInInventory: true }, { name: "MagicHammer", weight: 1, ignoreInInventory: true }, { name: "BlueKey", weight: 2 }] },
    { name: "BookChain", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["fireweakness", "chainimmune", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["MagicChain"], spellCooldownMult: 1, spellCooldownMod: 1, sneakthreshold: 0.95, kite: 1.5, difficulty: 0.05, noSpellLeashing: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#aaaaaa" },
        ],
        visionRadius: 6, maxhp: 6, minLevel: 0, weight: 20, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        terrainTags: { "open": 100, "passage": -7, "witch": 2 }, floors: KDMapInit(["lib"]) },
    { name: "BookCelestial", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["fireresist", "stunimmune", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["EnemyCorona", "OrbHeal"], spellCooldownMult: 1, spellCooldownMod: 1, sneakthreshold: 0.95, difficulty: 0.05, noSpellLeashing: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffff44" },
        ],
        visionRadius: 6, maxhp: 6, minLevel: 6, weight: 18, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        terrainTags: { "open": 100, "passage": -7, "elf": 2 }, floors: KDMapInit(["lib"]) },
    { name: "BookNature", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["unstoppable", "fireweakness", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["Entangle", "OrbHeal"], spellCooldownMult: 1, spellCooldownMod: 1, sneakthreshold: 0.95, difficulty: 0.05, noSpellLeashing: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#88ff88" },
        ],
        visionRadius: 6, maxhp: 6, minLevel: 0, weight: 18, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        terrainTags: { "open": 100, "passage": -7, "elf": 2 }, floors: KDMapInit(["lib"]) },
    { name: "BookElectric", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["fireweakness", "electricimmune", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["AreaElectrify"], spellCooldownMult: 1, spellCooldownMod: 1, sneakthreshold: 0.95, difficulty: 0.05, noSpellLeashing: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#8888ff" },
        ],
        visionRadius: 6, maxhp: 6, minLevel: 3, weight: 18, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        terrainTags: { "open": 100, "passage": -7, "elemental": 2 }, floors: KDMapInit(["lib"]) },
    { name: "BookSlime", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["fireweakness", "glueimmune", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["WitchSlimeBall", "WitchSlimeBall", "WitchSlime"], spellCooldownMult: 1, spellCooldownMod: 0, sneakthreshold: 0.95, difficulty: 0.05, noSpellLeashing: true,
        visionRadius: 6, maxhp: 6, minLevel: 2, weight: 18, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ff00ff" },
        ],
        terrainTags: { "open": 100, "passage": -7, "alchemist": 2 }, floors: KDMapInit(["lib"]) },
    { name: "BookIce", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["fireweakness", "iceimmune", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["IceSlowPrepare", "IceDragonBreathPrepare"], spellCooldownMult: 1, spellCooldownMod: 4, sneakthreshold: 0.95, difficulty: 0.05, noSpellLeashing: true,
        visionRadius: 6, maxhp: 6, minLevel: 4, weight: 18, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#44aaff" },
        ],
        terrainTags: { "open": 100, "passage": -7, "elemental": 2 }, floors: KDMapInit(["lib"]) },
    { name: "BookForbidden", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["fireweakness", "coldimmune", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["SoulCrystalBind"], spellCooldownMult: 1, spellCooldownMod: 3, sneakthreshold: 0.95, difficulty: 0.05, noSpellLeashing: true,
        visionRadius: 6, maxhp: 6, minLevel: 5, weight: 15, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ff5577" },
        ],
        terrainTags: { "open": 100, "passage": -8, "witch": 2 }, floors: KDMapInit(["lib", "tmp"]) },
    { name: "BookArcane", hidetimerbar: true, clusterWith: "book", tags: KDMapInit(["fireweakness", "coldimmune", "ignorenoSP", "book", "flying", "minor", "ranged", "slashsevereweakness", "acidweakness", "piercesevereweakness"]), followLeashedOnly: true, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, noAlert: true,
        spells: ["MummyBolt"], spellCooldownMult: 1, spellCooldownMod: 3, sneakthreshold: 0.95, difficulty: 0.05, noSpellLeashing: true,
        visionRadius: 6, maxhp: 6, minLevel: 0, weight: 15, movePoints: 5, attackPoints: 2, attack: "Spell", attackRange: 1, attackWidth: 1, power: 6,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#00ff00" },
        ],
        terrainTags: { "open": 100, "passage": -8, "mummy": 2 }, floors: KDMapInit(["lib", "tmp"]) },
    { name: "AnimatedArmor", blockVisionWhileStationary: true, tags: KDMapInit(["mimicBlock", "removeDoorSpawn", "ignoreharmless", "leashing", "construct", "poisonimmune", "soulimmune", "minor", "melee", "acidweakness", "shackleRestraints", "shackleGag", "slashresist", "crushweakness"]),
        evasion: -0.5, ignorechance: 1.0, armor: 2, followRange: 1, AI: "ambush", difficulty: 0.05, guardChance: 0,
        cueSfx: {
            Block: "Clang",
            Resist: "Clang",
            Damage: "ArmorHit",
        },
        visionRadius: 100, ambushRadius: 1.9, blindSight: 100, maxhp: 20, minLevel: 1, weight: 0, movePoints: 2, attackPoints: 3, attack: "MeleeBind",
        useLock: "Purple",
        attackWidth: 1, attackRange: 1, power: 4, dmgType: "crush", fullBoundBonus: 4,
        terrainTags: { "secondhalf": 4, "lastthird": 7, "passage": 70, "adjChest": 58, "door": 50, "rubble": 15 }, floors: KDMapInit(["cat"]), shrines: ["Metal"],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }, { name: "Sword", weight: 1, ignoreInInventory: true }] },
    { name: "Mimic", blockVisionWhileStationary: true, tags: KDMapInit(["removeDoorSpawn", "ignoreharmless", "ignorenoSP", "construct", "poisonresist", "soulresist", "minor", "melee", "trap", "shackleGag", "crushweakness", "meleeresist", "fireweakness", "electricresist", "chainweakness"]),
        evasion: -0.5, ignorechance: 1.0, armor: 0, followRange: 1, AI: "ambush", bypass: true, difficulty: 0.15, guardChance: 0,
        visionRadius: 100, ambushRadius: 1.9, blindSight: 100, maxhp: 20, minLevel: 2, weight: -1, movePoints: 1.5, attackPoints: 2, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 3, dmgType: "tickle", fullBoundBonus: 1,
        terrainTags: { "rubble": 100, "adjChest": 15, "passage": 14, "illusionRage": 2, "illusionAnger": 2 }, allFloors: true, shrines: ["Illusion"],
        dropTable: [{ name: "RedKey", weight: 1 }, { name: "Gold", amountMin: 10, amountMax: 40, weight: 6 }, { name: "ScrollArms", weight: 1 }, { name: "ScrollVerbal", weight: 1 }, { name: "ScrollLegs", weight: 1 }] },
    { name: "VinePlant", faction: "Plant", clusterWith: "plant", color: "#00FF00", blockVisionWhileStationary: true, tags: KDMapInit(["nature", "removeDoorSpawn", "ignorenoSP", "plant", "minor", "melee", "slashsevereweakness", "coldweakness", "firesevereweakness", "unarmedresist", "crushresist", "vineRestraints"]),
        ignorechance: 1.0, armor: 2, followRange: 1, AI: "ambush", specialCD: 99, specialAttack: "Stun", specialAttackPoints: 1, specialRemove: "Bind", difficulty: 0.05, guardChance: 0,
        visionRadius: 3, ambushRadius: 1.9, blindSight: 5, maxhp: 10, minLevel: 2, weight: 25, movePoints: 1.5, attackPoints: 2, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 2, dmgType: "crush", fullBoundBonus: 3,
        terrainTags: { "passage": -50, "adjChest": 8, "door": 12, "elf": 5, "nature": 5 }, floors: KDMapInit(["jng"]), shrines: ["Rope", "Will"] },
    { name: "Bramble", faction: "Plant", clusterWith: "plant", color: "#00FF00", hitsfx: "DealDamage", tags: KDMapInit(["removeDoorSpawn", "immobile", "nature", "plant", "minor", "melee", "slashsevereweakness", "coldweakness", "firesevereweakness", "unarmedresist", "crushresist"]),
        evasion: -9, ignorechance: 1.0, armor: 2, followRange: 1, AI: "wander", specialCD: 2, specialAttack: "Slow", specialAttackPoints: 1,
        visionRadius: 1.5, blindSight: 1.5, maxhp: 16, minLevel: 0, weight: -80, movePoints: 99999, attackPoints: 1, attack: "MeleeWill", attackWidth: 8, attackRange: 1, power: 1, dmgType: "pain",
        terrainTags: { "passage": -50, "adjChest": -50, "door": -50, "open": 140, "elf": 10 }, floors: KDMapInit(["jng"]), shrines: ["Rope", "Will"] },
    { name: "Alchemist", faction: "Alchemist", clusterWith: "alchemist", playLine: "Alchemist", bound: "Alchemist", tags: KDMapInit(["opendoors", "leashing", "imprisonable", "guardCall", "human", "alchemist", "ranged", "leatherRestraints", "handcuffer", "glueresist", "iceweakness", "electricresist", "leatherRestraintsHeavy", "jail", "jailer", "latexGag", "search"]), ignorechance: 0, armor: 0, followRange: 2, AI: "hunt",
        spells: ["AmpuleGreen", "AmpuleYellow", "AmpuleRed", "AmpuleBlue"], spellCooldownMult: 1, spellCooldownMod: 4, kite: 1.5, projectileAttack: true,
        visionRadius: 6, maxhp: 8, minLevel: 0, weight: 0.1, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "latexAnger": 12, "latexRage": 5, "latexPleased": 12, "latexFriendly": 5, "alchemist": 5 }, shrines: ["Latex"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }] },
    { name: "Alkahestor", faction: "Alchemist", clusterWith: "alchemist", playLine: "Alchemist", bound: "Alkahestor", tags: KDMapInit(["opendoors", "leashing", "guardCall", "human", "alchemist", "ranged", "miniboss", "glueresist", "iceweakness", "electricresist", "expRestraints", "handcuffer", "jailer", "latexGag", "search"]), ignorechance: 0, armor: 0, followRange: 2, AI: "hunt",
        spells: ["AmpuleBlue", "SummonLatexElemental"], spellCooldownMult: 1, spellCooldownMod: 4, kite: 1.5, projectileAttack: true,
        visionRadius: 6, maxhp: 16, minLevel: 4, weight: -1, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1.5, dmgType: "grope", fullBoundBonus: 2.5,
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "latexAnger": 4, "latexRage": 4, "latexPleased": 3, "latexFriendly": 5, "alchemist": 1 }, shrines: ["Latex"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }] },
    { name: "ElementalLatex", faction: "Elemental", hidetimerbar: true, playLine: "Elemental", clusterWith: "alchemist", bound: "ElementalLatex", squeeze: true,
        tags: KDMapInit(["opendoors", "elemental", "slashweakness", "melee", "glueimmune", "coldweakness", "electricresist", "pierceweakness", "acidweakness", "latexRestraints", "latexGag", "handcuffer", "leashing", "search", "doortrap"]),
        armor: 0, followRange: 1, AI: "hunt",
        visionRadius: 7, maxhp: 24, minLevel: 4, weight: -3, movePoints: 2, attackPoints: 2, attack: "MeleeWillBind", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 2, "thirdhalf": 1, "latexAnger": 4, "latexRage": 4, "latexPleased": 2, "latexFriendly": 3, "temple": 4, "doortrap": 2, "alchemist": 3, "witch": 5 }, allFloors: true, shrines: ["Latex", "Elements"],
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10, noSummon: true }, { name: "EarthRune", weight: 1, noSummon: true }] },
    { name: "SlimeEnthusiast", faction: "Alchemist", clusterWith: "alchemist", playLine: "Alchemist", bound: "SlimeEnthusiast", tags: KDMapInit(["opendoors", "leashing", "elite", "human", "alchemist", "ranged", "unflinching", "meleeweakness", "iceweakness", "electricresist", "miniboss", "glueresist", "leatherRestraints", "leatherRestraintsHeavy", "latexGag", "handcuffer", "jail", "jailer", "hunter"]), ignorechance: 0, armor: 0, followRange: 2, AI: "hunt",
        spells: ["RedSlime"], spellCooldownMult: 1, spellCooldownMod: 1, kite: 1.5, projectileAttack: true,
        visionRadius: 6, maxhp: 20, minLevel: 1, weight: 0, movePoints: 3, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 0.5, "thirdhalf": 1, "latexAnger": 5, "latexRage": 5, "latexPleased": 2, "latexFriendly": 2, "alchemist": 1 }, shrines: ["Latex"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }] },
    { name: "RedSlime", faction: "Alchemist", clusterWith: "alchemist", color: "#FF0000", hidetimerbar: true, tags: KDMapInit(["ignoretiedup", "ignoregagged", "experiment", "slime", "melee", "minor", "ballGagRestraints", "meleeresist", "glueimmune", "electricresist", "iceweakness"]), squeeze: true, followRange: 1, AI: "hunt", sneakThreshold: 1, hitsfx: "",
        spells: ["RedSlime"], spellCooldownMult: 1, spellCooldownMod: 1, evasion: 1,
        visionRadius: 4.5, maxhp: 2, minLevel: 5, weight: 10, movePoints: 2, attackPoints: 3, attack: "SpellMeleeSlowBindSuicide", suicideOnSpell: true, suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "crush",
        terrainTags: {}, floors: KDMapInit(["tmp"]), shrines: ["Latex"] },
    { name: "SummonedDrone", playLine: "Robot",
        tags: KDMapInit(["oldrobot", "ignoreharmless", "doortrap", "robot", "flying", "acidweakness", "soulresist", "minor", "melee",
            "electricsevereweakness", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "temporary"]),
        evasion: 0.2, armor: 1, followRange: 3.5, AI: "hunt",
        spells: ["EncaseBoltDrone"], spellCooldownMult: 2, spellCooldownMod: 0, projectileTargeting: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffff00" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        visionRadius: 14, sneakThreshold: 0.5, maxhp: 5, minLevel: 0, weight: -1000, kite: 1.5, movePoints: 1.5, attackPoints: 3, attack: "Spell", attackWidth: 1, attackRange: 1, power: 1, dmgType: "glue", fullBoundBonus: 1,
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "SummonedCaptureDrone", playLine: "Robot",
        tags: KDMapInit(["leashing", "oldrobot", "ignoreharmless", "doortrap", "robot", "flying", "acidweakness", "soulresist", "minor", "melee",
            "electricsevereweakness", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "temporary"]),
        evasion: 0.15, armor: 1, followRange: 1, AI: "hunt",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffff00" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        visionRadius: 15, sneakThreshold: 0.5, maxhp: 6, minLevel: 0, weight: -1000, movePoints: 1.35, attackPoints: 2, attack: "MeleeBind", attackWidth: 1.5, attackRange: 1, power: 1, dmgType: "chain", fullBoundBonus: 1.5,
        ondeath: [{ type: "spellOnSelf", spell: "RubberSlime" }],
        terrainTags: {}, floors: KDMapInit([]) },
    { name: "OldDrone", faction: "Enemy", clusterWith: "robot", playLine: "Robot", noChaseUnrestrained: true,
        color: "#ff3367",
        tags: KDMapInit(["oldrobot", "ignoreharmless", "doortrap", "robot", "flying", "acidweakness", "soulresist", "minor", "melee",
            "electricsevereweakness", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "jail", "search"]),
        AI: "hunt", difficulty: 0.05,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffff00" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        armor: 1.5, maxhp: 5, movePoints: 1.1,
        visionRadius: 7, followRange: 1, projectileAttack: true, useLock: "Red", followLeashedOnly: true,
        bindOnDisable: true, suicideOnAdd: true,
        attack: "MeleeBindSuicideWill", attackPoints: 2, attackWidth: 1, attackRange: 1, power: 2, dmgType: "electric", multiBind: 2, fullBoundBonus: 4,
        minLevel: 0, weight: 15, terrainTags: { "oldrobot": 10 }, shrines: ["Metal"], floors: KDMapInit(["bel"]),
        dropTable: [{ name: "Nothing", weight: 19 }, { name: "AncientPowerSourceSpent", weight: 1, noSummon: true }] },
    { name: "OldTapeDrone", faction: "Enemy", clusterWith: "robot", playLine: "Robot", noChaseUnrestrained: true,
        color: "#ff3367",
        tags: KDMapInit(["oldrobot", "leashing", "doortrap", "robot", "flying", "acidweakness", "soulresist", "melee",
            "electricsevereweakness", "coldresist", "iceresist", "slashresist", "crushweakness", "autoTape", "jail", "search"]),
        AI: "patrol",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffff00" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        armor: 1.5, maxhp: 9, movePoints: 1.75,
        visionRadius: 7, followRange: 1,
        attack: "MeleeBind", attackPoints: 2, attackWidth: 1, attackRange: 1, power: 2, dmgType: "glue", fullBoundBonus: 1,
        minLevel: 2, weight: 15, terrainTags: { "oldrobot": 10, "tapePref": 10, "tapeOptout": -15 }, shrines: ["Metal"], floors: KDMapInit(["bel"]),
        dropTable: [{ name: "Gold", amountMin: 7, amountMax: 15, weight: 10, noSummon: true }, { name: "AncientPowerSourceSpent", weight: 1, noSummon: true }] },
    { name: "RubberTurret", faction: "Enemy", clusterWith: "robot", playLine: "Robot", noChaseUnrestrained: true,
        color: "#ff3367",
        tags: KDMapInit(["oldrobot", "turret", "basicturret", "immobile", "ignoreharmless", "mimicBlock", "doortrap", "robot", "acidweakness", "soulresist", "minor", "ranged",
            "electricsevereweakness", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness"]),
        AI: "hunt", difficulty: 0.2,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#ff5555" },
        ],
        spells: ["EncaseBolt"], spellCooldownMult: 1, spellCooldownMod: 0, projectileTargeting: true,
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        armor: 2.0, maxhp: 20, movePoints: 9999, immobile: true,
        visionRadius: 6.5, followRange: 999,
        sneakThreshold: 1,
        attack: "SpellMeleeWill", attackPoints: 2, attackWidth: 1, attackRange: 1, power: 2, dmgType: "electric",
        minLevel: 0, weight: -50, terrainTags: { "oldrobot": 7, "oldrobotturret": 50, open: 50, "latexOptout": -100 }, shrines: ["Latex"], floors: KDMapInit(["bel"]),
        ondeath: [{ type: "spellOnSelf", spell: "RubberSlime" }],
        dropTable: [{ name: "AncientPowerSourceSpent", weight: 9, noSummon: true }, { name: "AncientPowerSource", weight: 1, noSummon: true }] },
    { name: "RubberSilo", faction: "Enemy", clusterWith: "robot", playLine: "Robot", noChaseUnrestrained: true,
        color: "#ff3367",
        tags: KDMapInit(["oldrobot", "turret", "immobile", "ignoreharmless", "mimicBlock", "doortrap", "robot", "acidweakness", "soulresist", "minor", "ranged",
            "electricsevereweakness", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness"]),
        AI: "hunt", difficulty: 0.2,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#ff5555" },
        ],
        spells: ["RubberMissile"], spellCooldownMult: 1, spellCooldownMod: 0, projectileTargeting: true,
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        armor: 2.0, maxhp: 20, movePoints: 9999, immobile: true,
        visionRadius: 8.5, followRange: 999,
        sneakThreshold: 1,
        attack: "SpellMeleeWill", attackPoints: 2, attackWidth: 1, attackRange: 1, power: 2, dmgType: "electric",
        minLevel: 7, weight: -50, terrainTags: { "oldrobot": 7, "oldrobotturret": 30, open: 50, "latexOptout": -24 }, shrines: ["Latex"], floors: KDMapInit(["bel"]),
        ondeath: [{ type: "spellOnSelf", spell: "RubberSlime" }],
        dropTable: [{ name: "AncientPowerSourceSpent", weight: 8, noSummon: true }, { name: "AncientPowerSource", weight: 2, noSummon: true }] },
    { name: "Drone", faction: "AncientRobot", clusterWith: "robot", playLine: "Robot", noChaseUnrestrained: true, color: "#ff7755",
        tags: KDMapInit(["ignoreharmless", "doortrap", "robot", "flying", "acidweakness", "soulresist", "minor", "melee", "electricsevereweakness", "coldresist", "iceresist",
            "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "jail", "search"]),
        AI: "patrol", difficulty: 0.3,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ff0000" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        armor: 2, maxhp: 5, movePoints: 1.25,
        visionRadius: 6, followRange: 1, projectileAttack: true, useLock: "Red",
        bindOnDisable: true, suicideOnAdd: true,
        specialCD: 30, specialAttack: "Stun", specialRemove: "Bind", specialCDonAttack: true, specialAttackPoints: 3, specialRange: 7, specialWidth: 1.5, specialMinrange: 3, specialsfx: "Laser", stunTime: 5,
        attack: "MeleeBindSuicideWill", attackPoints: 2, attackWidth: 1, attackRange: 1, power: 3, dmgType: "electric", multiBind: 2, fullBoundBonus: 6,
        minLevel: 0, weight: -4, terrainTags: { "secondhalf": 0.5, "thirdhalf": 0.5, "increasingWeight": 0.25, "metalAnger": 4, "metalRage": 2, "metalPleased": 4, "metalFriendly": 4, "robot": 40 }, shrines: ["Metal"], allFloors: true,
        dropTable: [{ name: "Nothing", weight: 19 }, { name: "AncientPowerSourceSpent", weight: 1, noSummon: true }] },
    { name: "CaptureBot", faction: "AncientRobot", clusterWith: "robot", playLine: "Robot", color: "#aaaaaa",
        tags: KDMapInit(["leashing", "jailer", "doortrap", "robot", "acidweakness", "melee", "electricsevereweakness", "coldresist", "soulresist", "guardCall", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "controlHarness", "jail", "jailer", "search"]),
        AI: "patrol",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#ff0000" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        armor: 2, maxhp: 10, movePoints: 2,
        visionRadius: 6, followRange: 1, projectileAttack: true, useLock: "Red",
        RemoteControl: {
            punishRemote: 4,
            punishRemoteChance: 0.25,
        },
        attack: "MeleeBind", attackPoints: 4, attackWidth: 3, attackRange: 1, power: 3, dmgType: "crush", multiBind: 2, fullBoundBonus: 2,
        minLevel: 3, weight: -6, terrainTags: { "secondhalf": 1, "thirdhalf": 1, "increasingWeight": 0.5, "metalAnger": 6, "metalRage": 4, "metalPleased": 6, "metalFriendly": 4, "robot": 20, "tapePref": -4, "tapeOptout": 3 }, shrines: ["Metal"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10, noSummon: true }, { name: "AncientPowerSourceSpent", weight: 1, noSummon: true }] },
    { name: "ForcefieldBot", faction: "AncientRobot", clusterWith: "robot", playLine: "Robot", color: "#aaaaaa",
        tags: KDMapInit(["leashing", "jailer", "doortrap", "robot", "acidweakness", "melee", "elite", "electricsevereweakness", "coldresist", "soulresist", "guardCall", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "controlHarness", "jail", "jailer", "search"]),
        AI: "patrol",
        spells: ["SummonForceFields"], spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#ff0000" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        armor: 2, maxhp: 14, movePoints: 3,
        visionRadius: 6, followRange: 1, projectileAttack: true, useLock: "Red",
        RemoteControl: {
            punishRemote: 4,
            punishRemoteChance: 0.25,
        },
        attack: "SpellMeleeBind", attackPoints: 4, attackWidth: 1, attackRange: 1, power: 3, dmgType: "electric", multiBind: 1, fullBoundBonus: 4,
        minLevel: 6, weight: -6,
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "increasingWeight": 0.5, "metalAnger": 5, "metalRage": 3, "metalPleased": 5, "metalFriendly": 3, "robot": 17 }, shrines: ["Metal"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10, noSummon: true }, { name: "AncientPowerSourceSpent", weight: 1, noSummon: true }] },
    { name: "TapeBot", faction: "AncientRobot", clusterWith: "robot", playLine: "Robot", color: "#00eeee",
        tags: KDMapInit(["leashing", "jailer", "doortrap", "robot", "acidweakness", "melee", "electricsevereweakness", "coldresist", "soulresist", "guardCall", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "autoTape", "jail", "jailer", "search"]),
        AI: "patrol",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4, color: "#00eeee" },
        ],
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        armor: 2, maxhp: 10, movePoints: 1.7,
        visionRadius: 6, followRange: 3.5, projectileAttack: true, useLock: "Red",
        RemoteControl: {
            punishRemote: 4,
            punishRemoteChance: 0.25,
        },
        attack: "MeleeBind", attackPoints: 3, attackWidth: 1, attackRange: 3.5, power: 3, dmgType: "glue", multiBind: 1, fullBoundBonus: 2,
        minLevel: 2, weight: -8, terrainTags: { "secondhalf": 1, "thirdhalf": 1, "increasingWeight": 0.5, "metalAnger": 6, "metalRage": 4, "metalPleased": 6, "metalFriendly": 4, "robot": 20, "tape": 5, "tapePref": 6, "tapeOptout": -30 }, shrines: ["Metal"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10, noSummon: true }, { name: "AncientPowerSourceSpent", weight: 1, noSummon: true }] },
    { name: "BotMissile", faction: "AncientRobot", clusterWith: "robot", playLine: "Robot", color: "#bbbbbb",
        tags: KDMapInit(["leashing", "robot", "ranged", "miniboss", "acidweakness", "electricsevereweakness",
            "unflinching", "coldresist", "soulresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "controlHarness", "search", "dollRoomBoss"]),
        AI: "guard", spellRdy: true, bypass: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 5.5, color: "#ff0000" },
        ],
        spells: ["RubberMissile"], spellCooldownMult: 0.7, spellCooldownMod: 0, castWhileMoving: true, followLeashedOnly: true,
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        armor: 2, maxhp: 20, movePoints: 4,
        visionRadius: 9, followRange: 3.5, projectileAttack: true, useLock: "Red",
        RemoteControl: {
            punishRemote: 6,
            punishRemoteChance: 0.5,
        },
        attack: "SpellMeleeBind", attackPoints: 2, attackWidth: 1, attackRange: 3.5, power: 1, dmgType: "crush", multiBind: 1, fullBoundBonus: 3,
        minLevel: 7, weight: -106, terrainTags: { "thirdhalf": 1, "increasingWeight": 0.5, "open": 100, "metalAnger": 44, "metalRage": 13, "metalPleased": 44, "latex": 5, "metalFriendly": 13, "robot": 7 }, shrines: ["Metal"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 20, amountMax: 30, weight: 5, noSummon: true }, { name: "AncientPowerSource", weight: 1, noSummon: true }] },
    { name: "EnforcerBot", faction: "AncientRobot", clusterWith: "robot", playLine: "Robot", color: "#bbbbbb",
        tags: KDMapInit(["leashing", "robot", "ranged", "miniboss", "acidweakness", "electricsevereweakness", "unflinching", "coldresist", "soulresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "controlHarness", "search"]),
        AI: "guard", spellRdy: true, bypass: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 5.5, color: "#ff0000" },
        ],
        spells: ["RobotBolt"], spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true, followLeashedOnly: true,
        cueSfx: {
            Block: "Clang",
            Resist: "SoftShield",
            Damage: "RobotHit",
        },
        summon: [
            { enemy: "Drone", range: 2, count: 2, chance: 0.25, strict: true },
        ],
        armor: 2, maxhp: 24, movePoints: 4,
        visionRadius: 9, followRange: 3.5, projectileAttack: true, useLock: "Red",
        RemoteControl: {
            punishRemote: 6,
            punishRemoteChance: 0.5,
        },
        attack: "SpellMeleeBind", attackPoints: 2, attackWidth: 1, attackRange: 3.5, power: 1, dmgType: "crush", multiBind: 1, fullBoundBonus: 3,
        minLevel: 9, weight: -106, terrainTags: { "thirdhalf": 1, "increasingWeight": 0.5, "open": 100, "metalAnger": 44, "metalRage": 13, "metalPleased": 44, "metalFriendly": 13, "robot": 7 }, shrines: ["Metal"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 20, amountMax: 30, weight: 5, noSummon: true }, { name: "AncientPowerSource", weight: 1, noSummon: true }] },
    { name: "AlchemistPet", faction: "Alchemist", clusterWith: "alchemist", bound: "AlchemistPet", playLine: "Gagged", color: "#007C59", tags: KDMapInit(["opendoors", "submissive", "noshop", "gagged", "imprisonable", "ignorenoSP", "alchemist", "ranged", "glueweakness", "electricresist", "ticklesevereweakness", "iceresist", "charmweakness", "stunweakness", "search"]), ignorechance: 0, armor: 0, followRange: 2, AI: "hunt",
        master: { type: "Alchemist", range: 2, loose: true, aggressive: true }, sneakThreshold: 1, blindSight: 2, projectileAttack: true, strictAttackLOS: true, dashOnMiss: true,
        specialCD: 11, specialAttack: "DashStun", specialRemove: "Will", specialCDonAttack: true, specialAttackPoints: 2, specialRange: 4, specialMinrange: 1.5, specialsfx: "HeavySwing", stunTime: 4, stunOnSpecialCD: 4,
        visionRadius: 6, maxhp: 10, minLevel: 3, weight: 0, movePoints: 1, attackPoints: 2, attack: "MeleeWill", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "latexAnger": 2, "latexRage": 2, "alchemist": 2 }, shrines: ["Latex"], allFloors: true,
        dropTable: [] },
    { name: "WolfgirlPet", faction: "Nevermere", clusterWith: "nevermere", bound: "WolfgirlPet", playLine: "Gagged", color: "#009C79", tags: KDMapInit(["opendoors", "wolfSub", "nevermere", "submissive", "noshop", "gagged", "wolfPet", "alwaysAlert", "imprisonable", "wolfgirl", "minor", "ignorenoSP", "alchemist", "ranged", "glueweakness", "electricresist", "ticklesevereweakness", "iceresist", "charmweakness", "stunweakness", "search"]), ignorechance: 0, armor: 0, followRange: 2, AI: "hunt", cohesion: 0.9,
        master: { type: "Wolfgirl", range: 2, loose: true, aggressive: true }, sneakThreshold: 1, blindSight: 2, projectileAttack: true, strictAttackLOS: true, dashOnMiss: true, difficulty: 0.5,
        specialCD: 11, specialAttack: "DashStun", specialRemove: "Will", specialCDonAttack: true, specialAttackPoints: 2, specialRange: 4, specialMinrange: 1.5, specialsfx: "HeavySwing", stunTime: 4, stunOnSpecialCD: 4,
        visionRadius: 6, maxhp: 10, minLevel: 0, weight: 0.1, movePoints: 1, attackPoints: 2, attack: "MeleeWill", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "metalAnger": 3, "metalRage": 3, "metalPleased": 2, "metalFriendly": 2, "nevermere": 2 }, shrines: ["Metal"], allFloors: true,
        dropTable: [] },
    { name: "WolfGuard", faction: "Nevermere", clusterWith: "nevermere", bound: "WolfGuard", color: "#00dCa9", playLine: "Gagged", tags: KDMapInit(["opendoors", "wolfSub", "nevermere", "submissive", "noshop", "gagged", "wolfPet", "autoTape", "alwaysAlert", "leashing", "wolfLeash", "imprisonable", "wolfgirl", "ignorenoSP", "alchemist", "ranged", "glueweakness", "electricresist", "ticklesevereweakness", "iceresist", "charmweakness", "stunweakness", "search"]),
        ignorechance: 0, armor: 1, followRange: 2, AI: "hunt", cohesion: 0.5,
        master: { type: "Wolfgirl", range: 2, loose: true, aggressive: true }, sneakThreshold: 1, blindSight: 2, projectileAttack: true, strictAttackLOS: true, dashOnMiss: true,
        specialCD: 9, specialAttack: "DashWill", specialRemove: "Bind", specialCDonAttack: true, specialAttackPoints: 2, specialRange: 4, specialMinrange: 1.5, specialsfx: "HeavySwing", stunTime: 4, stunOnSpecialCD: 4, specialDamage: "crush",
        visionRadius: 6, maxhp: 16, minLevel: 6, weight: 0, movePoints: 1, attackPoints: 3, attack: "MeleeBind", attackWidth: 1, attackRange: 3, projectileTargeting: true, power: 2, dmgType: "electric", fullBoundBonus: 2,
        terrainTags: { "metalAnger": 1.5, "metalRage": 8, "metalPleased": 4, "metalFriendly": 4, "nevermere": 1 }, shrines: ["Metal"], allFloors: true,
        dropTable: [{ name: "Nothing", weight: 10 }, { name: "EscortDrone", weight: 0.5, ignoreInInventory: true }, { name: "VibeWand", weight: 100, ignoreInInventory: true },] },
    { name: "WolfInstructor", faction: "Nevermere", clusterWith: "nevermere", bound: "Wolfgirl", playLine: "Wolfgirl", color: "#00EFAB", tags: KDMapInit(["leashing", "nevermere", "imprisonable", "trainer", "controlHarness", "wolfgirl", "jailer", "opendoors", "unflinching", "closedoors", "wolfGear", "handcuffer", "melee", "unflinching", "iceresist", "electricresist", "charmweakness", "stunweakness", "ticklesevereweakness", "jail", "jailer", "hunter"]),
        followRange: 3, kite: 2.5,
        summon: [
            { enemy: "WolfgirlPet", range: 2, count: 1, chance: 1.0, strict: true },
            { enemy: "WolfgirlPet", range: 2, count: 1, chance: 0.5, strict: true },
        ],
        spells: ["NevermereBoost"], spellCooldownMult: 1, spellCooldownMod: 5, buffallies: true,
        AI: "hunt", visionRadius: 10, maxhp: 9, minLevel: 6, weight: -2, movePoints: 2, evasion: 0.3,
        RemoteControl: {
            punishRemote: 4,
            punishRemoteChance: 0.25,
        },
        attackPoints: 3, attack: "MeleeBindLockWillSpell", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 3, dmgType: "pain", sneakThreshold: 1, attackLock: "Red",
        terrainTags: { "secondhalf": 4, "lastthird": 4, "metalAnger": 4, "metalRage": 4, "metalPleased": 9, "metalFriendly": 4, "nevermere": 9 }, allFloors: true, shrines: ["Metal"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }]
    },
    { name: "WolfExecutive", faction: "Nevermere", clusterWith: "nevermere", bound: "WolfExecutive", color: "#00EFAB", playLine: "Wolfgirl",
        tags: KDMapInit(["leashing", "nevermere", "trainer", "wolfgirl", "jailer", "opendoors", "unflinching", "closedoors", "wolfGear", "controlHarness", "wolfRestraints", "wolfRestraintsHeavy", "melee",
            "boss", "unstoppable", "iceresist", "electricresist", "charmweakness", "stunweakness", "ticklesevereweakness", "jailer", "hunter"]),
        followRange: 4.5, kite: 2.5,
        summon: [
            { enemy: "WolfGuard", range: 2, count: 2, chance: 1.0, strict: true },
            { enemy: "WolfShieldDrone", range: 2, count: 1, chance: 0.5, strict: true },
        ],
        spells: ["NevermereBoost", "SummonWolfDrone", "SummonWolfTapeDrone", "EnemyBlast"], spellCooldownMult: 0.5, spellCooldownMod: 0, buffallies: true, projectileTargeting: true,
        AI: "hunt", visionRadius: 10, maxhp: 30, minLevel: 5, weight: -30, movePoints: 1.2, evasion: 0.2, bindOnDisable: true,
        RemoteControl: {
            punishRemote: 5,
            punishRemoteChance: 0.35,
        },
        attackPoints: 4, attack: "MeleeBindLockAllSpell", multiBind: 2, attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 3, fullBoundBonus: 2, dmgType: "charm", attackLock: "Blue",
        terrainTags: { "secondhalf": 5, "lastthird": 5, "boss": -30, "open": 10, "passage": -40, "metalAnger": 2, "metalRage": 2, "metalPleased": 5, "metalFriendly": 5, "increasingWeight": 0.5, "nevermere": 30 },
        allFloors: true, shrines: ["Metal"],
        dropTable: [{ name: "Gold", amountMin: 35, amountMax: 50, weight: 10 }, { name: "Blaster", weight: 100, ignoreInInventory: true },]
    },
    { name: "Wolfgirl", faction: "Nevermere", clusterWith: "nevermere", bound: "Wolfgirl", color: "#00EFAB", playLine: "Wolfgirl",
        tags: KDMapInit(["leashing", "nevermere", "imprisonable", "trainer", "wolfgirl", "jailer", "opendoors", "unflinching", "closedoors", "wolfRestraints", "melee", "miniboss", "unflinching", "glueweakness", "ticklesevereweakness", "iceresist", "electricresist", "charmweakness", "stunweakness", "unflinching", "jail", "jailer", "hunter"]), followRange: 1,
        summon: [
            { enemy: "WolfgirlPet", range: 2, count: 1, chance: 0.7, strict: true },
        ],
        spells: ["RestrainingDevice"], spellCooldownMult: 1, spellCooldownMod: 1, AI: "hunt", visionRadius: 10, maxhp: 22, minLevel: 0, weight: -6, movePoints: 2, disarm: 0.5,
        RemoteControl: {
            punishRemote: 4,
            punishRemoteChance: 0.25,
        },
        attackPoints: 3, attack: "MeleeBindLockAllWillSpell", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 4, dmgType: "grope", sneakThreshold: 1, attackLock: "Red",
        terrainTags: { "secondhalf": 3, "lastthird": 5, "metalAnger": 7, "metalRage": 2, "metalPleased": 9, "metalFriendly": 6, "nevermere": 7 }, allFloors: true, shrines: ["Metal"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "EscortDrone", weight: 1.0, ignoreInInventory: true }]
    },
    { name: "WolfOperative", faction: "Nevermere", clusterWith: "nevermere", bound: "WolfOperative", color: "#00EFAB", playLine: "Hunter",
        tags: KDMapInit(["leashing", "bountyhunter", "nevermere", "imprisonable", "trainer", "wolfgirl", "jailer", "opendoors", "unflinching", "closedoors", "wolfRestraints", "melee", "elite", "unflinching", "glueweakness", "ticklesevereweakness", "iceresist", "electricresist", "charmweakness", "stunweakness", "unflinching", "jail", "jailer", "hunter"]), followRange: 1,
        spells: ["EnemyBlast"], spellCooldownMult: 0.75, spellCooldownMod: 0, AI: "hunt", visionRadius: 10, maxhp: 18, minLevel: 3, weight: -3, movePoints: 1.7, disarm: 0.5, stealth: 3.5,
        RemoteControl: {
            punishRemote: 3,
            punishRemoteChance: 0.2,
        },
        bindOnDisable: true, projectileTargeting: true, cohesion: 0.1,
        attackPoints: 2, attack: "MeleeBindLockAllWillSpell", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "grope", sneakThreshold: 1, attackLock: "Red",
        terrainTags: { "secondhalf": 1, "lastthird": 2, "metalAnger": 5, "metalRage": 5, "metalPleased": 15, "metalFriendly": 10, "nevermere": 13, "bountyhunter": 3 }, allFloors: true, shrines: ["Metal"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 19 }, { name: "Blaster", ignoreInInventory: true, weight: 0.5 }] },
    { name: "WolfApprentice", faction: "Nevermere", clusterWith: "nevermere", bound: "Wolfgirl", color: "#00EFAB", playLine: "Wolfgirl",
        tags: KDMapInit(["leashing", "imprisonable", "nevermere", "trainer", "wolfgirl", "jailer", "opendoors", "unflinching", "closedoors", "wolfRestraints", "melee", "elite", "unflinching", "glueweakness", "ticklesevereweakness", "iceresist", "electricresist", "charmweakness", "stunweakness", "unflinching", "jail", "jailer", "hunter"]),
        spells: ["SummonWolfDrone"], spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", visionRadius: 10, maxhp: 9, minLevel: 0, weight: 1, movePoints: 2.5,
        RemoteControl: {
            punishRemote: 3,
            punishRemoteChance: 0.15,
        },
        followRange: 1, kite: 2.5, dontKiteWhenDisabled: true, castWhileMoving: true,
        attackPoints: 3, attack: "MeleeBindLockWillSpell", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "grope", sneakThreshold: 1.5, attackLock: "Red",
        terrainTags: { "secondhalf": 1, "lastthird": 2, "metalAnger": 12, "metalRage": 6, "metalPleased": 5, "metalFriendly": 10, "nevermere": 15 }, allFloors: true, shrines: ["Metal"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "EscortDrone", weight: 0.25, ignoreInInventory: true }] },
    { name: "WolfDrone", faction: "Nevermere", clusterWith: "nevermere", color: "#00EFAB", playLine: "Robot",
        tags: KDMapInit(["ignoreharmless", "robot", "nevermere", "wolfdrone", "flying", "acidweakness", "soulresist", "minor", "ranged", "electricsevereweakness", "wolfPet", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "hitechCables", "cableGag", "search"]),
        followRange: 2.5, kite: 1.5,
        spells: ["WolfCrackle"], spellCooldownMult: 1, spellCooldownMod: 1, AI: "hunt", visionRadius: 9, maxhp: 6, minLevel: 0, weight: -1000, movePoints: 1,
        attackPoints: 3, attack: "Spell", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 1, dmgType: "grope",
        terrainTags: {}, allFloors: true, shrines: ["Metal"],
    },
    { name: "WolfShieldDrone", faction: "Nevermere", clusterWith: "nevermere", color: "#00EFAB", playLine: "Robot",
        tags: KDMapInit(["ignoreharmless", "robot", "wolfdrone", "nevermere", "flying", "acidweakness", "soulresist", "minor", "ranged", "electricsevereweakness", "wolfPet", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "search"]),
        followRange: 3.9, kite: 2.5, difficulty: 0.2,
        AI: "hunt", visionRadius: 9, maxhp: 8, minLevel: 0, weight: -4, movePoints: 1.5, cohesion: 1.0, armor: 1.5, spellResist: 1.5,
        attackPoints: 3, attack: "", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 1, dmgType: "grope",
        terrainTags: { "metalAnger": 4, "metalRage": 4, "nevermere": 8 }, allFloors: true, shrines: ["Metal"],
        events: [
            { trigger: "afterEnemyTick", type: "wolfShieldDroneAura", power: 1.5, dist: 4.5 },
        ],
    },
    { name: "WolfTapeDrones", faction: "Nevermere", clusterWith: "nevermere", color: "#00eeee", playLine: "Robot",
        tags: KDMapInit(["ignoreharmless", "robot", "wolfdrone", "leashing", "nevermere", "flying", "acidweakness", "soulresist", "minor", "ranged", "fireweakness", "electricsevereweakness", "wolfPet", "coldresist", "iceresist", "slashresist", "crushsevereweakness", "pierceweakness", "autoTape", "search"]),
        followRange: 1, difficulty: 0.5,
        AI: "hunt", visionRadius: 9, maxhp: 10, minLevel: 0, weight: -3, movePoints: 1, cohesion: 1.0, armor: 0.5, spellResist: -0.5, evasion: 0.5,
        attackPoints: 2, attack: "MeleeBind", attackWidth: 2.5, attackRange: 1, tilesMinRange: 1, power: 1, dmgType: "glue", fullBoundBonus: 1,
        terrainTags: { "metalPleased": 4, "metalFriendly": 8, "nevermere": 13, "tapeOptout": -30, "tape": 5, "tapePref": 2 }, allFloors: true, shrines: ["Metal"],
    },
    { name: "BanditGuard", faction: "Bandit", clusterWith: "bandit", playLine: "Bandit", bound: "Bandit", tags: KDMapInit(["opendoors", "closedoors", "leashing", "cacheguard", "bandit", "minor", "melee", "leatherRestraints", "leatherRestraintsHeavy", "clothRestraints", "chainweakness", "glueweakness", "jail", "jailer", "search"]), cohesion: 0.9, armor: 0, followRange: 1, AI: "hunt",
        master: { type: "BanditChief", range: 2, loose: true, aggressive: true },
        spells: ["BanditBola"], spellCooldownMult: 1, spellCooldownMod: 6, noSpellLeashing: true, difficulty: 0.9, miscastmsg: "KDBanditMiscast", miscastsfx: "Miss",
        visionRadius: 7, maxhp: 11, minLevel: 9, weight: 20, movePoints: 1.5, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "BanditEnemy": 10, "increasingWeight": -1, "BanditWanted": 10, "BanditHated": 5 }, shrines: ["Leather"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 20, weight: 24 }, { name: "Rope", weight: 100.5, ignoreInInventory: true },] },
    { name: "Miner", faction: "Bandit", clusterWith: "human", playLine: "Bandit", bound: "Miner", tags: KDMapInit(["opendoors", "closedoors", "leashing", "bandit", "human", "miner", "imprisonable", "melee", "leatherRestraints", "leatherRestraintsHeavy", "clothRestraints", "chainweakness", "glueweakness", "search"]), cohesion: 0.9, armor: 0, followRange: 1, AI: "hunt",
        spells: ["MinerBomb"], spellCooldownMult: 1, spellCooldownMod: 3, noSpellLeashing: true, miscastmsg: "KDBanditMiscast", miscastsfx: "Miss",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 5.5, color: "#ffdd00" },
        ],
        visionRadius: 5, maxhp: 11, minLevel: 0, weight: 12, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "pain", fullBoundBonus: 2,
        terrainTags: { "increasingWeight": 1 }, shrines: [], floors: KDMapInit(["cry"]), noOverrideFloor: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 21 }, { name: "Pickaxe", ignoreInInventory: true, weight: 100 }, { name: "Bomb", weight: 9 }] },
    { name: "Bandit", faction: "Bandit", clusterWith: "bandit", playLine: "Bandit", bound: "Bandit", tags: KDMapInit(["opendoors", "closedoors", "leashing", "cacheguard", "imprisonable", "bandit", "minor", "melee", "leatherRestraints", "leatherRestraintsHeavy", "clothRestraints", "chainweakness", "glueweakness", "jail", "jailer", "search"]), cohesion: 0.9, armor: 0, followRange: 1, AI: "hunt",
        spells: ["BanditBola"], spellCooldownMult: 1, spellCooldownMod: 8, noSpellLeashing: true, difficulty: 0.9, miscastmsg: "KDBanditMiscast", miscastsfx: "Miss",
        visionRadius: 6, maxhp: 9, minLevel: 0, maxLevel: 9, weight: 23, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "thirdhalf": -4, "increasingWeight": -1, "BanditEnemy": -7, "BanditWanted": -6, "BanditHated": -5 }, shrines: ["Leather"], floors: KDMapInit(["jng", "cry"]),
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 15, weight: 24 }, { name: "Rope", weight: 3.5, ignoreInInventory: true },] },
    { name: "BanditChief", faction: "Bandit", clusterWith: "bandit", playLine: "Bandit", bound: "BanditChief", tags: KDMapInit(["opendoors", "cacheguard", "closedoors", "leashing", "bandit", "miniboss", "banditleader", "melee", "unflinching", "ballGagRestraints", "handcuffer", "leatherRestraints", "leatherRestraintsHeavy", "clothRestraints", "chainweakness", "glueweakness", "jail", "jailer", "hunter"]), cohesion: 0.9, armor: 0, followRange: 1, AI: "hunt",
        summon: [
            { enemy: "BanditPet", range: 3, count: 1, chance: 1.0, strict: true },
        ],
        spells: ["BanditBola"], spellCooldownMult: 1, spellCooldownMod: 4, noSpellLeashing: true, miscastmsg: "KDBanditMiscast", miscastsfx: "Miss",
        visionRadius: 8, maxhp: 24, minLevel: 0, weight: -11, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 3.6, attackRange: 1, power: 4, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 16, "lastthird": 5, "open": 10, "passage": -10, "increasingWeight": 1 }, shrines: ["Leather"], floors: KDMapInit(["jng", "cry", "tmp"]),
        factionrep: { "Maidforce": 0.005 },
        dropTable: [{ name: "Gold", amountMin: 20, amountMax: 30, weight: 10 }, { name: "Knife", ignoreInInventory: true, weight: 2 }, { name: "Rope", weight: 100, ignoreInInventory: true },] },
    { name: "BanditPet", faction: "Bandit", clusterWith: "human", playLine: "Gagged", bound: "BanditPet", tags: KDMapInit(["opendoors", "submissive", "noshop", "gagged", "cacheguard", "closedoors", "leashing", "bandit", "melee", "minor", "ballGagRestraints", "ropeRestraints", "tickleweakness", "chainweakness", "glueweakness", "jail", "search"]), cohesion: 0.9, armor: 0, followRange: 1, AI: "hunt",
        master: { type: "BanditChief", range: 2, loose: true, aggressive: true }, difficulty: 0.7,
        visionRadius: 6, maxhp: 8, minLevel: 0, weight: 13, movePoints: 1, attackPoints: 3, attack: "MeleeBindLockWill", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "thirdhalf": -1, "increasingWeight": -1 }, shrines: ["Leather"], floors: KDMapInit(["jng", "cry"]),
        dropTable: [{ name: "Gold", amountMin: 1, amountMax: 5, weight: 10 }, { name: "Feather", weight: 50, ignoreInInventory: true }] },
    { name: "BanditHunter", faction: "Bandit", bound: "BanditHunter", playLine: "Bandit", tags: KDMapInit(["opendoors", "closedoors", "leashing", "bandit", "imprisonable", "melee", "elite", "leatherRestraints", "leatherRestraintsHeavy", "clothRestraints", "chainweakness", "glueweakness", "jail", "jailer", "hunter"]), ignorechance: 0, armor: 0, followRange: 2, AI: "hunt", guardChance: 0.6, stealth: 1,
        spells: ["BanditBola"], spellCooldownMult: 1, spellCooldownMod: 3, noSpellLeashing: true, projectileTargeting: true, focusPlayer: true, miscastmsg: "KDBanditMiscast", miscastsfx: "Miss",
        visionRadius: 7, maxhp: 9, minLevel: 0, weight: 4, movePoints: 2, attackPoints: 2, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 7, "thirdhalf": 5 }, shrines: ["Leather"], floors: KDMapInit(["jng", "cry", "tmp"]),
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "Rope", weight: 8, ignoreInInventory: true },] },
    { name: "BanditGrappler", faction: "Bandit", clusterWith: "bandit", playLine: "Bandit", bound: "BanditGrappler", color: "#ddcaaa",
        tags: KDMapInit(["opendoors", "closedoors", "leashing", "bandit", "melee", "cacheguard", "elite", "unflinching", "chainRestraints", "handcuffer", "leatherRestraintsHeavy", "clothRestraints", "chainweakness", "glueweakness", "jail", "jailer", "hunter"]),
        ignorechance: 0, armor: 1, followRange: 1, AI: "hunt",
        specialCD: 10, specialAttack: "Pull", specialCDonAttack: true, specialAttackPoints: 2, specialRange: 4, specialsfx: "Chain", specialWidth: 1, specialRemove: "BindLock", pullDist: 3, pullTowardSelf: true,
        visionRadius: 7, maxhp: 10, minLevel: 3, weight: 4, movePoints: 3, attackPoints: 2, attack: "MeleeBindLock", attackWidth: 2, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 10, "thirdhalf": 1 }, shrines: ["Leather", "Metal"], floors: KDMapInit(["jng", "cry", "tmp"]),
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }] },
    { name: "SlimeMold", clusterWith: "mold", faction: "Mold", color: "#FF00FF", tags: KDMapInit(["ignoretiedup", "doortrap", "mold", "minor", "melee", "moldRestraints", "fireweakness", "glueresist", "acidweakness"]),
        squeeze: true, ignorechance: 0.75, followRange: 1, AI: "hunt", sneakThreshold: 1,
        visionRadius: 5, maxhp: 1, minLevel: 0, weight: -15, movePoints: 1.5, attackPoints: 2, attack: "MeleeBindSuicide", suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "glue", fullBoundBonus: 1,
        terrainTags: { "increasingWeight": -2, "mold": 25 }, allFloors: true, shrines: ["Latex"] },
    { name: "SlimeMoldLeaper", clusterWith: "mold", faction: "Mold", color: "#FF00FF", tags: KDMapInit(["ignoretiedup", "doortrap", "mold", "minor", "melee", "moldRestraints", "fireweakness", "glueresist", "acidweakness"]),
        squeeze: true, ignorechance: 0.75, followRange: 1, AI: "hunt", sneakThreshold: 1,
        specialCD: 5, specialAttack: "Dash", specialRemove: "Bind", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 3, specialMinrange: 1.5, specialsfx: "Miss",
        visionRadius: 9, maxhp: 1, minLevel: 3, weight: -5, movePoints: 1, attackPoints: 2, attack: "MeleeBindSuicide", suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "glue", fullBoundBonus: 2,
        terrainTags: { "increasingWeight": -1, "mold": 25 }, allFloors: true, shrines: ["Latex"] },
    { name: "SlimeMoldSpawner", clusterWith: "mold", faction: "Mold", color: "#FF00FF", tags: KDMapInit(["mold", "immobile", "spawner", "melee", "moldRestraints", "meleeresist", "fireweakness", "glueresist", "acidweakness"]),
        immobile: true, squeeze: true, followRange: 1, AI: "hunt", sneakThreshold: 1, enemyCountSpellLimit: 40,
        spells: ["SummonSlimeMold"], spellCooldownMult: 1, spellCooldownMod: 0, castWhileMoving: true,
        visionRadius: 30, blindSight: 30, maxhp: 12, minLevel: 0, weight: -15, movePoints: 1000, attackPoints: 0, attack: "Spell", attackRange: 0, attackWidth: 1, power: 1, dmgType: "acid", fullBoundBonus: 5,
        terrainTags: { "increasingWeight": 0, "mold": 25, "maid": 15.25 }, allFloors: true, shrines: ["Latex"], ondeath: [{ type: "summon", enemy: "SlimeMold", range: 2.5, count: 4, strict: true }],
        factionrep: { "Maidforce": 0.005 },
    },
    { name: "SlimeAdv", faction: "Slime", clusterWith: "slime", bound: "SlimeAdv", playLine: "Gagged", color: "#FF00FF",
        tags: KDMapInit([
            "ignoretiedup", "latexTrap", "slime", "melee", "slimeRestraints", "glueimmune", "electricweakness", "acidresist", "iceweakness", "ticklesevereweakness", "charmweakness",
            "submissive", "noshop", "gagged", "imprisonable",
        ]),
        ignorechance: 0, armor: 0, followRange: 2, AI: "hunt", cohesion: 0.45, sneakThreshold: 1,
        master: { type: "WitchSlime", range: 2, loose: true, aggressive: true },
        visionRadius: 4.5, blindSight: 2.5, maxhp: 12, minLevel: 2, weight: 2, movePoints: 1.7,
        attackPoints: 3, attack: "MeleeBindSlow", attackWidth: 1, attackRange: 1, power: 1, dmgType: "glue", fullBoundBonus: 2,
        terrainTags: { "latexAnger": 3, "latexRage": 3, "alchemist": 2, "slimeBonus": 2, "slime": 5, "jungle": 8 }, shrines: ["Latex"], allFloors: true,
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0, duration: 20 },
        ], },
    { name: "SmallSlime", clusterWith: "slime", faction: "Slime", color: "#FF00FF", tags: KDMapInit(["ignoretiedup", "latexTrap", "minor", "slime", "melee", "slimeRestraints", "meleeresist", "glueimmune", "electricweakness", "acidresist", "iceweakness"]), squeeze: true, ignorechance: 0.75, followRange: 1, AI: "hunt", sneakThreshold: 1,
        visionRadius: 3, blindSight: 2.5, maxhp: 3, minLevel: 0, maxLevel: 5, weight: 8, movePoints: 1.5, attackPoints: 2, attack: "MeleeBindSuicideWill", suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "acid", fullBoundBonus: 2,
        terrainTags: { "increasingWeight": -1, "slime": 4, "jungle": 20, "alchemist": 4 }, allFloors: true, shrines: ["Latex"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0, duration: 20 },
        ], },
    { name: "SmallSlimeLeaper", clusterWith: "slime", faction: "Slime", color: "#FF00FF", tags: KDMapInit(["ignoretiedup", "latexTrap", "minor", "slime", "melee", "slimeRestraints", "meleeresist", "glueimmune", "electricweakness", "acidresist", "iceweakness"]), squeeze: true, ignorechance: 0.75, followRange: 1, AI: "hunt", sneakThreshold: 1,
        visionRadius: 4.5, blindSight: 2.5, maxhp: 3, minLevel: 5, weight: 8, movePoints: 1.5, attackPoints: 2, attack: "MeleeBindSuicideWill", suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "acid", fullBoundBonus: 2,
        specialCD: 5, specialAttack: "Dash", specialRemove: "BindSuicideWill", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 4.5, specialMinrange: 1.5, specialsfx: "Miss",
        terrainTags: { "increasingWeight": -1, "slime": 4, "jungle": 20, "alchemist": 4 }, allFloors: true, shrines: ["Latex"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0, duration: 20 },
        ], },
    { name: "FastSlime", clusterWith: "slime", faction: "Slime", color: "#FF00FF", tags: KDMapInit(["ignoretiedup", "latexTrap", "slime", "melee", "slimeRestraints", "meleeresist", "glueimmune", "electricweakness", "acidresist", "iceweakness"]), squeeze: true, evasion: 0.3, followRange: 1, AI: "hunt", sneakThreshold: 1,
        visionRadius: 4.5, blindSight: 2.5, maxhp: 3, minLevel: 9, weight: 3, movePoints: 1, attackPoints: 3, attack: "MeleeBindSuicideWill", suicideOnAdd: true, attackWidth: 1, attackRange: 3, power: 2, dmgType: "acid", fullBoundBonus: 2,
        terrainTags: { "increasingWeight": 1, "slime": 2.5, "jungle": 8, "alchemist": 4 }, allFloors: true, shrines: ["Latex"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0, duration: 20 },
        ], },
    { name: "BigSlime", clusterWith: "slime", faction: "Slime", color: "#FF00FF", tags: KDMapInit(["ignoretiedup", "slime", "latexTrap", "elite", "melee", "slimeRestraints", "meleeresist", "glueimmune", "electricweakness", "acidresist", "iceweakness"]), squeeze: true, evasion: 0.3, followRange: 1, AI: "hunt", sneakThreshold: 1,
        visionRadius: 4.5, blindSight: 2.5, maxhp: 12, minLevel: 9, weight: 2, movePoints: 3, attackPoints: 3, attack: "MeleeBind", attackWidth: 8, attackRange: 1, power: 4, dmgType: "acid", fullBoundBonus: 2, disarm: 0.5,
        terrainTags: { "slime": 1.5, "alchemist": 3 }, allFloors: true, shrines: ["Latex"], ondeath: [{ type: "summon", enemy: "SmallSlime", range: 2.5, count: 4, strict: true, lifetime: 50 }],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 3, chance: 1.0, duration: 20 },
            { trigger: "afterEnemyTick", type: "createEffectTile", kind: "Slime", time: 25, power: 2, chance: 0.3, aoe: 0.5 }
        ],
    },
    { name: "StoneDoor", faction: "Natural", blockVision: true,
        cueSfx: {
            Block: "Clang",
            Resist: "Clang",
            Damage: "ArmorHit",
        },
        tags: KDMapInit(["obstacledoor", "scenery", "minor", "inactive", "nonvulnerable", "unstoppable", "immobile", "nobrain", "poisonimmune", "harmless",
            "soulimmune", "slashresist", "pierceresist", "electricresist", "crushweakness", "unarmedresist", "chainimmune", "glueresist", "acidresist", "tickleimmune", "gropeimmune", "painimmune", "charmimmune",
        ]), spellResist: 0, sneakThreshold: 0.01,
        evasion: -9, ignorechance: 1.0, armor: 3, followRange: 1, AI: "ambush", ambushRadius: 0, difficulty: -0.05, immobile: true,
        visionRadius: 0, maxhp: 10, minLevel: 0, weight: -4, movePoints: 99999, attackPoints: 4, attack: "", attackWidth: 8, attackRange: 3, power: 1, dmgType: "souldrain",
        terrainTags: { "obstacle": 10, "obstacletile": 50 }, allFloors: true, shrines: [],
        events: [
            { trigger: "duringDamageEnemy", type: "damageThreshold", power: 1, chance: 1.0 },
        ],
    },
    { name: "SteelDoor", faction: "Natural", blockVision: true,
        cueSfx: {
            Block: "Clang",
            Resist: "Clang",
            Damage: "ArmorHit",
        },
        tags: KDMapInit(["obstacledoor", "steeldoor", "scenery", "minor", "inactive", "nonvulnerable", "unstoppable", "immobile", "nobrain", "poisonimmune", "harmless",
            "soulimmune", "slashresist", "pierceresist", "electricimmune", "unarmedresist", "chainimmune", "glueresist", "tickleimmune", "gropeimmune", "painimmune", "charmimmune",
        ]), spellResist: 1, sneakThreshold: 0.01,
        evasion: -9, ignorechance: 1.0, armor: 5, followRange: 1, AI: "ambush", ambushRadius: 0, difficulty: -0.05, immobile: true,
        visionRadius: 0, maxhp: 15, minLevel: 9, weight: -4, movePoints: 99999, attackPoints: 4, attack: "", attackWidth: 8, attackRange: 3, power: 1, dmgType: "souldrain",
        terrainTags: { "obstacle": 10, "obstacletile": 30 }, allFloors: true, shrines: [],
        events: [
            { trigger: "duringDamageEnemy", type: "damageThreshold", power: 1, chance: 1.0 },
        ],
    },
    { name: "DollDoor", faction: "Natural", blockVision: true,
        cueSfx: {
            Block: "Clang",
            Resist: "Clang",
            Damage: "ArmorHit",
        },
        tags: KDMapInit(["dolldoor", "scenery", "minor", "inactive", "nonvulnerable", "unstoppable", "immobile", "nobrain", "poisonimmune", "harmless",
            "soulimmune", "slashresist", "pierceresist", "electricimmune", "unarmedresist", "chainimmune", "glueresist", "tickleimmune", "gropeimmune", "painimmune", "charmimmune",
        ]), spellResist: 5, armor: 5, sneakThreshold: 0.01,
        evasion: -9, ignorechance: 1.0, followRange: 1, AI: "ambush", ambushRadius: 0, difficulty: -0.05, immobile: true,
        visionRadius: 0, maxhp: 60, minLevel: 0, weight: -100, movePoints: 99999, attackPoints: 4, attack: "", attackWidth: 8, attackRange: 3, power: 1, dmgType: "souldrain",
        terrainTags: { dolldoor: 200 }, allFloors: true, shrines: [],
        events: [
            { trigger: "duringDamageEnemy", type: "damageThreshold", power: 1, chance: 1.0 },
        ],
    },
    { name: "GiantMushroom", faction: "Natural", clusterWith: "mushroom", tags: KDMapInit(["mushroom", "scenery", "nonvulnerable", "minor", "inactive", "harmless", "immobile", "unstoppable", "soulimmune", "slashweakness", "fireweakness", "glueresist", "poisonimmune", "coldweakness"]), spellResist: 0.33, sneakThreshold: 0.01,
        evasion: -9, ignorechance: 1.0, armor: 0, followRange: 1, AI: "ambush", ambushRadius: 0, difficulty: -0.05, immobile: true,
        visionRadius: 0, maxhp: 1, minLevel: 0, weight: 5, movePoints: 99999, attackPoints: 4, attack: "", attackWidth: 8, attackRange: 3, power: 1, dmgType: "souldrain",
        terrainTags: {}, floors: KDMapInit(["cry", "jng"]), shrines: ["Will"], ondeath: [{ type: "spellOnSelf", spell: "Spores" }],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0 },
        ], },
    { name: "Toad", faction: "Beast", clusterWith: "beast", color: "#00FF44", tags: KDMapInit(["ignorenoSP", "beast", "soulresist", "ranged", "pierceweakness", "electricsevereweakness", "acidresist"]), followLeashedOnly: true, armor: 1, followRange: 1, AI: "hunt",
        pullTowardSelf: true, pullDist: 3, master: { type: "GiantMushroom", range: 3 }, projectileAttack: true, projectileTargeting: true,
        visionRadius: 5, maxhp: 16, minLevel: 0, weight: 7, movePoints: 2, attackPoints: 3, attack: "MeleePullWill", attackRange: 5, attackWidth: 1, power: 2, strictAttackLOS: true, dmgType: "tickle",
        terrainTags: { "increasingWeight": 2, "secondhalf": 3, }, floors: KDMapInit(["cry"]), dropTable: [{ name: "Nothing", weight: 12 }, { name: "WaterRune", weight: 3 }] },
    { name: "Mushy", faction: "Mushy", clusterWith: "mushroom", color: "#4fa4b8", difficulty: 0.2,
        tags: KDMapInit(["leashing", "mushroom", "soulresist", "mushy", "melee", "minor", "slashweakness", "fireweakness", "glueresist", "poisonimmune", "coldweakness", "ropeMagicStrong", "ropeAuxiliary", "ropeRestraintsHogtie", "clothRestraints", "tapeRestraints"]),
        squeeze: true, evasion: -0.5, followRange: 1, AI: "patrol", regen: 0.1,
        visionRadius: 5, maxhp: 8, minLevel: 4, weight: 14, movePoints: 4, attackPoints: 2, attack: "MeleeBindBlindWill", blindTime: 2, attackWidth: 3, attackRange: 1, power: 2, dmgType: "poison", fullBoundBonus: 2,
        terrainTags: { "mushy": 10 }, floors: KDMapInit(["cry"]), shrines: [], ondeath: [{ type: "spellOnSelf", spell: "Spores" }],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0 },
        ], },
    { name: "MushyHappy", clusterWith: "mushroom", color: "#4fa4b8", difficulty: 0.1,
        tags: KDMapInit(["ignorenoSP", "mushroom", "soulresist", "mushy", "melee", "minor", "slashweakness", "fireweakness", "glueresist", "poisonimmune", "coldweakness"]),
        squeeze: true, evasion: -0.5, followRange: 1, AI: "hunt", regen: 0.1,
        spells: ["SporesHappy"], spellCooldownMult: 1, spellCooldownMod: 0, stopToCast: true, castWhileMoving: true,
        visionRadius: 5, maxhp: 8, minLevel: 7, weight: 14, movePoints: 4, attackPoints: 2, attack: "SpellMeleeWillBlind", blindTime: 2, attackWidth: 1, attackRange: 1, power: 4, dmgType: "tickle", hitsfx: "Tickle",
        terrainTags: { "mushy": 10 }, floors: KDMapInit(["cry"]), shrines: [], ondeath: [{ type: "spellOnSelf", spell: "Spores" }],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0 },
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#ff44aa" },
        ], },
    { name: "MushySick", clusterWith: "mushroom", color: "#4fa4b8", difficulty: 0.1,
        tags: KDMapInit(["ignorenoSP", "mushroom", "soulresist", "mushy", "melee", "minor", "slashweakness", "fireweakness", "glueresist", "poisonimmune", "coldweakness"]),
        squeeze: true, evasion: -0.5, followRange: 1, AI: "hunt",
        spells: ["SporesSick"], spellCooldownMult: 1, spellCooldownMod: 0, stopToCast: true, castWhileMoving: true,
        visionRadius: 5, maxhp: 8, minLevel: 0, weight: 14, movePoints: 4, attackPoints: 2, attack: "SpellMeleeWillBlind", blindTime: 2, attackWidth: 1, attackRange: 1, power: 2, dmgType: "crush",
        terrainTags: { "mushy": 10 }, floors: KDMapInit(["cry"]), shrines: ["Will"], ondeath: [{ type: "spellOnSelf", spell: "Spores" }],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Slime", aoe: 1.5, power: 1, chance: 1.0 },
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#00ff00" },
        ], },
    { name: "Dragon", faction: "Dragon", clusterWith: "dragon", bound: "Dragon", color: "#F92900", tags: KDMapInit(["opendoors", "fire", "guardCall", "jailer", "leashing", "imprisonable", "minor", "dragon", "melee", "dragonRestraints", "handcuffer", "leatherRestraints", "fireresist", "jail", "jailer", "search"]), cohesion: 0.75,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", guardChance: 0.6, master: { type: "DragonLeader", range: 4, loose: true, aggressive: true }, difficulty: 0.5,
        visionRadius: 6, maxhp: 10, minLevel: 1, weight: -1, movePoints: 2, attackPoints: 2, attack: "MeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 1, maxLevel: 7,
        terrainTags: { "secondhalf": 2, "leatherAnger": 3, "dragon": 10, "fire": 4 }, shrines: ["Leather"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 15 }] },
    { name: "DragonShield", faction: "Dragon", clusterWith: "dragon", bound: "DragonShield", color: "#F92900", tags: KDMapInit(["opendoors", "guardCall", "fire", "imprisonable", "leashing", "dragon", "melee", "dragonRestraints", "handcuffer", "leatherRestraints", "fireresist", "jail", "jailer", "search"]), cohesion: 0.75,
        stunTime: 2, specialCD: 6, specialAttack: "Stun", specialRemove: "BindLock", specialPower: 6, specialDamage: "pain",
        spells: ["ArmorUpArea"], spellCooldownMult: 1, spellCooldownMod: 5, buffallies: true,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", guardChance: 0.6, master: { type: "DragonLeader", range: 4, loose: true, aggressive: true },
        visionRadius: 7, maxhp: 14, minLevel: 4, weight: -1, movePoints: 2, attackPoints: 2, attack: "SpellMeleeBindLock", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "leatherAnger": 3, "leatherRage": 4, "dragon": 10, "fire": 4 }, shrines: ["Leather"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 15 }] },
    { name: "DragonIce", faction: "Dragon", clusterWith: "dragon", bound: "DragonIce", color: "#aaaaff", tags: KDMapInit(["opendoors", "ice", "leashing", "dragon", "melee", "elite", "dragonRestraints", "handcuffer", "leatherRestraints", "iceimmune", "fireweakness", "crushweakness", "jail", "jailer", "hunter"]), cohesion: 0.75,
        followLeashedOnly: true, ignorechance: 0, armor: 1, followRange: 1, AI: "hunt", guardChance: 0.6, master: { type: "DragonLeader", range: 4, loose: true, aggressive: true },
        spells: ["IceDragonBreathPrepare"], spellCooldownMult: 1, spellCooldownMod: 3, spellRdy: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#00ffff" },
        ],
        visionRadius: 7, maxhp: 14, minLevel: 4, weight: -2, movePoints: 2, attackPoints: 2, attack: "SpellMeleeBindLockAll", attackWidth: 1, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 1,
        attackLock: "Purple",
        terrainTags: { "secondhalf": 2, "thirdhalf": 2, "dragon": 6, "ice": 4 }, shrines: ["Leather", "Elements"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 20, amountMax: 30, weight: 12 }, { name: "IceRune", weight: 3 }, { name: "IceBreaker", weight: 0.1, ignoreInInventory: true }] },
    { name: "DragonPoison", faction: "Dragon", clusterWith: "dragon", bound: "DragonPoison", color: "#44ff77", tags: KDMapInit(["opendoors", "nature", "leashing", "dragon", "melee", "elite", "dragonRestraints", "handcuffer", "leatherRestraints", "unflinching", "fireresist", "jail", "jailer", "hunter"]), cohesion: 0.75,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", guardChance: 0.6, master: { type: "DragonLeader", range: 4, loose: true, aggressive: true },
        spells: ["PoisonDragonBlast", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, spellCooldownMult: 1, spellCooldownMod: -1, tilesMinRange: 2, stopToCast: true, spellRdy: true,
        visionRadius: 7, maxhp: 11, minLevel: 6, weight: -2, movePoints: 3, attackPoints: 4, attack: "SpellMeleeStunWill", stunTime: 1, attackWidth: 3, attackRange: 2, power: 3, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 2, "thirdhalf": 2, "dragon": 6, "nature": 4 }, shrines: ["Leather", "Will"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 20, amountMax: 30, weight: 12 }, { name: "Pick", weight: 4 }, { name: "PotionStamina", weight: 3 }] },
    { name: "DragonCrystal", faction: "Dragon", clusterWith: "dragon", bound: "DragonCrystal", color: "#ff00aa", tags: KDMapInit(["opendoors", "chaos", "leashing", "dragon", "melee", "elite", "dragonRestraints", "handcuffer", "leatherRestraints", "leatherRestraintsHeavy", "pierceweakness", "electricresist", "crushweakness", "fireresist", "jail", "jailer", "hunter"]), cohesion: 0.75,
        followLeashedOnly: true, ignorechance: 0, armor: 1, followRange: 1, AI: "hunt", guardChance: 0.6, master: { type: "DragonLeader", range: 4, loose: true, aggressive: true },
        spells: ["SummonCrystals"], spellCooldownMult: 1, spellCooldownMod: 2, castWhileMoving: true, spellRdy: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#ff44aa" },
        ],
        visionRadius: 7, maxhp: 10, minLevel: 7, weight: -1, movePoints: 1.5, attackPoints: 2, attack: "SpellMeleeBindLockWill", stunTime: 1, attackWidth: 1, attackRange: 1, power: 3, dmgType: "crush", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 1, "thirdhalf": 2, "crystalline": 10, "dragon": 3 }, shrines: ["Leather", "Conjure"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 20, amountMax: 30, weight: 15 }, { name: "EarthRune", weight: 3 }] },
    { name: "DragonShadow", faction: "Dragon", clusterWith: "dragon", bound: "DragonShadow", color: "#4400ff",
        tags: KDMapInit(["opendoors", "shadow", "chaos", "leashing", "dragon", "melee", "elite", "dragonRestraints", "handcuffer", "shadowRestraints", "coldimmune", "fireresist", "jail", "jailer", "hunter"]),
        cohesion: 0.75,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt", guardChance: 0.6, master: { type: "DragonLeader", range: 4, loose: true, aggressive: true },
        spells: ["ShadowOrb"], spellCooldownMult: 1, spellCooldownMod: 0, pullTowardSelf: true, pullDist: 3, disarm: 0.4,
        specialCD: 7, specialAttack: "Pull", specialCDonAttack: true, specialAttackPoints: 2, specialRange: 4, specialsfx: "MagicSlash",
        visionRadius: 7, maxhp: 16, minLevel: 9, weight: -1, movePoints: 2, attackPoints: 2, attack: "SpellMeleeWill", stunTime: 3, attackWidth: 1, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 1, "thirdhalf": 2, "dragon": 3, "shadow": 4 }, shrines: ["Leather", "Conjure"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "Knife", ignoreInInventory: true, weight: 4 }] },
    { name: "DragonLeader", faction: "Dragon", clusterWith: "dragon", bound: "DragonLeader", color: "#F92900", tags: KDMapInit(["opendoors", "fire", "leashing", "dragon", "melee", "boss", "dragonRestraints", "unflinching", "handcuffer", "leatherRestraints", "leatherRestraintsHeavy", "jailer", "fireimmune"]),
        ignorechance: 0, armor: 0, followRange: 1, AI: "patrol", focusPlayer: true,
        summon: [
            { enemy: "Dragon", range: 2, count: 2, chance: 0.4, strict: true },
            { enemy: "DragonIce", range: 3, count: 1, chance: 0.25, strict: true },
            { enemy: "DragonPoison", range: 3, count: 1, chance: 0.25, strict: true },
            { enemy: "DragonCrystal", range: 3, count: 1, chance: 0.25, strict: true },
            { enemy: "DragonShadow", range: 3, count: 1, chance: 0.25, strict: true },
        ],
        specialCD: 5, specialAttack: "Dash", specialRemove: "BindLockWill", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 3, specialMinrange: 1.5, specialsfx: "Miss",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ff5555" },
        ],
        visionRadius: 8, maxhp: 20, minLevel: 4, weight: -11, movePoints: 2, attackPoints: 2, attack: "MeleeBindLockWill", attackWidth: 1, attackRange: 1, power: 4, dmgType: "crush", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 2, "thirdhalf": 4, "open": 10, "fire": 4, "leatherAnger": 6, "leatherRage": 30, "boss": -55, "increasingWeight": 0.5, "dragon": 1 }, shrines: ["Leather"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 30, amountMax: 40, weight: 10 }, { name: "Sword", ignoreInInventory: true, weight: 100 }, { name: "EnchKnife", ignoreInInventory: true, weight: 1 }] },
    { name: "ElementalFire", faction: "Elemental", playLine: "Elemental", clusterWith: "fire", bound: "ElementalFire", color: "#FF6200", tags: KDMapInit(["opendoors", "fire", "guardCall", "elemental", "fireimmune", "ranged", "coldweakness", "icesevereweakness", "obsidianRestraints", "shackleRestraints", "leashing", "jail", "jailer", "search"]),
        armor: 0, kite: 1.5, followRange: 3, AI: "hunt",
        spells: ["HeatBolt"], spellCooldownMult: 1, spellCooldownMod: 1, followLeashedOnly: true, stopToCast: true, spellRdy: true, projectileTargeting: true,
        visionRadius: 7, maxhp: 8, minLevel: 0, weight: -1, movePoints: 1.5, attackPoints: 3, attack: "SpellMeleeWillBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "pain", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 2, "thirdhalf": 1, "open": 1, "elementsAnger": 12, "elementsRage": 6, "temple": 5, "elemental": 6 }, allFloors: true, shrines: ["Elements", "Metal"],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }, { name: "EarthRune", weight: 1 }],
        events: [
            { trigger: "afterEnemyTick", type: "createEffectTile", kind: "Ember", time: 3, power: 2, chance: 0.2, aoe: 1.5 },
            { trigger: "getLights", type: "enemyTorch", power: 5.5, color: "#ff8933" }
        ],
    },
    { name: "ElementalIce", faction: "Elemental", playLine: "Elemental", clusterWith: "ice", bound: "ElementalIce", color: "#aaaaff", tags: KDMapInit(["opendoors", "elemental", "guardCall", "ice", "ranged", "firesevereweakness", "crushweakness", "coldresist", "iceimmune", "iceRestraints", "leashing", "jail", "jailer", "search"]),
        armor: 1, kite: 1.5, followRange: 3, AI: "hunt",
        spells: ["IceSlowPrepare"], spellCooldownMult: 1, spellCooldownMod: 1, followLeashedOnly: true, noSpellLeashing: true, spellRdy: true, projectileTargeting: true,
        visionRadius: 7, maxhp: 8, minLevel: 3, weight: -2, movePoints: 1.5, attackPoints: 3, attack: "SpellMeleeWillBindLockAll", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2, multiBind: 2,
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "open": 1, "elementsAnger": 8, "elementsRage": 3, "temple": 6, "elemental": 6, "ice": 4 }, allFloors: true, shrines: ["Elements"], attackLock: "Purple",
        events: [
            { trigger: "afterEnemyTick", type: "createIce", power: 1, chance: 1.0, aoe: 1.0 },
            { trigger: "getLights", type: "enemyTorch", power: 3.5, color: "#00ffff" },
        ],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 10, weight: 10 }, { name: "IceRune", weight: 1 }, { name: "IceBreaker", weight: 0.1, ignoreInInventory: true }] },
    { name: "ElementalWater", faction: "Elemental", playLine: "Elemental", clusterWith: "ice", bound: "ElementalWater", color: "#57ff88", tags: KDMapInit(["opendoors", "water", "elemental", "ranged", "fireresist", "acidimmune", "electricsevereweakness", "latexRestraints", "ropeRestraints", "elite", "leashing", "jail", "jailer", "hunter"]), armor: 0, kite: 1.5, followRange: 3, AI: "hunt", guardChance: 0.6, evasion: 0.25, summon: [{ enemy: "ElementalIce", range: 2.5, count: 1, chance: 0.6, strict: true }],
        specialCD: 5, specialAttack: "Pull", specialCDonAttack: true, specialAttackPoints: 4, specialRange: 4, specialWidth: 3, specialMinrange: 1.5, specialsfx: "Song", hitsfx: "Song", tilesMinRangeSpecial: 2,
        visionRadius: 7, maxhp: 12, minLevel: 3, weight: -2, movePoints: 1.5, followLeashedOnly: true, projectileTargeting: true,
        attackPoints: 3, attack: "MeleeBindLockAll", attackWidth: 3, attackRange: 1, power: 5, dmgType: "charm", pullTowardSelf: true, pullDist: 2, pullMsg: true,
        attackLock: "Purple",
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "open": 1, "elementsAnger": 8, "elementsRage": 3, "illusionAnger": 2, "latexAnger": 2, "temple": 5, "elemental": 4, "water": 4 }, allFloors: true, shrines: ["Elements"],
        events: [{ trigger: "afterEnemyTick", type: "createWater", power: 2, chance: 1.0, aoe: 0.5 }],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "WaterRune", weight: 2 }] },
    { name: "ElementalEarth", faction: "Elemental", playLine: "Elemental", clusterWith: "elemental", bound: "ElementalEarth", color: "#C1703A",
        tags: KDMapInit(["opendoors", "elemental", "fireresist", "melee", "nofreeze", "earth", "elite", "electricimmune", "guardCall", "unflinching", "iceweakness", "unarmedresist", "slashresist", "pierceresist", "obsidianRestraints", "shackleRestraints", "leashing", "magicresist", "jail", "jailer", "hunter"]), armor: 1, followRange: 1, AI: "hunt",
        specialCD: 15, specialAttack: "Dash", specialRemove: "Bind", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 4, specialMinrange: 1.5, specialsfx: "Miss", castWhileMoving: true, dashThruWalls: true,
        spells: ["ArmorUp", "Earthfield"], spellCooldownMult: 1, spellCooldownMod: 14, followLeashedOnly: true, spellRdy: true,
        visionRadius: 7, maxhp: 12, minLevel: 7, weight: -2, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 3, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 1, "thirdhalf": 2, "elementsAnger": 12, "elementsRage": 6, "temple": 6, "elemental": 4, "earth": 4 }, allFloors: true, shrines: ["Elements", "Metal"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "EarthRune", weight: 3 }],
        events: [{ trigger: "afterEnemyTick", type: "createEffectTile", kind: "Cracked", time: 10, power: 2, chance: 0.3, aoe: 0.5 }],
    },
    { name: "ElementalAir", faction: "Elemental", playLine: "Elemental", clusterWith: "electric", bound: "ElementalAir", color: "#88aaff", tags: KDMapInit(["opendoors", "electric", "nofreeze", "elemental", "melee", "elite", "fireweakness", "electricresist", "coldweakness", "latexRestraints", "ropeRestraints", "leashing", "jail", "jailer", "hunter"]), armor: -1, followRange: 1, AI: "hunt", guardChance: 0.6, evasion: 0.5,
        specialCD: 5, specialAttack: "Dash", specialRemove: "Bind", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 3, specialMinrange: 1.5, specialsfx: "Miss", castWhileMoving: true, dashThruWalls: true, dashThrough: true,
        spells: ["AreaElectrify"], spellCooldownMult: 1, spellCooldownMod: 3, followLeashedOnly: true, disarm: 1, noSpellLeashing: true, spellRdy: true, noChannel: true,
        visionRadius: 7, maxhp: 12, minLevel: 4, weight: -2, movePoints: 1, attackPoints: 2, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "thirdhalf": 2, "elementsAnger": 12, "elementsRage": 6, "temple": 5, "elemental": 4, "electric": 4, "air": 4 }, allFloors: true, shrines: ["Elements", "Latex"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }] },
    { name: "Dryad", faction: "Elf", clusterWith: "nature", bound: "Dryad", playLine: "Dryad", color: "#67ff44", tags: KDMapInit(["opendoors", "nature", "elf", "leashing", "plant", "ranged", "vineRestraints", "slashweakness", "pierceweakness", "fireweakness", "search"]), cohesion: 0.0,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 3, AI: "hunt",
        specialCD: 15, specialAttack: "Stun", specialRemove: "Bind", specialCDonAttack: true, specialAttackPoints: 2, specialRange: 4, specialWidth: 2, specialMinrange: 1.5, specialsfx: "Song", tilesMinRangeSpecial: 2, stunTime: 4,
        specialDamage: "charm", spellRdy: true,
        spells: ["PoisonDragonBlast", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, spellCooldownMult: 1, spellCooldownMod: -2, tilesMinRange: 1, stopToCast: true, kite: 1.5,
        visionRadius: 6, maxhp: 10, minLevel: 2, weight: -3, movePoints: 1.5, attackPoints: 3, attack: "SpellMeleeBind", attackWidth: 3, attackRange: 1, power: 2, dmgType: "tickle", fullBoundBonus: 2, hitsfx: "Tickle",
        terrainTags: { "secondhalf": 1, "thirdhalf": 2, "willAnger": 11, "willRage": -6, "elf": 5, "nature": 4 }, shrines: ["Will"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 12 }, { name: "EarthRune", weight: 4 }] },
    { name: "JungleDryad", faction: "Elf", clusterWith: "nature", bound: "JungleDryad", playLine: "Dryad", color: "#67ff44", tags: KDMapInit(["opendoors", "nature", "elf", "leashing", "plant", "ranged", "vineRestraints", "slashweakness", "pierceweakness", "fireweakness", "search"]), cohesion: 0.0,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 3, AI: "hunt",
        spellRdy: true,
        spells: ["PoisonDragonBlast", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, spellCooldownMult: 1, spellCooldownMod: -2, tilesMinRange: 1, stopToCast: true, kite: 1.5,
        visionRadius: 6, maxhp: 10, minLevel: 7, weight: 5, movePoints: 1, attackPoints: 3, attack: "SpellMeleeBind", attackWidth: 3, attackRange: 1, power: 2, dmgType: "tickle", fullBoundBonus: 2, hitsfx: "Tickle",
        terrainTags: { "secondhalf": 3, "thirdhalf": 4 }, shrines: ["Will"], floors: KDMapInit(["jng"]), noOverrideFloor: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 12 }, { name: "EarthRune", weight: 4 }] },
    { name: "ElfRanger", faction: "Elf", clusterWith: "nature", bound: "ElfRanger", playLine: "Elf", color: "#67ff44", tags: KDMapInit(["opendoors", "guardCall", "leashing", "elf", "ranged", "elite", "mithrilRope", "pierceweakness", "iceweakness", "chainresist", "jail", "jailer", "hunter"]), cohesion: 0.0,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 3, AI: "hunt", stealth: 3, focusPlayer: true,
        spells: ["ElfArrow"], miscastmsg: "KDBanditMiscast", miscastsfx: "Miss", spellCooldownMult: 1, spellCooldownMod: 0, stopToCast: true, castWhileMoving: true, kite: 1.5, projectileAttack: true,
        visionRadius: 9, maxhp: 13, minLevel: 3, weight: -0.5, movePoints: 1, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2,
        attackLock: "Purple",
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "willAnger": 5, "willRage": 8, "temple": 5, "elf": 12 }, shrines: ["Will"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 12 }, { name: "ElfCrystal", weight: 3 }] },
    { name: "Elf", faction: "Elf", clusterWith: "elf", bound: "Elf", playLine: "Elf", color: "#67ff44", tags: KDMapInit(["opendoors", "guardCall", "religious", "jailer", "leashing", "elf", "imprisonable", "ranged", "elite", "mithrilRestraints", "pierceweakness", "iceweakness", "chainresist", "jail", "jailer", "hunter"]), cohesion: 0.7,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 3, AI: "hunt", guardChance: 0.6, buffallies: true, spellRdy: true,
        spells: ["Entangle", "OrbHeal", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 16, spellCooldownMult: 1, spellCooldownMod: 0, stopToCast: true, castWhileMoving: true, kite: 1.5,
        visionRadius: 9, maxhp: 16, minLevel: 7, weight: -3, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 1,
        attackLock: "Purple",
        terrainTags: { "secondhalf": 1, "thirdhalf": 1, "willAnger": 4, "willRage": 6, "temple": 5, "elf": 8 }, shrines: ["Will"], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 9 }, { name: "ElfCrystal", weight: 4 }],
        ondeath: [
            { type: "summon", enemy: "Bramble", range: 0.5, count: 1, strict: true }
        ],
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4, color: "#ffffff" }
        ],
    },
    { name: "OrbOfLight", clusterWith: "nature", color: "#ffff00", tags: KDMapInit(["opendoors", "ignorenoSP", "nature", "ghost", "ranged", "soulimmune", "unstoppable", "coldsevereweakness", "flying"]), cohesion: 1.0, cohesionRange: 10,
        followLeashedOnly: true, ignorechance: 0, armor: 0, followRange: 3, AI: "hunt", buffallies: true, spellRdy: true, sneakthreshold: 0.95,
        spells: ["OrbHeal"], spellCooldownMult: 1, spellCooldownMod: 3, tilesMinRange: 1, stopToCast: true, kite: 1.5, kiteChance: 0.9,
        visionRadius: 10, blindSight: 10, maxhp: 10, minLevel: 3, weight: 1.5, movePoints: 3, attackPoints: 4, attack: "SpellMeleeBlindWill", blindTime: 3, attackWidth: 8, attackRange: 1, power: 6, dmgType: "fire",
        terrainTags: { "willAnger": 4, "willRage": 4, "magical": 4, "elf": 6 }, shrines: ["Will"], allFloors: true, dropTable: [{ name: "Ectoplasm", weight: 9 }, { name: "ElfCrystal", weight: 3 }],
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffff44" }
        ],
    },
    { name: "Monolith", clusterWith: "chaos", color: "#ff5277",
        tags: KDMapInit(["opendoors", "ignorenoSP", "construct", "poisonimmune", "soulimmune", "temple", "minor", "chaos", "ranged", "slashimmune", "unarmedresist", "pierceimmune", "fireresist", "unstoppable", "tickleresist", "groperesist", "electricresist", "flying"]),
        cohesion: 0, cohesionRange: 10, difficulty: 0.3,
        followLeashedOnly: true, ignorechance: 0, armor: 1, spellResist: 0.5, followRange: 2, AI: "guard", buffallies: true, spellRdy: false, sneakthreshold: 0.95,
        spells: ["MonolithBeam"], spellCooldownMult: 1, spellCooldownMod: 0, stopToCast: true, kite: 1.5, kiteChance: 0.9,
        visionRadius: 5, blindSight: 5, maxhp: 7, minLevel: 10, weight: 4, movePoints: 4, attackPoints: 4, attack: "Spell", attackWidth: 8, attackRange: 1, power: 3, dmgType: "fire",
        terrainTags: { "open": 25, "temple": 6 }, shrines: [], floors: KDMapInit(["tmp", "tmb", "cry"]), dropTable: [{ name: "EarthRune", weight: 7 }, { name: "ElfCrystal", weight: 3 }],
    },
    { name: "Pixie", clusterWith: "nature", tags: KDMapInit(["ignorenoSP", "fairy", "soulresist", "chaos", "melee", "minor", "magicweakness", "flying"]), followRange: 1, AI: "hunt", squeeze: true, ethereal: true, cohesion: 1.0,
        summon: [
            { enemy: "Pixie", range: 3, count: 2, chance: 0.2, strict: true },
        ],
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3.5, color: "#ffffff" }
        ],
        difficulty: 0.2,
        spells: ["EnemyFlash"], spellCooldownMult: 1, spellCooldownMod: 14, castWhileMoving: true,
        visionRadius: 6, blindSight: 4, maxhp: 1, evasion: 1.0, minLevel: 0, weight: 0.1, movePoints: 1.25, attackPoints: 2, attack: "MeleeWillSpell", attackWidth: 1, attackRange: 1, power: 2, dmgType: "charm",
        terrainTags: { "willAnger": 2, "willRage": 3, "elf": 0.4 }, shrines: ["Will"], allFloors: true },
    { name: "ChaoticCrystal", faction: "Natural", clusterWith: "chaos", color: "#ff00aa", immobile: true, hitsfx: "Evil", tags: KDMapInit(["crystal", "chaos", "minor", "inactive", "melee", "crushweakness", "soulimmune"]),
        evasion: -9, ignorechance: 1.0, armor: 0, followRange: 1, AI: "wander", sneakThreshold: 0.01,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ff44aa" }
        ],
        visionRadius: 1.5, blindSight: 1.5, maxhp: 8, minLevel: 0, weight: 0, movePoints: 99999, attackPoints: 1, attack: "MeleeWill", attackWidth: 8, attackRange: 1, power: 1, dmgType: "drain",
        terrainTags: { "passage": -999, "door": -99, "crystalline": 45 }, floors: KDMapInit(["cry"]), shrines: [] },
    { name: "ChaoticCrystalActive", faction: "Natural", clusterWith: "chaos", immobile: true, color: "#ff00aa", hitsfx: "Evil", tags: KDMapInit(["crystal", "active", "chaos", "melee", "crushweakness", "crystalRestraints", "soulimmune"]),
        evasion: -9, ignorechance: 1.0, armor: 0, followRange: 1, AI: "wander", sneakThreshold: 0.01,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 5.5, color: "#ff44aa" }
        ],
        visionRadius: 5, blindSight: 5, maxhp: 16, minLevel: 0, weight: 0, movePoints: 99999, attackPoints: 4, attack: "MeleeWillBind", attackWidth: 8, attackRange: 2, power: 2, dmgType: "drain", fullBoundBonus: 2,
        terrainTags: { "passage": -999, "door": -99, "crystalline": 5, "open": 45 }, floors: KDMapInit(["cry"]), shrines: [] },
    { name: "Statue", faction: "Natural", tags: KDMapInit(["mimicBlock", "statue", "minor", "melee", "unflinching", "crushweakness", "harmless", "pierceweakness", "chainresist", "soulimmune"]), immobile: true, spellResist: 0.33, sneakThreshold: 0.01,
        evasion: -9, ignorechance: 1.0, armor: 2, followRange: 1, AI: "ambush", ambushRadius: 0,
        visionRadius: 0, maxhp: 8, minLevel: 0, weight: 30, movePoints: 99999, attackPoints: 4, attack: "", attackWidth: 8, attackRange: 3, power: 4, dmgType: "souldrain",
        terrainTags: { "passage": -999, "temple": 82, "open": 10 }, floors: KDMapInit(["tmp"]), shrines: [] },
    { name: "StatueGag", tags: KDMapInit(["ignoregagged", "mimicBlock", "statue", "minor", "melee", "unflinching", "ballGagRestraintsMagic", "crushweakness", "pierceweakness", "chainresist", "soulimmune"]), spellResist: 0.33, sneakThreshold: 0.01,
        evasion: -9, ignorechance: 1.0, armor: 2, followRange: 1, AI: "ambush", ambushRadius: 1.5, difficulty: 0.2,
        visionRadius: 8, maxhp: 12, minLevel: 0, weight: 10, movePoints: 2, attackPoints: 2, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope",
        terrainTags: { "passage": -999, "temple": 72, "open": 10 }, floors: KDMapInit(["tmp"]), shrines: ["Latex"] },
    { name: "StatueDart", tags: KDMapInit(["mimicBlock", "statue", "minor", "melee", "unflinching", "crushweakness", "pierceweakness", "chainresist", "soulimmune"]), immobile: true, spellResist: 0.33, sneakThreshold: 0.01,
        spells: ["SleepDart"], spellCooldownMult: 1, spellCooldownMod: 20, stopToCast: true, castWhileMoving: true, projectileAttack: true,
        evasion: -9, ignorechance: 1.0, armor: 2, followRange: 1, AI: "ambush", ambushRadius: 1.5,
        visionRadius: 4, maxhp: 8, minLevel: 0, weight: 25, movePoints: 99999, attackPoints: 4, attack: "Spell", attackWidth: 8, attackRange: 3, power: 4, dmgType: "souldrain",
        terrainTags: { "passage": -999, "temple": 72, "open": 15 }, floors: KDMapInit(["tmp"]), shrines: [] },
    { name: "SoulCrystal", clusterWith: "chaos", color: "#880000", immobile: true, hitsfx: "Evil", tags: KDMapInit(["crystal", "soul", "minor", "unstoppable", "ranged", "crushweakness", "soulimmune", "flying"]), spellResist: 0.33, sneakThreshold: 0.01,
        evasion: -9, ignorechance: 1.0, armor: 2, followRange: 1, AI: "wander",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ff0000" }
        ],
        visionRadius: 100, maxhp: 20, minLevel: 0, weight: -99, movePoints: 99999, attackPoints: 4, attack: "MeleeWill", attackWidth: 2.5, attackRange: 3, power: 4, dmgType: "souldrain",
        terrainTags: { "passage": -999, "temple": 20, "open": 125 }, floors: KDMapInit(["tmp"]), shrines: ["Conjure"],
        dropTable: [{ name: "AncientPowerSourceSpent", weight: 9 }, { name: "AncientPowerSource", weight: 1 }] },
    { name: "SoulCrystalActive", clusterWith: "chaos", color: "#880000", immobile: true, hitsfx: "Evil", tags: KDMapInit(["crystal", "soul", "active", "unstoppable", "miniboss", "ranged", "crushweakness", "soulimmune", "flying"]), spellResist: 0.33,
        evasion: -9, ignorechance: 1.0, armor: 2, followRange: 1, AI: "wander",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 5.5, color: "#ff0000" }
        ],
        spells: ["SoulCrystalBind"], spellCooldownMult: 1, spellCooldownMod: 0, followLeashedOnly: true, stopToCast: true, castWhileMoving: true, sneakThreshold: 0.01,
        visionRadius: 100, maxhp: 20, minLevel: 0, weight: -99, movePoints: 99999, attackPoints: 4, attack: "SpellMeleeWill", attackWidth: 2.5, attackRange: 3, power: 4, dmgType: "souldrain",
        terrainTags: { "passage": -999, "temple": 10, "open": 115 }, floors: KDMapInit(["tmp"]), shrines: ["Conjure"],
        dropTable: [{ name: "AncientPowerSource", weight: 10 }] },
    { name: "ShadowHand", faction: "Ghost", clusterWith: "ghost", color: "#880044", tags: KDMapInit(["opendoors", "shadowHandEnemy", "shadowTrap", "ghost", "soulimmune", "fireweakness", "melee", "shadowimmune", "glueimmune", "chainimmune", "shadowHands", "poisonimmune", "meleeresist", "flying"]),
        ignorechance: 0, armor: 0, followRange: 1, AI: "huntshadow", noAlert: true, hitsfx: "Evil", ignoreflag: ["ShadowHand"], failAttackflag: ["ShadowHand"], failAttackflagDuration: 2,
        visionRadius: 10, blindSight: 4, evasion: 0.4, maxhp: 6, minLevel: 0, weight: -5, movePoints: 1, attackPoints: 2, attack: "MeleeWillBind", attackWidth: 1, attackRange: 1, power: 1.0, dmgType: "grope", fullBoundBonus: 4,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 0, color: "#880044" },
            { trigger: "beforeDamage", type: "shadowEngulf", power: 0, color: "#880044" },
            { trigger: "afterEnemyTick", type: "shadowDebuff", power: -0.5 },
        ],
        terrainTags: { "trap": 100 }, shrines: [], allFloors: true },
    { name: "ShadowGhast", faction: "Ghost", clusterWith: "ghost", color: "#880044", tags: KDMapInit(["opendoors", "shadowHandEnemy", "shadowTrap", "ghost", "soulimmune", "fireweakness", "melee", "shadowimmune", "glueimmune", "chainimmune", "shadowHands", "poisonimmune", "meleeresist", "flying"]),
        ignorechance: 0, armor: 0, followRange: 1, AI: "huntshadow", hitsfx: "Evil", ignoreflag: ["ShadowHand"], failAttackflag: ["ShadowHand"], failAttackflagDuration: 2,
        visionRadius: 10, blindSight: 5, evasion: 0.15, maxhp: 14, minLevel: 0, weight: -4, movePoints: 4, attackPoints: 3, attack: "SpellMeleeWillBindSlow", attackWidth: 1, attackRange: 3, power: 2.0, dmgType: "cold", fullBoundBonus: 2,
        projectileAttack: true,
        spells: ["SummonShadowHand"], spellCooldownMult: 2, spellCooldownMod: 0, castWhileMoving: true, followLeashedOnly: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 0, color: "#880044" },
            { trigger: "beforeDamage", type: "shadowEngulf", power: 0, color: "#880044" },
            { trigger: "afterEnemyTick", type: "shadowDebuff", power: -0.5 },
        ],
        terrainTags: { "shadowcreature": 20, "increasingWeight": 0.1, "trap": 10, "goddessRage": 1 }, shrines: [], allFloors: true,
        dropTable: [{ name: "Ectoplasm", weight: 1 }] },
    { name: "CorruptedAdventurer", faction: "Ghost", clusterWith: "ghost", bound: "CorruptedAdventurer", playLine: "Elemental", color: "#880044",
        tags: KDMapInit(["shadowHandEnemy", "ghost", "soulresist", "fireweakness", "melee", "shadowresist", "glueresist", "chainresist", "shadowHands"]),
        followRange: 1, ignoreflag: ["ShadowDommed"], failAttackflag: ["ShadowDommed"],
        spells: ["ShadowBolt"], spellCooldownMult: 1, spellCooldownMod: 0,
        AI: "huntshadow", visionRadius: 10, maxhp: 20, minLevel: 3, weight: -1, movePoints: 4, disarm: 0.33,
        events: [
            { trigger: "afterEnemyTick", type: "shadowDebuff", power: -0.5 },
            { trigger: "afterEnemyTick", type: "shadowDommeRefresh" },
            { trigger: "beforeDamage", type: "shadowDomme", power: 0, color: "#880044" },
        ],
        attackPoints: 4, attack: "MeleeBindWillSpell", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 3, dmgType: "cold", multiBind: 2,
        terrainTags: { "shadowcreature": 9, "increasingWeight": 0.1, "goddessRage": 3 }, shrines: [], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "Ectoplasm", weight: 10 }]
    },
    { name: "ChainBeing", clusterWith: "elemental", bound: "ChainBeing", playLine: "Elemental", color: "#c7a9fa",
        tags: KDMapInit(["construct", "soulresist", "fireweakness", "melee", "shadowresist", "glueresist", "chainimmune", "obsidianRestraints", "chainRestraintsMagic", "leashing"]),
        armor: 0, kite: 1.5, followRange: 3, AI: "hunt",
        spells: ["ObsidianBolt"], spellCooldownMult: 1, spellCooldownMod: 1, followLeashedOnly: true, stopToCast: true, spellRdy: true, projectileTargeting: true,
        visionRadius: 10, maxhp: 11, minLevel: 0, weight: -10, movePoints: 2,
        attackPoints: 4, attack: "MeleeBindLockSpell", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 2, dmgType: "soul", fullBoundBonus: 2.5,
        attackLock: "Purple",
        terrainTags: { "shadowcreature": 6, "increasingWeight": 0.1, "metalAnger": 10, "metalPleased": 10, }, shrines: ["Metal"], allFloors: true,
        events: [
            { trigger: "afterEnemyTick", type: "createEffectTile", kind: "Chains", time: 5, power: 1, chance: 0.5, aoe: 0.5 },
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Chains", aoe: 1.5, power: 1, chance: 1.0 },
        ],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }]
    },
    { name: "DemonStar", clusterWith: "demon", bound: "Demon", playLine: "Elemental", color: "#9ea7de",
        tags: KDMapInit(["opendoors", "order", "leashing", "demon", "melee", "miniboss", "mithrilRestraints", "electricresist", "fireresist", "coldresist", "soulweakness", "charmweakness", "jail", "jailer", "hunter"]),
        armor: 1, followRange: 0, AI: "hunt",
        spells: ["BoundByFate"], spellCooldownMult: 1, spellCooldownMod: 0, followLeashedOnly: true, stopToCast: true, spellRdy: true, projectileTargeting: true,
        visionRadius: 10, maxhp: 16, minLevel: 0, weight: -10, movePoints: 4,
        attackPoints: 3, attack: "MeleeBindLockSpell", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 4, dmgType: "cold", fullBoundBonus: 2,
        attackLock: "Purple",
        terrainTags: { "demon": 15, "increasingWeight": 0.1, "goddessRage": 10, "goddessPleased": 10, }, shrines: [], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 25, amountMax: 35, weight: 10 }]
    },
    { name: "DemonMoon", clusterWith: "demon", bound: "Demon", playLine: "Elemental", color: "#9ea7de",
        tags: KDMapInit(["opendoors", "order", "leashing", "demon", "melee", "miniboss", "mithrilRestraints", "electricresist", "fireresist", "coldresist", "soulweakness", "charmweakness", "jail", "jailer", "hunter"]),
        armor: 1, followRange: 0, AI: "hunt",
        spells: ["CrushingFate"], spellCooldownMult: 1, spellCooldownMod: 0, followLeashedOnly: true, stopToCast: true, spellRdy: true, projectileTargeting: true,
        visionRadius: 10, maxhp: 16, minLevel: 0, weight: -10, movePoints: 4,
        attackPoints: 3, attack: "MeleeBindLockSpell", attackWidth: 1, attackRange: 1, tilesMinRange: 1, power: 4, dmgType: "cold", fullBoundBonus: 2,
        attackLock: "Purple",
        terrainTags: { "demon": 15, "increasingWeight": 0.1, "goddessRage": 10, "goddessPleased": 10, }, shrines: [], allFloors: true,
        dropTable: [{ name: "Gold", amountMin: 25, amountMax: 35, weight: 10 }]
    },
    { name: "Gag", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["leatherTrap", "ropeTrap", "ignoregagged", "construct", "poisonresist", "soulimmune", "melee", "ballGagRestraints", "gagSpell", "minor", "chainresist", "doortrap", "flying"]),
        ignorechance: 0.75, followRange: 1, AI: "hunt", ignoreflag: ["FA_Gag"], failAttackflag: ["FA_Gag"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        specialCD: 8, specialAttack: "Dash", specialRemove: "BindSuicide", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 4.5, specialMinrange: 1.5, dashThrough: true, specialsfx: "Miss",
        visionRadius: 3, visionSummoned: 12, maxhp: 4, minLevel: 0, weight: 0, movePoints: 1, attackPoints: 2, attack: "MeleeBindSuicide", focusPlayer: true,
        suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "trap": 50, gag: -40 }, allFloors: true, shrines: [], summonTags: ["gag"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Belts", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "AnimLegbinder", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["leatherTrap", "ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "legbinderSpell", "minor", "chainresist", "doortrap", "flying"]),
        ignorechance: 0.75, followRange: 1, AI: "hunt", ignoreflag: ["FA_Legb"], failAttackflag: ["FA_Legb"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        visionRadius: 6, visionSummoned: 12, maxhp: 10, minLevel: 5, weight: 0, movePoints: 2, attackPoints: 3, attack: "MeleeBindSuicide", focusPlayer: true,
        suicideOnAdd: true, attackWidth: 3, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "trap": 30, legbinder: -25 }, allFloors: true, shrines: [], summonTags: ["legbinder"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Belts", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "AnimArmbinder", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["leatherTrap", "ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "armbinderSpell", "minor", "chainresist", "doortrap", "flying"]),
        ignorechance: 0.75, followRange: 1, AI: "hunt", ignoreflag: ["FA_Armb"], failAttackflag: ["FA_Armb"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        visionRadius: 6, visionSummoned: 12, maxhp: 8, minLevel: 3, weight: 0, movePoints: 1.5, attackPoints: 3, attack: "MeleeBindSuicide", focusPlayer: true,
        suicideOnAdd: true, attackWidth: 3, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "trap": 30, armbinder: -25 }, allFloors: true, shrines: [], summonTags: ["armbinder"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Belts", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "AnimHarness", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["leatherTrap", "ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "harnessSpell", "minor", "chainresist", "doortrap", "flying"]),
        ignorechance: 0.75, followRange: 1, AI: "hunt", ignoreflag: ["FA_Harness"], failAttackflag: ["FA_Harness"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        visionRadius: 6, visionSummoned: 12, maxhp: 6, minLevel: 0, weight: 0, movePoints: 1.5, attackPoints: 2, attack: "MeleeBindSuicide", focusPlayer: true,
        suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 2, dmgType: "crush", fullBoundBonus: 1,
        terrainTags: { "trap": 25, harness: -20 }, allFloors: true, shrines: [], summonTags: ["harness"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Belts", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "AnimBlindfold", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["leatherTrap", "ropeTrap", "ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "blindfoldSpell", "minor", "chainresist", "doortrap", "flying"]),
        ignorechance: 0.75, followRange: 1, AI: "hunt", ignoreflag: ["FA_BF"], failAttackflag: ["FA_BF"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        specialCD: 8, specialAttack: "Dash", specialRemove: "BindSuicide", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 4.5, specialMinrange: 1.5, dashThrough: true, specialsfx: "Miss",
        visionRadius: 9, visionSummoned: 12, maxhp: 4, minLevel: 4, weight: 0, movePoints: 1, attackPoints: 2, attack: "MeleeBindSuicide", focusPlayer: true,
        suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "trap": 25, blindfold: -20 }, allFloors: true, shrines: [], summonTags: ["blindfold"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Belts", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "AnimStraitjacket", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["leatherTrap", "ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "jacketSpell", "minor", "chainresist", "doortrap", "flying"]),
        ignorechance: 0.75, followRange: 1, AI: "hunt", ignoreflag: ["FA_Jacket"], failAttackflag: ["FA_Jacket"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        visionRadius: 9, visionSummoned: 12, maxhp: 12, minLevel: 7, weight: 0, movePoints: 1.5, attackPoints: 3, attack: "MeleeBindSuicide", focusPlayer: true,
        suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "trap": 20, "leatherRage": 5, jacket: -20 }, allFloors: true, shrines: [], summonTags: ["jacket"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Belts", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "Cuffs", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["metalTrap", "doortrap", "ignoreharmless", "construct", "poisonimmune", "soulimmune", "melee", "cuffsSpell", "minor", "chainresist", "meleeresist", "glueweakness", "iceweakness", "flying"]), ignorechance: 0.75,
        armor: 1, followRange: 1, AI: "hunt", ignoreflag: ["FA_Cuffs"], failAttackflag: ["FA_Cuffs"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        specialCD: 8, specialAttack: "Dash", specialRemove: "BindSuicide", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 4.5, specialMinrange: 1.5, dashThrough: true, specialsfx: "Miss",
        visionRadius: 4, visionSummoned: 12, maxhp: 2, minLevel: 0, weight: 0, movePoints: 1, attackPoints: 2, attack: "MeleeBindSuicide", suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "charm", fullBoundBonus: 1,
        terrainTags: { "doortrap": 6, "trap": 50, cuffs: -40 }, allFloors: true, shrines: ["Metal"], summonTags: ["cuffs"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Chains", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "AnimChastity", arousalMode: true, faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["metalTrap", "ignoreharmless", "doortrap", "construct", "poisonimmune", "soulimmune", "melee", "chastitySpell", "minor", "chainresist", "meleeresist", "glueweakness", "iceweakness", "flying"]), ignorechance: 0.75,
        armor: 2, followRange: 1, AI: "hunt", ignoreflag: ["FA_Chastity"], failAttackflag: ["FA_Chastity"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        visionRadius: 6, visionSummoned: 12, maxhp: 5, minLevel: 2, weight: 0, movePoints: 1.5, attackPoints: 3, attack: "MeleeBindSuicide", suicideOnAdd: true, attackWidth: 3, attackRange: 1, power: 2, dmgType: "charm", fullBoundBonus: 1,
        terrainTags: { "doortrap": 6, "trap": 35, chastity: -25 }, allFloors: true, shrines: ["Metal"], summonTagsMulti: ["chastity"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Chains", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "AnimYoke", arousalMode: true, faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["metalTrap", "ignoreharmless", "doortrap", "construct", "poisonimmune", "soulimmune", "melee", "yokeSpell", "minor", "chainresist", "meleeresist", "glueweakness", "iceweakness", "flying"]), ignorechance: 0.75,
        armor: 2, followRange: 1, AI: "hunt", ignoreflag: ["FA_Yoke"], failAttackflag: ["FA_Yoke"], squeeze: true, ignoreStaminaForBinds: true,
        Attack: {
            mustBindorFail: true,
        },
        visionRadius: 6, visionSummoned: 12, maxhp: 5, minLevel: 4, weight: 0, movePoints: 1.5, attackPoints: 3, attack: "MeleeBindSuicide", suicideOnAdd: true, attackWidth: 3, attackRange: 1, power: 2, dmgType: "charm", fullBoundBonus: 1,
        terrainTags: { "doortrap": 6, "trap": 35, yoke: -30 }, allFloors: true, shrines: ["Metal"], summonTags: ["yoke"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Chains", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "Lock", faction: "KinkyConstruct", clusterWith: "construct", color: "#bbbbbb", tags: KDMapInit(["metalTrap", "leatherTrap", "ignorenoSP", "lock", "construct", "poisonimmune", "soulimmune", "melee", "minor", "chainresist", "meleeresist", "glueweakness", "iceweakness", "doortrap", "flying"]), difficulty: 0.2,
        ignorechance: 0.75, armor: 1, followRange: 1, AI: "hunt", ignoreflag: ["FA_Lock"], failAttackflag: ["FA_Lock"], squeeze: true, suicideOnLock: true,
        Attack: {
            mustBindorFail: true,
        },
        specialCD: 8, specialAttack: "MeleeDash", specialRemove: "SuicideMeleeBindLockWill", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 4.5, specialMinrange: 1.5, dashThrough: true, specialsfx: "Miss",
        visionRadius: 3, visionSummoned: 12, maxhp: 4, minLevel: 2, weight: 0, movePoints: 1, attackPoints: 3, attack: "SuicideMeleeBindLockWill", attackWidth: 3, tilesMinRange: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "secondhalf": 1, "lastthird": 1, "doortrap": 5, "trap": 100 }, allFloors: true, shrines: ["Metal"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Chains", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "Feathers", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["ignorenoSP", "construct", "poisonresist", "soulimmune", "melee", "chainRestraints", "minor", "firesevereweakness", "meleeresist", "doortrap", "flying"]), ignorechance: 0.75, armor: -1, followRange: 1, AI: "hunt", ignoreflag: ["feathers"], failAttackflag: ["feathers"], squeeze: true,
        visionRadius: 5, visionSummoned: 12, maxhp: 3, minLevel: 0, weight: -2, movePoints: 2, attackPoints: 2, attack: "MeleeWill", attackWidth: 3, tilesMinRange: 1, attackRange: 1, power: 1, dmgType: "tickle", ondeath: [{ type: "spellOnSelf", spell: "Feathers" }],
        terrainTags: { "secondhalf": 2, "lastthird": -1, "increasingLevel": -1.5, "doortrap": 8 }, allFloors: true, shrines: [], difficulty: 0.7, hitsfx: "Tickle", },
    { name: "Scarves", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "scarfRestraints", "minor", "firesevereweakness", "acidweakness", "slashweakness", "meleeresist", "doortrap"]), ignorechance: 0.75, armor: 0, followRange: 1, AI: "hunt", ignoreflag: ["scarves"], failAttackflag: ["scarves"], squeeze: true,
        visionRadius: 3, visionSummoned: 12, maxhp: 1, minLevel: 0, maxLevel: 3, weight: 1, movePoints: 1.5, attackPoints: 2, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 1, dmgType: "tickle", fullBoundBonus: 1,
        Attack: {
            mustBindorFail: true,
        },
        terrainTags: { "secondhalf": -1, "lastthird": -2, "increasingLevel": -2, "doortrap": 6, "ribbon": 3 }, allFloors: true, shrines: [], difficulty: 0.4 },
    { name: "Ribbons", faction: "KinkyConstruct", color: "#f135a4", clusterWith: "dressmaker", tags: KDMapInit(["ropeTrap", "ignoreharmless", "construct", "poisonresist", "ribbon", "soulimmune", "melee", "magicRibbons", "minor", "fireweakness", "acidweakness", "slashweakness", "meleeresist", "doortrap", "flying"]), ignorechance: 0.75, armor: 0, followRange: 1, AI: "hunt", ignoreflag: ["ribbons"], failAttackflag: ["ribbons"], squeeze: true,
        visionRadius: 5, visionSummoned: 12, maxhp: 6, minLevel: 0, weight: 0, movePoints: 1.25, attackPoints: 3, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 1, dmgType: "chain", fullBoundBonus: 1,
        Attack: {
            mustBindorFail: true,
        },
        terrainTags: { "dressmaker": 7, "conjureAnger": 4, "ribbon": 3 }, allFloors: true, shrines: ["Conjure", "Rope"], difficulty: 0.2, ondeath: [{ type: "spellOnSelf", spell: "RibbonBurst" }] },
    { name: "RopeSnake", faction: "KinkyConstruct", clusterWith: "construct", color: "#ffae70", tags: KDMapInit(["ropeTrap", "ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "ropeRestraints", "minor", "fireweakness", "slashweakness", "chainresist", "doortrap"]), ignorechance: 0.75, followRange: 1, AI: "wander", squeeze: true,
        ignoreflag: ["ropesnake"], failAttackflag: ["ropesnake"],
        Attack: {
            mustBindorFail: true,
        },
        visionRadius: 3, maxhp: 4, minLevel: 0, weight: 3, movePoints: 1.5, attackPoints: 3, attack: "MeleeBindSuicideWill", suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "increasingWeight": -3, "trap": 40 }, allFloors: true, shrines: ["Rope"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Ropes", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "UnforseenRope", faction: "KinkyConstruct", clusterWith: "construct", color: "#ffae70", tags: KDMapInit(["ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "ropeRestraints", "ropeRestraints2", "minor", "fireweakness", "slashweakness", "chainresist", "search"]), ignorechance: 0.75, followRange: 1, AI: "hunt", stealth: 2.5, squeeze: true,
        ignoreflag: ["ropesnake"], failAttackflag: ["ropesnake"],
        visionRadius: 10, blindSight: 8, maxhp: 4, minLevel: 0, weight: 0, movePoints: 1, attackPoints: 2, attack: "MeleeBindSuicideWill", suicideOnAdd: true, attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 1, "lastthird": 3, "trap": 20 }, allFloors: true, shrines: ["Rope"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Ropes", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "LearnedRope", faction: "KinkyConstruct", clusterWith: "construct", color: "#ffae70", tags: KDMapInit(["ignoreharmless", "construct", "poisonresist", "soulimmune", "melee", "ropeRestraints", "ropeRestraints2", "fireweakness", "slashweakness", "chainresist", "search"]), ignorechance: 0.75, followRange: 1, AI: "hunt", squeeze: true, disarm: 0.5,
        ignoreflag: ["ropesnake"], failAttackflag: ["ropesnake"],
        Attack: {
            mustBindorFail: true,
        },
        specialCD: 8, specialAttack: "Dash", specialRemove: "BindSuicide", specialCDonAttack: true, specialAttackPoints: 1, specialRange: 4.5, specialMinrange: 1.5, dashThrough: true, specialsfx: "Miss",
        visionRadius: 5, maxhp: 8, minLevel: 2, weight: 1, movePoints: 1, attackPoints: 3, attack: "MeleeBindSuicideWill", suicideOnAdd: true, attackWidth: 1, attackRange: 2.5, power: 2, multiBind: 2, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "trap": 30 }, allFloors: true, shrines: ["Rope"],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Ropes", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "MonsterRope", faction: "KinkyConstruct", clusterWith: "construct", color: "#ffae70", tags: KDMapInit(["ropeTrap", "ignoreharmless", "doortrap", "construct", "poisonresist", "soulimmune", "melee", "unstoppable", "ropeRestraintsHogtie", "ropeRestraints", "ropeRestraints2", "elite", "fireweakness", "slashweakness", "chainresist", "hunter"]), ignorechance: 0.75, followRange: 1, AI: "guard",
        ignoreflag: ["ropesnake"], failAttackflag: ["ropesnake"], disarm: 0.5, ignoreStaminaForBinds: true,
        visionRadius: 6, maxhp: 20, minLevel: 3, weight: 0, movePoints: 3, attackPoints: 3, attack: "MeleeBindSuicideWill", suicideOnAdd: true, attackWidth: 3, attackRange: 1, power: 5, multiBind: 6, dmgType: "grope", fullBoundBonus: 6,
        terrainTags: { "secondhalf": 1, "lastthird": 4, "increasingWeight": 2, "trap": 20 }, allFloors: true, shrines: ["Rope"],
        ondeath: [
            { type: "summon", enemy: "RopeSnake", range: 2.5, count: 3, strict: true, lifetime: 30 },
            { type: "summon", enemy: "LearnedRope", range: 2.5, count: 1, strict: true, lifetime: 30 },
        ],
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Ropes", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "ElementalRope", faction: "Elemental", playLine: "Elemental", clusterWith: "elemental", bound: "ElementalRope", squeeze: true, color: "#ffae70",
        tags: KDMapInit(["opendoors", "elemental", "rope", "slashweakness", "melee", "chainresist", "coldweakness", "pierceresist", "crushresist", "jail", "jailer", "unarmedresist", "fireweakness", "ropeRestraints", "ropeRestraints2", "ballGagRestraints", "leashing", "search", "doortrap"]),
        armor: 0, followRange: 1, AI: "hunt",
        visionRadius: 6, maxhp: 15, minLevel: 3, weight: -2, movePoints: 1.5, attackPoints: 3, attack: "MeleeBind", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 2.5, dmgType: "crush", fullBoundBonus: 2.5,
        terrainTags: { "secondhalf": 2, "thirdhalf": 1, "ropeAnger": 4, "ropeRage": 4, "temple": 8, "doortrap": 4, "elemental": 3, "witch": 5, "rope": 4 }, allFloors: true, shrines: ["Rope", "Elements"],
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10, noSummon: true }, { name: "Knife", ignoreInInventory: true, weight: 3, noSummon: true }],
        events: [
            { trigger: "afterEnemyTick", type: "createEffectTile", kind: "Ropes", time: 5, power: 1, chance: 0.5, aoe: 0.5 },
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Ropes", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "ElementalLeather", faction: "Elemental", playLine: "Elemental", clusterWith: "elemental", bound: "ElementalLeather", squeeze: true, color: "#9999a0",
        tags: KDMapInit(["opendoors", "elemental", "leather", "melee", "chainresist", "crushresist", "jail", "jailer", "leatherRestraints", "leatherRestraintsHeavy", "ballGagRestraints", "leashing", "search", "doortrap"]),
        armor: 2, followRange: 1, AI: "hunt", guardChance: 0.6, kite: 1.5,
        visionRadius: 6, maxhp: 12, minLevel: 2, weight: -2, movePoints: 1.5, attackPoints: 3, attack: "MeleeBindLock", attackWidth: 1, attackRange: 2.5, tilesMinRange: 1, power: 2.5, dmgType: "pain", fullBoundBonus: 2.5, projectileTargeting: true,
        terrainTags: { "secondhalf": 2, "thirdhalf": 1, "leatherAnger": 4, "leatherRage": 4, "temple": 8, "doortrap": 5, "elemental": 3, "witch": 5, "leather": 4 }, allFloors: true, shrines: ["Leather", "Elements"],
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 10, noSummon: true }, { name: "EarthRune", weight: 2, noSummon: true }],
        events: [
            { trigger: "afterEnemyTick", type: "createEffectTile", kind: "Belts", time: 5, power: 1, chance: 0.5, aoe: 0.5 },
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "Belts", aoe: 1.5, power: 1, chance: 1.0 },
        ],
    },
    { name: "RopeKraken", faction: "KinkyConstruct", clusterWith: "construct", tags: KDMapInit(["construct", "poisonresist", "soulimmune", "melee", "boss", "elite", "unflinching", "fireweakness", "slashweakness", "chainresist", "hunter"]),
        Awareness: {
            chaseradius: 15,
        },
        ignorechance: 0.75, followRange: 1, AI: "hunt", summon: [{ enemy: "RopeMinion", range: 2.5, count: 4, strict: true }],
        spells: ["RopeEngulf", "SummonRopeTentacle"], spellCooldownMult: 1, spellCooldownMod: 0, ignoreflag: ["kraken"], disarm: 0.25,
        visionRadius: 9, maxhp: 60, minLevel: 3, weight: -31, movePoints: 4, attackPoints: 2, attack: "Spell", attackWidth: 1, attackRange: 1, power: 6, dmgType: "chain",
        terrainTags: { "secondhalf": 12, "lastthird": 5, "boss": -80, "open": 20, "passage": -60, "ropeAnger": 20, "ropeRage": 40, "increasingWeight": 0.5 }, allFloors: true, shrines: ["Rope"],
        events: [
            { trigger: "passout", type: "delete", chance: 1.0 },
            { trigger: "spellCast", type: "ropeKrakenSummonTentacle" },
        ],
        dropTable: [{ name: "Scissors", ignoreInInventory: true, weight: 2 }, { name: "Knife", ignoreInInventory: true, weight: 5 }, { name: "EnchKnife", ignoreInInventory: true, weight: 2 }, { name: "ElfCrystal", weight: 3 }] },
    { name: "RopeMinion", faction: "KinkyConstruct", tags: KDMapInit(["construct", "poisonresist", "soulimmune", "melee", "fireweakness", "minor", "slashweakness", "chainresist", "krakententacle"]), ignorechance: 0.75, followRange: 1, AI: "hunt", master: { type: "RopeKraken", range: 4 }, ignoreflag: ["kraken"], dependent: true,
        visionRadius: 10,
        Awareness: {
            chaseradius: 15,
        },
        maxhp: 8, minLevel: 0, weight: -1000, movePoints: 1.5, attackPoints: 2, attack: "MeleePullWill", attackWidth: 1, attackRange: 1, power: 3, dmgType: "crush", noAlert: true,
        terrainTags: {}, allFloors: true, shrines: ["Rope"] },
    { name: "SarcoKraken", faction: "KinkyConstruct", clusterWith: "construct", color: "#3b7d4f", tags: KDMapInit(["construct", "poisonresist", "soulimmune", "melee", "boss", "elite", "unflinching", "fireresist", "crushweakness", "chainweakness", "glueweakness", "hunter"]),
        armor: 2.5, spellResist: 1.5,
        ignorechance: 0.75, followRange: 1, AI: "hunt", summon: [{ enemy: "SarcoMinion", range: 2.5, count: 3, strict: true }],
        spells: ["SarcoHex", "SummonSarcoTentacle"], spellCooldownMult: 1, spellCooldownMod: 0, ignoreflag: ["kraken"],
        events: [
            { trigger: "spellCast", type: "sarcoKrakenSummonTentacle" },
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "FabricGreen", aoe: 1.5, power: 1, chance: 1.0, duration: 20 },
        ],
        visionRadius: 10, maxhp: 40, minLevel: 0, weight: -11, movePoints: 4, attackPoints: 3, attack: "SpellMeleePull", attackWidth: 1.5, attackMinRange: 1.5, attackRange: 6, power: 4, pullDist: 4, pullTowardSelf: true, dmgType: "charm",
        terrainTags: { "secondhalf": 16, "lastthird": 5, "boss": -80, "open": 20, "passage": -60, "increasingWeight": 1 }, floors: KDMapInit(["tmb"]), shrines: [],
        dropTable: [{ name: "Gold", amountMin: 40, amountMax: 50, weight: 12 }],
    },
    { name: "SarcoMinion", faction: "KinkyConstruct", color: "#99ff99", tags: KDMapInit(["construct", "poisonresist", "soulimmune", "melee", "fireweakness", "minor", "slashweakness", "chainresist", "sarcotentacle", "mummyRestraints"]),
        ignorechance: 0.75, followRange: 1, AI: "hunt", master: { type: "SarcoKraken", range: 7 }, ignoreflag: ["kraken"], dependent: true, suicideOnAdd: true,
        visionRadius: 10, maxhp: 5, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 2, attack: "MeleeBindSuicide", attackWidth: 1, attackRange: 1, power: 2, fullBoundBonus: 2, dmgType: "chain", noAlert: true,
        events: [
            { trigger: "afterDamageEnemy", type: "bleedEffectTile", kind: "FabricGreen", aoe: 1.5, power: 1, chance: 1.0, duration: 20 },
        ],
        terrainTags: {}, allFloors: true, shrines: ["Rope"] },
    { name: "Dollsmith", faction: "Enemy", clusterWith: "smithdoll", bound: "FactoryDoll", playLine: "Robot", color: "#ff3388",
        tags: KDMapInit(["leashing", "dollsmith", "doll", "opendoors", "closedoors", "jail", "jailer", "melee", "elite", "glueresist", "crushresist", "electricresist", "handcuffer", "iceweakness", "blacksteelrestraints", "blacksteelcuffs", "teasetoys"]),
        spellResist: 1.0,
        followLeashedOnly: true, followRange: 1,
        spells: ["RubberBolt"], spellCooldownMult: 2, spellCooldownMod: 0,
        Security: {
            level_key: 3,
            level_tech: 1,
        },
        Behavior: {
            thorough: 0.6,
            ensurePlayerTagArousal: ["ChastityUpper", "ChastityLower"],
        },
        RestraintFilter: {
            bonusRestraints: 2,
            requiredItems: ["BlacksteelBelt", "BlacksteelBra"],
        },
        summon: [{ enemy: "DollsmithDoll", range: 2.5, count: 1, strict: true }, { enemy: "DollsmithDoll", range: 2.5, count: 1, chance: 0.5, strict: true }],
        specialCD: 6, specialAttack: "WillBind", specialRemove: "Lock", specialExtraTags: ["redLatexBasic"], specialRemoveTags: ["blacksteelrestraints", "blacksteelcuffs", "leashing", "teasetoys"],
        specialAttackPoints: 2, specialWidth: 3, specialMsg: true, specialCondition: "canRestrainWithExtra", specialCDonAttack: true, specialIgnoreStam: true,
        attackLock: "Red",
        AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 14, minLevel: 3, weight: 15, movePoints: 2,
        attackPoints: 2, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1.5,
        terrainTags: { "increasingWeight": 1, "dollsmith": 5 }, floors: KDMapInit(["bel"]), shrines: ["Metal", "Latex"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }] },
    { name: "Dollmaker", faction: "Enemy", clusterWith: "smithdoll", bound: "FactoryDoll", playLine: "Robot", color: "#ff88ff",
        tags: KDMapInit(["leashing", "dollsmith", "doll", "opendoors", "closedoors", "jail", "jailer", "ranged", "miniboss",
            "glueresist", "electricresist", "crushresist", "iceweakness", "blacksteelchastity", "latexEncase", "teasetoys"]),
        spellResist: 1.5,
        followLeashedOnly: true, followRange: 1.5, dontKiteWhenDisabled: true, kite: 4.5, noKiteWhenHarmless: true,
        spells: ["RubberBolt", "EncaseBolt", "DollConvert", "DollBoost", "EnemyCM1"],
        unlockCommandLevel: 2, unlockCommandCD: 30, spellCooldownMult: 1, spellCooldownMod: -1, buffallies: true, projectileTargeting: true, bypass: true,
        Security: {
            level_key: 3,
            level_tech: 1,
        },
        Behavior: {
            thorough: 0.6,
            ensurePlayerTagArousal: ["ChastityUpper", "ChastityLower"],
        },
        RestraintFilter: {
            bonusRestraints: 2,
            requiredItems: ["BlacksteelBelt", "BlacksteelBra"],
        },
        useLock: "Purple",
        specialAttack: "WillBind", specialCD: 5, specialExtraTags: ["redLatexBasic"], specialRemoveTags: ["blacksteelchastity", "latexEncase", "leashing", "teasetoys"],
        specialAttackPoints: 2, specialWidth: 3, specialMsg: true, specialCondition: "canRestrainWithExtra", specialCDonAttack: true, specialIgnoreStam: true,
        AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 14, minLevel: 5, weight: 10, movePoints: 2.4,
        attackPoints: 3, attack: "SpellMeleeBindWill", attackWidth: 1, attackRange: 1, power: 4, dmgType: "glue",
        terrainTags: { "increasingWeight": 1, "dollsmith": 5, "latexOptout": -9 }, floors: KDMapInit(["bel"]), shrines: ["Metal", "Latex"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }, { name: "StaffDoll", ignoreInInventory: true, weight: 100 },] },
    { name: "DollsmithDoll", faction: "Enemy", clusterWith: "dollsmith", bound: "EncasedFactoryDoll", playLine: "Gagged", color: "#ff3388",
        tags: KDMapInit(["opendoors", "doll", "smithdoll", "submissive", "noshop", "gagged", "alwaysAlert", "imprisonable", "minor", "ignorenoSP", "melee",
            "glueresist", "electricresist", "ticklesevereweakness", "chainresist", "charmweakness", "crushresist"]),
        ignorechance: 0, armor: 0, spellResist: 1.0, followRange: 2, AI: "hunt", cohesion: 0.9,
        master: { type: "Dollsmith", range: 2.5, loose: true, aggressive: true },
        sneakThreshold: 1, difficulty: 0.05,
        ignoreflag: ["dollSmithDoll"], failAttackflag: ["dollSmithDoll"],
        visionRadius: 7.5, maxhp: 8, minLevel: 0, weight: -2, movePoints: 1.5,
        attackPoints: 3, attack: "MeleeWillSlow", attackWidth: 3, attackRange: 1, power: 2, dmgType: "charm",
        terrainTags: { "latexAnger": 3, "latexRage": 3, "metalAnger": 3, "metalRage": 3, "smithdoll": 40 },
        shrines: ["Metal"], floors: KDMapInit(["bel"]) },
    { name: "Rat", faction: "Beast", tags: KDMapInit(["ignorenoSP", "beast", "darkvision", "melee", "minor"]), followRange: 1, AI: "guard", squeeze: true,
        visionRadius: 4, maxhp: 1, evasion: 0.5, minLevel: 0, weight: 8, movePoints: 1.5, attackPoints: 2, attack: "MeleeWill", attackWidth: 1, attackRange: 1, power: 1, dmgType: "pain",
        terrainTags: { "rubble": 20, "increasingWeight": -5 }, floors: KDMapInit(["grv"]) },
    { name: "Bat", faction: "Beast", tags: KDMapInit(["ignorenoSP", "beast", "darkvision", "melee", "minor", "chainresist", "flying"]), followRange: 1, AI: "guard", squeeze: true, ethereal: true,
        visionRadius: 4, maxhp: 1, evasion: 0.5, minLevel: 0, weight: 4, movePoints: 1, attackPoints: 1, attack: "MeleeWill", attackWidth: 1, attackRange: 1, power: 1, dmgType: "pain",
        terrainTags: { "rubble": 20, "increasingWeight": -5 }, floors: KDMapInit(["jng"]) },
    { name: "Apprentice", faction: "Apprentice", color: "#9563ff", spellWhileParole: true, bound: "Apprentice", playLine: "Apprentice",
        tags: KDMapInit(["leashing", "opendoors", "binding", "human", "closedoors", "apprentice", "ropeRestraints", "ranged", "glueweakness", "chainweakness", "tickleweakness", "search"]), followRange: 2,
        castWhileMoving: true, spells: ["RopeEngulfWeak", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, stopToCast: true, spellRdy: true, kite: 1.5, kiteChance: 0.9, cohesion: 1.0, followLeashedOnly: true,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 5, maxhp: 8, minLevel: 2, weight: 10, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 3, "lastthird": 3, "increasingWeight": -1, "apprentice": 4, "rope": 4, "magical": 4 }, allFloors: true, shrines: ["Elements"],
        dropTable: [{ name: "RedKey", weight: 1 }, { name: "Nothing", weight: 29 }] },
    { name: "Apprentice2", faction: "Apprentice", color: "#ff1616", bound: "Apprentice2", playLine: "Apprentice",
        tags: KDMapInit(["leashing", "opendoors", "binding", "human", "conjurer", "latexRestraints", "ropeRestraints", "closedoors", "apprentice", "ranged", "glueweakness", "chainweakness", "tickleweakness", "search"]), followRange: 2,
        castWhileMoving: true, spells: ["SummonSingleTickleHand", "SummonEnemyGag", "SummonLock", "SummonCuff", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, stopToCast: true, spellRdy: true, kite: 1.5, kiteChance: 0.9, cohesion: 1.0, followLeashedOnly: true,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 5, maxhp: 8, minLevel: 2, weight: 6, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 3, "lastthird": 3, "increasingWeight": -1, "apprentice": 4, "conjure": 4, "magical": 4 }, allFloors: true, shrines: ["Conjure"],
        dropTable: [{ name: "RedKey", weight: 1 }, { name: "Nothing", weight: 29 }] },
    { name: "ApprenticeSlime", faction: "Apprentice", color: "#FF00FF", bound: "ApprenticeSlime", playLine: "Apprentice", tags: KDMapInit(["leashing", "opendoors", "binding", "human", "conjurer", "latexRestraints", "closedoors", "apprentice", "ranged", "glueweakness", "chainweakness", "tickleweakness", "search"]), followRange: 2,
        castWhileMoving: true, spells: ["SlimePuddle", "ManySlimes", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, stopToCast: true, spellRdy: true, kite: 1.5, kiteChance: 0.9, cohesion: 1.0, followLeashedOnly: true,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 5, maxhp: 8, minLevel: 2, weight: 8, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 3, "lastthird": 3, "increasingWeight": -1, "apprentice": 4, "slime": 4, "magical": 4 }, allFloors: true, shrines: ["Latex"],
        dropTable: [{ name: "RedKey", weight: 1 }, { name: "Nothing", weight: 29 }] },
    { name: "WitchRope", faction: "Witch", clusterWith: "apprentice", bound: "Witch", playLine: "Witch", tags: KDMapInit(["leashing", "guardCall", "jail", "jailer", "opendoors", "ropeRestraints", "closedoors", "human", "witch", "ranged", "elite", "hunter"]), followRange: 2,
        castWhileMoving: true, spells: ["WitchRope", "RopeEngulfWeak", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 30, stopToCast: true, spellRdy: true, kite: 1.5, kiteChance: 0.9,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 10, minLevel: 0, weight: 4, movePoints: 3, attackPoints: 2, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "lastthird": 2, "increasingWeight": -1, "ropeAnger": 6, "tech": -6, "rope": 6 }, allFloors: true, shrines: ["Rope"], followLeashedOnly: true,
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 15, weight: 14, noSummon: true }] },
    { name: "WitchFlame", faction: "Witch", clusterWith: "elemental", bound: "WitchFlame", playLine: "Witch", color: "#d30000", tags: KDMapInit(["leashing", "guardCall", "jail", "jailer", "opendoors", "handcuffer", "fire", "closedoors", "human", "witch", "ranged", "elite", "unflinching", "fireimmune", "acidweakness", "iceweakness", "hunter"]), followRange: 2,
        castWhileMoving: true, spells: ["HeatBolt", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 30, stopToCast: true, spellRdy: true, kite: 1.5, kiteChance: 0.9,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 11, minLevel: 0, weight: 2, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "lastthird": 2, "elementsAnger": 6, "tech": -6, "fire": 4 }, allFloors: true, shrines: [], followLeashedOnly: true,
        events: [{ trigger: "getLights", type: "enemyTorch", power: 3.5, color: "#ff8933" }],
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }],
    },
    { name: "WitchIce", faction: "Witch", clusterWith: "elemental", bound: "WitchIce", playLine: "Witch", color: "#73efe8", tags: KDMapInit(["leashing", "guardCall", "jail", "jailer", "opendoors", "handcuffer", "ice", "closedoors", "human", "witch", "ranged", "elite", "unflinching", "crushweakness", "fireweakness", "acidresist", "iceresist", "stunresist", "slashresist", "hunter"]), followRange: 2,
        castWhileMoving: true, spells: ["WitchIcebolt", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 30, stopToCast: true, spellRdy: true, kite: 1.5, kiteChance: 0.9,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 11, minLevel: 2, weight: 2, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "lastthird": 2, "elementsAnger": 6, "tech": -6, "ice": 6, "water": 2 }, allFloors: true, shrines: [], followLeashedOnly: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }],
    },
    { name: "WitchEarth", faction: "Witch", clusterWith: "elemental", bound: "WitchEarth", playLine: "Witch", color: "#f8c53a", tags: KDMapInit(["leashing", "guardCall", "jail", "jailer", "opendoors", "handcuffer", "ice", "closedoors", "human", "witch", "ranged", "elite", "unflinching", "crushweakness", "acidweakness", "iceweakness", "fireresist", "hunter", "slashresist", "pierceresist", "shackleRestraints"]), followRange: 1,
        castWhileMoving: true, spells: ["WitchBoulder", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 30, stopToCast: true, spellRdy: true,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.7, visionRadius: 7, maxhp: 14, minLevel: 2, weight: 2, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "lastthird": 2, "elementsAnger": 6, "tech": -6, "earth": 4 }, allFloors: true, shrines: [], followLeashedOnly: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }],
    },
    { name: "WitchWater", faction: "Witch", clusterWith: "elemental", bound: "WitchWater", playLine: "Witch", color: "#4572e3", tags: KDMapInit(["leashing", "guardCall", "jailer", "opendoors", "handcuffer", "ice", "closedoors", "human", "witch", "ranged", "elite", "unflinching", "fireresist", "acidimmune", "electricweakness", "pierceresist", "hunter", "latexRestraints"]), followRange: 1,
        castWhileMoving: true, spells: ["WitchWaterBall", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 30, stopToCast: true, spellRdy: true, evasion: 0.25,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 11, minLevel: 0, weight: 2, movePoints: 3, attackPoints: 4, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 1, "lastthird": 2, "elementsAnger": 6, "tech": -6, "water": 6, "ice": 2 }, allFloors: true, shrines: [], followLeashedOnly: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }],
    },
    { name: "WitchShock", faction: "Witch", clusterWith: "apprentice", bound: "Witch", playLine: "Witch", tags: KDMapInit(["leashing", "opendoors", "handcuffer", "electric", "jail", "jailer", "closedoors", "human", "witch", "ranged", "miniboss", "unflinching", "electricimmune", "glueweakness", "iceweakness", "hunter"]), followRange: 2,
        castWhileMoving: true, spells: ["WitchElectrify", "WitchElectricOrb", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 12, stopToCast: true, spellRdy: true, kite: 1.5, kiteChance: 0.9,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 15, minLevel: 3, weight: 2, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 3,
        terrainTags: { "secondhalf": 2, "lastthird": 1, "tech": -10, "electric": 6 }, allFloors: true, shrines: [], followLeashedOnly: true,
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }],
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#8888ff" },
            { trigger: "afterEnemyTick", type: "electrifyLocal", power: 1, chance: 0.5, aoe: 1.5 }
        ],
    },
    { name: "WitchMagnet", faction: "Witch", color: "#92e8c0", clusterWith: "apprentice", bound: "Witch", playLine: "Witch", tags: KDMapInit(["leashing", "opendoors", "magnetCuffs", "electric", "jailer", "closedoors", "human", "witch", "ranged", "miniboss", "unflinching", "electricimmune", "glueweakness", "iceweakness", "hunter"]),
        castWhileMoving: true, spells: ["AreaElectrify", "WitchElectricOrb", "EnemyCM1"], unlockCommandLevel: 2, unlockCommandCD: 10, stopToCast: true, spellRdy: true, followRange: 1,
        spellCooldownMult: 1, spellCooldownMod: -1, AI: "hunt", guardChance: 0.6, visionRadius: 8, maxhp: 24, minLevel: 12, weight: 1, movePoints: 2, attackPoints: 2, attack: "SpellMeleeBindLock",
        attackWidth: 1, attackRange: 1, power: 1, dmgType: "electric", fullBoundBonus: 1, noLeashUnlessExhausted: true,
        terrainTags: { "lastthird": 1, "miniboss": -10, "tech": -10, "metalAnger": 4, "elementsAnger": 6, "increasingWeight": 0.5, "electric": 6 }, allFloors: true, shrines: [], followLeashedOnly: true,
        dropTable: [{ name: "BlueKey", weight: 3 }, { name: "ScrollArms", weight: 1 }, { name: "ScrollVerbal", weight: 1 }, { name: "ScrollLegs", weight: 1 }],
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#8888ff" },
            { trigger: "afterEnemyTick", type: "electrifyLocal", power: 1, aoe: 1.5 },
        ],
    },
    { name: "WitchChain", faction: "Witch", clusterWith: "bandit", bound: "WitchChain", playLine: "Witch", color: "#AAAAAA", tags: KDMapInit(["leashing", "opendoors", "closedoors", "jail", "jailer", "chainRestraints", "human", "witch", "melee", "miniboss", "unflinching", "electricweakness", "crushweakness", "meleeresist", "fireweakness", "hunter"]),
        followRange: 1, spells: ["WitchChainBolt", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 12, spellRdy: true,
        spellCooldownMult: 2, spellCooldownMod: 2, AI: "hunt", guardChance: 0.6, visionRadius: 6, maxhp: 20, minLevel: 3, weight: 2, movePoints: 3, disarm: 0.33,
        attackPoints: 3, attack: "MeleeLockAllBindSpell", attackWidth: 2.5, attackRange: 1, tilesMinRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 3, multiBind: 2, attackLock: "Red",
        terrainTags: { "secondhalf": 3, "lastthird": 3, "tech": -10, "metal": 6 }, allFloors: true, shrines: [],
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }] },
    { name: "WitchMetal", faction: "Witch", clusterWith: "bandit", bound: "WitchChain", playLine: "Witch", color: "#AAAAAA", tags: KDMapInit(["leashing", "opendoors", "closedoors", "jailer", "chainRestraints", "shackleRestraints", "handcuffer", "human", "witch", "melee", "elite", "miniboss", "unflinching", "electricweakness", "crushweakness", "meleeresist", "fireweakness", "hunter"]),
        followRange: 1, spells: ["ManyChains", "SummonChainWalls", "EnemyCM1"], unlockCommandLevel: 2, unlockCommandCD: 10, spellRdy: true,
        spellCooldownMult: 1, spellCooldownMod: 2, AI: "hunt", guardChance: 0.6, visionRadius: 6, maxhp: 30, minLevel: 9, weight: 1, movePoints: 3, disarm: 0.33,
        attackPoints: 3, attack: "MeleeLockAllBindSpell", attackWidth: 3, attackRange: 1, tilesMinRange: 1, power: 4, dmgType: "grope", fullBoundBonus: 4, multiBind: 3, attackLock: "Purple",
        terrainTags: { "lastthird": 1, "miniboss": -10, "tech": -10, "metalAnger": 4, "metalFriendly": 6, "conjureAnger": 6, "increasingWeight": 0.5, "metal": 6 }, allFloors: true, shrines: [],
        dropTable: [{ name: "BlueKey", weight: 3 }, { name: "ScrollArms", weight: 1 }, { name: "ScrollVerbal", weight: 1 }, { name: "ScrollLegs", weight: 1 }],
    },
    { name: "WitchSlime", faction: "Witch", clusterWith: "slime", bound: "WitchSlime", playLine: "Witch",
        tags: KDMapInit(["leashing", "slimewalk", "opendoors", "closedoors", "witch", "jail", "jailer", "ranged", "miniboss",
            "unflinching", "slimeRestraints", "glueimmune", "meleeresist", "electricweakness", "iceweakness", "hunter"]), squeeze: true,
        followLeashedOnly: true, kite: 1.5, kiteChance: 0.9, followRange: 4, castWhileMoving: true,
        spells: ["ManySlimes", "ManySlimes", "WitchSlimeBall", "WitchSlime", "ManySlimes", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 12, stopToCast: true, spellRdy: true,
        spellCooldownMult: 2, spellCooldownMod: -7, AI: "hunt", guardChance: 0.6, visionRadius: 8, maxhp: 13, minLevel: 3, weight: 2, movePoints: 3, attackPoints: 3, attack: "Spell", attackWidth: 1, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 1,
        attackLock: "Purple",
        terrainTags: { "secondhalf": 2, "lastthird": 1, "open": 4, "tech": -8, "slime": 4 }, allFloors: true, shrines: [],
        events: [
            { trigger: "afterEnemyTick", type: "createEffectTile", kind: "Slime", time: 12, power: 1, chance: 0.5, aoe: 0.5 },
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ff00ff" },
        ],
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }] },
    { name: "Necromancer", faction: "Enemy", clusterWith: "skeleton", bound: "Necromancer", playLine: "Necromancer",
        tags: KDMapInit(["leashing", "guardCall", "opendoors", "jailer", "closedoors", "human", "witch",
            "ranged", "miniboss", "unflinching", "meleeweakness", "hunter"]), followRange: 1, cohesion: 0.9,
        spells: ["SummonSkeleton", "SummonSkeletons", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 16, spellCooldownMult: 1, spellCooldownMod: 2, spellRdy: true,
        AI: "hunt", guardChance: 0.6, visionRadius: 6, maxhp: 20, minLevel: 2, weight: 3, movePoints: 3, attackPoints: 3, attack: "MeleeLockAllWillSpellBind", attackWidth: 1, attackRange: 1, power: 5, dmgType: "grope",
        terrainTags: { "secondhalf": 3, "lastthird": 3, "miniboss": -7, "tech": -20 }, shrines: [], floors: KDMapInit(["cat", "jng", "tmb", "tmp"]), attackLock: "Purple",
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 14, noSummon: true }] },
    { name: "HighWizard", clusterWith: "mushroom", bound: "HighWizard", faction: "Mushy", playLine: "Witch", color: "#a583ff", tags: KDMapInit(["leashing", "mushy", "opendoors", "closedoors", "human", "ranged", "unflinching", "hunter"]), squeeze: true,
        followLeashedOnly: true, kite: 1.5, kiteChance: 0.9, followRange: 4, castWhileMoving: true, spells: ["HighBolt", "Spores", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 12, stopToCast: true, spellRdy: true,
        spellCooldownMult: 2, spellCooldownMod: 1, AI: "hunt", guardChance: 0.6, visionRadius: 6, maxhp: 13, minLevel: 4, weight: 12, movePoints: 2, attackPoints: 2, attack: "Spell", attackWidth: 1, attackRange: 1, power: 1, dmgType: "tickle", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 2, "lastthird": 1, "open": 4, "mushy": 5 }, floors: KDMapInit(["cry"]), shrines: [],
        dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 9 }] },
    { name: "Fungal", clusterWith: "mushroom", bound: "HighWizard", faction: "Mushy", playLine: "Fungal", color: "#a583ff", tags: KDMapInit(["leashing", "guardCall", "mushy", "jail", "jailer", "opendoors", "closedoors", "mushroom", "ranged", "unflinching", "hunter"]), squeeze: true,
        followLeashedOnly: true, kite: 1.5, kiteChance: 0.9, followRange: 4, castWhileMoving: true, spells: ["HighBolt", "CrystalPuff", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 30, stopToCast: true, spellRdy: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 4.5, color: "#892fcc" },
        ],
        spellCooldownMult: 1, spellCooldownMod: 1, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 8, regen: 0.1, minLevel: 3, weight: 12, movePoints: 3, attackPoints: 3, attack: "SpellMeleeWillLockAll", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2,
        attackLock: "Purple",
        terrainTags: { "secondhalf": 2, "lastthird": 1, "open": 4, "mushroom": 4, "mushy": 5 }, floors: KDMapInit(["cry"]), shrines: [],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 0, weight: 8 }] },
    { name: "Dressmaker", clusterWith: "construct", bound: "Dressmaker", playLine: "Dressmaker", faction: "Dressmaker", color: "#f135a4", tags: KDMapInit(["leashing", "dressmaker", "guardCall", "jail", "jailer", "conjurer", "acidweakness", "opendoors", "closedoors", "human", "ranged", "unflinching", "hunter", "dressRestraints"]),
        RestraintFilter: {
            requiredItems: ["BindingDress"],
        },
        followLeashedOnly: true, kite: 1.5, kiteChance: 0.3, followRange: 4, castWhileMoving: true, spells: ["Ribbons", "Ribbons", "Ribbons", "RibbonBurst", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, stopToCast: true, spellRdy: true, noKiteWhenHarmless: true, noSpellsWhenHarmless: true,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 13, minLevel: 0, weight: -6, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", projectileTargeting: true,
        attackWidth: 1, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 3, focusPlayer: true, attackLock: "Purple",
        terrainTags: { "secondhalf": 2, "lastthird": 1, "open": 4, "dressmaker": 20, "conjureAnger": 5, "conjureRage": 4, "ropeAnger": 3, "ropeRage": 2 }, allFloors: true, shrines: ["Conjure", "Rope"],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 15, weight: 14, noSummon: true }] },
    { name: "Nurse", clusterWith: "construct", bound: "Dressmaker", playLine: "Nurse", faction: "Dressmaker", color: "#f135a4", tags: KDMapInit(["leashing", "guardCall", "genericJailer", "dressmaker", "jail", "jailer", "conjurer", "acidweakness", "opendoors", "closedoors", "human", "ranged", "unflinching", "hunter", "nurseRestraints"]),
        followLeashedOnly: true, kite: 1.5, kiteChance: 0.3, followRange: 4, castWhileMoving: true, spells: ["NurseBola", "NurseSyringe"], miscastmsg: "KDBanditMiscast", miscastsfx: "Miss", stopToCast: true, spellRdy: true, noKiteWhenHarmless: true, noSpellsWhenHarmless: true, dontKiteWhenDisabled: true,
        spellCooldownMult: 1, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 13, minLevel: 0, weight: -40, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindWillLock", projectileTargeting: true,
        attackWidth: 1, attackRange: 1, power: 3, dmgType: "charm", fullBoundBonus: 3, focusPlayer: true, attackLock: "Red",
        terrainTags: { "secondhalf": 2, "lastthird": 1, "jailGuard": 50, "Guard": 50, "willAnger": 49, "willRage": 4, "ropeAnger": 3, "ropeRage": 2, "dressmaker": 50, "NoNurse": -10000 }, allFloors: true, shrines: ["Will", "Rope"],
        events: [
            { trigger: "afterEnemyTick", type: "nurseAura", power: 0.1, dist: 2.59 },
        ],
        dropTable: [{ name: "Gold", amountMin: 5, amountMax: 15, weight: 14, noSummon: true }] },
    { name: "Librarian", clusterWith: "construct", bound: "Dressmaker", playLine: "Librarian", faction: "Dressmaker", color: "#f135a4",
        tags: KDMapInit(["leashing", "dressmaker", "miniboss", "jailer", "acidweakness", "conjurer", "opendoors", "closedoors", "human", "ranged", "unflinching", "hunter", "lowWeightRibbons", "magicRibbonsHarsh", "gagSpell", "mittensSpell"]),
        followLeashedOnly: true, kite: 1.5, kiteChance: 0.3, followRange: 4, castWhileMoving: true, spells: [
            "SummonBookChain",
            "SummonBookSlime",
            "SummonBookIce",
            "SummonBookNature",
            "SummonBookForbidden",
            "SummonBookArcane",
            "SummonBookCelestial",
            "SummonBookElectric",
            "EnemyCM1"
        ], unlockCommandLevel: 2, unlockCommandCD: 12, stopToCast: true, spellRdy: true, noKiteWhenHarmless: true, noSpellsWhenHarmless: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#ffffff" },
        ],
        spellCooldownMult: 0.7, spellCooldownMod: 0, AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 8, spellResist: 0.35, minLevel: 0, weight: -12, movePoints: 2, attackPoints: 2, attack: "SpellMeleeBindLockAll", projectileAttack: true,
        attackWidth: 1, attackRange: 1, power: 3, dmgType: "grope", fullBoundBonus: 3, focusPlayer: true, attackLock: "Purple",
        terrainTags: { "secondhalf": 2, "lastthird": 1, "open": 10, "miniboss": -5, "dressmaker": 12, "elementsAnger": 7, "elementsRage": 5 }, allFloors: true, shrines: ["Conjure", "Elements"],
        dropTable: [{ name: "ScrollArms", weight: 2 }, { name: "ScrollVerbal", weight: 2 }, { name: "ScrollLegs", weight: 2 }, { name: "ScrollPurity", weight: 1 }] },
    { name: "MummyCursed", bound: "MummyCursed", nopickpocket: true, color: "#55ff55", playLine: "GaggedMummy", faction: "Bast", tags: KDMapInit(["mimicBlock", "gagged", "removeDoorSpawn", "ignoreharmless", "darkvision", "mummy", "melee", "elite", "mummyRestraints", "coldresist", "fireweakness", "meleeweakness", "charmweakness"]),
        evasion: -0.25, ignorechance: 1.0, armor: 0, followRange: 1, AI: "ambush", difficulty: 0.05, guardChance: 0,
        visionRadius: 10, ambushRadius: 2.01, blindSight: 10, maxhp: 12, minLevel: 0, weight: 5, movePoints: 1, attackPoints: 2, attack: "MeleeBind", attackWidth: 1, attackRange: 1, power: 2, dmgType: "charm", fullBoundBonus: 1,
        terrainTags: { "secondhalf": 5, "lastthird": 5, "door": 50 }, floors: KDMapInit(["tmb"]), shrines: ["Will"],
        dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 25 }] },
    { name: "Mummy", clusterWith: "mummy", nopickpocket: true, bound: "Mummy", faction: "Bast", color: "#55ff55", tags: KDMapInit(["leashing", "religious", "darkvision", "opendoors", "closedoors", "jail", "jailer", "mummy", "melee", "elite", "mummyRestraints", "coldresist", "fireweakness", "meleeweakness", "hunter"]), followLeashedOnly: true, followRange: 1,
        spells: ["MummyBolt", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, specialCD: 3, specialAttack: "BindLock", playLine: "Mummy", spellCooldownMult: 1, spellCooldownMod: 5, specialAttackPoints: 2, specialWidth: 3, spellRdy: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3, color: "#00ff00" },
        ],
        attackLock: "Purple",
        AI: "hunt", guardChance: 0.6, visionRadius: 7, maxhp: 8, minLevel: 3, weight: 18, movePoints: 2, attackPoints: 1, attack: "SpellMeleeWill", attackWidth: 1, attackRange: 1, power: 2, fullBoundBonus: 1, dmgType: "crush",
        terrainTags: { "secondhalf": 2, "lastthird": 4, "open": 2, "increasingWeight": 1, "mummy": 4 }, floors: KDMapInit(["tmb"]), shrines: ["Will"], dropTable: [{ name: "Gold", amountMin: 15, amountMax: 20, weight: 10 }] },
    { name: "Cleric", clusterWith: "mummy", bound: "Cleric", faction: "Bast", playLine: "Mummy", color: "#00FF00", tags: KDMapInit(["leashing", "religious", "opendoors", "closedoors", "mummy", "ranged", "search", "coldresist", "fireweakness"]),
        followLeashedOnly: true, followRange: 4, attackThruBars: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#00ff00" },
        ],
        spells: ["ClericBeam", "EnemyCM1"], unlockCommandLevel: 1, unlockCommandCD: 90, spellCooldownMult: 1, spellCooldownMod: 0, stopToCast: true, kite: 1.5, kiteChance: 0.9,
        attackPoints: 3, attack: "Spell", attackWidth: 1, attackRange: 1, power: 3, dmgType: "fire",
        AI: "guard", visionRadius: 7, maxhp: 8, minLevel: 0, weight: 13, movePoints: 1.5, fullBoundBonus: 1,
        terrainTags: { "secondhalf": 0, "lastthird": 1, "passage": -99, "open": 4, "mummy": 5 }, floors: KDMapInit(["tmb"]), shrines: ["Will"], dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 12 }] },
    { name: "MeleeCleric", clusterWith: "mummy", bound: "MeleeCleric", playLine: "Mummy", faction: "Bast", tags: KDMapInit(["leashing", "darkvision", "opendoors", "closedoors", "mummy", "melee", "kittyRestraints", "jail", "jailer", "search", "coldresist", "fireweakness"]),
        followRange: 1, blindSight: 2.5, specialCD: 5, specialAttack: "BindLock",
        AI: "hunt", guardChance: 0.6, visionRadius: 6, maxhp: 8, minLevel: 0, weight: 15, movePoints: 1.5, attackPoints: 2, attack: "MeleeWill", attackWidth: 1, attackRange: 1, power: 2, fullBoundBonus: 2, dmgType: "grope",
        terrainTags: { "secondhalf": 0, "lastthird": -2, "mummy": 6 }, floors: KDMapInit(["tmb"]), shrines: ["Will"], dropTable: [{ name: "Gold", amountMin: 10, amountMax: 20, weight: 12 }] },
    { name: "Jailer", faction: "Jail", bound: "Jailer", tags: KDMapInit(["leashing", "opendoors", "closedoors", "jail", "jailer", "genericJailer", "melee", "shackleRestraints", "guardCall", "jailRestraints"]), keys: true, followRange: 1, AI: "patrol",
        visionRadius: 6, maxhp: 12, minLevel: -1, weight: 0, movePoints: 1, attackPoints: 3, attack: "MeleeBindLockWill", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "jailGuard": 15, "Guard": 1 }, allFloors: true, disarm: 0.5, evasion: -0.5, focusPlayer: true,
        dropTable: [{ name: "Pick", weight: 15 }, { name: "RedKey", weight: 5 }], rep: { "Prisoner": 5 } },
    { name: "Guard", faction: "Jail", bound: "Guard", tags: KDMapInit(["leashing", "opendoors", "closedoors", "miniboss", "jail", "jailer", "melee", "shackleRestraints", "jailRestraints", "guardCall"]), noDisplace: true, keys: true, followRange: 1, AI: "guard", visionRadius: 6, disarm: 0.5,
        maxhp: 12, minLevel: -1, weight: -1000, movePoints: 1, attackPoints: 3, attack: "MeleeBindLockWill", attackWidth: 1, attackRange: 1, power: 2, dmgType: "grope", fullBoundBonus: 2, evasion: -0.5, focusPlayer: true, attackLock: "Red",
        RemoteControl: {
            punishRemote: 3,
            punishRemoteChance: 0.15,
        },
        events: [
            { trigger: "defeat", type: "delete", chance: 1.0 },
        ],
        terrainTags: { "Guard": 1010 }, allFloors: true, dropTable: [{ name: "RedKey", weight: 1 }], rep: { "Prisoner": 10 } },
    { name: "GuardHeavy", faction: "Jail", bound: "GuardHeavy", tags: KDMapInit(["leashing", "opendoors", "closedoors", "jail", "jailer", "melee", "unflinching", "hunter", "guardCall", "miniboss", "shackleRestraints", "handcuffer", "jailRestraints"]), noDisplace: true, disarm: 0.5,
        keys: true, followRange: 1, AI: "guard", visionRadius: 7, maxhp: 12, minLevel: 4, weight: -20, movePoints: 1, attackPoints: 2, evasion: -0.5, focusPlayer: true,
        attack: "MeleeBindLockWillStun", attackWidth: 3, attackRange: 1, power: 5, dmgType: "electric", stunTime: 1, attackLock: "Red",
        RemoteControl: {
            punishRemote: 4,
            punishRemoteChance: 0.2,
        },
        events: [
            { trigger: "defeat", type: "delete", chance: 1.0 },
        ],
        terrainTags: { "jailGuard": 22, "increasingWeight": 1, "jailbreak": 28 }, allFloors: true, dropTable: [{ name: "RedKey", weight: 1 }], rep: { "Prisoner": 10 } },
    { name: "BanditMerchant", faction: "Bandit", clusterWith: "bandit", playLine: "Bandit", bound: "BanditChief",
        tags: KDMapInit([
            "opendoors", "cacheguard", "closedoors", "leashing", "bandit", "banditleader",
            "boss", "melee", "ranged", "caster",
            "ballGagRestraints", "banditMagicRestraints", "leatherRestraints", "leatherRestraintsHeavy", "chainweakness", "glueweakness", "jailer", "hunter"
        ]), cohesion: 0.9, armor: 0, followRange: 1, AI: "hunt",
        spells: ["PoisonDagger", "BearTrap", "LustBomb"], spellCooldownMult: 1, spellCooldownMod: 0, noSpellLeashing: true,
        summon: [
            { enemy: "BanditPet", range: 3, count: 2, chance: 1.0, strict: true },
        ],
        visionRadius: 8, maxhp: 30, minLevel: 3, weight: -20, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 3.6, attackRange: 1, power: 4, dmgType: "grope", fullBoundBonus: 2,
        terrainTags: { "boss": -5, "open": 10, "increasingWeight": 1, "BanditEnemy": 11, "BanditWanted": 3, "BanditHated": 4 }, shrines: ["Leather"], allFloors: true,
        factionrep: { "Bountyhunter": 0.02 },
        dropTable: [{ name: "Gold", amountMin: 80, amountMax: 100, weight: 10 }] },
    { name: "Fuuka1", playLine: "Fuuka", bound: "TalismanZombie", faction: "Boss", clusterWith: "zombie", tags: KDMapInit(["nosub", "leashing", "noshop", "zombie", "ranged", "mikoRestraints", "stageBoss", "boss", "nocapture", "unflinching"]),
        armor: 0, followRange: 3, AI: "guard",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3.5, color: "#ffffff" },
        ],
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        unlockCommandLevel: 3, unlockCommandCD: 7,
        spells: ["ZombieOrb", "ManyOrbs", "SummonZombies", "EnemyCM_self"], spellCooldownMult: 0.25, spellCooldownMod: 0, castWhileMoving: true, buffallies: true, kite: 1.5, projectileAttack: true, accuracy: 0.7, noChannel: true,
        visionRadius: 8, maxhp: 80, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 3, attackRange: 1, power: 4, dmgType: "grope", fullBoundBonus: 4,
        terrainTags: {}, floors: KDMapInit([]), dropTable: [{ name: "Scrolls", weight: 10 }], ondeath: [{ type: "dialogue", dialogue: "FuukaStage2", click: true }] },
    { name: "Fuuka2", playLine: "Fuuka", bound: "TalismanZombie", faction: "Boss", clusterWith: "zombie", tags: KDMapInit(["nosub", "leashing", "zombie", "ranged", "mikoRestraints", "stageBoss", "boss", "nocapture", "unflinching"]),
        armor: 0, followRange: 1, AI: "hunt",
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 7, color: "#ffffff" },
        ],
        unlockCommandLevel: 3, unlockCommandCD: 7,
        spells: ["ZombieOrb", "ManyOrbs", "SummonMikoGhosts", "SummonZombies", "EnemyCM_self"], spellCooldownMult: 0.25, spellCooldownMod: 0, castWhileMoving: true, buffallies: true, projectileAttack: true, accuracy: 0.85, noChannel: true,
        visionRadius: 12, maxhp: 45, minLevel: 0, weight: -1000, movePoints: 1, attackPoints: 3, attack: "SpellMeleeBindLock", attackWidth: 3, attackRange: 1, power: 4, dmgType: "grope", fullBoundBonus: 4,
        terrainTags: {}, floors: KDMapInit([]), dropTable: [{ name: "BlueKey", weight: 10 }], ondeath: [{ type: "dialogue", dialogue: "FuukaWin", click: true }] },
    { name: "MikoGhost", faction: "Ghost", color: "#FFFFFF", clusterWith: "ghost", tags: KDMapInit(["ignorenoSP", "ghost", "melee", "glueimmune", "chainimmune", "temporary"]), ethereal: true, ignorechance: 0, armor: 0, followRange: 1, AI: "hunt",
        specialCD: 7, specialAttack: "Slow",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 2, color: "#ffffff" },
        ],
        visionRadius: 30, blindSight: 30, evasion: 9.0, alwaysEvade: true, maxhp: 1, regen: -0.051, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 1, attack: "MeleeWill", attackWidth: 3, attackRange: 1, power: 1, dmgType: "grope", fullBoundBonus: 0,
        terrainTags: {}, shrines: ["Illusion"], floors: KDMapInit([]), dropTable: [{ name: "Ectoplasm", chance: 0.6, weight: 10 }], },
    { name: "DollmakerBoss1", playLine: "Dollmaker", bound: "DollmakerBoss", faction: "Boss", clusterWith: "dollsmith",
        tags: KDMapInit(["nosub", "leashing", "noshop", "dollsmith", "ranged",
            "glueresist", "electricresist", "crushresist", "iceweakness", "dollmakerrestraints", "controlharness", "cyberdollchastity", "teasetoys", "stageBoss", "boss", "nocapture", "unstoppable"]),
        spellResist: 2.0, armor: 0.5, followRange: 1.5, AI: "guard", kite: 4.5, noKiteWhenHarmless: true, dontKiteWhenDisabled: true,
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3.5, color: "#ff88ff" },
            { trigger: "afterEnemyTick", type: "dollmakerMissiles", count: 2, time: 8, dist: 10, kind: "RubberMissile" },
        ],
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        unlockCommandLevel: 3, unlockCommandCD: 14,
        spells: ["SummonDrones", "DollConvertMany", "DollBoost", "EnemyCM_self"],
        spellCooldownMult: 0.25, spellCooldownMod: 0, castWhileMoving: true, buffallies: true, projectileAttack: true, accuracy: 0.7, noChannel: true,
        visionRadius: 9, maxhp: 70, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLockAll", attackWidth: 3, attackRange: 1, power: 4, dmgType: "soul", fullBoundBonus: 4,
        terrainTags: {}, floors: KDMapInit([]),
        ondeath: [{ type: "dialogue", dialogue: "DollmakerStage2", click: true }] },
    { name: "DollmakerBoss2", playLine: "Dollmaker", bound: "DollmakerBoss", faction: "Boss", clusterWith: "dollsmith",
        tags: KDMapInit(["nosub", "leashing", "noshop", "dollsmith", "ranged",
            "glueresist", "electricresist", "crushresist", "iceweakness", "dollmakerrestraints", "cyberdollchastity", "cyberdollrestraints", "controlharness", "teasetoys", "stageBoss", "boss", "nocapture", "unstoppable"]),
        spellResist: 2.0, armor: 0.5, followRange: 5.5, AI: "guard",
        events: [
            { trigger: "tick", type: "suicideWhenBound" },
            { trigger: "getLights", type: "enemyTorch", power: 3.5, color: "#ff88ff" },
            { trigger: "afterEnemyTick", type: "dollmakerMissiles", count: 2, time: 15, dist: 10, kind: "RubberNuke" },
        ],
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        unlockCommandLevel: 3, unlockCommandCD: 14,
        spells: ["SummonCaptureDrones", "DollConvertMany", "DollBoost", "EnemyCM_self"],
        spellCooldownMult: 0.15, spellCooldownMod: 0, castWhileMoving: true, buffallies: true, kite: 2.5, accuracy: 0.85, noChannel: true,
        visionRadius: 20, blindSight: 7, maxhp: 60, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLockAll", attackWidth: 3, attackRange: 1, power: 4, dmgType: "soul", fullBoundBonus: 4,
        terrainTags: {}, floors: KDMapInit([]),
        ondeath: [{ type: "dialogue", dialogue: "DollmakerStage3", click: true }] },
    { name: "DollmakerBoss3", playLine: "Dollmaker", bound: "DollmakerBoss", faction: "Boss", clusterWith: "dollsmith",
        tags: KDMapInit(["nosub", "leashing", "noshop", "dollsmith", "ranged",
            "glueresist", "electricresist", "crushresist", "iceweakness", "dollmakerrestraints", "cyberdollchastity", "cyberdollrestraints", "cyberdollheavy", "controlharness", "teasetoys", "stageBoss", "boss", "nocapture", "unstoppable"]),
        spellResist: 2.0, armor: 0.5, followRange: 1.5, AI: "guard",
        events: [
            { trigger: "getLights", type: "enemyTorch", power: 3.5, color: "#ff88ff" },
            { trigger: "afterEnemyTick", type: "dollmakerMissiles", count: 2, time: 9, dist: 10, kind: "RubberNuke" },
        ],
        RestraintFilter: {
            unlimitedRestraints: true,
        },
        unlockCommandLevel: 3, unlockCommandCD: 14,
        spells: ["DollConvertMany", "DollBoost", "EnemyCM_self", "ManyCables"],
        spellCooldownMult: 0.2, spellCooldownMod: 0, castWhileMoving: true, buffallies: true, projectileAttack: true, accuracy: 1.15, noChannel: true,
        visionRadius: 30, blindSight: 30, maxhp: 140, minLevel: 0, weight: -1000, movePoints: 2, attackPoints: 3, attack: "SpellMeleeBindLockAll", attackWidth: 3, attackRange: 1, power: 4, dmgType: "soul", fullBoundBonus: 4,
        terrainTags: {}, floors: KDMapInit([]),
        ondeath: [{ type: "dialogue", dialogue: "DollmakerWin", click: true }] },
];
let KDOndeath = {
    "summon": (enemy, o) => {
        KinkyDungeonSummonEnemy(enemy.x, enemy.y, o.enemy, o.count, o.range, o.strict, o.lifetime, o.hidden, undefined, o.faction || KDGetFaction(enemy), o.hostile, o.minradius, o.startAware, undefined, o.hideTimer);
    },
    "dialogue": (enemy, o) => {
        KDStartDialog(o.dialogue, enemy.Enemy.name, o.click, enemy.personality, enemy);
    },
    "spellOnSelf": (enemy, o) => {
        let spell = KinkyDungeonFindSpell(o.spell, true);
        if (spell)
            KinkyDungeonCastSpell(enemy.x, enemy.y, spell, undefined, undefined, undefined, KDGetFaction(enemy));
    },
    "removeQuest": (enemy, o) => {
        KDRemoveQuest(o.quest);
    },
    "dollID": (enemy, o) => {
        if (KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 9) {
            if (!KinkyDungeonFlags.get("gotDollID")) {
                let dropped = { x: enemy.x, y: enemy.y, name: "DollID" };
                KinkyDungeonGroundItems.push(dropped);
                KinkyDungeonSetFlag("gotDollID", -1, 1);
            }
        }
    },
    "addQuest": (enemy, o) => {
        KDAddQuest(o.quest);
    },
};
let KDAIType = {
    "wander": {
        init: (enemy, player, AIData) => { },
        beforemove: (enemy, player, AIData) => { return false; },
        chase: (enemy, player, AIData) => { return false; },
        persist: (enemy, player, AIData) => { return false; },
        move: (enemy, player, AIData) => { return true; },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return true; },
        wander_far: (enemy, player, AIData) => { return KDRandom() < 0.2; },
        resetguardposition: (enemy, player, AIData) => { return false; },
        attack: (enemy, player, AIData) => { return true; },
        spell: (enemy, player, AIData) => { return true; },
        aftermove: (enemy, player, AIData) => { return false; },
        wanderDelay_long: (enemy, AIData) => { return 35 + Math.floor(KDRandom() * 35); },
        wanderDelay_short: (enemy, AIData) => { return 10 + Math.floor(KDRandom() * 25); },
    },
    "hunt": {
        init: (enemy, player, AIData) => { },
        beforemove: (enemy, player, AIData) => { return false; },
        chase: (enemy, player, AIData) => { return true; },
        persist: (enemy, player, AIData) => { return true; },
        move: (enemy, player, AIData) => { return true; },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return true; },
        wander_far: (enemy, player, AIData) => { return KDRandom() < 0.2; },
        resetguardposition: (enemy, player, AIData) => { return false; },
        attack: (enemy, player, AIData) => { return true; },
        spell: (enemy, player, AIData) => { return true; },
        aftermove: (enemy, player, AIData) => { return false; },
        wanderDelay_long: (enemy, AIData) => { return 35 + Math.floor(KDRandom() * 35); },
        wanderDelay_short: (enemy, AIData) => { return 10 + Math.floor(KDRandom() * 25); },
    },
    "huntshadow": {
        init: (enemy, player, AIData) => { },
        beforemove: (enemy, player, AIData) => { return false; },
        chase: (enemy, player, AIData) => { return true; },
        persist: (enemy, player, AIData) => { return true; },
        move: (enemy, player, AIData) => { return true; },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return true; },
        wander_far: (enemy, player, AIData) => { return KDRandom() < 0.4; },
        wandernear_func: (enemy, player, AIData) => {
            if (KinkyDungeonAlert && AIData.playerDist < Math.max(4, AIData.visionRadius)) {
                enemy.gx = KinkyDungeonPlayerEntity.x;
                enemy.gy = KinkyDungeonPlayerEntity.y;
            }
            else {
                let ex = enemy.x;
                let ey = enemy.y;
                let cohesion = enemy.Enemy.cohesion ? enemy.Enemy.cohesion : 0.5;
                let masterCloseness = enemy.Enemy.cohesion ? enemy.Enemy.cohesion : 0.7;
                if (AIData.master && KDRandom() < masterCloseness) {
                    ex = AIData.master.x;
                    ey = AIData.master.y;
                }
                else if (KDRandom() < cohesion) {
                    let minDist = enemy.Enemy.cohesionRange ? enemy.Enemy.cohesionRange : AIData.visionRadius;
                    for (let e of KinkyDungeonEntities) {
                        if (e == enemy)
                            continue;
                        if (['guard', 'ambush'].includes(KDGetAI(enemy)))
                            continue;
                        if (enemy.Enemy.clusterWith && !e.Enemy.tags[enemy.Enemy.clusterWith])
                            continue;
                        if (KinkyDungeonTilesGet(e.x + "," + e.y) && KinkyDungeonTilesGet(e.x + "," + e.y).OffLimits)
                            continue;
                        let dist = KDistEuclidean(e.x - enemy.x, e.y - enemy.y);
                        if (dist < minDist) {
                            minDist = dist;
                            let ePoint = KinkyDungeonGetNearbyPoint(ex, ey, false);
                            if (ePoint) {
                                ex = ePoint.x;
                                ey = ePoint.y;
                            }
                        }
                    }
                }
                let newPoint = KinkyDungeonGetNearbyPoint(ex, ey, false, undefined, undefined, undefined, (x, y) => {
                    return KinkyDungeonBrightnessGet(x, y) < 4;
                });
                if (newPoint && (KDGetFaction(enemy) != "Player" || !KinkyDungeonPointInCell(newPoint.x, newPoint.y))) {
                    enemy.gx = newPoint.x;
                    enemy.gy = newPoint.y;
                    return true;
                }
            }
            return false;
        },
        wanderfar_func: (enemy, player, AIData) => {
            let newPoint = KinkyDungeonGetRandomEnemyPointCriteria((x, y) => {
                return KinkyDungeonBrightnessGet(x, y) < 4;
            }, false, enemy.tracking && KinkyDungeonHuntDownPlayer && KDGameData.PrisonerState != "parole" && KDGameData.PrisonerState != "jail");
            if (newPoint) {
                enemy.gx = newPoint.x;
                enemy.gy = newPoint.y;
                return true;
            }
            return false;
        },
        resetguardposition: (enemy, player, AIData) => { return false; },
        attack: (enemy, player, AIData) => { return true; },
        spell: (enemy, player, AIData) => { return true; },
        aftermove: (enemy, player, AIData) => { return false; },
        wanderDelay_long: (enemy, AIData) => { return 20 + Math.floor(KDRandom() * 15); },
        wanderDelay_short: (enemy, AIData) => { return 10 + Math.floor(KDRandom() * 10); },
    },
    "patrol": {
        init: (enemy, player, AIData) => { },
        beforemove: (enemy, player, AIData) => { return false; },
        chase: (enemy, player, AIData) => { return true; },
        persist: (enemy, player, AIData) => { return true; },
        move: (enemy, player, AIData) => { return true; },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return true; },
        wander_far: (enemy, player, AIData) => { return true; },
        resetguardposition: (enemy, player, AIData) => { return false; },
        attack: (enemy, player, AIData) => { return true; },
        spell: (enemy, player, AIData) => { return true; },
        aftermove: (enemy, player, AIData) => {
            if (!AIData.followPlayer && !KDEnemyHasFlag(enemy, "StayHere")) {
                let patrolChance = AIData.patrolChange ? 0.13 : 0.02;
                if (!enemy.patrolIndex)
                    enemy.patrolIndex = KinkyDungeonNearestPatrolPoint(enemy.x, enemy.y);
                if (KinkyDungeonPatrolPoints[enemy.patrolIndex] && KDRandom() < patrolChance) {
                    if (enemy.patrolIndex < KinkyDungeonPatrolPoints.length - 1)
                        enemy.patrolIndex += 1;
                    else
                        enemy.patrolIndex = 0;
                    let newPoint = KinkyDungeonGetPatrolPoint(enemy.patrolIndex, 1.4, AIData.MovableTiles);
                    enemy.gx = newPoint.x;
                    enemy.gy = newPoint.y;
                }
                return true;
            }
            return false;
        },
        wanderDelay_long: (enemy, AIData) => { return 35 + Math.floor(KDRandom() * 35); },
        wanderDelay_short: (enemy, AIData) => { return 10 + Math.floor(KDRandom() * 20); },
    },
    "guard": {
        init: (enemy, player, AIData) => {
            AIData.visionMod *= 0.7;
        },
        beforemove: (enemy, player, AIData) => { return false; },
        chase: (enemy, player, AIData) => { return true; },
        persist: (enemy, player, AIData) => { return false; },
        move: (enemy, player, AIData) => { return true; },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return false; },
        wander_far: (enemy, player, AIData) => { return false; },
        resetguardposition: (enemy, player, AIData) => { return true; },
        attack: (enemy, player, AIData) => { return true; },
        spell: (enemy, player, AIData) => { return true; },
        aftermove: (enemy, player, AIData) => { return false; },
        wanderDelay_long: (enemy, AIData) => { return 35 + Math.floor(KDRandom() * 35); },
        wanderDelay_short: (enemy, AIData) => { return 15 + Math.floor(KDRandom() * 30); },
    },
    "looseguard": {
        strictwander: true,
        init: (enemy, player, AIData) => { },
        beforemove: (enemy, player, AIData) => { return false; },
        chase: (enemy, player, AIData) => { return true; },
        persist: (enemy, player, AIData) => { return false; },
        move: (enemy, player, AIData) => { return true; },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return true; },
        wander_far: (enemy, player, AIData) => { return false; },
        resetguardposition: (enemy, player, AIData) => { return true; },
        attack: (enemy, player, AIData) => { return true; },
        spell: (enemy, player, AIData) => { return true; },
        aftermove: (enemy, player, AIData) => { return false; },
        wanderDelay_long: (enemy, AIData) => { return 35 + Math.floor(KDRandom() * 35); },
        wanderDelay_short: (enemy, AIData) => { return 15 + Math.floor(KDRandom() * 30); },
    },
    "verylooseguard": {
        strictwander: true,
        init: (enemy, player, AIData) => { },
        beforemove: (enemy, player, AIData) => { return false; },
        chase: (enemy, player, AIData) => { return true; },
        persist: (enemy, player, AIData) => { return false; },
        move: (enemy, player, AIData) => { return true; },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return true; },
        wander_far: (enemy, player, AIData) => { return true; },
        resetguardposition: (enemy, player, AIData) => { return true; },
        attack: (enemy, player, AIData) => { return true; },
        spell: (enemy, player, AIData) => { return true; },
        aftermove: (enemy, player, AIData) => { return false; },
        wanderDelay_long: (enemy, AIData) => { return 35 + Math.floor(KDRandom() * 35); },
        wanderDelay_short: (enemy, AIData) => { return 15 + Math.floor(KDRandom() * 30); },
    },
    "ambush": {
        ambush: true,
        ambushtile: 'X',
        init: (enemy, player, AIData) => { },
        beforemove: (enemy, player, AIData) => {
            if (AIData.playerDist < 1.5)
                enemy.ambushtrigger = true;
            return false;
        },
        chase: (enemy, player, AIData) => { return enemy.ambushtrigger; },
        persist: (enemy, player, AIData) => { return enemy.ambushtrigger; },
        move: (enemy, player, AIData) => { return enemy.ambushtrigger || (enemy.Enemy.wanderTillSees && !AIData.canSeePlayer); },
        follower: (enemy, player, AIData) => { return true; },
        followsound: (enemy, player, AIData) => { return true; },
        wander_near: (enemy, player, AIData) => { return (enemy.Enemy.wanderTillSees && !AIData.canSeePlayer); },
        wander_far: (enemy, player, AIData) => { return false; },
        resetguardposition: (enemy, player, AIData) => { return true; },
        attack: (enemy, player, AIData) => { return enemy.ambushtrigger; },
        spell: (enemy, player, AIData) => { return enemy.ambushtrigger; },
        aftermove: (enemy, player, AIData) => { return false; },
        wanderDelay_long: (enemy, AIData) => { return 35 + Math.floor(KDRandom() * 35); },
        wanderDelay_short: (enemy, AIData) => { return 10 + Math.floor(KDRandom() * 25); },
    },
};
let KDLoadouts = {
    "guard": {
        name: "guard",
        tags: ["elite"],
        singletag: ["human", "elf", "alchemist", "dragon", "witch", "apprentice", "mummy", "jailer"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.1,
        items: ["RedKey"],
    },
    "thief": {
        name: "guard",
        tags: ["human"],
        singletag: ["bandit", "bountyhunter"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.15,
        items: ["Pick", "Knife"],
    },
    "mistress": {
        name: "mistress",
        tags: ["miniboss"],
        singletag: ["human", "elf", "alchemist", "dragon", "witch", "apprentice", "mummy"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.65,
        items: ["RedKey"],
    },
    "scientist_I": {
        name: "scientist_I",
        tags: ["alchemist"],
        singletag: ["alchemist"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.65,
        items: ["SmokeBomb"],
    },
    "scientist_II": {
        name: "scientist_II",
        tags: ["alchemist"],
        singletag: ["alchemist"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.5,
        items: ["PotionFrigid", "PotionStamina"],
    },
    "scientist_III": {
        name: "scientist_III",
        tags: ["alchemist"],
        singletag: ["alchemist"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.35,
        items: ["PotionMana"],
    },
    "magus": {
        name: "magus",
        tags: [],
        singletag: ["dressmaker", "elf", "witch", "apprentice", "mummy", "fungal"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.01,
        multiplier: 10,
        items: ["BlueKey", "ScrollVerbal", "ScrollLegs", "ScrollArms"],
    },
    "magusElite": {
        name: "magusElite",
        tags: [],
        singletag: ["dressmaker", "elf", "witch", "apprentice", "mummy", "fungal"],
        singletag2: ["elite", "miniboss", "boss"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.6,
        multiplier: 10,
        items: ["BlueKey", "ScrollVerbal", "ScrollLegs", "ScrollArms"],
    },
    "scroll_arm": {
        name: "scroll_arm",
        tags: [],
        singletag: ["dressmaker", "elf", "witch", "apprentice", "mummy", "fungal"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.04,
        items: ["ScrollArms"],
    },
    "scroll_leg": {
        name: "scroll_arm",
        tags: [],
        singletag: ["dressmaker", "elf", "witch", "apprentice", "mummy", "fungal"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.04,
        items: ["ScrollLegs"],
    },
    "scroll_verbal": {
        name: "scroll_arm",
        tags: [],
        singletag: ["dressmaker", "elf", "witch", "apprentice", "mummy", "fungal"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.04,
        items: ["ScrollVerbal"],
    },
    "mage": {
        name: "mage",
        tags: [],
        singletag: ["witch", "apprentice", "fungal", "elf", "dressmaker"],
        forbidtags: [],
        chance: 0.08,
        items: ["PotionMana"],
    },
    "police": {
        name: "police",
        tags: ["police"],
        singletag: ["human", "bountyhunter"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.2,
        items: ["RedKey"],
    },
    "ninja": {
        name: "ninja",
        tags: [],
        singletag: ["ninja", "maid", "bountyhunter"],
        forbidtags: [],
        chance: 0.7,
        items: ["SmokeBomb"],
    },
    "bandit_I": {
        name: "bandit_I",
        tags: [],
        singletag: ["bandit"],
        forbidtags: [],
        chance: 0.3,
        items: ["Bomb"],
    },
    "bandit_II": {
        name: "bandit_II",
        tags: [],
        singletag: ["bandit"],
        forbidtags: [],
        chance: 0.7,
        items: ["Bola"],
    },
    "bandit_III": {
        name: "bandit_III",
        tags: ["bandit"],
        singletag: ["miniboss", "boss", "elite"],
        forbidtags: [],
        chance: 0.5,
        items: ["PotionStamina", "Bola", "Knife"],
    },
    "bandit_IV": {
        name: "bandit_IV",
        tags: ["bandit"],
        singletag: ["miniboss", "boss", "elite"],
        forbidtags: [],
        chance: 0.5,
        multiplier: 5,
        items: ["PotionWill", "Bomb", "Rope"],
    },
    "bandit_V": {
        name: "bandit_V",
        tags: ["bandit"],
        singletag: ["miniboss", "boss"],
        forbidtags: [],
        chance: 0.1,
        multiplier: 10,
        items: ["PotionStamina", "RedKey", "RedKey"],
    },
    "miner": {
        name: "miner",
        tags: ["miner"],
        singletag: ["miner"],
        forbidtags: [],
        chance: 1.0,
        items: ["Bomb", "Bomb", "Bomb"],
    },
    "trainer": {
        name: "trainer",
        tags: ["trainer"],
        singletag: ["trainer"],
        forbidtags: [],
        chance: 0.4,
        items: ["AncientPowerSource"],
    },
    "nevermere": {
        name: "nevermere",
        tags: ["nevermere"],
        singletag: ["trainer", "wolfgirl"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.15,
        items: ["AncientPowerSource", "RedKey"],
    },
    "agent": {
        name: "agent",
        tags: [],
        singletag: ["ninja", "maid", "bountyhunter"],
        forbidtags: [],
        chance: 0.1,
        items: ["SmokeBomb", "PotionInvisibility"],
    },
    "ninja_II": {
        name: "ninja_II",
        tags: [],
        singletag: ["ninja", "maid", "bountyhunter"],
        forbidtags: [],
        chance: 0.3,
        items: ["SmokeBomb", "Bola"],
    },
    "religious": {
        name: "religious",
        tags: ["religious"],
        singletag: ["mummy", "elf"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.01,
        items: ["ScrollPurity"],
    },
    "religiousElite": {
        name: "religiousElite",
        tags: ["religious", "elite"],
        singletag: ["mummy", "elf"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.2,
        multiplier: 4,
        items: ["ScrollPurity", "BlueKey"],
    },
    "religiousMiniboss": {
        name: "religiousMiniboss",
        tags: ["religious", "miniboss"],
        singletag: ["mummy", "elf"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.5,
        multiplier: 10,
        items: ["ScrollPurity", "BlueKey"],
    },
    "religiousBoss": {
        name: "religiousBoss",
        tags: ["religious", "boss"],
        singletag: ["mummy", "elf"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.8,
        multiplier: 10,
        items: ["ScrollPurity", "BlueKey"],
    },
    "keyholder": {
        name: "keyholder",
        tags: ["miniboss"],
        singletag: ["human", "elf", "alchemist", "dragon", "witch", "apprentice", "mummy", "jailer"],
        forbidtags: ["submissive", "gagged"],
        chance: 0.22,
        multiplier: 2,
        items: ["Keyring"],
    },
    "potMana_minor": {
        name: "potMana_minor",
        tags: ["jail"],
        singletag: [],
        forbidtags: [],
        chance: 0.05,
        items: ["PotionMana"],
    },
    "potStam_minor": {
        name: "potStam_minor",
        tags: ["jail"],
        singletag: [],
        forbidtags: [],
        chance: 0.05,
        items: ["PotionStamina"],
    },
    "potWill_minor": {
        name: "potWill_minor",
        tags: ["jail"],
        singletag: [],
        forbidtags: [],
        chance: 0.04,
        items: ["PotionWill"],
    },
    "potMana": {
        name: "potMana",
        tags: ["jail"],
        singletag: [],
        forbidtags: ["minor"],
        chance: 0.05,
        items: ["PotionMana"],
    },
    "potStam": {
        name: "potStam",
        tags: ["jail"],
        singletag: [],
        forbidtags: ["minor"],
        chance: 0.05,
        items: ["PotionStamina"],
    },
    "potWill": {
        name: "potWill",
        tags: ["jail"],
        singletag: [],
        forbidtags: ["minor"],
        chance: 0.04,
        items: ["PotionWill"],
    },
    "potFrigid": {
        name: "potFrigid",
        tags: ["jail"],
        singletag: [],
        forbidtags: ["minor"],
        chance: 0.08,
        items: ["PotionFrigid"],
    },
    "boss": {
        name: "boss",
        tags: ["boss"],
        singletag: ["human", "elf", "alchemist", "dragon", "witch", "apprentice", "mummy"],
        forbidtags: ["submissive", "gagged"],
        chance: 1.0,
        items: ["RedKey", "Keyring"],
    },
};
let KDSpecialConditions = {
    "canRestrainWithExtra": {
        resetCD: false,
        criteria: (enemy, AIData) => {
            var _a;
            let rThresh = ((_a = enemy.Enemy.RestraintFilter) === null || _a === void 0 ? void 0 : _a.powerThresh) || KDDefaultRestraintThresh;
            return KDGetRestraintsEligible({ tags: KDGetTags(enemy, true) }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], enemy.Enemy.bypass, enemy.Enemy.useLock ? enemy.Enemy.useLock : "", !(enemy.Enemy.ignoreStaminaForBinds || (true && enemy.Enemy.specialIgnoreStam)) && !AIData.attack.includes("Suicide"), false, !(KinkyDungeonStatsChoice.has("TightRestraints") || enemy.Enemy.tags.miniboss || enemy.Enemy.tags.boss), KDGetExtraTags(enemy, true), false, {
                maxPower: rThresh + 0.01,
                looseLimit: true,
                onlyUnlimited: true,
                ignore: enemy.items,
            }, enemy).length > 0;
        }
    }
};
let KDIntentEvents = {
    "leashFurniture": {
        play: true,
        nonaggressive: true,
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            if (allied)
                return 0;
            if (!enemy.Enemy.tags.leashing)
                return 0;
            if (KinkyDungeonFlags.get("Released"))
                return 0;
            if (KDGameData.PrisonerState == 'jail')
                return 0;
            if (KinkyDungeonGetRestraintItem("ItemDevices"))
                return 0;
            if (enemy.playWithPlayer > 0)
                return 0;
            let nearestfurniture = KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["furniture"]);
            return nearestfurniture && KDistChebyshev(enemy.x - nearestfurniture.x, enemy.y - nearestfurniture.y) < 14 ? (hostile ? 120 : 40) : 0;
        },
        trigger: (enemy, AIData) => {
            KDResetIntent(enemy, AIData);
            enemy.IntentAction = 'leashFurniture';
            KinkyDungeonSetEnemyFlag(enemy, "noResetIntent", 140);
            let nearestfurniture = KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["furniture"]);
            enemy.IntentLeashPoint = nearestfurniture;
            enemy.playWithPlayer = 22;
            KDSetPlayCD(enemy, 2);
            KinkyDungeonSetEnemyFlag(enemy, "playstart", 3);
            KinkyDungeonSetEnemyFlag(enemy, "motivated", 50);
            KDAddThought(enemy.id, "Jail", 5, enemy.playWithPlayer);
            let suff = (enemy.Enemy.playLine ? enemy.Enemy.playLine : "");
            KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJailPlay" + suff + "Leash").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 4, 3);
        },
        arrive: (enemy, AIData) => {
            enemy.IntentAction = '';
            enemy.IntentLeashPoint = null;
            KinkyDungeonSetEnemyFlag(enemy, "noResetIntent", -1);
            enemy.playWithPlayer = 12 + Math.floor(KDRandom() * 12);
            enemy.playWithPlayerCD = 30;
            KinkyDungeonSetEnemyFlag(enemy, "playstart", 7);
            return KDSettlePlayerInFurniture(enemy, AIData);
        },
        maintain: (enemy, delta) => {
            if (KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 1.5 && (KDEnemyHasFlag(enemy, "motivated") || KDHostile(enemy))) {
                if (enemy.playWithPlayer < 10) {
                    enemy.playWithPlayer = 10;
                    KDSetPlayCD(enemy, 1.5);
                }
            }
            return false;
        },
    },
    "Ignore": {
        nonaggressive: true,
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            return 90;
        },
        trigger: (enemy, AIData) => {
        },
    },
    "Play": {
        play: true,
        nonaggressive: true,
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            return (KDEnemyHasFlag(enemy, "HelpMe")) ?
                0
                : (!(enemy === null || enemy === void 0 ? void 0 : enemy.playWithPlayer) ? (allied ? 10 : 110) : 0);
        },
        trigger: (enemy, AIData) => {
            KDResetIntent(enemy, AIData);
            enemy.playWithPlayer = 8 + Math.floor(KDRandom() * (5 * Math.min(5, Math.max(enemy.Enemy.attackPoints || 0, enemy.Enemy.movePoints || 0))));
            KinkyDungeonSetEnemyFlag(enemy, "playstart", 7);
            KDSetPlayCD(enemy, 2.5);
            if (AIData.domMe)
                enemy.playWithPlayer = Math.floor(enemy.playWithPlayer * 0.7);
            KDAddThought(enemy.id, "Play", 4, enemy.playWithPlayer);
            let index = Math.floor(Math.random() * 3);
            let suff = (enemy.Enemy.playLine ? enemy.Enemy.playLine : "");
            if (AIData.domMe) {
                if (KDIsBrat(enemy))
                    suff = "Brat" + suff;
                else
                    suff = "Sub" + suff;
            }
            KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJailPlay" + suff + index).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 4, 3);
        },
    },
    "freeFurniture": {
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            return 0;
        },
        trigger: (enemy, AIData) => {
            KinkyDungeonSetEnemyFlag(enemy, "noResetIntent", 100);
        },
        maintain: (enemy, delta) => {
            if (KinkyDungeonGetRestraintItem("ItemDevices")) {
                if (KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 1.5) {
                    KinkyDungeonRemoveRestraint("ItemDevices", false, false, false);
                    KDResetIntent(enemy, undefined);
                    KinkyDungeonSetEnemyFlag(enemy, "noResetIntent", -1);
                    if (enemy.playWithPlayer > 0)
                        enemy.playWithPlayerCD = Math.max(enemy.playWithPlayer, 30);
                    KinkyDungeonSetFlag("Released", 24);
                    KinkyDungeonSetFlag("nojailbreak", 12);
                }
                else {
                    enemy.gx = KinkyDungeonPlayerEntity.x;
                    enemy.gy = KinkyDungeonPlayerEntity.y;
                }
                if (enemy.playWithPlayer > 0)
                    enemy.playWithPlayer = 12;
                return true;
            }
            return false;
        },
    },
    "Capture": {
        aggressive: true,
        noplay: true,
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            return 100;
        },
        trigger: (enemy, AIData) => {
            enemy.playWithPlayer = 0;
        },
    },
    "CaptureJail": {
        aggressive: true,
        nonaggressive: true,
        noplay: true,
        forceattack: true,
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            return hostile && (enemy.Enemy.tags.jailer || enemy.Enemy.tags.jail || enemy.Enemy.tags.leashing) && (KinkyDungeonFlags.has("Released")) ?
                ((KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["dropoff"]) && !KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["jail"])) ? 0 : 100)
                : 0;
        },
        trigger: (enemy, AIData) => {
            KinkyDungeonSetEnemyFlag(enemy, "noResetIntent", 30);
            enemy.playWithPlayer = 0;
            enemy.IntentAction = 'CaptureJail';
            let nj = KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["jail"]);
            enemy.IntentLeashPoint = nj ? nj : Object.assign({ type: "jail", radius: 1 }, KinkyDungeonStartPosition);
            if (!nj)
                KinkyDungeonSetFlag("LeashToPrison", -1, 1);
        },
        arrive: (enemy, AIData) => {
            if (KDGameData.PrisonerState == 'parole') {
                KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonJailer" + KDJailPersonality(enemy) + "Mistake").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 6, 8);
                KDBreakTether();
                if (enemy.IntentLeashPoint)
                    KDMovePlayer(enemy.IntentLeashPoint.x, enemy.IntentLeashPoint.y, false, false);
                KDResetIntent(enemy, AIData);
                enemy.playWithPlayer = 0;
                enemy.playWithPlayerCD = 24;
                return true;
            }
            AIData.defeat = true;
            KDBreakTether();
            return false;
        },
    },
    "CaptureDoll": {
        aggressive: true,
        nonaggressive: true,
        noplay: true,
        forceattack: true,
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            return hostile && (enemy.Enemy.tags.jailer || enemy.Enemy.tags.jail || enemy.Enemy.tags.leashing) && (KinkyDungeonFlags.has("Released") && KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["dropoff"])) ? 200 : 0;
        },
        trigger: (enemy, AIData) => {
            KinkyDungeonSetEnemyFlag(enemy, "noResetIntent", 30);
            enemy.playWithPlayer = 0;
            enemy.IntentAction = 'CaptureDoll';
            enemy.IntentLeashPoint = KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["dropoff"]);
        },
        arrive: (enemy, AIData) => {
            if (KDGameData.PrisonerState == 'parole') {
                KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonJailer" + KDJailPersonality(enemy) + "Mistake").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 6, 8);
                KDBreakTether();
                if (enemy.IntentLeashPoint)
                    KDMovePlayer(enemy.IntentLeashPoint.x, enemy.IntentLeashPoint.y, false, false);
                KDResetIntent(enemy, AIData);
                enemy.playWithPlayer = 0;
                enemy.playWithPlayerCD = 24;
                return true;
            }
            AIData.defeat = true;
            KDBreakTether();
            return false;
        },
    },
    "leashFurnitureAggressive": {
        noplay: true,
        aggressive: true,
        weight: (enemy, AIData, allied, hostile, aggressive) => {
            if (!enemy.Enemy.tags.leashing)
                return 0;
            if (KinkyDungeonFlags.get("Released"))
                return 0;
            if (KDGameData.PrisonerState == 'jail')
                return 0;
            if (KinkyDungeonGetRestraintItem("ItemDevices"))
                return 0;
            let nearestfurniture = KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["furniture"]);
            return nearestfurniture && KDistChebyshev(enemy.x - nearestfurniture.x, enemy.y - nearestfurniture.y) < 14 ? (hostile ? 120 : (AIData.domMe ? 0 : 40)) : 0;
        },
        trigger: (enemy, AIData) => {
            KDResetIntent(enemy, AIData);
            enemy.IntentAction = 'leashFurnitureAggressive';
            let nearestfurniture = KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["furniture"]);
            enemy.IntentLeashPoint = nearestfurniture;
            KDAddThought(enemy.id, "Jail", 5, 3);
            let suff = (enemy.Enemy.playLine ? enemy.Enemy.playLine : "");
            KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJailPlay" + suff + "Leash").replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 4, 3);
        },
        arrive: (enemy, AIData) => {
            enemy.IntentAction = '';
            enemy.IntentLeashPoint = null;
            let res = KDSettlePlayerInFurniture(enemy, AIData, ["callGuardJailerOnly"]);
            if (res) {
                for (let e of KinkyDungeonEntities) {
                    if (e.hostile < 9000)
                        e.hostile = 0;
                    if (e.attackPoints > 0)
                        e.attackPoints = 0;
                    if (!e.ceasefire)
                        e.ceasefire = 1;
                }
                KDGameData.PrisonerState = 'jail';
            }
            return res;
        },
        maintain: (enemy, delta) => {
            if (KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 1.5) {
                if (enemy.playWithPlayer < 10) {
                    enemy.playWithPlayer = 10;
                }
            }
            return false;
        },
    },
};
function KDResetIntent(enemy, AIData) {
    enemy.IntentLeashPoint = null;
    enemy.IntentAction = "";
}
function KDSettlePlayerInFurniture(enemy, AIData, tags, guardDelay = 24) {
    let nearestfurniture = KinkyDungeonNearestJailPoint(enemy.x, enemy.y, ["furniture"]);
    let tile = KinkyDungeonTilesGet(nearestfurniture.x + "," + nearestfurniture.y);
    let type = tile ? tile.Furniture : undefined;
    let ee = KinkyDungeonEnemyAt(nearestfurniture.x, nearestfurniture.y);
    if (ee && ee != enemy) {
        KDKickEnemy(ee);
    }
    if (enemy.x == nearestfurniture.x && enemy.y == nearestfurniture.y)
        KDMoveEntity(enemy, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, true, undefined, undefined, true);
    KDMovePlayer(nearestfurniture.x, nearestfurniture.y, false);
    if (KinkyDungeonPlayerEntity.x == nearestfurniture.x && KinkyDungeonPlayerEntity.y == nearestfurniture.y) {
        let furn = KDFurniture[type];
        if (furn) {
            KinkyDungeonSetFlag("GuardCalled", guardDelay);
            if (tags) {
                for (let t of tags) {
                    KinkyDungeonSetFlag(t, guardDelay + 60);
                }
            }
            let rest = KinkyDungeonGetRestraint({ tags: [furn.restraintTag] }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], true, "", true, false, false);
            KinkyDungeonAddRestraintIfWeaker(rest, 0, true);
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
            KinkyDungeonMakeNoise(10, nearestfurniture.x, nearestfurniture.y);
        }
        KDResetAllAggro();
        KDResetAllIntents();
        KDBreakTether();
        return true;
    }
    return false;
}
let KDCurses = {
    "GhostLock": {
        condition: (item) => {
            return KinkyDungeonItemCount("Ectoplasm") >= 25;
        },
        remove: (item, host) => {
            KinkyDungeonChangeConsumable(KinkyDungeonConsumables.Ectoplasm, -25);
        }
    },
    "DollLock": {
        condition: (item) => {
            return KinkyDungeonItemCount("DollID") >= 8;
        },
        remove: (item, host) => {
            KinkyDungeonChangeConsumable(KinkyDungeonConsumables.DollID, -8);
        }
    },
    "MistressKey": {
        noShrine: true,
        condition: (item) => {
            return KinkyDungeonItemCount("MistressKey") > 0;
        },
        remove: (item, host) => {
            KinkyDungeonChangeConsumable(KinkyDungeonConsumables.MistressKey, -1);
        }
    },
    "5Keys": {
        condition: (item) => {
            return KinkyDungeonRedKeys >= 5;
        },
        remove: (item, host) => {
            KinkyDungeonRedKeys -= 5;
        }
    },
    "Key": {
        condition: (item) => {
            return KinkyDungeonRedKeys >= 1;
        },
        remove: (item, host) => {
            KinkyDungeonRedKeys -= 1;
        }
    },
    "BlueLock": {
        condition: (item) => {
            return KinkyDungeonBlueKeys >= 1;
        },
        remove: (item, host) => {
            KinkyDungeonBlueKeys -= 1;
        }
    },
    "TakeDamageFire": {
        condition: (item) => { return false; },
        remove: (item, host) => { },
        events: [
            { type: "RemoveOnDmg", power: 1, count: 3, damage: "fire", trigger: "beforePlayerDamage", kind: "CurseMelt" },
            { type: "RemoveOnDmg", power: 1, count: 3, damage: "crush", trigger: "beforePlayerDamage", kind: "CurseMelt" },
        ],
    },
    "TakeDamageIce": {
        condition: (item) => { return false; },
        remove: (item, host) => { },
        events: [
            { type: "RemoveOnDmg", power: 1, count: 4, damage: "ice", trigger: "beforePlayerDamage", kind: "CurseExtinguish" },
            { type: "RemoveOnDmg", power: 1, count: 4, damage: "acid", trigger: "beforePlayerDamage", kind: "CurseExtinguish" },
            { type: "RemoveOnDmg", power: 1, count: 4, damage: "stun", trigger: "beforePlayerDamage", kind: "CurseExtinguish" },
            { type: "RemoveOnBuffName", trigger: "tick", kind: "Drenched" },
            { type: "RemoveOnBuffName", trigger: "tick", kind: "Chilled" },
        ],
    },
    "TakeDamageElectric": {
        condition: (item) => { return false; },
        remove: (item, host) => { },
        events: [
            { type: "RemoveOnDmg", power: 1, count: 2, damage: "electric", trigger: "beforePlayerDamage", kind: "CurseShock" }
        ],
    },
    "TakeDamageGlue": {
        condition: (item) => { return false; },
        remove: (item, host) => { },
        events: [
            { type: "RemoveOnDmg", power: 1, count: 5, damage: "glue", trigger: "beforePlayerDamage", kind: "CurseGlue" }
        ],
    },
    "TakeDamageChain": {
        condition: (item) => { return false; },
        remove: (item, host) => { },
        events: [
            { type: "RemoveOnDmg", power: 1, count: 5, damage: "chain", trigger: "beforePlayerDamage", kind: "CurseChain" }
        ],
    },
    "Will": {
        onApply: (item, host) => {
            KinkyDungeonChangeWill(-1);
        },
        condition: (item) => {
            return KinkyDungeonStatWill >= KinkyDungeonStatWillMax * 0.99;
        },
        remove: (item, host) => {
        }
    },
    "Mana": {
        condition: (item) => {
            return KinkyDungeonStatMana + KinkyDungeonStatManaPool >= 20;
        },
        remove: (item, host) => {
            KinkyDungeonChangeMana(-20, false, 0, true, true);
        }
    },
    "ShrineWill": {
        condition: (item) => {
            return KDNearbyTiles(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 1.5).some((tile) => {
                var _a;
                return ((_a = tile === null || tile === void 0 ? void 0 : tile.tile) === null || _a === void 0 ? void 0 : _a.Type) == "Shrine" && tile.tile.Name == "Will";
            });
        }, remove: (item, host) => { }
    },
    "ShrineElements": {
        condition: (item) => {
            return KDNearbyTiles(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 1.5).some((tile) => {
                var _a;
                return ((_a = tile === null || tile === void 0 ? void 0 : tile.tile) === null || _a === void 0 ? void 0 : _a.Type) == "Shrine" && tile.tile.Name == "Elements";
            });
        }, remove: (item, host) => { }
    },
    "ShrineConjure": {
        condition: (item) => {
            return KDNearbyTiles(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 1.5).some((tile) => {
                var _a;
                return ((_a = tile === null || tile === void 0 ? void 0 : tile.tile) === null || _a === void 0 ? void 0 : _a.Type) == "Shrine" && tile.tile.Name == "Conjure";
            });
        }, remove: (item, host) => { }
    },
    "ShrineIllusion": {
        condition: (item) => {
            return KDNearbyTiles(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 1.5).some((tile) => {
                var _a;
                return ((_a = tile === null || tile === void 0 ? void 0 : tile.tile) === null || _a === void 0 ? void 0 : _a.Type) == "Shrine" && tile.tile.Name == "Illusion";
            });
        }, remove: (item, host) => { }
    },
};
let KDCursedVars = {
    "Light": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { type: "ItemLight", trigger: "getLights", power: 3.5, color: "#ffff55", inheritLinked: true },
                { trigger: "tick", type: "sneakBuff", power: -1.0, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Illumination", color: "#ff5555", inheritLinked: true },
            ]);
        }
    },
    "Attraction": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { type: "CurseAttraction", trigger: "calcPlayChance", power: 0.5, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Attraction", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
    "Sensitivity": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { type: "CurseSensitivity", trigger: "calcOrgThresh", power: 0.5, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Sensitivity", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
    "Submission": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { type: "CurseSubmission", trigger: "orgasm", power: 10, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Submission", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
    "Distraction": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { type: "multDistractionPos", trigger: "changeDistraction", power: 1.5, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Distraction", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
    "Breathlessness": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { type: "multStaminaPos", trigger: "changeStamina", power: 0.6, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Breathlessness", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
    "Futility": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { type: "multWillPos", trigger: "changeWill", power: 0.25, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Futile", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
    "Tickle": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { trigger: "tick", type: "tickleDrain", power: -0.02, inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Tickle", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
    "Punish": {
        level: 1,
        variant: (restraint, newRestraintName) => {
            return KDAddEventVariant(restraint, newRestraintName, [
                { trigger: "playerAttack", type: "cursePunish", chance: 1, damage: "souldrain", power: 1, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerCurse", inheritLinked: true },
                { trigger: "playerCast", type: "cursePunish", chance: 1, damage: "souldrain", power: 1, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerCurse", inheritLinked: true },
                { trigger: "drawSGTooltip", type: "curseInfo", msg: "Punish", color: "#ff5555", inheritLinked: true }
            ]);
        }
    },
};
let KDCurseVariantList = {
    "Basic": [
        "Tickle",
        "Punish",
        "Light",
        "Attraction",
        "Submission",
        "Distraction",
        "Breathlessness",
        "Futility",
        "Sensitivity",
    ],
};
let KDCurseUnlockList = {
    "Basic": [
        "ShrineWill",
        "ShrineIllusion",
        "ShrineElements",
        "ShrineConjure",
        "BlueLock",
        "Will",
        "TakeDamageFire",
        "TakeDamageElectric",
        "TakeDamageIce",
        "TakeDamageGlue",
        "TakeDamageChain",
        "Mana",
    ],
};
function KDAddEventVariant(restraint, newRestraintName, ev, power = 4, lock = "Purple", enemyTags = { basicCurse: 10 }) {
    var _a;
    KinkyDungeonDupeRestraintText(restraint.name, newRestraintName);
    let events = ev.concat(restraint.events);
    let escapeChance = {
        Struggle: Math.min(restraint.escapeChance.Struggle, 0 - .2),
        Cut: Math.min(restraint.escapeChance.Cut || 1.0, -0.1),
        Pick: Math.min(restraint.escapeChance.Pick || 1.0, 0.1),
    };
    return {
        protectionCursed: true,
        escapeChance: escapeChance,
        DefaultLock: lock,
        HideDefaultLock: true,
        magic: true,
        events: events,
        power: power,
        good: false,
        enemyTags: Object.assign({}, enemyTags),
        shrine: (_a = restraint.shrine) === null || _a === void 0 ? void 0 : _a.concat(["Cursed"]),
        inventoryAsSelf: restraint.inventoryAsSelf || restraint.inventoryAs || restraint.name,
        displayPower: restraint.displayPower || restraint.power,
    };
}
function KinkyDungeonCurseInfo(item, Curse) {
    if (Curse == "MistressKey" && KinkyDungeonItemCount("MistressKey")) {
        KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonCurseInfoMistressKeyHave").replace("KeyAmount", "" + KinkyDungeonItemCount("MistressKey")), "White", 2);
    }
    else {
        KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonCurseInfo" + Curse), "White", 2);
    }
}
function KinkyDungeonCurseStruggle(item, Curse) {
    if (Curse == "MistressKey") {
        KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonCurseStruggle" + Curse + item.name), "White", 2);
    }
    else
        KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonCurseStruggle" + Curse), "White", 2);
}
function KinkyDungeonCurseAvailable(item, Curse) {
    if (KDCurses[Curse] && KDCurses[Curse].condition(item)) {
        return true;
    }
    return false;
}
function KinkyDungeonCurseUnlock(group, index, Curse) {
    let unlock = true;
    let keep = false;
    let restraint = KinkyDungeonGetRestraintItem(group);
    let host = restraint;
    if (index) {
        let surfaceItems = KDDynamicLinkListSurface(restraint);
        if (surfaceItems[index]) {
            host = surfaceItems[index - 1];
            restraint = surfaceItems[index];
        }
        else
            console.log("Error! Please report the item combination and screenshot to Ada!");
    }
    if (KDCurses[Curse]) {
        KDCurses[Curse].remove(restraint, host);
    }
    if (unlock) {
        KDSendStatus('escape', KinkyDungeonGetRestraintItem(group).name, "Curse");
        KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonCurseUnlock" + Curse), "#99FF99", 2);
        if (restraint != host) {
            KinkyDungeonRemoveDynamicRestraint(host, keep, undefined, KinkyDungeonPlayerEntity);
        }
        else {
            KinkyDungeonRemoveRestraint(group, keep, undefined, undefined, undefined, undefined, KinkyDungeonPlayerEntity);
        }
    }
}
let KinkyDungeonRestraintsLocked = [];
let KDWillEscapePenalty = 0.25;
let KDWillEscapePenaltyArms = 0.1;
let KDWillEscapePenaltyStart = 0.0;
let KDWillEscapePenaltyStartArms = 0.0;
let KDWillEscapePenaltyEnd = 0.0;
let KDMinEscapeRate = 0.2;
let KDMinPickRate = 0.2;
let KDStruggleTime = 3;
let StruggleTypeHandThresh = {
    Struggle: 0.01,
    Unlock: 0.85,
    Pick: 0.45,
    Cut: 0.7,
    Remove: 0.99,
};
function KDGetWillPenalty() {
    let perc = KinkyDungeonStatWill / KinkyDungeonStatWillMax;
    let scale = 0;
    let scalestart = KDWillEscapePenaltyStart;
    let max = KDWillEscapePenalty;
    if (!KinkyDungeonIsArmsBound(true)) {
        scalestart = KDWillEscapePenaltyStartArms;
        max = KDWillEscapePenaltyArms;
    }
    if (perc < scalestart) {
        if (scalestart - KDWillEscapePenaltyEnd > 0)
            scale = Math.min(1.0, (scalestart - perc) / (scalestart - KDWillEscapePenaltyEnd));
        else if (perc <= 0)
            scale = 1.0;
    }
    return scale * max;
}
let KinkyDungeonCurrentEscapingItem = null;
let KinkyDungeonCurrentEscapingMethod = null;
let KinkyDungeonStruggleTime = 0;
let KinkyDungeonMultiplayerInventoryFlag = false;
let KinkyDungeonItemDropChanceArmsBound = 0.2;
let KinkyDungeonKeyJamChance = 0.33;
let KinkyDungeonKeyPickBreakAmount = 12;
let KinkyDungeonKeyPickBreakAmountBase = 12;
let KinkyDungeonPickBreakProgress = 0;
let KinkyDungeonKnifeBreakAmount = 10;
let KinkyDungeonKnifeBreakAmountBase = 10;
let KinkyDungeonKnifeBreakProgress = 0;
let KinkyDungeonEnchKnifeBreakAmount = 24;
let KinkyDungeonEnchKnifeBreakAmountBase = 24;
let KinkyDungeonEnchKnifeBreakProgress = 0;
let KinkyDungeonMaxImpossibleAttempts = 3;
let KinkyDungeonEnchantedKnifeBonus = 0.1;
let KDLocksmithPickBonus = 0.15;
let KDLocksmithBonus = 0.15;
let KDLocksmithSpeedBonus = 2.0;
let KDCluelessPickBonus = -0.2;
let KDCluelessBonus = -0.25;
let KDCluelessSpeedBonus = 0.5;
let KDFlexibleBonus = 0.1;
let KDFlexibleSpeedBonus = 1.5;
let KDInflexibleMult = 0.5;
let KDInflexibleSpeedBonus = 0.75;
let KDUnchainedBonus = 0.12;
let KDDamselBonus = -0.2;
let KDDamselPickAmount = 6;
let KDArtistBonus = 0.15;
let KDBunnyBonus = -0.2;
let KDBunnyKnifeAmount = 5;
let KDBunnyEnchKnifeAmount = 12;
let KDSlipperyBonus = 0.15;
let KDDollBonus = -0.2;
let KDEscapeeBonus = 0.12;
let KDDragonBonus = -0.2;
let KDStrongBonus = 0.15;
let KDWeakBonus = -0.15;
let KDBondageLoverAmount = 1;
let KinkyDungeonRestraintsCache = new Map();
function KDRestraint(item) {
    return KinkyDungeonRestraintsCache.get(item.name);
}
function KDItemIsMagic(item) {
    let res = KinkyDungeonRestraintsCache.get(item.name);
    if (!res.magic)
        return false;
    let disenchlevel = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Disenchant");
    return !(disenchlevel > res.power);
}
const KinkyDungeonStrictnessTable = new Map([
    ["ItemHood", ["ItemHead", "ItemEars", "ItemMouth", "ItemMouth2", "ItemMouth3"]],
    ["ItemHead", ["ItemEars", "ItemMouth"]],
    ["ItemMouth", ["ItemMouth"]],
    ["ItemNeck", ["ItemMouth", "ItemArms"]],
    ["ItemArms", ["ItemHands"]],
    ["ItemHands", ["ItemHands"]],
    ["ItemTorso", ["ItemArms", "ItemLegs", "ItemPelvis", "ItemBreast"]],
    ["ItemLegs", ["ItemFeet", "ItemBoots"]],
    ["ItemFeet", ["ItemBoots"]],
]);
let KDRestraintGroupProgressiveOrderStrict = [
    "ItemPelvis",
    "ItemBreast",
    "ItemTorso",
    "ItemBoots",
    "ItemEars",
    "ItemHead",
    "ItemLegs",
    "ItemHands",
    "ItemMouth",
    "ItemFeet",
    "ItemArms",
];
let KDRestraintGroupProgressiveOrderFun = [
    "ItemPelvis",
    "ItemBreast",
    "ItemTorso",
    "ItemBoots",
    "ItemMouth",
    "ItemHands",
    "ItemLegs",
    "ItemArms",
    "ItemFeet",
    "ItemHead",
    "ItemEars",
];
let KDRestraintsCache = new Map();
let KDTetherGraphics = new PIXI.Graphics;
KDTetherGraphics.zIndex = 2;
let KDGameBoardAddedTethers = false;
function KinkyDungeonDrawTethers(Entity, CamX, CamY) {
    var _a;
    if (!KDGameBoardAddedTethers) {
        kdgameboard.addChild(KDTetherGraphics);
    }
    KDTetherGraphics.clear();
    for (let inv of KinkyDungeonAllRestraint()) {
        if (inv && KDRestraint(inv).tether && inv.tx && inv.ty) {
            let vx = inv.tx;
            let vy = inv.ty;
            if (inv.tetherToLeasher && KinkyDungeonLeashingEnemy()) {
                vx = KinkyDungeonLeashingEnemy().visual_x;
                vy = KinkyDungeonLeashingEnemy().visual_y;
            }
            if (inv.tetherToGuard && KinkyDungeonJailGuard()) {
                vx = KinkyDungeonJailGuard().visual_x;
                vy = KinkyDungeonJailGuard().visual_y;
            }
            let xx = canvasOffsetX + (Entity.visual_x - CamX) * KinkyDungeonGridSizeDisplay;
            let yy = canvasOffsetY + (Entity.visual_y - CamY) * KinkyDungeonGridSizeDisplay;
            let txx = canvasOffsetX + (vx - CamX) * KinkyDungeonGridSizeDisplay;
            let tyy = canvasOffsetY + (vy - CamY) * KinkyDungeonGridSizeDisplay;
            let dx = (txx - xx);
            let dy = (tyy - yy);
            let dd = 0.1;
            let color = ((_a = KDRestraint(inv).Color[0]) === null || _a === void 0 ? void 0 : _a.length) > 3 ? KDRestraint(inv).Color[0] : KDRestraint(inv).Color;
            if (!color || color == "Default")
                color = "#aaaaaa";
            KDTetherGraphics.lineStyle(4, string2hex(color), 1);
            for (let d = 0; d < 1; d += dd) {
                let yOffset = 30 * Math.sin(Math.PI * d);
                let yOffset2 = 30 * Math.sin(Math.PI * (d + dd));
                KDTetherGraphics.moveTo(KinkyDungeonGridSizeDisplay / 2 + xx + dx * d, KinkyDungeonGridSizeDisplay * 0.8 + yOffset + yy + dy * d);
                KDTetherGraphics.lineTo(KinkyDungeonGridSizeDisplay / 2 + xx + dx * (d + dd), KinkyDungeonGridSizeDisplay * 0.8 + yOffset2 + yy + dy * (d + dd));
            }
            return;
        }
    }
}
function KDIsPlayerTethered(player) {
    let inv = KinkyDungeonGetRestraintItem("ItemNeckRestraints");
    if (inv && KDRestraint(inv).tether && (inv.tx || inv.ty)) {
        return true;
    }
    let found = KinkyDungeonFindID(KDGameData.KinkyDungeonLeashingEnemy);
    if (!found)
        KDGameData.KinkyDungeonLeashingEnemy = 0;
    return KDGameData.KinkyDungeonLeashedPlayer > 0;
}
function KinkyDungeonAttachTetherToEntity(dist, entity) {
    let inv = KinkyDungeonGetRestraintItem("ItemNeckRestraints");
    if (inv && KDRestraint(inv).tether) {
        let newLeash = inv.tetherEntity != entity.id;
        inv.tetherEntity = entity.id;
        if (dist)
            inv.tetherLength = dist;
        return newLeash;
    }
    return false;
}
function KDBreakTether() {
    for (let pair of KinkyDungeonAllRestraintDynamic()) {
        let inv = pair.item;
        if (inv && KDRestraint(inv).tether) {
            inv.tetherToLeasher = false;
            inv.tetherToGuard = false;
            inv.tetherEntity = undefined;
            inv.tx = undefined;
            inv.ty = undefined;
        }
    }
}
let KDLeashPullCost = 0.5;
let KDLeashPullKneelTime = 5;
function KinkyDungeonUpdateTether(Msg, Entity, xTo, yTo) {
    var _a;
    if (Entity.player && KinkyDungeonFlags.get("pulled"))
        return false;
    else if (KDEnemyHasFlag(Entity, "pulled"))
        return false;
    let exceeded = false;
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv).tether && (inv.tx && inv.ty || inv.tetherToLeasher || inv.tetherToGuard || inv.tetherEntity)) {
            let tether = inv.tetherLength ? inv.tetherLength : KDRestraint(inv).tether;
            if (inv.tetherToLeasher && KinkyDungeonLeashingEnemy()) {
                inv.tx = KinkyDungeonLeashingEnemy().x;
                inv.ty = KinkyDungeonLeashingEnemy().y;
            }
            else if (inv.tetherToLeasher && !KinkyDungeonLeashingEnemy()) {
                inv.tetherToLeasher = undefined;
                inv.tx = undefined;
                inv.ty = undefined;
            }
            if (inv.tetherToGuard && KinkyDungeonJailGuard()) {
                inv.tx = KinkyDungeonJailGuard().x;
                inv.ty = KinkyDungeonJailGuard().y;
            }
            else if (inv.tetherToGuard && !KinkyDungeonJailGuard()) {
                inv.tetherToGuard = undefined;
                inv.tx = undefined;
                inv.ty = undefined;
            }
            if (inv.tetherEntity && KinkyDungeonFindID(inv.tetherEntity) && !KinkyDungeonIsDisabled(KinkyDungeonFindID(inv.tetherEntity))) {
                inv.tx = KinkyDungeonFindID(inv.tetherEntity).x;
                inv.ty = KinkyDungeonFindID(inv.tetherEntity).y;
            }
            else if (inv.tetherEntity) {
                inv.tetherEntity = undefined;
                inv.tx = undefined;
                inv.ty = undefined;
            }
            if (inv.tx && inv.ty)
                KDGameData.KinkyDungeonLeashedPlayer = Math.max(KDGameData.KinkyDungeonLeashedPlayer, 5);
            if (xTo || yTo) {
                let pathToTether = KinkyDungeonFindPath(xTo, yTo, inv.tx, inv.ty, false, !Entity.player, false, KinkyDungeonMovableTilesSmartEnemy);
                let playerDist = Math.max((pathToTether === null || pathToTether === void 0 ? void 0 : pathToTether.length) || 0, KDistChebyshev(xTo - inv.tx, yTo - inv.ty));
                if (playerDist > KDRestraint(inv).tether) {
                    if (Msg)
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonTetherTooShort").replace("TETHER", TextGet("Restraint" + inv.name)), "#ff0000", 2, true);
                    if (KinkyDungeonCanStand()) {
                        KDGameData.KneelTurns = Math.max(KDGameData.KneelTurns, KDLeashPullKneelTime + KinkyDungeonSlowMoveTurns);
                        KinkyDungeonChangeWill(-KDLeashPullCost, false);
                    }
                    return true;
                }
            }
            else {
                for (let i = 0; i < 10; i++) {
                    let pathToTether = KinkyDungeonFindPath(Entity.x, Entity.y, inv.tx, inv.ty, false, !Entity.player, false, KinkyDungeonMovableTilesSmartEnemy);
                    let playerDist = pathToTether === null || pathToTether === void 0 ? void 0 : pathToTether.length;
                    if (!pathToTether)
                        playerDist = KDistChebyshev(Entity.x - inv.tx, Entity.y - inv.ty);
                    if (playerDist > tether) {
                        let slot = null;
                        if (pathToTether
                            && (pathToTether === null || pathToTether === void 0 ? void 0 : pathToTether.length) > 0
                            && (KDistEuclidean(pathToTether[0].x - inv.tx, pathToTether[0].y - inv.ty) > -0.01 + KDistEuclidean(Entity.x - inv.tx, Entity.y - inv.ty)
                                || ((_a = KinkyDungeonFindPath(pathToTether[0].x, pathToTether[0].y, inv.tx, inv.ty, false, !Entity.player, false, KinkyDungeonMovableTilesSmartEnemy)) === null || _a === void 0 ? void 0 : _a.length) < pathToTether.length) && KDistChebyshev(pathToTether[0].x - Entity.x, pathToTether[0].y - Entity.y) < 1.5)
                            slot = pathToTether[0];
                        if (!slot) {
                            let mindist = playerDist;
                            for (let X = Entity.x - 1; X <= Entity.x + 1; X++) {
                                for (let Y = Entity.y - 1; Y <= Entity.y + 1; Y++) {
                                    if ((X != Entity.x || Y != Entity.y) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(X, Y)) && KDistEuclidean(X - inv.tx, Y - inv.ty) < mindist) {
                                        mindist = KDistEuclidean(X - inv.tx, Y - inv.ty);
                                        slot = { x: X, y: Y };
                                    }
                                }
                            }
                        }
                        if (!slot) {
                            slot = { x: inv.tx, y: inv.ty };
                        }
                        if (slot) {
                            let enemy = KinkyDungeonEnemyAt(slot.x, slot.y);
                            if (enemy) {
                                let slot2 = null;
                                let mindist2 = playerDist;
                                for (let X = enemy.x - 1; X <= enemy.x + 1; X++) {
                                    for (let Y = enemy.y - 1; Y <= enemy.y + 1; Y++) {
                                        if ((X != enemy.x || Y != enemy.y) && !KinkyDungeonEntityAt(slot.x, slot.y) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(X, Y)) && KDistEuclidean(X - Entity.x, Y - Entity.y) < mindist2) {
                                            mindist2 = KDistEuclidean(X - Entity.x, Y - Entity.y);
                                            slot2 = { x: X, y: Y };
                                        }
                                    }
                                }
                                if (slot2) {
                                    KDMoveEntity(enemy, slot2.x, slot2.y, false);
                                }
                                else {
                                    let pointSwap = KinkyDungeonGetNearbyPoint(slot.x, slot.y, true, undefined, true, true);
                                    if (pointSwap)
                                        KDMoveEntity(enemy, pointSwap.x, pointSwap.y, false);
                                    else
                                        KDMoveEntity(enemy, Entity.x, Entity.y, false, undefined, undefined, true);
                                }
                            }
                            if (KinkyDungeonMapGet(slot.x, slot.y) == 'D')
                                KinkyDungeonMapSet(slot.x, slot.y, 'd');
                            KDMoveEntity(Entity, slot.x, slot.y, false, undefined, undefined, true);
                            if (Entity.player)
                                KinkyDungeonSetFlag("pulled", 1);
                            else
                                KinkyDungeonSetEnemyFlag(Entity, "pulled");
                            if (Entity.player) {
                                KinkyDungeonInterruptSleep();
                                KinkyDungeonSendEvent("leashTug", { Entity: Entity, slot: slot, item: inv });
                                if (KinkyDungeonLeashingEnemy()) {
                                    KinkyDungeonSetEnemyFlag(KinkyDungeonLeashingEnemy(), "harshpull", 5);
                                }
                                if (Msg)
                                    KinkyDungeonSendActionMessage(9, TextGet("KinkyDungeonTetherPull").replace("TETHER", TextGet("Restraint" + inv.name)), "#ff0000", 2, true);
                                exceeded = true;
                            }
                        }
                    }
                }
            }
        }
    }
    return exceeded;
}
function KinkyDungeonTetherLength() {
    let inv = KinkyDungeonGetRestraintItem("ItemNeckRestraints");
    if (inv && KDRestraint(inv).tether && inv.tx && inv.ty) {
        return KDRestraint(inv).tether;
    }
    return undefined;
}
function KinkyDungeonKeyGetPickBreakChance(modifier) {
    let mult = (modifier) ? modifier : 1.0;
    let chance = 0;
    KinkyDungeonPickBreakProgress += mult;
    if (KinkyDungeonPickBreakProgress > KinkyDungeonKeyPickBreakAmount / 1.5)
        chance = (KinkyDungeonPickBreakProgress - KinkyDungeonKeyPickBreakAmount / 1.5) / (KinkyDungeonKeyPickBreakAmount + 1);
    return chance;
}
function KinkyDungeonGetKnifeBreakChance(modifier) {
    let mult = (modifier) ? modifier : 1.0;
    let chance = 0;
    KinkyDungeonKnifeBreakProgress += mult;
    if (KinkyDungeonKnifeBreakProgress > KinkyDungeonKnifeBreakAmount / 1.5)
        chance = (KinkyDungeonKnifeBreakProgress - KinkyDungeonKnifeBreakAmount / 1.5) / (KinkyDungeonKnifeBreakAmount + 1);
    return chance;
}
function KinkyDungeonGetEnchKnifeBreakChance(modifier) {
    let mult = (modifier) ? modifier : 1.0;
    let chance = 0;
    KinkyDungeonEnchKnifeBreakProgress += mult;
    if (KinkyDungeonEnchKnifeBreakProgress > KinkyDungeonEnchKnifeBreakAmount / 1.5)
        chance = (KinkyDungeonEnchKnifeBreakProgress - KinkyDungeonEnchKnifeBreakAmount / 1.5) / (KinkyDungeonEnchKnifeBreakAmount + 1);
    return chance;
}
function KinkyDungeonIsLockable(restraint) {
    if (restraint && restraint.escapeChance && (restraint.escapeChance.Pick != undefined || restraint.escapeChance.Unlock != undefined))
        return true;
    return false;
}
function KinkyDungeonLock(item, lock) {
    if (lock != "") {
        if (KinkyDungeonIsLockable(KDRestraint(item))) {
            item.lock = lock;
            if (lock == "Gold")
                item.lockTimer = MiniGameKinkyDungeonLevel + 2;
            if (!StandalonePatched)
                InventoryLock(KinkyDungeonPlayer, InventoryGet(KinkyDungeonPlayer, KDRestraint(item).AssetGroup ? KDRestraint(item).AssetGroup : KDRestraint(item).Group), "IntricatePadlock", Player.MemberNumber, true);
            item.pickProgress = 0;
            if (ArcadeDeviousChallenge && InventoryGet(KinkyDungeonPlayer, KDRestraint(item).AssetGroup ? KDRestraint(item).AssetGroup : KDRestraint(item).Group) && !KinkyDungeonRestraintsLocked.includes(KDRestraint(item).AssetGroup ? KDRestraint(item).AssetGroup : KDRestraint(item).Group)) {
                InventoryLock(Player, InventoryGet(Player, KDRestraint(item).AssetGroup ? KDRestraint(item).AssetGroup : KDRestraint(item).Group), "IntricatePadlock", null, false);
                KinkyDungeonPlayerNeedsRefresh = true;
            }
        }
    }
    else {
        item.lock = lock;
        InventoryUnlock(KinkyDungeonPlayer, KDRestraint(item).AssetGroup ? KDRestraint(item).AssetGroup : KDRestraint(item).Group);
        if (!KinkyDungeonRestraintsLocked.includes(KDRestraint(item).AssetGroup ? KDRestraint(item).AssetGroup : KDRestraint(item).Group))
            InventoryUnlock(Player, KDRestraint(item).AssetGroup ? KDRestraint(item).AssetGroup : KDRestraint(item).Group);
    }
}
function KDGetCurse(item) {
    var _a;
    return item.curse || ((_a = KDRestraint(item)) === null || _a === void 0 ? void 0 : _a.curse);
}
function KinkyDungeonGetRestraintsWithShrine(shrine, ignoreGold, recursive, ignoreNoShrine) {
    let ret = [];
    for (let item of KinkyDungeonAllRestraint()) {
        if (((!KDRestraint(item).noShrine && (!KDGetCurse(item) || !KDCurses[KDGetCurse(item)].noShrine)) || ignoreNoShrine) && KDRestraint(item).shrine && KDRestraint(item).shrine.includes(shrine) && (ignoreGold || item.lock != "Gold")) {
            ret.push(item);
        }
        if (recursive) {
            let link = item.dynamicLink;
            while (link) {
                if (((!KDRestraint(link).noShrine && (!KDGetCurse(link) || !KDCurses[KDGetCurse(link)].noShrine)) || ignoreNoShrine) && KDRestraint(link).shrine && KDRestraint(link).shrine.includes(shrine) && (ignoreGold || link.lock != "Gold")) {
                    ret.push(link);
                }
                link = link.dynamicLink;
            }
        }
    }
    return ret;
}
function KinkyDungeonRemoveRestraintsWithShrine(shrine, maxCount, recursive, noPlayer, ignoreGold, ignoreNoShrine) {
    let count = 0;
    for (let i = 0; i < (maxCount ? maxCount : 100); i++) {
        let items = KinkyDungeonAllRestraint().filter((r) => { return ((!KDRestraint(r).noShrine && (!KDGetCurse(r) || !KDCurses[KDGetCurse(r)].noShrine)) || ignoreNoShrine) && KDRestraint(r).shrine && KDRestraint(r).shrine.includes(shrine) && (ignoreGold || r.lock != "Gold"); });
        let item = items.length > 0 ? items.reduce((prev, current) => (KDRestraint(prev).power * KinkyDungeonGetLockMult(prev.lock) > KDRestraint(current).power * KinkyDungeonGetLockMult(current.lock)) ? prev : current) : null;
        if (item) {
            KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false, false, true, undefined, !noPlayer ? KinkyDungeonPlayerEntity : undefined);
            KDSendStatus('escape', item.name, "shrine_" + shrine);
            count++;
        }
        if (recursive) {
            items = KinkyDungeonGetRestraintsWithShrine(shrine, ignoreGold, true);
            item = items.length > 0 ? items.reduce((prev, current) => (KDRestraint(prev).power * KinkyDungeonGetLockMult(prev.lock) > KDRestraint(current).power * KinkyDungeonGetLockMult(current.lock)) ? prev : current) : null;
            if (item) {
                let groupItem = KinkyDungeonGetRestraintItem(KDRestraint(item).Group);
                if (groupItem == item) {
                    KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false, false, true, undefined, !noPlayer ? KinkyDungeonPlayerEntity : undefined);
                    KDSendStatus('escape', item.name, "shrine_" + shrine);
                    count++;
                }
                else {
                    let host = groupItem;
                    let link = host.dynamicLink;
                    while (link) {
                        if (link == item) {
                            KinkyDungeonRemoveDynamicRestraint(host, false, false, !noPlayer ? KinkyDungeonPlayerEntity : undefined);
                            KDSendStatus('escape', item.name, "shrine_" + shrine);
                            count++;
                            link = null;
                        }
                        else {
                            host = link;
                            link = link.dynamicLink;
                        }
                    }
                }
            }
        }
    }
    return count;
}
function KinkyDungeonUnlockRestraintsWithShrine(shrine) {
    let count = 0;
    for (let item of KinkyDungeonAllRestraint()) {
        if (item.lock && !KDRestraint(item).noShrine && (!KDGetCurse(item) || !KDCurses[KDGetCurse(item)].noShrine) && KDRestraint(item).shrine && KDRestraint(item).shrine.includes(shrine) && KDLocks[item.lock] && !KDLocks[item.lock].shrineImmune) {
            KinkyDungeonLock(item, "");
            count++;
        }
    }
    return count;
}
function KinkyDungeonPlayerGetLockableRestraints() {
    let ret = [];
    for (let item of KinkyDungeonAllRestraint()) {
        if (!item.lock && KDRestraint(item).escapeChance && KDRestraint(item).escapeChance.Pick != undefined) {
            ret.push(item);
        }
    }
    return ret;
}
function KinkyDungeonPlayerGetRestraintsWithLocks(Locks, recursive) {
    let ret = [];
    for (let itemhost of (recursive ? KinkyDungeonAllRestraintDynamic() : KinkyDungeonAllRestraint())) {
        let item = itemhost.item ? itemhost.item : itemhost;
        if (item && item.lock && Locks.includes(item.lock)) {
            ret.push(item);
        }
    }
    return ret;
}
function KinkyDungeonRemoveKeysUnlock(lock) {
    if (KDLocks[lock])
        KDLocks[lock].removeKeys({ unlock: true });
}
function KinkyDungeonGetKey(lock) {
    if (KDLocks[lock])
        return KDLocks[lock].key;
    return "";
}
function KinkyDungeonHasGhostHelp() {
    return ((KinkyDungeonTargetTile && ((KinkyDungeonTargetTile.Type == "Ghost" && KinkyDungeonTargetTile.GhostDecision <= 0) || KinkyDungeonTargetTile.Type == "Angel")));
}
function KinkyDungeonHasAllyHelp() {
    return (KDNearbyEnemies(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 1.5).some((enemy) => {
        return (KDEnemyHasFlag(enemy, "HelpMe") || enemy.Enemy.tags.alwayshelp)
            && enemy.Enemy.bound
            && !enemy.Enemy.tags.nohelp
            && !KDHelpless(enemy)
            && KDBoundEffects(enemy) < 4;
    })
        || KDNearbyEnemies(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 1.5).some((enemy) => {
            return enemy.Enemy.bound
                && !enemy.Enemy.tags.nohelp
                && KDAllied(enemy)
                && !KDHelpless(enemy)
                && KDBoundEffects(enemy) < 4;
        }));
}
KinkyDungeonSetFlag("HelpMeFlag", 20);
function KinkyDungeonHasAngelHelp() {
    return (KinkyDungeonTargetTile && KinkyDungeonTargetTile.Type == "Angel");
}
function KinkyDungeonIsWearingLeash() {
    for (let restraint of KinkyDungeonAllRestraint()) {
        if (KDRestraint(restraint) && KDRestraint(restraint).leash) {
            return true;
        }
    }
    return false;
}
let KDAffinityList = ["Hook", "Edge", "Sticky", "Sharp"];
function KinkyDungeonGetAffinity(Message, affinity, group) {
    let effectTiles = KDGetEffectTiles(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
    let groupIsHigh = !group || (group.startsWith("ItemM")
        || group == "ItemArms"
        || (group == "ItemHands" || !KinkyDungeonIsArmsBound())
        || group == "ItemEars"
        || group == "ItemHood"
        || group == "ItemHead"
        || group == "ItemNeck"
        || group == "ItemNeckAccessories"
        || group == "ItemNeckRestraints");
    let canStand = KinkyDungeonCanStand();
    if (effectTiles)
        for (let t of Object.values(effectTiles)) {
            if (t.affinities && t.affinities.includes(affinity))
                return true;
            else if (canStand && groupIsHigh && t.affinitiesStanding && t.affinitiesStanding.includes(affinity))
                return true;
        }
    if (affinity == "Hook") {
        let tile = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
        if (tile == '?') {
            if (canStand && groupIsHigh)
                return true;
            else
                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonHookHighFail"), "#ff0000", 2);
        }
        else if (KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y - 1) == ',')
            return true;
        return KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp();
    }
    else if (affinity == "Edge") {
        for (let X = KinkyDungeonPlayerEntity.x - 1; X <= KinkyDungeonPlayerEntity.x + 1; X++) {
            for (let Y = KinkyDungeonPlayerEntity.y - 1; Y <= KinkyDungeonPlayerEntity.y + 1; Y++) {
                let tile = KinkyDungeonMapGet(X, Y);
                if (tile == 'A'
                    || tile == 'a'
                    || tile == 'c'
                    || tile == 'O'
                    || tile == '-'
                    || tile == '='
                    || tile == '+'
                    || tile == 'o'
                    || tile == 'B') {
                    return true;
                }
                else if (tile == 'C' && Message) {
                    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonNeedOpenChest"), "#ff0000", 2, true);
                }
            }
        }
        return KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp();
    }
    else if (affinity == "Sticky") {
        return KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp();
    }
    else if (affinity == "Sharp") {
        if (((KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && KinkyDungeonAllWeapon().some((inv) => { return KDWeapon(inv).light && KDWeapon(inv).cutBonus != undefined; })) || KinkyDungeonWeaponCanCut(true))
            return true;
        if (KinkyDungeonAllWeapon().some((inv) => { return KDWeapon(inv).light && KDWeapon(inv).cutBonus != undefined; }) && (!KinkyDungeonIsArmsBound() || KinkyDungeonStatsChoice.has("Psychic") || KinkyDungeonWallCrackAndKnife(false)))
            return true;
        let tile = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
        if (tile == '/') {
            if (Message)
                KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonScrapUse"), "lightgreen", 2);
            return true;
        }
        for (let X = KinkyDungeonPlayerEntity.x - 1; X <= KinkyDungeonPlayerEntity.x + 1; X++) {
            for (let Y = KinkyDungeonPlayerEntity.y - 1; Y <= KinkyDungeonPlayerEntity.y + 1; Y++) {
                let tile2 = KinkyDungeonMapGet(X, Y);
                if (tile2 == '-'
                    || tile == 'a') {
                    if (Message)
                        KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonScrapObjectUse"), "lightgreen", 2);
                    return true;
                }
            }
        }
        return false;
    }
    return KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp();
}
function KinkyDungeonWallCrackAndKnife(Message) {
    for (let X = KinkyDungeonPlayerEntity.x - 1; X <= KinkyDungeonPlayerEntity.x + 1; X++) {
        for (let Y = KinkyDungeonPlayerEntity.y - 1; Y <= KinkyDungeonPlayerEntity.y + 1; Y++) {
            if (X == KinkyDungeonPlayerEntity.x || Y == KinkyDungeonPlayerEntity.y) {
                let tile = KinkyDungeonMapGet(X, Y);
                if (tile == '4' || tile == '\\') {
                    if (!KinkyDungeonIsArmsBound(true) || KinkyDungeonCanStand()) {
                        if (Message) {
                            if (!KinkyDungeonIsArmsBound(true))
                                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonUseCrack"), "lightgreen", 2, true);
                            else
                                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonUseCrackLegs"), "lightgreen", 2, true);
                        }
                        return true;
                    }
                    else {
                        if (Message) {
                            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonNeedCrack"), "#ff0000", 2, true);
                        }
                        return false;
                    }
                }
            }
        }
    }
    return false;
}
function KDIsTreeAccessible(item) {
    let link = item;
    while (link && KDRestraint(link)) {
        if (KDRestraint(link).inaccessible)
            return false;
        link = link.dynamicLink;
    }
    return true;
}
function KDIsTreeChastity(item) {
    let link = item;
    while (link && KDRestraint(link)) {
        if (KDRestraint(link).chastity)
            return false;
        link = link.dynamicLink;
    }
    return true;
}
function KDIsTreeChastityBra(item) {
    let link = item;
    while (link && KDRestraint(link)) {
        if (KDRestraint(link).chastitybra)
            return false;
        link = link.dynamicLink;
    }
    return true;
}
function KDGroupBlocked(Group, External) {
    if (KinkyDungeonPlayerTags.get("ChastityLower") && ["ItemVulva", "ItemVulvaPiercings", "ItemButt"].includes(Group))
        return true;
    if (KinkyDungeonPlayerTags.get("ChastityUpper") && ["ItemNipples", "ItemNipplesPiercings"].includes(Group))
        return true;
    if (KinkyDungeonPlayerTags.get("Block_" + Group))
        return true;
    if (Group.includes("ItemHands")) {
        let arms = KinkyDungeonGetRestraintItem("ItemArms");
        if (arms && !KDIsTreeAccessible(arms))
            return true;
    }
    return false;
}
function KDGetBlockingRestraints(Group, External) {
    var _a, _b, _c, _d;
    let map = new Map();
    let all = KinkyDungeonAllRestraintDynamic();
    if (KinkyDungeonPlayerTags.get("ChastityLower") && ["ItemVulva", "ItemVulvaPiercings", "ItemButt"].includes(Group)) {
        for (let item of all) {
            if (!map.get(item.item) && ((_a = KDRestraint(item.item)) === null || _a === void 0 ? void 0 : _a.chastity)) {
                map.set(item.item, true);
            }
        }
    }
    if (KinkyDungeonPlayerTags.get("ChastityUpper") && ["ItemNipples", "ItemNipplesPiercings"].includes(Group)) {
        for (let item of all) {
            if (!map.get(item.item) && ((_b = KDRestraint(item.item)) === null || _b === void 0 ? void 0 : _b.chastitybra)) {
                map.set(item.item, true);
            }
        }
    }
    if (KinkyDungeonPlayerTags.get("Block_" + Group)) {
        for (let item of all) {
            if (!map.get(item.item) && ((_d = (_c = KDRestraint(item.item)) === null || _c === void 0 ? void 0 : _c.shrine) === null || _d === void 0 ? void 0 : _d.includes("Block_" + Group))) {
                map.set(item.item, true);
            }
        }
    }
    if (Group.includes("ItemHands")) {
        let arms = KinkyDungeonGetRestraintItem("ItemArms");
        if (arms) {
            let link = arms;
            while (link && KDRestraint(link)) {
                if (KDRestraint(link).inaccessible && !map.get(link)) {
                    map.set(link, true);
                }
                link = link.dynamicLink;
            }
        }
    }
    return [...map.keys()];
}
function KDGetBlockingSecurity(Group, External) {
    let items = KDGetBlockingRestraints(Group, External);
    items = items.filter((item) => {
        var _a;
        return ((_a = KDRestraint(item)) === null || _a === void 0 ? void 0 : _a.Security) != undefined;
    });
    return items;
}
function KinkyDungeonCanUseKey() {
    return !KinkyDungeonIsHandsBound(true, false, 0.7) || KinkyDungeonStatsChoice.has("Psychic");
}
function KinkyDungeonIsHandsBound(ApplyGhost, Other, Threshold = 0.99) {
    let blocked = KDHandBondageTotal() > Threshold;
    let help = ApplyGhost && (KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp());
    if (!Other && (!ApplyGhost || !(help)) && KinkyDungeonStatsChoice.get("Butterfingers") && KinkyDungeonIsArmsBound(ApplyGhost, Other))
        return true;
    return (!ApplyGhost || !(help)) &&
        blocked;
}
function KDHandBondageTotal() {
    let total = 0;
    for (let rest of KinkyDungeonAllRestraintDynamic()) {
        let inv = rest.item;
        if (KDRestraint(inv).bindhands)
            total += KDRestraint(inv).bindhands;
    }
    return total;
}
function KinkyDungeonCanUseFeet() {
    return KinkyDungeonStatsChoice.get("Flexible") && KinkyDungeonSlowLevel < 1;
}
function KinkyDungeonIsArmsBound(ApplyGhost, Other) {
    let blocked = KDGroupBlocked("ItemArms");
    if (!blocked)
        for (let inv of KinkyDungeonAllRestraint()) {
            if (KDRestraint(inv).bindarms) {
                blocked = true;
                break;
            }
        }
    return (!ApplyGhost || !(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp())) &&
        blocked;
}
function KinkyDungeonStrictness(ApplyGhost, Group, excludeItem) {
    if (ApplyGhost && (KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()))
        return 0;
    let strictness = 0;
    for (let invItem of KinkyDungeonAllRestraint()) {
        let inv = invItem;
        while (inv) {
            if (inv != excludeItem && ((KDRestraint(inv).strictness && KDRestraint(inv).strictness > strictness))) {
                let strictGroups = KDRestraint(inv).strictnessZones || KinkyDungeonStrictnessTable.get(KDRestraint(inv).Group);
                if (strictGroups) {
                    for (let s of strictGroups) {
                        if (s == Group) {
                            if (KDRestraint(inv).strictness > strictness)
                                strictness = KDRestraint(inv).strictness;
                            break;
                        }
                    }
                }
            }
            inv = inv.dynamicLink;
        }
    }
    return strictness;
}
function KinkyDungeonGetStrictnessItems(Group, excludeItem) {
    let list = [];
    for (let invItem of KinkyDungeonAllRestraint()) {
        let inv = invItem;
        while (inv) {
            if (inv != excludeItem && KDRestraint(inv).strictness) {
                let strictGroups = KDRestraint(inv).strictnessZones || KinkyDungeonStrictnessTable.get(KDRestraint(inv).Group);
                if (strictGroups) {
                    for (let s of strictGroups) {
                        if (s == Group) {
                            if (KDRestraint(inv).strictness)
                                list.push(KDRestraint(inv).name);
                            break;
                        }
                    }
                }
            }
            inv = inv.dynamicLink;
        }
    }
    return list;
}
function KinkyDungeonGetPickBaseChance() {
    let bonus = 0;
    if (KinkyDungeonStatsChoice.get("Locksmith"))
        bonus += KDLocksmithPickBonus;
    if (KinkyDungeonStatsChoice.get("Clueless"))
        bonus += KDCluelessPickBonus;
    if (KinkyDungeonStatsChoice.get("LocksmithMaster"))
        bonus += 0.15;
    return 0.33 / (1.0 + 0.02 * MiniGameKinkyDungeonLevel) + bonus;
}
function KinkyDungeonGetPickBonus() {
    let bonus = 0;
    if (KinkyDungeonStatsChoice.get("Locksmith"))
        bonus += KDLocksmithBonus;
    if (KinkyDungeonStatsChoice.get("Clueless"))
        bonus += KDCluelessBonus;
    if (KinkyDungeonStatsChoice.get("LocksmithMaster"))
        bonus += 0.15;
    return bonus;
}
function KinkyDungeonPickAttempt() {
    let Pass = "Fail";
    let escapeChance = KinkyDungeonGetPickBaseChance();
    let cost = KinkyDungeonStatStaminaCostPick;
    let wcost = KinkyDungeonStatWillCostPick;
    let lock = KinkyDungeonTargetTile.Lock;
    if (!KinkyDungeonTargetTile.pickProgress)
        KinkyDungeonTargetTile.pickProgress = 0;
    if (!lock)
        return;
    KinkyDungeonInterruptSleep();
    if (KDLocks[lock] && !KDLocks[lock].pickable) {
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggleCantPick" + lock + "Lock"), "orange", 2, true);
        Pass = "Fail";
    }
    let handsBound = KinkyDungeonIsHandsBound(false, true, 0.55) && !KinkyDungeonCanUseFeet();
    let armsBound = KinkyDungeonIsArmsBound();
    let strict = KinkyDungeonStrictness(false, "ItemHands");
    if (!strict)
        strict = 0;
    if (armsBound)
        escapeChance = Math.max(0.0, escapeChance - 0.25);
    if (handsBound && strict < 0.5)
        escapeChance = Math.max(0, escapeChance - 0.5);
    else if (strict)
        escapeChance = Math.max(0, escapeChance - strict);
    escapeChance /= 1.0 + KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax * KinkyDungeonDistractionUnlockSuccessMod;
    let chargecosts = true;
    if (wcost > 0 && !KinkyDungeonHasWill(-wcost, false)) {
        chargecosts = false;
        KinkyDungeonSendActionMessage(10, TextGet("KDWillStruggle"), "#ff0000", 2, true);
    }
    else if (!KinkyDungeonHasStamina(-cost, true)) {
        chargecosts = false;
        KinkyDungeonWaitMessage(true);
    }
    else if (KinkyDungeonTargetTile && KinkyDungeonTargetTile.pickProgress >= 1) {
        Pass = "Success";
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Unlock.ogg");
    }
    else if (KDLocks[lock] && KDLocks[lock].breakChance({})) {
        Pass = "Break";
        KinkyDungeonLockpicks -= 1;
        KinkyDungeonPickBreakProgress = 0;
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/PickBreak.ogg");
    }
    else if (!KinkyDungeonStatsChoice.get("Psychic") && (handsBound || (armsBound && KDRandom() < KinkyDungeonItemDropChanceArmsBound))) {
        KinkyDungeonDropItem({ name: "Pick" }, KinkyDungeonPlayerEntity, true);
        KinkyDungeonLockpicks -= 1;
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Miss.ogg");
    }
    else {
        KinkyDungeonTargetTile.pickProgress += escapeChance;
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Pick.ogg");
    }
    KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonAttemptPick" + Pass).replace("TargetRestraint", TextGet("KinkyDungeonObject")), (Pass == "Success") ? "lightgreen" : "#ff0000", 1);
    if (chargecosts) {
        KinkyDungeonChangeStamina(cost, 1);
        KinkyDungeonChangeWill(wcost);
    }
    return Pass == "Success";
}
function KinkyDungeonUnlockAttempt(lock) {
    let Pass = "Fail";
    let escapeChance = 1.0;
    KinkyDungeonInterruptSleep();
    let handsBound = KinkyDungeonIsHandsBound(false, true, 0.85) && !KinkyDungeonCanUseFeet();
    let armsBound = KinkyDungeonIsArmsBound();
    let strict = KinkyDungeonStrictness(false, "ItemHands");
    if (!strict)
        strict = 0;
    if (armsBound)
        escapeChance = Math.max(0.1, escapeChance - 0.25);
    if (handsBound && strict < 0.5)
        escapeChance = Math.max(0, escapeChance - 0.5);
    else if (strict)
        escapeChance = Math.max(0, escapeChance - strict);
    if (KinkyDungeonStatsChoice.get("Psychic"))
        escapeChance = Math.max(escapeChance, 0.33);
    if (KDRandom() < escapeChance)
        Pass = "Success";
    KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonStruggleUnlock" + Pass).replace("TargetRestraint", TextGet("KinkyDungeonObject")), (Pass == "Success") ? "lightgreen" : "#ff0000", 1);
    if (Pass == "Success") {
        KinkyDungeonRemoveKeysUnlock(lock);
        if (KDLocks[lock] && KDLocks[lock].loot_special && KinkyDungeonTargetTile && KinkyDungeonTargetTile.Loot == "normal")
            KinkyDungeonSpecialLoot = true;
        else if (KDLocks[lock] && KDLocks[lock].loot_locked && KinkyDungeonTargetTile && KinkyDungeonTargetTile.Loot == "normal")
            KinkyDungeonLockedLoot = true;
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Unlock.ogg");
        return true;
    }
    else if (!KinkyDungeonStatsChoice.get("Psychic") && (handsBound || (armsBound && KDRandom() < KinkyDungeonItemDropChanceArmsBound))) {
        let keytype = KinkyDungeonGetKey(lock);
        if (keytype) {
            KinkyDungeonDropItem({ name: keytype + "Key" }, KinkyDungeonPlayerEntity, true);
            KDLocks[lock].removeKeys({ dropped: true });
        }
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Miss.ogg");
    }
    else {
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Pick.ogg");
    }
    return false;
}
function KDGetRestraintAffinity(item, data) {
    data.item = item;
    data.affinity = "";
    data.overrideAffinity = false;
    if (KDRestraint(item) && KDRestraint(item).affinity) {
        if (KDRestraint(item).affinity[data.StruggleType]) {
            for (let a of KDRestraint(item).affinity[data.StruggleType]) {
                data.affinity = a;
                if (KinkyDungeonGetAffinity(false, a, data.StruggleGroup))
                    break;
            }
        }
    }
    KinkyDungeonSendEvent("beforeAffinityCalc", data);
    if (!data.overrideAffinity && data.affinity == "") {
        switch (data.StruggleType) {
            case "Struggle":
                data.affinity = "Hook";
                break;
            case "Remove":
                data.affinity = "Edge";
                break;
            case "Cut":
                data.affinity = "Sharp";
                break;
            case "Pick":
                data.affinity = "";
                break;
            case "Unlock":
                data.affinity = "Sticky";
                break;
        }
    }
    return data.affinity;
}
function KDGetEscapeChance(restraint, StruggleType, escapeChancePre, limitChancePre, ApplyGhost, ApplyPlayerBonus, Msg) {
    let escapeChance = escapeChancePre != undefined ? escapeChancePre : KDRestraint(restraint).escapeChance[StruggleType] != undefined ? KDRestraint(restraint).escapeChance[StruggleType] : 1.0;
    let limitChance = limitChancePre != undefined ? limitChancePre : (KDRestraint(restraint).limitChance != undefined && KDRestraint(restraint).limitChance[StruggleType] != undefined) ? KDRestraint(restraint).limitChance[StruggleType] :
        ((StruggleType == "Unlock" || StruggleType == "Pick") ? 0 : 0.05);
    if ((!ApplyGhost || !(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp())) && !ApplyPlayerBonus) {
        if (StruggleType == "Pick") {
            if (KinkyDungeonStatsChoice.get("Locksmith"))
                escapeChance += KDLocksmithBonus;
            if (KinkyDungeonStatsChoice.get("Clueless"))
                escapeChance += KDCluelessBonus;
        }
        else if (StruggleType == "Remove" || StruggleType == "Unlock") {
            if (KinkyDungeonStatsChoice.get("Flexible"))
                escapeChance += KDFlexibleBonus;
            if (KinkyDungeonStatsChoice.get("Inflexible"))
                escapeChance *= KDInflexibleMult;
        }
        else if (StruggleType == "Struggle") {
            if (KinkyDungeonStatsChoice.get("Strong"))
                escapeChance += KDStrongBonus;
            if (KinkyDungeonStatsChoice.get("Weak"))
                escapeChance += KDWeakBonus;
        }
    }
    if (KinkyDungeonStatsChoice.get("Unchained") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Metal"))
        escapeChance += KDUnchainedBonus;
    if (KinkyDungeonStatsChoice.get("Damsel") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Metal")) {
        if (escapeChance > 0)
            escapeChance /= 1.5;
        if (StruggleType != "Pick" && StruggleType != "Unlock" && limitChance > 0 && limitChance < KDDamselBonus)
            limitChance = KDDamselBonus;
    }
    if (KinkyDungeonStatsChoice.get("HighSecurity")) {
        KinkyDungeonKeyPickBreakAmount = KDDamselPickAmount;
    }
    else {
        KinkyDungeonKeyPickBreakAmount = KinkyDungeonKeyPickBreakAmountBase;
    }
    if (KinkyDungeonStatsChoice.get("FreeSpirit") && (KDRestraint(restraint).chastity || KDRestraint(restraint).chastitybra))
        escapeChance += 0.5;
    if (KinkyDungeonStatsChoice.get("Artist") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Rope"))
        escapeChance += KDArtistBonus;
    if (KinkyDungeonStatsChoice.get("Bunny") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Rope")) {
        if (escapeChance > 0)
            escapeChance /= 1.5;
        if (StruggleType != "Pick" && StruggleType != "Unlock" && limitChance > 0 && limitChance < KDBunnyBonus)
            limitChance = KDBunnyBonus;
    }
    if (KinkyDungeonStatsChoice.get("ShoddyKnives")) {
        KinkyDungeonKnifeBreakAmount = KDBunnyKnifeAmount;
        KinkyDungeonEnchKnifeBreakAmount = KDBunnyEnchKnifeAmount;
    }
    else {
        KinkyDungeonKnifeBreakAmount = KinkyDungeonKnifeBreakAmountBase;
        KinkyDungeonEnchKnifeBreakAmount = KinkyDungeonEnchKnifeBreakAmountBase;
    }
    if (KinkyDungeonStatsChoice.get("Slippery") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Latex"))
        escapeChance += KDSlipperyBonus;
    else if (KinkyDungeonStatsChoice.get("Doll") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Latex")) {
        if (escapeChance > 0)
            escapeChance /= 1.5;
        if (StruggleType != "Pick" && StruggleType != "Unlock" && limitChance > 0 && limitChance < KDDollBonus)
            limitChance = KDDollBonus;
    }
    if (KinkyDungeonStatsChoice.get("Escapee") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Leather"))
        escapeChance += KDEscapeeBonus;
    else if (KinkyDungeonStatsChoice.get("Dragon") && KDRestraint(restraint).shrine && KDRestraint(restraint).shrine.includes("Leather")) {
        if (escapeChance > 0)
            escapeChance /= 1.5;
        if (StruggleType != "Pick" && StruggleType != "Unlock" && limitChance > 0 && limitChance < KDDragonBonus)
            limitChance = KDDragonBonus;
    }
    let data = {
        restraint: restraint,
        escapeChance: escapeChance,
        limitChance: limitChance,
        struggleType: StruggleType,
        escapeChancePre: escapeChancePre,
        limitChancePre: limitChancePre,
        ApplyGhost: ApplyGhost,
        ApplyPlayerBonus: ApplyPlayerBonus,
        GoddessBonus: 0,
        Msg: Msg,
    };
    let GoddessBonus = KDGetItemGoddessBonus(restraint, data);
    data.escapeChance += GoddessBonus;
    data.GoddessBonus = GoddessBonus;
    KinkyDungeonSendEvent("perksStruggleCalc", data);
    return {
        escapeChance: data.escapeChance,
        limitChance: data.limitChance,
        escapeChanceData: data,
    };
}
let KDUnboundAffinityOverride = {
    "Sticky": true,
    "Edge": true,
    "Hook": true,
};
function KDGetDynamicItem(group, index) {
    let restraint = KinkyDungeonGetRestraintItem(group);
    let host = restraint;
    if (index) {
        let surfaceItems = KDDynamicLinkListSurface(restraint);
        if (surfaceItems[index]) {
            host = surfaceItems[index - 1];
            restraint = surfaceItems[index];
        }
        else
            console.log("Error! Please report the item combination and screenshot to Ada!");
    }
    return { restraint: restraint, host: host };
}
function KinkyDungeonStruggle(struggleGroup, StruggleType, index) {
    var _a, _b, _c, _d;
    let restraint = KinkyDungeonGetRestraintItem(struggleGroup);
    let host = restraint;
    if (index) {
        let surfaceItems = KDDynamicLinkListSurface(restraint);
        if (surfaceItems[index]) {
            host = surfaceItems[index - 1];
            restraint = surfaceItems[index];
        }
        else
            console.log("Error! Please report the item combination and screenshot to Ada!");
    }
    let failSuffix = "";
    if (restraint && KDRestraint(restraint).failSuffix && KDRestraint(restraint).failSuffix[StruggleType]) {
        failSuffix = KDRestraint(restraint).failSuffix[StruggleType];
    }
    if (!restraint)
        return "Fail";
    KinkyDungeonCurrentEscapingItem = restraint;
    KinkyDungeonCurrentEscapingMethod = StruggleType;
    KinkyDungeonStruggleTime = CommonTime() + 750;
    let Pass = "Fail";
    let restraintEscapeChancePre = KDRestraint(restraint).escapeChance[StruggleType] != undefined ? KDRestraint(restraint).escapeChance[StruggleType] : 1.0;
    let helpChance = (KDRestraint(restraint).helpChance != undefined && KDRestraint(restraint).helpChance[StruggleType] != undefined) ? KDRestraint(restraint).helpChance[StruggleType] : 0.0;
    let limitChance = (KDRestraint(restraint).limitChance != undefined && KDRestraint(restraint).limitChance[StruggleType] != undefined) ? KDRestraint(restraint).limitChance[StruggleType] :
        ((StruggleType == "Unlock" || StruggleType == "Pick") ? 0 : 0.05);
    if (KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) {
        KinkyDungeonSetFlag("HelpMeFlag", 8);
        if (helpChance)
            restraintEscapeChancePre = helpChance;
        limitChance = 0;
    }
    if (KinkyDungeonHasAngelHelp()) {
        restraintEscapeChancePre += 0.1;
    }
    let affinity = KDGetRestraintAffinity(restraint, { StruggleType: StruggleType });
    let data = {
        restraint: restraint,
        struggleType: StruggleType,
        struggleGroup: struggleGroup,
        escapeChance: restraintEscapeChancePre,
        origEscapeChance: restraintEscapeChancePre,
        limitChance: limitChance,
        helpChance: helpChance,
        cutSpeed: 0.25,
        affinity: affinity,
        strict: KinkyDungeonStrictness(true, struggleGroup, restraint),
        hasAffinity: KinkyDungeonGetAffinity(true, affinity, struggleGroup),
        restraintEscapeChance: KDRestraint(restraint).escapeChance[StruggleType],
        cost: KinkyDungeonStatStaminaCostStruggle,
        wcost: KinkyDungeonStatWillCostStruggle,
        escapePenalty: 0,
        willEscapePenalty: KDGetWillPenalty(),
        canCutMagic: KinkyDungeonWeaponCanCut(true, true),
    };
    if (StruggleType == "Cut")
        data.cost = KinkyDungeonStatStaminaCostTool;
    else if (StruggleType == "Pick")
        data.cost = KinkyDungeonStatStaminaCostPick;
    else if (StruggleType == "Remove")
        data.cost = KinkyDungeonStatStaminaCostRemove;
    else if (StruggleType == "Unlock")
        data.cost = KinkyDungeonStatStaminaCostPick;
    if (StruggleType == "Cut")
        data.wcost = KinkyDungeonStatWillCostTool;
    else if (StruggleType == "Pick")
        data.wcost = KinkyDungeonStatWillCostPick;
    else if (StruggleType == "Remove")
        data.wcost = KinkyDungeonStatWillCostRemove;
    else if (StruggleType == "Unlock")
        data.wcost = KinkyDungeonStatWillCostUnlock;
    if (StruggleType == "Unlock")
        data.cost = 0;
    KinkyDungeonSendEvent("beforeStruggleCalc", data);
    if (!restraint.pickProgress)
        restraint.pickProgress = 0;
    if (!restraint.struggleProgress)
        restraint.struggleProgress = 0;
    if (!restraint.unlockProgress)
        restraint.unlockProgress = 0;
    if (!restraint.cutProgress)
        restraint.cutProgress = 0;
    let EC = KDGetEscapeChance(restraint, StruggleType, data.escapeChance, data.limitChance, true, true, true);
    data.escapeChance = EC.escapeChance;
    data.limitChance = EC.limitChance;
    data.origEscapeChance = data.escapeChance;
    KinkyDungeonInterruptSleep();
    let increasedAttempts = false;
    let handsBound = KinkyDungeonIsHandsBound(true, false, StruggleTypeHandThresh[StruggleType]) && !KinkyDungeonCanUseFeet();
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BoostStruggle"))
        data.escapeChance += KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BoostStruggle");
    if (StruggleType == "Cut") {
        if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BoostCutting"))
            data.escapeChance += KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BoostCutting");
        if (data.hasAffinity) {
            if (KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp() || !KinkyDungeonPlayerDamage) {
                let maxBonus = 0;
                let weaponsToTest = KinkyDungeonAllWeapon();
                for (let inv of weaponsToTest) {
                    if (KDWeapon(inv).cutBonus > maxBonus)
                        maxBonus = KDWeapon(inv).cutBonus;
                    if (KDWeapon(inv).cutBonus != undefined && KDWeapon(inv).magic)
                        data.canCutMagic = true;
                }
                data.escapeChance += maxBonus;
                data.origEscapeChance += maxBonus;
            }
            else if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.cutBonus) {
                data.escapeChance += KinkyDungeonPlayerDamage.cutBonus;
                data.origEscapeChance += KinkyDungeonPlayerDamage.cutBonus;
            }
        }
        if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BoostCuttingMinimum"))
            data.escapeChance = Math.max(data.escapeChance, KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BoostCuttingMinimum"));
    }
    if (StruggleType == "Cut" && !KDRestraint(restraint).magic && KinkyDungeonWeaponCanCut(true, true)) {
        data.escapeChance += KinkyDungeonEnchantedKnifeBonus;
        data.origEscapeChance += KinkyDungeonEnchantedKnifeBonus;
    }
    let escapeSpeed = 2.0;
    let armsBound = KinkyDungeonIsArmsBound(true);
    let armsBoundOverride = false;
    let handsBoundOverride = false;
    if (KDUnboundAffinityOverride[affinity] && (!handsBound || handsBoundOverride) && (!armsBound || armsBoundOverride))
        data.hasAffinity = true;
    if (StruggleType == "Remove" &&
        (!handsBound && (KinkyDungeonWeaponCanCut(true) || KinkyDungeonLockpicks > 0)
            || (struggleGroup == "ItemHands" && KinkyDungeonCanTalk() && !armsBound))) {
        data.escapeChance = Math.max(data.escapeChance, Math.min(1, data.escapeChance + 0.15));
        data.origEscapeChance = Math.max(data.origEscapeChance, Math.min(1, data.origEscapeChance + 0.15));
    }
    if (StruggleType == "Unlock" && KinkyDungeonStatsChoice.get("Psychic"))
        data.escapeChance = Math.max(data.escapeChance, 0.25);
    let edgeBonus = 0.12;
    if (StruggleType == "Struggle" && data.hasAffinity)
        data.escapeChance += edgeBonus;
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Lockdown")) {
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonBuffLockdownTry")
            .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 1);
        data.escapeChance -= KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Lockdown") * 0.1;
    }
    if ((StruggleType == "Struggle") && !data.hasAffinity && data.escapeChance <= 0 && data.escapeChance >= -edgeBonus && (!KDRestraint(restraint).alwaysEscapable || !KDRestraint(restraint).alwaysEscapable.includes(StruggleType))) {
        let typesuff = "";
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
        if (affinity && !KinkyDungeonGetAffinity(false, affinity, struggleGroup))
            typesuff = "Wrong" + affinity;
        if (typesuff == "" && KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.1)
            typesuff = typesuff + "Aroused";
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggle" + StruggleType + "NeedEdge" + typesuff)
            .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
        KinkyDungeonLastAction = "Struggle";
        KinkyDungeonSendEvent("struggle", {
            restraint: restraint,
            group: struggleGroup,
            struggleType: StruggleType,
            result: "NeedEdge",
        });
        return "NeedEdge";
    }
    let removeFail = (data.struggleType == "Unlock" || data.struggleType == "Pick") && !(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && KDGetEscapeChance(restraint, "Remove", undefined, undefined, false, false).escapeChance <= 0;
    if (removeFail)
        data.escapeChance = 0;
    if (data.escapeChance <= 0) {
        if (!restraint.attempts)
            restraint.attempts = 0;
        if (restraint.attempts < KinkyDungeonMaxImpossibleAttempts) {
            increasedAttempts = true;
            restraint.attempts += 1;
            if (data.escapeChance <= -0.5)
                restraint.attempts += 1;
        }
        else {
            let typesuff = "";
            if (removeFail || (data.origEscapeChance <= 0 && data.helpChance))
                typesuff = "3";
            else if (KDRestraint(restraint).specStruggleTypes && KDRestraint(restraint).specStruggleTypes.includes(StruggleType))
                typesuff = "2";
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
            if (typesuff == "" && failSuffix)
                typesuff = failSuffix;
            if (typesuff == "" && KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.1)
                typesuff = typesuff + "Aroused";
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggle" + StruggleType + "Impossible" + typesuff)
                .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
            if (EC.escapeChanceData.GoddessBonus < 0 && EC.escapeChanceData.escapeChance < 0 && EC.escapeChance - EC.escapeChanceData.GoddessBonus > 0) {
                KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonStruggle" + StruggleType + "ImpossibleGoddess")
                    .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
            }
            if (KinkyDungeonHasStamina(-data.cost)) {
                KinkyDungeonLastAction = "Struggle";
                KinkyDungeonSendEvent("struggle", {
                    restraint: restraint,
                    group: struggleGroup,
                    struggleType: StruggleType,
                    result: "Impossible",
                });
                KinkyDungeonChangeStamina(data.cost, true, 1);
                KinkyDungeonChangeWill(data.wcost);
                if (KinkyDungeonStatsChoice.get("BondageLover"))
                    KinkyDungeonChangeDistraction(KDBondageLoverAmount, false, 0.5);
            }
            KinkyDungeonAdvanceTime(1);
            return "Impossible";
        }
    }
    let minAmount = 0.1 - Math.max(0, 0.01 * KDRestraint(restraint).power);
    if (StruggleType == "Remove" && !data.hasAffinity)
        minAmount = 0;
    if (!(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && StruggleType != "Struggle" && (struggleGroup != "ItemArms" && struggleGroup != "ItemHands") && (handsBound || armsBound))
        data.escapeChance /= 1.5;
    if (StruggleType != "Struggle" && struggleGroup != "ItemArms" && armsBound)
        data.escapeChance = Math.max(minAmount, data.escapeChance - 0.3);
    if (((StruggleType == "Pick" && !KinkyDungeonStatsChoice.get("Psychic")) || StruggleType == "Unlock" || StruggleType == "Remove") && struggleGroup != "ItemHands" && handsBound)
        data.escapeChance = (StruggleType == "Remove" && data.hasAffinity) ? data.escapeChance / 2 : Math.max(0, data.escapeChance - 0.5);
    if (StruggleType == "Unlock" && KinkyDungeonStatsChoice.get("Psychic"))
        data.escapeChance = Math.max(data.escapeChance, 0.2);
    if ((StruggleType == "Remove") && !data.hasAffinity && data.escapeChance == 0 && (!KDRestraint(restraint).alwaysEscapable || !KDRestraint(restraint).alwaysEscapable.includes(StruggleType))) {
        let typesuff = "";
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
        if (affinity && !KinkyDungeonGetAffinity(false, affinity, struggleGroup))
            typesuff = "Wrong" + affinity;
        if (typesuff == "" && KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.1)
            typesuff = typesuff + "Aroused";
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggle" + StruggleType + "NeedEdge" + typesuff)
            .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
        KinkyDungeonLastAction = "Struggle";
        KinkyDungeonSendEvent("struggle", {
            restraint: restraint,
            group: struggleGroup,
            struggleType: StruggleType,
            result: "NeedEdge",
        });
        return "NeedEdge";
    }
    let possible = data.escapeChance > 0;
    if (data.strict)
        data.escapeChance = Math.max(0, data.escapeChance - data.strict);
    if (StruggleType == "Unlock" && KinkyDungeonStatsChoice.get("Psychic"))
        data.escapeChance = Math.max(data.escapeChance, 0.2);
    if (possible && data.escapeChance == 0 && (!KDRestraint(restraint).alwaysEscapable || !KDRestraint(restraint).alwaysEscapable.includes(StruggleType))) {
        let typesuff = "";
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
        if (typesuff == "" && KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.1)
            typesuff = typesuff + "Aroused";
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggle" + StruggleType + "Strict" + typesuff)
            .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
        KinkyDungeonLastAction = "Struggle";
        KinkyDungeonSendEvent("struggle", {
            restraint: restraint,
            group: struggleGroup,
            struggleType: StruggleType,
            result: "Strict",
        });
        return "Strict";
    }
    if (StruggleType == "Cut" && !KinkyDungeonWeaponCanCut(true) && KinkyDungeonIsHandsBound(true)) {
        if (KinkyDungeonAllWeapon().some((inv) => { return KDWeapon(inv).light && KDWeapon(inv).cutBonus != undefined; })) {
            if (KinkyDungeonWallCrackAndKnife(true)) {
                data.escapeChance *= 0.92;
            }
            else if (!KinkyDungeonIsArmsBound(true)) {
                data.escapeChance *= 0.7;
            }
            else if (KinkyDungeonStatsChoice.get("Psychic")) {
                data.escapeChance *= 0.55;
            }
            else if (data.hasAffinity) {
                data.escapeChance *= 0.4;
            }
            else {
                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonNeedGrip"), "#ff0000", 2, true);
                data.escapeChance *= 0.0;
            }
        }
        else if (data.hasAffinity)
            data.escapeChance *= 0.4;
        else
            data.escapeChance = 0;
        data.escapeChance = Math.max(0, data.escapeChance - 0.05);
    }
    if (!(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && (StruggleType == "Pick" || StruggleType == "Unlock" || StruggleType == "Remove"))
        data.escapeChance /= 1.0 + KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax * KinkyDungeonDistractionUnlockSuccessMod;
    if (KDGroupBlocked(struggleGroup) && !KDRestraint(restraint).alwaysStruggleable)
        data.escapeChance = 0;
    let lockType = restraint.lock && KDLocks[restraint.lock] ? KDLocks[restraint.lock] : null;
    if (lockType && lockType.penalty && lockType.penalty[StruggleType])
        data.escapeChance = Math.max(0, data.escapeChance - lockType.penalty[StruggleType]);
    if (StruggleType == "Cut" && struggleGroup != "ItemHands" && handsBound)
        data.escapeChance = data.escapeChance / 2;
    if (data.escapeChance > 0 && StruggleType == "Struggle") {
        for (let T = 0; T < restraint.tightness; T++) {
            data.escapeChance *= 0.8;
        }
    }
    if (StruggleType == "Pick")
        data.escapeChance += KinkyDungeonGetPickBonus();
    if (StruggleType == "Unlock" && KinkyDungeonStatsChoice.get("Psychic"))
        data.escapeChance = Math.max(data.escapeChance, 0.15);
    if (data.escapePenalty > 0) {
        data.escapeChance = Math.max(0, data.escapeChance - data.escapePenalty);
    }
    let belt = null;
    let bra = null;
    if (struggleGroup == "ItemVulva" || struggleGroup == "ItemVulvaPiercings" || struggleGroup == "ItemButt")
        belt = KinkyDungeonGetRestraintItem("ItemPelvis");
    if (belt && KDRestraint(belt) && KDRestraint(belt).chastity)
        data.escapeChance = 0.0;
    if (struggleGroup == "ItemNipples" || struggleGroup == "ItemNipplesPiercings")
        bra = KinkyDungeonGetRestraintItem("ItemBreast");
    if (bra && KDRestraint(bra) && KDRestraint(bra).chastitybra)
        data.escapeChance = 0.0;
    if (data.escapeChance <= 0 && (!KDRestraint(restraint).alwaysEscapable || !KDRestraint(restraint).alwaysEscapable.includes(StruggleType))) {
        if (!restraint.attempts)
            restraint.attempts = 0;
        if (restraint.attempts < KinkyDungeonMaxImpossibleAttempts || increasedAttempts) {
            if (!increasedAttempts) {
                restraint.attempts += 0.5;
                if (data.escapeChance <= -0.5)
                    restraint.attempts += 0.5;
            }
        }
        else {
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
            let suff = "";
            if (suff == "" && failSuffix)
                suff = failSuffix;
            if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.1)
                suff = suff + "Aroused";
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggle" + StruggleType + "ImpossibleBound" + suff)
                .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
            if (KinkyDungeonHasStamina(-data.cost)) {
                KinkyDungeonLastAction = "Struggle";
                KinkyDungeonSendEvent("struggle", {
                    restraint: restraint,
                    group: struggleGroup,
                    struggleType: StruggleType,
                    result: "Impossible",
                });
                KinkyDungeonChangeStamina(data.cost, true, 1);
                KinkyDungeonChangeWill(data.wcost);
                if (KinkyDungeonStatsChoice.get("BondageLover"))
                    KinkyDungeonChangeDistraction(KDBondageLoverAmount, false, 0.5);
            }
            KinkyDungeonAdvanceTime(1);
            return "Impossible";
        }
    }
    if (KDRestraint(restraint) && KDRestraint(restraint).escapeMult != undefined)
        data.escapeChance *= KDRestraint(restraint).escapeMult;
    if (KDRestraint(restraint) && KDRestraint(restraint).struggleMult && KDRestraint(restraint).struggleMult[StruggleType] != undefined)
        data.escapeChance *= KDRestraint(restraint).struggleMult[StruggleType];
    if (data.escapeChance > 0) {
        let minSpeed = (KDRestraint(restraint).struggleMinSpeed && KDRestraint(restraint).struggleMinSpeed[StruggleType]) ? KDRestraint(restraint).struggleMinSpeed[StruggleType] : 0.05;
        data.escapeChance = Math.max(data.escapeChance, minSpeed);
    }
    if (KDRestraint(restraint) && KDRestraint(restraint).struggleMaxSpeed && KDRestraint(restraint).struggleMaxSpeed[StruggleType] != undefined)
        data.escapeChance = Math.min(data.escapeChance, KDRestraint(restraint).struggleMaxSpeed[StruggleType]);
    if (lockType && (StruggleType == "Unlock" && !lockType.canUnlock(data))
        || (StruggleType == "Pick" && lockType && !lockType.pickable)) {
        if (StruggleType == "Unlock")
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggleUnlockNo" + restraint.lock + "Key")
                .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "orange", 2, true);
        else
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonStruggleCantPick" + restraint.lock + "Lock")
                .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "orange", 2, true);
    }
    else {
        let maxLimit = 100;
        if ((data.wcost > 0 && !KinkyDungeonHasWill(-data.wcost, false)) && (data.escapeChance <= data.willEscapePenalty && !KinkyDungeonHasWill(0.01, false))) {
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                    + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.NoWill) ? KDRestraint(restraint).sfxEscape.NoWill : "Struggle")
                    + ".ogg");
            KinkyDungeonSendActionMessage(10, TextGet("KDWillStruggle")
                .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
            KinkyDungeonLastAction = "Struggle";
            KinkyDungeonSendEvent("struggle", {
                restraint: restraint,
                group: struggleGroup,
                struggleType: StruggleType,
                result: "Will",
            });
            return "Will";
        }
        else if (!KinkyDungeonHasStamina(-data.cost, true)) {
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                    + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.NoStamina) ? KDRestraint(restraint).sfxEscape.NoStamina : "Struggle")
                    + ".ogg");
            KinkyDungeonWaitMessage(true);
        }
        else if (data.escapeChance > 0) {
            let extraLim = (StruggleType == "Pick" && lockType.pick_lim) ? Math.max(0, lockType.pick_lim) : 0;
            let extraLimPenalty = (StruggleType == "Pick") ? extraLim * restraint.pickProgress : 0;
            let extraLimThreshold = Math.min(1, (data.escapeChance / extraLim));
            if ((data.limitChance > 0 || extraLim > 0) && data.escapeChance > 0) {
                let threshold = 0.75;
                if (data.limitChance > data.escapeChance) {
                    threshold = Math.min(threshold, 0.9 * (data.escapeChance / data.limitChance));
                }
                let limitProgress = restraint.struggleProgress ? (StruggleType == "Struggle" ?
                    (restraint.struggleProgress < threshold ? threshold * restraint.struggleProgress : 1.0) :
                    Math.min(1, 1.15 - 1.15 * restraint.struggleProgress))
                    : (StruggleType == "Struggle" ? 0 : 1);
                let limitPenalty = Math.max(0, Math.min(1, limitProgress) * data.limitChance, extraLimPenalty);
                let maxPossible = 1;
                if ((data.limitChance > 0 && data.limitChance > data.escapeChance && StruggleType == "Struggle")) {
                    maxPossible = threshold;
                }
                if (extraLim > data.escapeChance) {
                    maxPossible = Math.min(extraLimThreshold, maxPossible);
                }
                if (maxPossible < 1)
                    maxLimit = maxPossible;
                if (extraLimPenalty > 0 && extraLimPenalty > limitPenalty) {
                    data.escapeChance -= extraLimPenalty;
                    if (data.escapeChance <= 0) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeon" + StruggleType + "Limit")
                            .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
                        KinkyDungeonLastAction = "Struggle";
                        KinkyDungeonSendEvent("struggle", {
                            restraint: restraint,
                            group: struggleGroup,
                            struggleType: StruggleType,
                            result: "LimitExtra",
                        });
                        return "LimitExtra";
                    }
                }
                else if (limitPenalty > 0) {
                    data.escapeChance -= limitPenalty;
                    if (data.escapeChance <= 0) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeon" + StruggleType + "Limit")
                            .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
                        KinkyDungeonLastAction = "Struggle";
                        KinkyDungeonSendEvent("struggle", {
                            restraint: restraint,
                            group: struggleGroup,
                            struggleType: StruggleType,
                            result: "Limit",
                        });
                        return "Limit";
                    }
                }
            }
            if (data.escapeChance > 0 && KinkyDungeonHasWill(0.01, false)) {
                data.escapeChance -= data.willEscapePenalty;
                if (data.escapeChance <= 0) {
                    if (KDToggles.Sound)
                        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                            + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.NoWill) ? KDRestraint(restraint).sfxEscape.NoWill : "Struggle")
                            + ".ogg");
                    KinkyDungeonSendActionMessage(10, TextGet("KDWillStruggle")
                        .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
                    KinkyDungeonLastAction = "Struggle";
                    KinkyDungeonSendEvent("struggle", {
                        restraint: restraint,
                        group: struggleGroup,
                        struggleType: StruggleType,
                        result: "Will",
                    });
                    return "Will";
                }
            }
            if (data.escapeChance <= 0) {
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Struggle.ogg");
                KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeon" + StruggleType + "Barely")
                    .replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2, true);
                KinkyDungeonLastAction = "Struggle";
                KinkyDungeonSendEvent("struggle", {
                    restraint: restraint,
                    group: struggleGroup,
                    struggleType: StruggleType,
                    result: "Barely",
                });
                return "Barely";
            }
            let progress = restraint.cutProgress ? restraint.cutProgress : 0;
            let struggleTime = KinkyDungeonStatsChoice.get("FranticStruggle") ? 1 : KDStruggleTime;
            if (KinkyDungeonStatsChoice.get("FranticStruggle"))
                data.cost *= 1.5;
            if (((StruggleType == "Cut" && progress >= 1 - data.escapeChance)
                || (StruggleType == "Pick" && restraint.pickProgress >= 1 - data.escapeChance)
                || (StruggleType == "Unlock" && restraint.unlockProgress >= 1 - data.escapeChance)
                || (StruggleType == "Remove" && progress >= 1 - data.escapeChance)
                || (progress >= 1 - data.escapeChance))
                && !(StruggleType == "Pick" && lockType && !lockType.canPick(data))) {
                Pass = "Success";
                KDSuccessRemove(StruggleType, restraint, lockType, index, data, host);
            }
            else {
                if (StruggleType == "Cut") {
                    if (((handsBound && KDRandom() < KinkyDungeonItemDropChanceArmsBound) || (armsBound && KDRandom() < KinkyDungeonItemDropChanceArmsBound)) && KinkyDungeonWeaponCanCut(true) && KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.name) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.KnifeDrop) ? KDRestraint(restraint).sfxEscape.KnifeDrop : "Miss")
                                + ".ogg");
                        Pass = "Drop";
                        KinkyDungeonDisarm(KinkyDungeonPlayerEntity, "Cut");
                    }
                    else {
                        if (KDItemIsMagic(restraint) && !data.canCutMagic) {
                            if (KDToggles.Sound)
                                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                    + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.NoMagic) ? KDRestraint(restraint).sfxEscape.NoMagic : "SoftShield")
                                    + ".ogg");
                            Pass = "Fail";
                        }
                        else {
                            if (KDToggles.Sound) {
                                if (KDItemIsMagic(restraint))
                                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                        + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.MagicCut) ? KDRestraint(restraint).sfxEscape.MagicCut : "Cut")
                                        + ".ogg");
                                else
                                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                        + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.Cut) ? KDRestraint(restraint).sfxEscape.Cut : "Cut")
                                        + ".ogg");
                            }
                            let mult = 1.0 - 0.9 * Math.min(1.0, progress);
                            if (KinkyDungeonStatsChoice.get("Flexible"))
                                mult *= KDFlexibleSpeedBonus;
                            if (KinkyDungeonStatsChoice.get("Inflexible"))
                                mult *= KDInflexibleSpeedBonus;
                            let speed = data.cutSpeed * mult + Math.max(0, data.escapeChance) * 0.5;
                            mult *= 0.75 + 0.25 * (KinkyDungeonStatWill / KinkyDungeonStatWillMax);
                            KDAddDelayedStruggle(escapeSpeed * speed * (0.3 + 0.2 * KDRandom() + 0.6 * Math.max(0, (KinkyDungeonStatStamina) / KinkyDungeonStatStaminaMax)), struggleTime, StruggleType, struggleGroup, index, data, restraint.cutProgress, maxLimit);
                            if (speed > 0) {
                                let debris = "";
                                let debrisFlag = KDRestraint(restraint).Group + "deb";
                                if (!KinkyDungeonFlags.get(debrisFlag)) {
                                    if (((_a = KDRestraint(restraint)) === null || _a === void 0 ? void 0 : _a.debris) && KDRandom() < ((_b = KDRestraint(restraint)) === null || _b === void 0 ? void 0 : _b.debrisChance) ? (_c = KDRestraint(restraint)) === null || _c === void 0 ? void 0 : _c.debrisChance : 1.0)
                                        debris = (_d = KDRestraint(restraint)) === null || _d === void 0 ? void 0 : _d.debris;
                                }
                                if (debris) {
                                    KinkyDungeonSetFlag(debrisFlag, 4);
                                    KDCreateDebris(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, {
                                        aoe: 1.5,
                                        dist: 0.5,
                                        kind: debris,
                                        number: 1,
                                    });
                                }
                            }
                        }
                    }
                }
                else if (StruggleType == "Pick") {
                    if (lockType && lockType.breakChance(data)) {
                        Pass = "Break";
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.PickBreak) ? KDRestraint(restraint).sfxEscape.PickBreak : "PickBreak")
                                + ".ogg");
                        KinkyDungeonLockpicks -= 1;
                        KinkyDungeonPickBreakProgress = 0;
                    }
                    else if (!KinkyDungeonStatsChoice.get("Psychic") && (handsBound || (armsBound && KDRandom() < KinkyDungeonItemDropChanceArmsBound))) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.PickDrop) ? KDRestraint(restraint).sfxEscape.PickDrop : "Miss")
                                + ".ogg");
                        Pass = "Drop";
                        KinkyDungeonDropItem({ name: "Pick" }, KinkyDungeonPlayerEntity, true);
                        KinkyDungeonLockpicks -= 1;
                    }
                    else {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.Pick) ? KDRestraint(restraint).sfxEscape.Pick : "Pick")
                                + ".ogg");
                        if (!restraint.pickProgress)
                            restraint.pickProgress = 0;
                        let mult = 0.5 + 0.6 * (progress);
                        if (KinkyDungeonStatsChoice.get("Locksmith"))
                            mult *= KDLocksmithSpeedBonus;
                        if (KinkyDungeonStatsChoice.get("Clueless"))
                            mult *= KDCluelessSpeedBonus;
                        mult *= 0.5 + 0.5 * (KinkyDungeonStatWill / KinkyDungeonStatWillMax);
                        KDAddDelayedStruggle(escapeSpeed * mult * (data.escapeChance > 0 ? (KDMinPickRate * (data.escapeChance > 0.5 ? 2 : 1)) : 0) * (0.8 + 0.4 * KDRandom() - 0.4 * Math.max(0, (KinkyDungeonStatDistraction) / KinkyDungeonStatDistractionMax)), struggleTime, StruggleType, struggleGroup, index, data, restraint.pickProgress, maxLimit);
                    }
                }
                else if (StruggleType == "Unlock") {
                    if (!KinkyDungeonStatsChoice.get("Psychic") && (handsBound || (armsBound && KDRandom() < KinkyDungeonItemDropChanceArmsBound))) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.KeyDrop) ? KDRestraint(restraint).sfxEscape.KeyDrop : "Miss")
                                + ".ogg");
                        Pass = "Drop";
                        let keytype = KinkyDungeonGetKey(restraint.lock);
                        if (keytype) {
                            KinkyDungeonDropItem({ name: keytype + "Key" }, KinkyDungeonPlayerEntity, true);
                            KinkyDungeonRemoveKeysUnlock(restraint.lock);
                        }
                    }
                    else {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                                + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.Pick) ? KDRestraint(restraint).sfxEscape.Pick : "Pick")
                                + ".ogg");
                        let mult = 0.2 + 1.8 * (progress);
                        if (KinkyDungeonStatsChoice.get("Flexible"))
                            mult *= KDFlexibleSpeedBonus;
                        if (KinkyDungeonStatsChoice.get("Inflexible"))
                            mult *= KDInflexibleSpeedBonus;
                        mult *= 0.5 + 0.5 * (KinkyDungeonStatWill / KinkyDungeonStatWillMax);
                        KDAddDelayedStruggle(escapeSpeed * mult * Math.max(data.escapeChance > 0 ? KDMinEscapeRate : 0, data.escapeChance) * (0.8 + 0.4 * KDRandom() - 0.4 * Math.max(0, (KinkyDungeonStatDistraction) / KinkyDungeonStatDistractionMax)), struggleTime, StruggleType, struggleGroup, index, data, restraint.unlockProgress, maxLimit);
                    }
                }
                else if (StruggleType == "Remove") {
                    if (KDToggles.Sound)
                        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                            + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.Remove) ? KDRestraint(restraint).sfxEscape.Remove : "Struggle")
                            + ".ogg");
                    let mult = 0.3 + 1.7 * (progress * progress);
                    if (KinkyDungeonStatsChoice.get("Flexible"))
                        mult *= KDFlexibleSpeedBonus;
                    if (KinkyDungeonStatsChoice.get("Inflexible"))
                        mult *= KDInflexibleSpeedBonus;
                    mult *= 0.75 + 0.25 * (KinkyDungeonStatWill / KinkyDungeonStatWillMax);
                    KDAddDelayedStruggle(escapeSpeed * mult * Math.max(data.escapeChance > 0 ? KDMinEscapeRate : 0, data.escapeChance) * (0.8 + 0.4 * KDRandom() - 0.3 * Math.max(0, (KinkyDungeonStatDistraction) / KinkyDungeonStatDistractionMax)), struggleTime, StruggleType, struggleGroup, index, data, restraint.struggleProgress, maxLimit);
                }
                else if (StruggleType == "Struggle") {
                    if (KDToggles.Sound)
                        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                            + ((KDRestraint(restraint).sfxEscape && KDRestraint(restraint).sfxEscape.Struggle) ? KDRestraint(restraint).sfxEscape.Struggle : "Struggle")
                            + ".ogg");
                    let mult = 1.25 - 0.75 * (progress);
                    if (KinkyDungeonStatsChoice.get("Flexible"))
                        mult *= KDFlexibleSpeedBonus;
                    if (KinkyDungeonStatsChoice.get("Inflexible"))
                        mult *= KDInflexibleSpeedBonus;
                    mult *= 0.5 + 0.5 * (KinkyDungeonStatWill / KinkyDungeonStatWillMax);
                    KDAddDelayedStruggle(escapeSpeed * mult * Math.max(data.escapeChance > 0 ? KDMinEscapeRate : 0, data.escapeChance) * (0.5 + 0.4 * KDRandom() + 0.3 * Math.max(0, (KinkyDungeonStatStamina) / KinkyDungeonStatStaminaMax)), struggleTime, StruggleType, struggleGroup, index, data, restraint.struggleProgress, maxLimit);
                }
            }
        }
        let suff = "";
        if (Pass == "Fail" && data.escapeChance > 0 && data.origEscapeChance <= 0) {
            if ((KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && data.helpChance)
                suff = "3";
            else
                suff = "2";
        }
        else if (Pass == "Fail") {
            if (suff == "" && failSuffix)
                suff = failSuffix;
        }
        if ((suff == "" || (Pass == "Fail" && suff == failSuffix)) && (Pass == "Fail" || Pass == "Success") && KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.1)
            suff = suff + "Aroused";
        if (Pass != "Success")
            KinkyDungeonSendActionMessage(9, TextGet("KinkyDungeonStruggle" + StruggleType + Pass + suff).replace("TargetRestraint", TextGet("Restraint" + KDRestraint(restraint).name)), (Pass == "Success") ? "lightgreen" : "#ff0000", 2);
        if (KinkyDungeonHasStamina(-data.cost)) {
            KinkyDungeonChangeStamina(data.cost, true, 1);
            KinkyDungeonChangeWill(data.wcost);
            if (KinkyDungeonStatsChoice.get("BondageLover"))
                KinkyDungeonChangeDistraction(KDBondageLoverAmount, false, 0.5);
            if (Pass != "Success") {
                if (StruggleType == "Struggle") {
                    restraint.pickProgress = Math.max(0, restraint.pickProgress * 0.5 - 0.01);
                    restraint.unlockProgress = Math.max(0, restraint.unlockProgress * 0.5 - 0.01);
                }
                else if (StruggleType == "Pick") {
                    restraint.unlockProgress = Math.max(0, restraint.unlockProgress * 0.5 - 0.01);
                }
                else if (StruggleType == "Unlock") {
                    restraint.pickProgress = Math.max(0, restraint.pickProgress * 0.5 - 0.01);
                }
                if (StruggleType == "Remove") {
                    restraint.pickProgress = Math.max(0, restraint.pickProgress * 0.5 - 0.01);
                    restraint.unlockProgress = Math.max(0, restraint.unlockProgress * 0.5 - 0.01);
                }
                if (StruggleType == "Struggle") {
                    let tightness_reduction = 1;
                    for (let _item of KinkyDungeonAllRestraint()) {
                        tightness_reduction *= 0.8;
                    }
                    restraint.tightness = Math.max(0, restraint.tightness - tightness_reduction);
                }
            }
            else if (KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp())
                KinkyDungeonChangeRep("Ghost", 1);
            KinkyDungeonSendEvent("struggle", {
                restraint: restraint,
                group: struggleGroup,
                struggleType: StruggleType,
                result: Pass,
            });
            KinkyDungeonLastAction = "Struggle";
            if (StruggleType == "Struggle") {
                KinkyDungeonMakeNoise(4, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
                KinkyDungeonAlert = 3;
            }
        }
        KinkyDungeonAdvanceTime(1);
        if (Pass == "Success")
            KinkyDungeonCurrentEscapingItem = null;
        return Pass;
    }
    return "Impossible";
}
function KinkyDungeonGetRestraintItem(group, index) {
    for (let item of KinkyDungeonAllRestraint()) {
        if (item.type == Restraint && KDRestraint(item).Group == group) {
            if (index) {
                let link = item;
                let count = 0;
                while (count < index && link) {
                    count += 1;
                    link = link.dynamicLink;
                }
                if (count == index)
                    return link;
                return null;
            }
            return item;
        }
    }
    return null;
}
function KinkyDungeonRefreshRestraintsCache() {
    KinkyDungeonRestraintsCache = new Map();
    for (let r of KinkyDungeonRestraints) {
        KinkyDungeonRestraintsCache.set(r.name, r);
    }
}
function KinkyDungeonGetRestraintByName(Name) {
    if (KinkyDungeonRestraintsCache.size > 0) {
        return KinkyDungeonRestraintsCache.get(Name);
    }
    else {
        KinkyDungeonRefreshRestraintsCache();
        return KinkyDungeonRestraintsCache.get(Name);
    }
}
function KinkyDungeonGetLockMult(Lock) {
    if (KDLocks[Lock])
        return KDLocks[Lock].lockmult;
    return 1;
}
let KDNoOverrideTags = [
    "NoVibes",
    "Unmasked",
    "Unchained",
    "Damsel",
];
function KDGetRestraintsEligible(enemy, Level, Index, Bypass, Lock, RequireWill, LeashingOnly, NoStack, extraTags, agnostic, filter, securityEnemy) {
    var _a;
    let RestraintsList = [];
    if (KinkyDungeonStatsChoice.has("NoWayOut"))
        RequireWill = false;
    let willPercent = (KinkyDungeonStatWill / KinkyDungeonStatWillMax - 0.15 * KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax)
        / (1 + (KinkyDungeonGoddessRep.Ghost + 50) / 100);
    if (KinkyDungeonSlowLevel > 0)
        willPercent = willPercent * (0.6 + 0.4 * Math.min(1, Math.max(0, 1 - KinkyDungeonSlowLevel / 3)));
    let tags = new Map();
    if (enemy.tags.length) {
        for (let t of enemy.tags) {
            tags.set(t, true);
        }
    }
    else {
        for (let t of Object.keys(enemy.tags)) {
            tags.set(t, true);
        }
    }
    if (extraTags)
        for (let t of Object.entries(extraTags)) {
            if (Level >= t[1])
                tags.set(t[0], true);
        }
    if (filter === null || filter === void 0 ? void 0 : filter.ignoreTags) {
        for (let ft of filter.ignoreTags) {
            tags.delete(ft);
        }
    }
    let arousalMode = KinkyDungeonStatsChoice.get("arousalMode");
    let cache = [];
    for (let restraint of KinkyDungeonRestraints) {
        let effLevel = Level;
        if (KinkyDungeonStatsChoice.has("TightRestraints")) {
            effLevel *= KDTightRestraintsMult;
            effLevel += KDTightRestraintsMod;
        }
        if ((effLevel >= restraint.minLevel || KinkyDungeonNewGame > 0 || ((_a = filter === null || filter === void 0 ? void 0 : filter.require) === null || _a === void 0 ? void 0 : _a.includes(restraint.name))) && (!restraint.maxLevel || effLevel < restraint.maxLevel) && (restraint.allFloors || restraint.floors[Index])) {
            if (!restraint.arousalMode || arousalMode) {
                let enabled = false;
                let weight = 0;
                for (let t of tags.keys())
                    if (restraint.enemyTags[t] != undefined) {
                        weight += restraint.enemyTags[t];
                        enabled = true;
                    }
                if (enabled) {
                    cache.push({ r: restraint, w: weight });
                }
            }
        }
    }
    for (let r of cache) {
        let restraint = r.r;
        if (filter) {
            if (filter.maxPower && r.r.power > filter.maxPower && (!filter.looseLimit || !r.r.unlimited))
                continue;
            if (filter.minPower && r.r.power < filter.minPower && (!filter.looseLimit || !r.r.limited) && !r.r.unlimited)
                continue;
            if (filter.onlyUnlimited && r.r.limited)
                continue;
            if (filter.noUnlimited && r.r.unlimited)
                continue;
            if (filter.noLimited && r.r.limited)
                continue;
            if (filter.onlyLimited && !r.r.limited && !r.r.unlimited)
                continue;
            if (filter.ignore && filter.ignore.includes(r.r.name))
                continue;
            if (filter.require && !filter.require.includes(r.r.name))
                continue;
        }
        if ((!LeashingOnly || (restraint.Group == "ItemNeck" || restraint.Group == "ItemNeckRestraints"))
            && (!RequireWill || !restraint.maxwill || willPercent <= restraint.maxwill || (LeashingOnly && (restraint.Group == "ItemNeck" || restraint.Group == "ItemNeckRestraints"))))
            if (agnostic || KDCanAddRestraint(restraint, Bypass, Lock, NoStack, undefined, KinkyDungeonStatsChoice.has("MagicHands") ? true : undefined, undefined, securityEnemy)) {
                if (restraint.playerTags)
                    for (let tag in restraint.playerTags)
                        if ((!agnostic || !KDNoOverrideTags.includes(tag)) && KinkyDungeonPlayerTags.get(tag))
                            r.w += restraint.playerTags[tag];
                if (r.w > 0)
                    RestraintsList.push({
                        restraint: restraint,
                        weight: r.w,
                    });
            }
    }
    return RestraintsList;
}
function KinkyDungeonGetRestraint(enemy, Level, Index, Bypass, Lock, RequireWill, LeashingOnly, NoStack, extraTags, agnostic, filter, securityEnemy) {
    let restraintWeightTotal = 0;
    let restraintWeights = [];
    let Restraints = KDGetRestraintsEligible(enemy, Level, Index, Bypass, Lock, RequireWill, LeashingOnly, NoStack, extraTags, agnostic, filter, securityEnemy);
    for (let rest of Restraints) {
        let restraint = rest.restraint;
        let weight = rest.weight;
        restraintWeights.push({ restraint: restraint, weight: restraintWeightTotal });
        weight += restraint.weight;
        restraintWeightTotal += Math.max(0, weight);
    }
    let selection = KDRandom() * restraintWeightTotal;
    for (let L = restraintWeights.length - 1; L >= 0; L--) {
        if (selection > restraintWeights[L].weight) {
            return restraintWeights[L].restraint;
        }
    }
}
function KinkyDungeonUpdateRestraints(delta) {
    let playerTags = new Map();
    for (let inv of KinkyDungeonAllRestraint()) {
        let group = KDRestraint(inv).Group;
        if (group) {
            if (KDGroupBlocked(group))
                playerTags.set(group + "Blocked", true);
            playerTags.set(group + "Full", true);
            playerTags.set(inv.name + "Worn", true);
        }
    }
    for (let sg of KinkyDungeonStruggleGroupsBase) {
        let group = sg;
        if (group == "ItemM") {
            if (!KinkyDungeonGetRestraintItem("ItemMouth"))
                playerTags.set("ItemMouth" + "Empty", true);
            if (!KinkyDungeonGetRestraintItem("ItemMouth2"))
                playerTags.set("ItemMouth2" + "Empty", true);
            if (!KinkyDungeonGetRestraintItem("ItemMouth3"))
                playerTags.set("ItemMouth3" + "Empty", true);
        }
        else if (group == "ItemH") {
            if (!KinkyDungeonGetRestraintItem("ItemHood"))
                playerTags.set("ItemHood" + "Empty", true);
            if (!KinkyDungeonGetRestraintItem("ItemHead"))
                playerTags.set("ItemHead" + "Empty", true);
        }
        else if (!KinkyDungeonGetRestraintItem(group))
            playerTags.set(group + "Empty", true);
    }
    for (let inv2 of KinkyDungeonAllRestraintDynamic()) {
        let inv = inv2.item;
        playerTags.set("Item_" + inv.name, true);
        if (KDRestraint(inv).Link)
            playerTags.set("LinkTo_" + KDRestraint(inv).Link, true);
        if (KDRestraint(inv).UnLink)
            playerTags.set("UnLinkTo_" + KDRestraint(inv).UnLink, true);
        if (KDRestraint(inv).addTag)
            for (let tag of KDRestraint(inv).addTag) {
                if (!playerTags.get(tag))
                    playerTags.set(tag, true);
            }
        if (KDRestraint(inv).chastity)
            playerTags.set("ChastityLower", true);
        if (KDRestraint(inv).chastitybra)
            playerTags.set("ChastityUpper", true);
        if (KDRestraint(inv).hobble)
            playerTags.set("Hobble", true);
        if (KDRestraint(inv).blockfeet)
            playerTags.set("BoundFeet", true);
        if (KDRestraint(inv).bindarms)
            playerTags.set("BoundHands", true);
        if (KDRestraint(inv).bindhands)
            playerTags.set("BoundHands", true);
        if (KDRestraint(inv).blindfold)
            playerTags.set("Blindfolded", true);
        if (KDRestraint(inv).shrine) {
            for (let tag of KDRestraint(inv).shrine) {
                if (!playerTags.get(tag))
                    playerTags.set(tag, true);
            }
        }
    }
    if (KinkyDungeonStatsChoice.get("Deprived"))
        playerTags.set("NoVibes", true);
    if (KinkyDungeonStatsChoice.get("Unmasked"))
        playerTags.set("Unmasked", true);
    if (KinkyDungeonStatsChoice.get("Unchained"))
        playerTags.set("Unchained", true);
    if (KinkyDungeonStatsChoice.get("Damsel"))
        playerTags.set("Damsel", true);
    if (KinkyDungeonStatsChoice.get("arousalMode"))
        playerTags.set("arousalMode", true);
    if (KinkyDungeonStatsChoice.get("arousalModePlug"))
        playerTags.set("arousalModePlug", true);
    if (KinkyDungeonStatsChoice.get("arousalModePiercing"))
        playerTags.set("arousalModePiercing", true);
    let tags = [];
    KinkyDungeonAddTags(tags, MiniGameKinkyDungeonLevel);
    for (let t of tags) {
        playerTags.set(t, true);
    }
    KinkyDungeonSendEvent("updatePlayerTags", { tags: playerTags, player: KinkyDungeonPlayerEntity });
    return playerTags;
}
function KinkyDungeonRestraintPower(item, NoLink, toLink) {
    if (item && item.type == Restraint) {
        let lockMult = item ? KinkyDungeonGetLockMult(item.lock) : 1;
        let power = (item.lock ? KDRestraint(item).power * lockMult : KDRestraint(item).power);
        if (item.dynamicLink && !NoLink) {
            let link = item.dynamicLink;
            if (!toLink || !KinkyDungeonIsLinkable(KinkyDungeonGetRestraintByName(link.name), toLink, link)) {
                let lock = link.lock;
                let mult = lock ? KinkyDungeonGetLockMult(lock) : 1;
                let pp = link ? (KDRestraint({ name: link.name }).power) : 0;
                power = Math.max(power, pp * mult);
            }
        }
        return power;
    }
    return 0;
}
function KinkyDungeonLinkableAndStricter(oldRestraint, newRestraint, item, newLock) {
    if (oldRestraint && newRestraint) {
        return KinkyDungeonIsLinkable(oldRestraint, newRestraint, item);
    }
    return false;
}
function KinkyDungeonGenerateRestraintTrap() {
    let enemy = KinkyDungeonGetEnemy(["chestTrap"], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', ["chestTrap"]);
    if (enemy)
        return enemy.name;
    return "GreedyGhast";
}
function KDGetLockVisual(item) {
    return `Locks/${item.lock}.png`;
}
function KDCanAddRestraint(restraint, Bypass, Lock, NoStack, r, Deep, noOverpower, securityEnemy) {
    if (restraint.bypass)
        Bypass = true;
    if (restraint.shrine && restraint.shrine.includes("Vibes") && KinkyDungeonPlayerTags.get("NoVibes"))
        return false;
    if (restraint.arousalMode && !KinkyDungeonStatsChoice.get("arousalMode"))
        return false;
    if (restraint.Group == "ItemButt" && !KinkyDungeonStatsChoice.get("arousalModePlug"))
        return false;
    if (restraint.Group == "ItemNipplesPiercing" && !KinkyDungeonStatsChoice.get("arousalModePiercing"))
        return false;
    if (restraint.requireSingleTagToEquip) {
        let pass = false;
        for (let tag of restraint.requireSingleTagToEquip) {
            if (KinkyDungeonPlayerTags.has(tag)) {
                pass = true;
                break;
            }
        }
        if (!pass)
            return false;
    }
    if (!r)
        r = KinkyDungeonGetRestraintItem(restraint.Group);
    let power = KinkyDungeonRestraintPower(r, false, restraint);
    let linkUnder = KDGetLinkUnder(r, restraint, Bypass, NoStack, Deep, securityEnemy);
    let linkableCurrent = r && KDRestraint(r) && KinkyDungeonLinkableAndStricter(KDRestraint(r), restraint, r);
    if (linkUnder)
        return true;
    let link = r === null || r === void 0 ? void 0 : r.dynamicLink;
    while (link && !linkableCurrent) {
        let linkableUnder = KinkyDungeonLinkableAndStricter(KDRestraint(link), restraint, link);
        if (!linkableUnder) {
            power = Math.max(power, KinkyDungeonRestraintPower(link, false, restraint));
            link = link.dynamicLink;
        }
        else {
            link = null;
        }
    }
    let newLock = (Lock && KinkyDungeonIsLockable(restraint)) ? Lock : restraint.DefaultLock;
    if (!r
        || linkableCurrent
        || (!KDRestraint(r).enchanted
            && (!noOverpower && power < restraint.power * KinkyDungeonGetLockMult(newLock)))) {
        if (Bypass || restraint.bypass || !KDGroupBlocked(restraint.Group, true) || KDEnemyPassesSecurity(restraint.Group, securityEnemy))
            return true;
    }
    return false;
}
function KDEnemyPassesSecurity(Group, enemy) {
    var _a;
    if (!enemy)
        return false;
    let blockers = KDGetBlockingRestraints(Group, true);
    for (let blocker of blockers) {
        if (!((_a = KDRestraint(blocker)) === null || _a === void 0 ? void 0 : _a.Security))
            return false;
        for (let secure of Object.entries(KDRestraint(blocker).Security)) {
            if (KDGetSecurity(enemy, secure[0]) >= secure[1])
                return true;
        }
    }
    return false;
}
function KDGetLinkUnder(currentRestraint, restraint, bypass, NoStack, Deep, securityEnemy) {
    let link = currentRestraint;
    if (restraint.bypass)
        bypass = true;
    while (link) {
        if (KDCanLinkUnder(link, restraint, bypass, NoStack, securityEnemy)) {
            return link;
        }
        if (Deep)
            link = link.dynamicLink;
        else
            link = null;
    }
    return null;
}
function KDCanLinkUnder(currentRestraint, restraint, bypass, NoStack, securityEnemy) {
    if (restraint.bypass)
        bypass = true;
    let linkUnder = currentRestraint
        && (bypass || (KDRestraint(currentRestraint).accessible) || (KDRestraint(currentRestraint).deepAccessible) || KDEnemyPassesSecurity(KDRestraint(currentRestraint).Group, securityEnemy))
        && KinkyDungeonIsLinkable(restraint, KDRestraint(currentRestraint), { name: restraint.name, id: -1 }, currentRestraint, currentRestraint)
        && (!currentRestraint.dynamicLink || KinkyDungeonIsLinkable(KDRestraint(currentRestraint.dynamicLink), restraint, currentRestraint.dynamicLink, currentRestraint));
    if (!linkUnder)
        return false;
    if (KDCheckLinkSize(currentRestraint, restraint, bypass, NoStack, securityEnemy)) {
        return true;
    }
}
function KDCheckLinkSize(currentRestraint, restraint, bypass, NoStack, securityEnemy, ignoreItem) {
    if (restraint.bypass)
        bypass = true;
    return (restraint.linkCategory && KDLinkCategorySize(KinkyDungeonGetRestraintItem(KDRestraint(currentRestraint).Group), restraint.linkCategory, ignoreItem) + KDLinkSize(restraint) <= (NoStack ? 0.1 : 1.0))
        || (!restraint.linkCategory
            && !KDDynamicLinkList(KinkyDungeonGetRestraintItem(KDRestraint(currentRestraint).Group), true).some((item) => {
                return restraint.name == item.name && (ignoreItem === null || ignoreItem === void 0 ? void 0 : ignoreItem.id) != item.id;
            }));
}
function KinkyDungeonAddRestraintIfWeaker(restraint, Tightness, Bypass, Lock, Keep, Trapped, events, faction, Deep, Curse, securityEnemy) {
    if (typeof restraint === "string")
        restraint = KinkyDungeonGetRestraintByName(restraint);
    if (restraint.bypass)
        Bypass = true;
    if (KDCanAddRestraint(restraint, Bypass, Lock, false, undefined, Deep, false, securityEnemy)) {
        let r = KinkyDungeonGetRestraintItem(restraint.Group);
        let linkUnder = null;
        linkUnder = KDGetLinkUnder(r, restraint, Bypass, undefined, Deep, securityEnemy);
        let linkableCurrent = r
            && KDRestraint(r)
            && KinkyDungeonLinkableAndStricter(KDRestraint(r), restraint, r);
        let ret = 0;
        let alwaysLinkUnder = false;
        if (!linkableCurrent && linkUnder && (!linkableCurrent || !restraint.inaccessible || alwaysLinkUnder)) {
            ret = Math.max(1, Tightness);
            linkUnder.dynamicLink = { name: restraint.name, id: KinkyDungeonGetItemID(), type: Restraint, events: events ? events : Object.assign([], restraint.events), tightness: Tightness, lock: "", faction: faction, dynamicLink: linkUnder.dynamicLink };
            KinkyDungeonLock(linkUnder.dynamicLink, Lock);
            if (Curse && KDCurses[Curse] && KDCurses[Curse].onApply) {
                KDCurses[Curse].onApply(linkUnder.dynamicLink, linkUnder);
            }
            if (r)
                KDUpdateLinkCaches(r);
            KinkyDungeonSendEvent("postApply", { player: KinkyDungeonPlayerEntity, item: linkUnder.dynamicLink, host: linkUnder, keep: Keep, Link: true });
        }
        else {
            ret = KinkyDungeonAddRestraint(restraint, Tightness + Math.round(0.1 * KinkyDungeonDifficulty), Bypass, Lock, Keep, false, !linkableCurrent, events, faction, undefined, undefined, Curse, undefined, securityEnemy);
        }
        if (Trapped) {
            let rest = KinkyDungeonGetRestraintItem(restraint.Group);
            if (rest && KDRestraint(rest) && KDRestraint(rest).trappable && !rest.trap) {
                rest.trap = KinkyDungeonGenerateRestraintTrap();
            }
        }
        return ret;
    }
    return 0;
}
function KinkyDungeonIsLinkable(oldRestraint, newRestraint, item, ignoreItem, linkUnderItem) {
    if (!oldRestraint.nonbinding && newRestraint.nonbinding)
        return false;
    if (oldRestraint && newRestraint && oldRestraint && oldRestraint.Link) {
        if (newRestraint.name == oldRestraint.Link)
            return true;
    }
    if (item && !KDCheckLinkSize(item, newRestraint, false, false, undefined, ignoreItem))
        return false;
    if (item && !KDCheckLinkTotal(item, newRestraint, linkUnderItem))
        return false;
    if (oldRestraint && newRestraint && oldRestraint && oldRestraint.LinkableBy && newRestraint.shrine) {
        for (let l of oldRestraint.LinkableBy) {
            for (let s of newRestraint.shrine) {
                if (l == s) {
                    return true;
                }
            }
        }
    }
    return false;
}
function KDCheckLinkTotal(oldRestraint, newRestraint, ignoreItem) {
    if (KDRestraint(oldRestraint).Link && KDRestraint(oldRestraint).Link == newRestraint.name) {
        return true;
    }
    if (newRestraint.UnLink && oldRestraint.name == newRestraint.UnLink) {
        return true;
    }
    let link = oldRestraint;
    if (oldRestraint.linkCache) {
        for (let s of newRestraint.shrine) {
            if (oldRestraint.linkCache.includes(s))
                return true;
        }
    }
    while (link) {
        let pass = false;
        let r = KDRestraint(link);
        if (link != ignoreItem) {
            if (r.LinkableBy && newRestraint.shrine) {
                for (let l of r.LinkableBy) {
                    if (!pass)
                        for (let s of newRestraint.shrine) {
                            if (l == s) {
                                pass = true;
                            }
                        }
                }
            }
            if (!pass)
                return false;
        }
        link = link.dynamicLink;
    }
    return true;
}
function KDUpdateLinkCaches(restraint) {
    let link = restraint;
    while (link) {
        link.linkCache = KDGetLinkCache(link);
        link = link.dynamicLink;
    }
}
function KDGetLinkCache(restraint) {
    let cache = Object.assign([], KDRestraint(restraint).LinkableBy);
    let link = restraint.dynamicLink;
    while (link) {
        let r = KDRestraint(link);
        if (r.LinkableBy) {
            for (let l of cache) {
                if (!r.LinkableBy.includes(l))
                    cache.splice(cache.indexOf(l), 1);
            }
        }
        else
            return [];
        link = link.dynamicLink;
    }
    return cache;
}
let KinkyDungeonRestraintAdded = false;
let KinkyDungeonCancelFlag = false;
function KinkyDungeonAddRestraint(restraint, Tightness, Bypass, Lock, Keep, Link, SwitchItems, events, faction, Unlink, dynamicLink, Curse, autoMessage = true, securityEnemy = undefined) {
    KDDelayedActionPrune(["Restrain"]);
    if (restraint.bypass)
        Bypass = true;
    KDStruggleGroupLinkIndex = {};
    let start = performance.now();
    let tight = (Tightness) ? Tightness : 0;
    let AssetGroup = restraint.AssetGroup ? restraint.AssetGroup : restraint.Group;
    if (restraint) {
        if (!KDGroupBlocked(restraint.Group, true) || Bypass || KDEnemyPassesSecurity(restraint.Group, securityEnemy)) {
            KinkyDungeonEvasionPityModifier = 0;
            KinkyDungeonMiscastPityModifier = 0;
            let r = KinkyDungeonGetRestraintItem(restraint.Group);
            let linkable = !Unlink && (!Link && r && KinkyDungeonIsLinkable(KDRestraint(r), restraint, r));
            let linked = false;
            if (linkable) {
                linked = true;
                KinkyDungeonCancelFlag = KinkyDungeonLinkItem(restraint, r, Tightness, Lock, Keep, faction, Curse, autoMessage);
            }
            let eventsAdd = false;
            let oldevents = null;
            let prevR = null;
            if (!KinkyDungeonCancelFlag) {
                KinkyDungeonRemoveRestraint(restraint.Group, Keep && !Link, Link || Unlink, undefined, undefined, r && r.dynamicLink && restraint.name == r.dynamicLink.name);
                let newR = KinkyDungeonGetRestraintItem(restraint.Group);
                if (r && r.events) {
                    oldevents = r.events;
                    eventsAdd = newR != undefined;
                    prevR = r;
                }
                r = newR;
                KinkyDungeonCancelFlag = r != undefined;
            }
            let color = (typeof restraint.Color === "string") ? [restraint.Color] : Object.assign([], restraint.Color);
            if (restraint.factionColor && faction && KinkyDungeonFactionColors[faction]) {
                for (let i = 0; i < restraint.factionColor.length; i++) {
                    for (let n of restraint.factionColor[i]) {
                        if (KinkyDungeonFactionColors[faction][i])
                            color[n] = KinkyDungeonFactionColors[faction][i];
                    }
                }
            }
            if (!KinkyDungeonCancelFlag) {
                KinkyDungeonRemoveRestraint(restraint.Group, Keep, false, undefined, undefined, r && r.dynamicLink && restraint.name == r.dynamicLink.name);
                if (restraint.remove)
                    for (let remove of restraint.remove) {
                        InventoryRemove(KinkyDungeonPlayer, remove);
                    }
                if (restraint.removeShrine)
                    for (let remove of restraint.removeShrine) {
                        for (let removeR of KinkyDungeonAllRestraint()) {
                            let host = removeR;
                            let link = removeR.dynamicLink;
                            let iter = 0;
                            while (link && iter < 100) {
                                if (KDRestraint(link).shrine && KDRestraint(link).shrine.includes(remove)) {
                                    KinkyDungeonRemoveDynamicRestraint(host, Keep, false);
                                    host = removeR;
                                    link = removeR.dynamicLink;
                                }
                                else {
                                    host = link;
                                    link = link.dynamicLink;
                                }
                                iter += 1;
                            }
                            if (KDRestraint(removeR).shrine && KDRestraint(removeR).shrine.includes(remove)) {
                                KinkyDungeonRemoveRestraint(KDRestraint(removeR).Group, Keep, false, false, false, false);
                            }
                        }
                    }
                KinkyDungeonSendFloater({ x: 1100, y: 600 - KDRecentRepIndex * 40 }, `+${TextGet("Restraint" + restraint.name)}!`, "pink", 5, true);
                KDRecentRepIndex += 1;
                let placedOnPlayer = false;
                if (ArcadeDeviousChallenge && KinkyDungeonDeviousDungeonAvailable() && !KinkyDungeonRestraintsLocked.includes(AssetGroup) && AssetGroup != "ItemHead" && InventoryAllow(Player, AssetGet("3DCGFemale", AssetGroup, restraint.Asset)) &&
                    (!InventoryGetLock(InventoryGet(Player, AssetGroup))
                        || (InventoryGetLock(InventoryGet(Player, AssetGroup)).Asset.OwnerOnly == false && InventoryGetLock(InventoryGet(Player, AssetGroup)).Asset.LoverOnly == false))) {
                    const asset = AssetGet(Player.AssetFamily, AssetGroup, restraint.Asset);
                    if (asset) {
                        placedOnPlayer = true;
                        CharacterAppearanceSetItem(Player, AssetGroup, asset, color || asset.DefaultColor, 0, null, false);
                        KinkyDungeonPlayerNeedsRefresh = true;
                    }
                }
                if (placedOnPlayer && restraint.Type) {
                    let options = window["Inventory" + ((AssetGroup.includes("ItemMouth")) ? "ItemMouth" : AssetGroup) + restraint.Asset + "Options"];
                    if (!options)
                        options = TypedItemDataLookup[`${AssetGroup}${restraint.Asset}`].options;
                    const option = options.find(o => o.Name === restraint.Type);
                    const playerItem = InventoryGet(Player, AssetGroup);
                    if (playerItem) {
                        TypedItemSetOption(Player, playerItem, options, option, false);
                        KinkyDungeonPlayerNeedsRefresh = true;
                    }
                }
                if (placedOnPlayer && restraint.Modules) {
                    let data = ModularItemDataLookup[AssetGroup + restraint.Asset];
                    let asset = data.asset;
                    let modules = data.modules;
                    InventoryGet(Player, AssetGroup).Property = ModularItemMergeModuleValues({ asset, modules }, restraint.Modules);
                }
                if (placedOnPlayer && color) {
                    KDCharacterAppearanceSetColorForGroup(Player, color, AssetGroup);
                }
                let item = { name: restraint.name, id: KinkyDungeonGetItemID(), type: Restraint, curse: Curse, events: events ? events : Object.assign([], restraint.events), tightness: tight, lock: "", faction: faction, dynamicLink: dynamicLink };
                KinkyDungeonInventoryAdd(item);
                KinkyDungeonSendEvent("postApply", { player: KinkyDungeonPlayerEntity, item: item, host: undefined, keep: Keep, Link: Link });
                if (Curse && KDCurses[Curse] && KDCurses[Curse].onApply) {
                    KDCurses[Curse].onApply(item, undefined);
                }
                if (Lock)
                    KinkyDungeonLock(item, Lock);
                else if (restraint.DefaultLock && !Unlink)
                    KinkyDungeonLock(item, KDProcessLock(restraint.DefaultLock));
                KDUpdateLinkCaches(item);
            }
            else if ((!Link && !linked) || SwitchItems) {
                KinkyDungeonCancelFlag = false;
                r = KinkyDungeonGetRestraintItem(restraint.Group);
                if (SwitchItems) {
                    KinkyDungeonAddRestraintIfWeaker(restraint, Tightness, Bypass, Lock, Keep, false, undefined, faction, undefined, Curse, securityEnemy);
                }
                else if (r && KDRestraint(r) && KinkyDungeonIsLinkable(KDRestraint(r), restraint, r)) {
                    KinkyDungeonLinkItem(restraint, r, Tightness, Lock, Keep, faction, Curse);
                }
            }
            if (oldevents) {
                if (prevR.events) {
                    for (let e of oldevents) {
                        if (e.trigger == "postRemoval" && (!e.requireEnergy || ((!e.energyCost && KDGameData.AncientEnergyLevel > 0) || (e.energyCost && KDGameData.AncientEnergyLevel > e.energyCost)))) {
                            KinkyDungeonHandleInventoryEvent("postRemoval", e, prevR, { item: prevR, add: eventsAdd, keep: Keep, Link: Link, shrine: undefined });
                        }
                    }
                }
                KinkyDungeonSendEvent("postRemoval", { item: prevR, add: eventsAdd, keep: Keep, Link: Link, shrine: undefined });
            }
            KinkyDungeonCancelFlag = false;
        }
        KinkyDungeonPlayerTags = KinkyDungeonUpdateRestraints();
        KinkyDungeonCalculateSlowLevel();
        KinkyDungeonCheckClothesLoss = true;
        KinkyDungeonDressPlayer();
        KinkyDungeonMultiplayerInventoryFlag = true;
        KinkyDungeonSleepTime = 0;
        KinkyDungeonUpdateStruggleGroups();
        if (!KinkyDungeonRestraintAdded) {
            KinkyDungeonRestraintAdded = true;
            let sfx = (restraint && restraint.sfx) ? restraint.sfx : "Struggle";
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg");
        }
        let end = performance.now();
        if (KDDebug)
            console.log(`Took ${end - start} milliseconds to add restraint ${restraint.name}`);
        return Math.max(1, restraint.power);
    }
    return 0;
}
function KinkyDungeonRemoveRestraint(Group, Keep, Add, NoEvent, Shrine, UnLink, Remover) {
    var _a, _b, _c, _d;
    KDDelayedActionPrune(["Remove"]);
    KDStruggleGroupLinkIndex = {};
    for (let item of KinkyDungeonAllRestraint()) {
        const rest = KinkyDungeonRestraintsCache.get(item.name);
        if (rest.Group == Group) {
            let AssetGroup = rest && rest.AssetGroup ? rest.AssetGroup : Group;
            if (!NoEvent)
                KinkyDungeonSendEvent("remove", { item: rest, add: Add, keep: Keep, shrine: Shrine });
            if (!KinkyDungeonCancelFlag && !Add && !UnLink) {
                KinkyDungeonCancelFlag = KinkyDungeonUnLinkItem(item, Keep);
            }
            if (!KinkyDungeonCancelFlag) {
                if (ArcadeDeviousChallenge && KinkyDungeonDeviousDungeonAvailable() && !KinkyDungeonRestraintsLocked.includes(AssetGroup) && InventoryGet(Player, AssetGroup) &&
                    (!InventoryGetLock(InventoryGet(Player, AssetGroup)) || (((_a = InventoryGetLock(InventoryGet(Player, AssetGroup))) === null || _a === void 0 ? void 0 : _a.Asset.OwnerOnly) == false && ((_b = InventoryGetLock(InventoryGet(Player, Group))) === null || _b === void 0 ? void 0 : _b.Asset.LoverOnly) == false))
                    && Group != "ItemHead") {
                    InventoryRemove(Player, AssetGroup, false);
                    if (Group == "ItemNeck" && !Add) {
                        InventoryRemove(Player, "ItemNeckAccessories", false);
                        InventoryRemove(Player, "ItemNeckRestraints", false);
                    }
                    KinkyDungeonPlayerNeedsRefresh = true;
                }
                let inventoryAs = (Remover === null || Remover === void 0 ? void 0 : Remover.player) ? rest.inventoryAsSelf : rest.inventoryAs;
                if (rest.inventory && (Keep || ((rest.enchanted || rest.alwaysKeep) && !KinkyDungeonInventoryGetLoose(inventoryAs || rest.name)))) {
                    if (inventoryAs) {
                        let origRestraint = KinkyDungeonGetRestraintByName(inventoryAs);
                        if (origRestraint && ((_c = rest.shrine) === null || _c === void 0 ? void 0 : _c.includes("Cursed")) && !((_d = origRestraint.shrine) === null || _d === void 0 ? void 0 : _d.includes("Cursed"))) {
                            KinkyDungeonSendTextMessage(10, TextGet("KDCursedArmorUncurse").replace("RestraintName", TextGet("Restraint" + rest.name)), "#aaffaa", 1);
                        }
                        if (!KinkyDungeonInventoryGetLoose(origRestraint.name)) {
                            KinkyDungeonInventoryAdd({ name: origRestraint.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: origRestraint.events, quantity: 1 });
                        }
                        else {
                            if (!KinkyDungeonInventoryGetLoose(origRestraint.name).quantity)
                                KinkyDungeonInventoryGetLoose(origRestraint.name).quantity = 0;
                            KinkyDungeonInventoryGetLoose(origRestraint.name).quantity += 1;
                        }
                    }
                    else {
                        if (!KinkyDungeonInventoryGetLoose(rest.name)) {
                            KinkyDungeonInventoryAdd({ name: rest.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: rest.events, quantity: 1 });
                        }
                        else {
                            if (!KinkyDungeonInventoryGetLoose(rest.name).quantity)
                                KinkyDungeonInventoryGetLoose(rest.name).quantity = 0;
                            KinkyDungeonInventoryGetLoose(rest.name).quantity += 1;
                        }
                    }
                }
                InventoryRemove(KinkyDungeonPlayer, AssetGroup);
                for (let _item of KinkyDungeonInventory.get(Restraint).values()) {
                    if (_item && KDRestraint(_item).Group == Group) {
                        KinkyDungeonInventoryRemove(_item);
                        break;
                    }
                }
                if (rest.Group == "ItemNeck" && !Add && KinkyDungeonGetRestraintItem("ItemNeckRestraints"))
                    KinkyDungeonRemoveRestraint("ItemNeckRestraints", KDRestraint(KinkyDungeonGetRestraintItem("ItemNeckRestraints")).inventory);
                if (!NoEvent) {
                    if (rest.events) {
                        for (let e of rest.events) {
                            if (e.trigger == "postRemoval" && (!e.requireEnergy || ((!e.energyCost && KDGameData.AncientEnergyLevel > 0) || (e.energyCost && KDGameData.AncientEnergyLevel > e.energyCost)))) {
                                KinkyDungeonHandleInventoryEvent("postRemoval", e, item, { item: item, id: KinkyDungeonGetItemID(), add: Add, keep: Keep, shrine: Shrine });
                            }
                        }
                    }
                    KinkyDungeonSendEvent("postRemoval", { item: rest, add: Add, keep: Keep, shrine: Shrine });
                }
                let sfx = (rest && rest.sfxRemove) ? rest.sfxRemove : "Struggle";
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg");
                KinkyDungeonCalculateSlowLevel();
                KinkyDungeonCheckClothesLoss = true;
                KinkyDungeonDressPlayer();
                KinkyDungeonMultiplayerInventoryFlag = true;
                KinkyDungeonUpdateStruggleGroups();
            }
            KinkyDungeonCancelFlag = false;
            if (KinkyDungeonPlayerWeapon != KinkyDungeonPlayerWeaponLastEquipped && KinkyDungeonInventoryGet(KinkyDungeonPlayerWeaponLastEquipped)) {
                KDSetWeapon(KinkyDungeonPlayerWeaponLastEquipped);
            }
            return true;
        }
    }
    return false;
}
function KDIInsertRestraintUnderneath(restraint) {
    return false;
}
function KinkyDungeonRemoveDynamicRestraint(hostItem, Keep, NoEvent, Remover) {
    var _a, _b;
    let item = hostItem.dynamicLink;
    if (item) {
        const rest = KDRestraint(item);
        if (!NoEvent)
            KinkyDungeonSendEvent("remove", { item: rest, keep: Keep, shrine: false, dynamic: true });
        if (!KinkyDungeonCancelFlag) {
            if (rest.inventory && (Keep || rest.enchanted || rest.alwaysKeep) && !KinkyDungeonInventoryGetLoose(rest.name)) {
                let inventoryAs = (Remover === null || Remover === void 0 ? void 0 : Remover.player) ? rest.inventoryAsSelf : rest.inventoryAs;
                if (inventoryAs) {
                    let origRestraint = KinkyDungeonGetRestraintByName(inventoryAs);
                    if (origRestraint && ((_a = rest.shrine) === null || _a === void 0 ? void 0 : _a.includes("Cursed")) && !((_b = origRestraint.shrine) === null || _b === void 0 ? void 0 : _b.includes("Cursed")))
                        KinkyDungeonSendTextMessage(10, TextGet("KDCursedArmorUncurse").replace("RestraintName", TextGet("Restraint" + rest.name)), "#aaffaa", 1);
                    if (!KinkyDungeonInventoryGetLoose(origRestraint.name)) {
                        KinkyDungeonInventoryAdd({ name: origRestraint.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: origRestraint.events, quantity: 1 });
                    }
                    else
                        KinkyDungeonInventoryGetLoose(origRestraint.name).quantity += 1;
                }
                else
                    KinkyDungeonInventoryAdd({ name: rest.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: rest.events });
            }
            hostItem.dynamicLink = item.dynamicLink;
            let r = KinkyDungeonGetRestraintItem(KDRestraint(hostItem).Group);
            if (r)
                KDUpdateLinkCaches(r);
            if (!NoEvent) {
                if (rest.events) {
                    for (let e of rest.events) {
                        if (e.trigger == "postRemoval" && (!e.requireEnergy || ((!e.energyCost && KDGameData.AncientEnergyLevel > 0) || (e.energyCost && KDGameData.AncientEnergyLevel > e.energyCost)))) {
                            KinkyDungeonHandleInventoryEvent("postRemoval", e, item, { item: item, id: KinkyDungeonGetItemID(), keep: Keep, shrine: false, dynamic: true });
                        }
                    }
                }
                KinkyDungeonSendEvent("postRemoval", { item: rest, keep: Keep, shrine: false, dynamic: true });
            }
            let sfx = (rest && rest.sfxRemove) ? rest.sfxRemove : "Struggle";
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg");
            KinkyDungeonCalculateSlowLevel();
            KinkyDungeonCheckClothesLoss = true;
            KinkyDungeonDressPlayer();
            KinkyDungeonMultiplayerInventoryFlag = true;
            KinkyDungeonUpdateStruggleGroups();
        }
        KinkyDungeonCancelFlag = false;
        return true;
    }
    return false;
}
function KinkyDungeonRestraintTypes(ShrineFilter) {
    let ret = [];
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv).shrine) {
            for (let shrine of KDRestraint(inv).shrine) {
                if (ShrineFilter.includes(shrine) && !ret.includes(shrine))
                    ret.push(shrine);
            }
        }
    }
    return ret;
}
function KinkyDungeonLinkItem(newRestraint, oldItem, tightness, Lock, Keep, faction, Curse, autoMessage = true) {
    if (newRestraint && oldItem && oldItem.type == Restraint) {
        if (newRestraint) {
            KinkyDungeonAddRestraint(newRestraint, tightness, true, Lock, Keep, true, undefined, undefined, faction, undefined, oldItem, Curse);
            let newItem = KinkyDungeonGetRestraintItem(newRestraint.Group);
            if (newItem)
                newItem.dynamicLink = oldItem;
            if (newRestraint.UnLink && KDRestraint(oldItem).Link == newRestraint.name) {
                oldItem.name = newRestraint.UnLink;
                oldItem.events = Object.assign([], KDRestraint(oldItem).events);
            }
            KDUpdateLinkCaches(newItem);
            if (autoMessage && KDRestraint(oldItem).Link)
                KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonLink" + oldItem.name), "#ff0000", 2);
            KinkyDungeonSendEvent("postApply", { player: KinkyDungeonPlayerEntity, item: newItem, host: undefined, keep: Keep, Link: true });
            return true;
        }
    }
    return false;
}
function KinkyDungeonUnLinkItem(item, Keep, dynamic) {
    if (item.type == Restraint) {
        let UnLink = null;
        if (item.dynamicLink) {
            UnLink = item.dynamicLink;
        }
        if (UnLink) {
            let newRestraint = KinkyDungeonGetRestraintByName(UnLink.name);
            if (newRestraint) {
                KinkyDungeonAddRestraint(newRestraint, UnLink.tightness, true, UnLink.lock, Keep, undefined, undefined, undefined, UnLink.faction, true, UnLink.dynamicLink);
                KinkyDungeonSendEvent("postRemoval", { item: null, keep: Keep, shrine: false, Link: false, dynamic: true });
                if (KDRestraint(item).UnLink) {
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonUnLink" + item.name), "lightgreen", 2);
                }
                else
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonUnLink"), "lightgreen", 2);
                return true;
            }
        }
    }
    return false;
}
function KDCreateDebris(x, y, options) {
    let count = options.number ? options.number : 1;
    let rad = options.aoe ? options.aoe : 1.5;
    let minrad = options.dist;
    for (let i = 0; i < count; i++) {
        let slots = [];
        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                if (Math.sqrt(X * X + Y * Y) <= rad && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                    if ((x + X > 0 && y + Y > 0 && x + X < KinkyDungeonGridWidth && y + Y < KinkyDungeonGridHeight)
                        && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(x + X, y + Y)))
                        slots.push({ x: X, y: Y });
                }
            }
        if (slots.length > 0) {
            let slot = slots[Math.floor(KDRandom() * slots.length)];
            if (slot) {
                KDCreateEffectTile(x + slot.x, y + slot.y, {
                    name: options.kind,
                    duration: options.duration
                }, options.durationExtra || 0);
            }
        }
    }
}
function KDSuccessRemove(StruggleType, restraint, lockType, index, data, host) {
    let progress = restraint.cutProgress ? restraint.cutProgress : 0;
    let destroyChance = (StruggleType == "Cut" || restraint.cutProgress) ? 1.0 : 0;
    if (restraint.struggleProgress && restraint.struggleProgress > 0) {
        progress += restraint.struggleProgress;
        destroyChance = restraint.cutProgress / progress;
    }
    let destroy = false;
    KinkyDungeonFastStruggleType = "";
    KinkyDungeonFastStruggleGroup = "";
    if (StruggleType == "Pick" || StruggleType == "Unlock") {
        if (StruggleType == "Unlock") {
            if (lockType && lockType.canUnlock(data)) {
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                        + ((KDRestraint(restraint).sfxFinishEscape && KDRestraint(restraint).sfxFinishEscape.Unlock) ? KDRestraint(restraint).sfxFinishEscape.Unlock : "Unlock")
                        + ".ogg");
                KinkyDungeonRemoveKeysUnlock(restraint.lock);
                KinkyDungeonLock(restraint, "");
            }
        }
        else {
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                    + ((KDRestraint(restraint).sfxFinishEscape && KDRestraint(restraint).sfxFinishEscape.Unlock) ? KDRestraint(restraint).sfxFinishEscape.Unlock : "Unlock")
                    + ".ogg");
            KinkyDungeonLock(restraint, "");
        }
    }
    else {
        if (KDToggles.Sound) {
            if (StruggleType == "Cut")
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                    + ((KDRestraint(restraint).sfxFinishEscape && KDRestraint(restraint).sfxFinishEscape.Cut) ? KDRestraint(restraint).sfxFinishEscape.Cut : "Cut")
                    + ".ogg");
            else if (StruggleType == "Remove")
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                    + ((KDRestraint(restraint).sfxFinishEscape && KDRestraint(restraint).sfxFinishEscape.Remove) ? KDRestraint(restraint).sfxFinishEscape.Remove : "Unbuckle")
                    + ".ogg");
            else
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                    + ((KDRestraint(restraint).sfxFinishEscape && KDRestraint(restraint).sfxFinishEscape.Struggle) ? KDRestraint(restraint).sfxFinishEscape.Struggle : "Struggle")
                    + ".ogg");
        }
        if (KDRandom() < destroyChance) {
            KinkyDungeonSendTextMessage(9, TextGet("KinkyDungeonStruggleCutDestroy").replace("TargetRestraint", TextGet("Restraint" + restraint.name)), "#ff0000", 2);
            destroy = true;
        }
        let trap = restraint.trap;
        KDSendStatus('escape', restraint.name, StruggleType);
        if (KDToggles.Sound && destroy) {
            if (KDRestraint(restraint).sfxFinishEscape && KDRestraint(restraint).sfxFinishEscape.Destroy) {
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/"
                    + (KDRestraint(restraint).sfxFinishEscape.Destroy)
                    + ".ogg");
            }
        }
        if (index) {
            KinkyDungeonRemoveDynamicRestraint(host, (StruggleType != "Cut") || !destroy, false, KinkyDungeonPlayerEntity);
        }
        else {
            KinkyDungeonRemoveRestraint(KDRestraint(restraint).Group, (StruggleType != "Cut") || !destroy, undefined, undefined, undefined, undefined, KinkyDungeonPlayerEntity);
        }
        if (KinkyDungeonStatsChoice.get("FutileStruggles") && data.escapeChance < 0.25)
            KinkyDungeonChangeWill(KinkyDungeonStatWillCostEscape);
        else if (KinkyDungeonStatsChoice.get("SecondWind") && data.escapeChance < 0.25) {
            KinkyDungeonChangeWill(KinkyDungeonStatWillBonusEscape);
            destroy = true;
        }
        if (trap) {
            let summon = KinkyDungeonSummonEnemy(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, trap, 1, 2.5);
            if (summon) {
                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonSummonTrapMonster"), "#ff0000", 2);
            }
        }
    }
    let suff = "";
    if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.1)
        suff = "Aroused";
    KinkyDungeonSendActionMessage(9, TextGet("KinkyDungeonStruggle" + StruggleType + "Success" + suff).replace("TargetRestraint", TextGet("Restraint" + KDRestraint(restraint).name)), "lightgreen", 2);
    return destroy;
}
function KDAddDelayedStruggle(amount, time, StruggleType, struggleGroup, index, data, progress = 0, limit = 100) {
    let cur = progress;
    for (let t = 1; t <= time; t++) {
        let plus = amount / time * Math.max(0, 1 - (limit > 0 ? (cur / limit) : 1));
        if (plus > 0 && plus < 0.04)
            plus = 0.04;
        cur += plus;
        KDAddDelayedAction({
            commit: "Struggle",
            data: {
                group: struggleGroup,
                index: index,
                amount: plus,
                escapeData: data,
            },
            time: t,
            tags: ["Action", "Remove", "Restrain", "Hit"],
        });
    }
}
function KDGetItemGoddessBonus(item, data) {
    var _a;
    if (!item)
        return 0;
    if (data) {
        if (data.struggleType == "Unlock")
            return 0;
    }
    let bonus = 0;
    let avg = 0;
    for (let s of (_a = KDRestraint(item)) === null || _a === void 0 ? void 0 : _a.shrine) {
        if (KinkyDungeonGoddessRep[s] != undefined) {
            bonus += KDGetGoddessBonus(s);
            avg += 1;
        }
    }
    if (avg > 0)
        bonus = bonus / avg;
    return bonus;
}
function getItemDataString(item, key) {
    if (item.dataString)
        return item.dataString[key];
    return undefined;
}
function getItemDataNumber(item, key) {
    if (item.dataNumber)
        return item.dataNumber[key];
    return undefined;
}
function setItemDataString(item, key, value) {
    if (key != undefined && !item.dataString)
        item.dataString = {};
    if (key != undefined) {
        item.dataString[key] = value;
    }
    else if (item.dataString) {
        delete item.dataString[key];
    }
}
function setItemDataNumber(item, key, value) {
    if (key != undefined && !item.dataNumber)
        item.dataNumber = {};
    if (key != undefined) {
        item.dataNumber[key] = value;
    }
    else if (item.dataNumber) {
        delete item.dataNumber[key];
    }
}
function KDChooseRestraintFromListGroupPri(RestraintList, GroupOrder) {
    for (let i = 0; i < GroupOrder.length; i++) {
        let group = GroupOrder[i];
        let Restraints = RestraintList.filter((rest) => {
            return rest.restraint.Group == group;
        });
        if (Restraints.length > 0) {
            let restraintWeightTotal = 0;
            let restraintWeights = [];
            for (let rest of Restraints) {
                let restraint = rest.restraint;
                let weight = rest.weight;
                restraintWeights.push({ restraint: restraint, weight: restraintWeightTotal });
                weight += restraint.weight;
                restraintWeightTotal += Math.max(0, weight);
            }
            let selection = KDRandom() * restraintWeightTotal;
            for (let L = restraintWeights.length - 1; L >= 0; L--) {
                if (selection > restraintWeights[L].weight) {
                    return restraintWeights[L].restraint;
                }
            }
        }
    }
    return null;
}
let KDMagicLocks = ["Purple"];
let KDKeyedLocks = ["Red", "White", "Blue"];
let KDHarnessLink = ["Wrapping", "HeavyCorsets", "Corsets", "ArmbinderHarness", "Ties", "Belts", "Harnesses"];
let KDCorsetLink = ["Wrapping", "Harnesses", "ArmbinderHarness", "Ties", "Belts"];
let KDBindable = ["Wrapping", "Belts", "Tape", "Ties", "Cuffs"];
let KDDevices = ["Armbinders", "Straitjackets", "Legbinders", "BindingDress", "Boxbinders", "Petsuits"];
let KDElbowBind = ["Armbinders", "BindingDress", "Hogties"];
let KDBoxBind = ["Boxbinders", "Hogties"];
let KDWrappable = ["Wrapping", "Belts", "Tape"];
let KDArmbinderLink = ["Wrapping", "Belts", "BindingDress", "Hogties"];
let KDDressLink = ["Armbinders", "Ties", "Wrapping", "Belts", "BindingDress", "Hogties", "Straitjackets"];
let KDJacketLink = ["Wrapping", "Belts", "Hogties"];
let KDJacketRender = ["Wrapping", "Belts", "BindingDress"];
let KDLegbinderLink = ["Belts", "Tape", "Wrapping", "Hobbleskirts"];
let KDLegbinderRender = ["Belts", "Tape", "Wrapping"];
let KDLegRopesBind = ["Legbinders", "Hobbleskirts", "Tape", "Belts", "Wrapping"];
let KDLegRopesRender = ["Belts", "Ties"];
let KDTapeLink = ["Wrapping", "Belts", "Masks", "Mittens", "FlatGags"];
let KDTapeRender = ["Wrapping", "Tape", "Belts", "Masks", "Mittens", "FlatGags", "Ties", "Harnesses", "Corsets"];
let KDRubberLink = ["Wrapping", "Tape", "Belts", "Masks", "Mittens"];
let KDBlindfoldLink = ["Wrapping", "Masks", "Tape"];
let KDVisorLink = ["Wrapping", "Masks", "Tape"];
let KDWrappingLink = ["Masks", "Wrapping"];
let KDMaskLink = [];
let KDStuffingLink = ["BallGags", "FlatGags", "Stuffing", "Tape", "Wrapping"];
let KDBallGagLink = ["FlatGags", "Tape", "Wrapping"];
let KDFlatGagLink = ["FlatGags", "Tape", "Wrapping"];
let KDPlugGagLink = ["FlatGags", "Tape", "Wrapping"];
let KDCollarLink = ["Collars", "HighCollars"];
const KinkyDungeonRestraints = [
    { name: "ScarfArms", unlimited: true, accessible: true, debris: "Fabric", Asset: "DuctTape", Color: "#880022", Group: "ItemArms", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], bindarms: true, power: 0, weight: 0, escapeChance: { "Struggle": 0.5, "Cut": 0.9, "Remove": 0.2 },
        affinity: { Remove: ["Hook"], },
        enemyTags: { "scarfRestraints": 2 }, playerTags: { "ItemArmsFull": 2 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Tape"] },
    { name: "ScarfLegs", unlimited: true, accessible: true, debris: "Fabric", OverridePriority: 25.1, Asset: "DuctTape", Color: "#880022", Group: "ItemLegs", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], hobble: true, power: 0, weight: 0, escapeChance: { "Struggle": 0.5, "Cut": 0.9, "Remove": 0.2 },
        affinity: { Remove: ["Hook"], },
        enemyTags: { "scarfRestraints": 2 }, playerTags: { "ItemLegsFull": 2 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Tape"] },
    { name: "ScarfFeet", unlimited: true, accessible: true, debris: "Fabric", Asset: "DuctTape", Color: "#880022", Group: "ItemFeet", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], blockfeet: true, addTag: ["FeetLinked"], power: 0, weight: 0, escapeChance: { "Struggle": 0.5, "Cut": 0.9, "Remove": 0.2 },
        affinity: { Remove: ["Hook"], },
        enemyTags: { "scarfRestraints": 2 }, playerTags: { "ItemFeetFull": 2 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Tape"] },
    { name: "ScarfGag", unlimited: true, Asset: "ScarfGag", debris: "Fabric", accessible: true, gag: 0.3, Type: "OTN", Color: "#880022", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 0.1, weight: 2, escapeChance: { "Struggle": 0.5, "Cut": 1.0, "Remove": 0.8 },
        affinity: { Remove: ["Hook"], },
        enemyTags: { "scarfRestraints": 8, "ropeAuxiliary": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Gags", "Tape"] },
    { name: "ScarfBlindfold", unlimited: true, Asset: "ScarfBlindfold", debris: "Fabric", accessible: true, Color: "#880022", Group: "ItemHead", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], power: 0.1, weight: 2, escapeChance: { "Struggle": 0.5, "Cut": 1.0, "Remove": 0.8 },
        affinity: { Struggle: ["Sticky", "Hook"], Remove: ["Hook"], },
        blindfold: 1, enemyTags: { "scarfRestraints": 8, "ropeAuxiliary": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Blindfolds", "Tape"] },
    { inventory: true, name: "KiguMask", inaccessible: true, Asset: "KirugumiMask", Color: ["Default", "Default"], AssetGroup: "ItemHood", Group: "ItemHead", LinkableBy: [...KDMaskLink], gag: 0.3, blindfold: 1, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.1, "Remove": 0.33, "Pick": 0.15, "Unlock": 0.6 },
        enemyTags: { "kiguRestraints": 1 }, playerTags: { "ItemMouth1Full": 2, "ItemMouth2Full": 1, "Unmasked": -1000 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Masks", "Block_ItemMouth"], events: [
            { trigger: "onWear", type: "setSkinColor" },
        ] },
    { inventory: true, name: "DuctTapeHands", unlimited: true, inaccessible: true, Asset: "DuctTape", Color: "Default", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemHands",
        factionColor: [[], [0]],
        bindhands: 0.9, power: 1, weight: 0, escapeChance: { "Struggle": -0.1, "Cut": 0.4, "Remove": 0.4 }, struggleMaxSpeed: { "Remove": 0.1 },
        strictness: 0.05, strictnessZones: ["ItemHands"], failSuffix: { "Remove": "Tape" },
        maxwill: 0.6, enemyTags: { "tapeRestraints": 8 }, playerTags: { "ItemHandsFull": -4 }, minLevel: 0, allFloors: true, shrine: ["Tape"] },
    { removePrison: true, name: "DuctTapeArms", unlimited: true, debris: "Fabric", accessible: true, Asset: "DuctTape", Color: "#AA2222", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemArms", bindarms: true, power: -2, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.9, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 5, "ribbonRestraintsLight": 5 }, playerTags: { "ItemArmsFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Tape", "Will"] },
    { removePrison: true, name: "DuctTapeFeet", unlimited: true, debris: "Fabric", accessible: true, Asset: "DuctTape", Color: "#AA2222", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: -2, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.9, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 5, "ribbonRestraintsLight": 5 }, playerTags: { "ItemLegsFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Tape", "Will"] },
    { removePrison: true, name: "DuctTapeBoots", unlimited: true, debris: "Fabric", inaccessible: true, Asset: "ToeTape", Type: "Full", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Color: "#AA2222", Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: -2, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.9, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 5, "ribbonRestraintsLight": 5 }, playerTags: { "ItemFeetFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Wrapping", "Will"] },
    { removePrison: true, name: "DuctTapeLegs", OverridePriority: 25.1, unlimited: true, debris: "Fabric", accessible: true, Asset: "DuctTape", Color: "#AA2222", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemLegs", hobble: true, power: -2, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.9, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 5, "ribbonRestraintsLight": 5 }, playerTags: { "ItemFeetFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Tape", "Will"] },
    { removePrison: true, name: "DuctTapeHead", unlimited: true, debris: "Fabric", inaccessible: true, Type: "Wrap", Asset: "DuctTape", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Color: "#AA2222", Group: "ItemHead", power: -2, blindfold: 2, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.9, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 5, "ribbonRestraintsLight": 5 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Charms", "Tape", "Will"] },
    { removePrison: true, name: "DuctTapeMouth", unlimited: true, debris: "Fabric", Asset: "DuctTape", Color: "#AA2222", Group: "ItemMouth", AssetGroup: "ItemMouth2", gag: 0.5, power: -2, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.9, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 5, "ribbonRestraintsLight": 5 }, playerTags: { "ItemMouth1Full": 8 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Gags", "Tape", "Will"] },
    { removePrison: true, name: "DuctTapeHeadMummy", unlimited: true, debris: "Fabric", inaccessible: true, Asset: "LeatherSlimMask", LinkableBy: [...KDWrappingLink], renderWhenLinked: [...KDWrappingLink], Color: "#AA2222", Group: "ItemHead", gag: 0.5, blindfold: 3, power: 2, weight: 0, escapeChance: { "Struggle": 0.15, "Cut": 0.8, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 1 }, playerTags: { "ItemMouth1Full": 2, "ItemMouth2Full": 1, "Unmasked": -1000 }, minLevel: 2, allFloors: true, shrine: ["Charms", "Wrapping", "Block_ItemMouth", "Will"] },
    { removePrison: true, name: "DuctTapeArmsMummy", unlimited: true, debris: "Fabric", inaccessible: true, Type: "Complete", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], remove: ["Cloth", "ClothLower"], Asset: "DuctTape", Color: "#AA2222", Group: "ItemArms", bindarms: true, power: 2, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.8, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 1 }, playerTags: { "ItemArmsFull": 3 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Wrapping", "Will"] },
    { removePrison: true, name: "DuctTapeLegsMummy", OverridePriority: 25.1, unlimited: true, debris: "Fabric", inaccessible: true, Type: "CompleteLegs", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], remove: ["ClothLower"], Asset: "DuctTape", Color: "#AA2222", Group: "ItemLegs", hobble: true, power: 2, weight: 0, escapeChance: { "Struggle": 0.15, "Cut": 0.8, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 1 }, playerTags: { "ItemLegsFull": 3 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Hobbleskirts", "Wrapping", "Will"] },
    { removePrison: true, name: "DuctTapeFeetMummy", unlimited: true, debris: "Fabric", inaccessible: true, Type: "CompleteFeet", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Asset: "DuctTape", Color: "#AA2222", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 2, weight: 0, escapeChance: { "Struggle": 0.15, "Cut": 0.8, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "ribbonRestraints": 1 }, playerTags: { "ItemFeetFull": 3 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Wrapping", "Will"] },
    { removePrison: true, name: "MysticDuctTapeHead", unlimited: true, debris: "FabricGreen", inaccessible: true, Type: "Wrap", Asset: "DuctTape", Color: "#55AA22", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemHead", blindfold: 3, power: 1, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": 0.6, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "mummyRestraints": -399 }, playerTags: { "ItemMouth2Full": 99, "ItemArmsFull": 99, "ItemLegsFull": 99, "ItemFeetFull": 99, "ItemBootsFull": 99 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Wrapping", "Block_ItemMouth", "Will"] },
    { removePrison: true, name: "MysticDuctTapeMouth", unlimited: true, debris: "FabricGreen", inaccessible: true, Asset: "DuctTape", Color: "#55AA22", Group: "ItemMouth", AssetGroup: "ItemMouth2", gag: 0.5, power: 1, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": 0.6, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "mummyRestraints": -299 }, playerTags: { "ItemArmsFull": 99, "ItemLegsFull": 99, "ItemFeetFull": 99, "ItemBootsFull": 99 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Gags", "Tape", "Will"] },
    { removePrison: true, name: "MysticDuctTapeArmsMummy", unlimited: true, debris: "FabricGreen", inaccessible: true, Type: "Complete", remove: ["Cloth", "ClothLower"], LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Asset: "DuctTape", Color: "#55AA22", Group: "ItemArms", bindarms: true, power: 3, weight: 0, escapeChance: { "Struggle": 0.05, "Cut": 0.5, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "mummyRestraints": -199 }, playerTags: { "ItemLegsFull": 99, "ItemFeetFull": 99, "ItemBootsFull": 99 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Wrapping", "Will"] },
    { removePrison: true, name: "MysticDuctTapeLegsMummy", unlimited: true, OverridePriority: 25.1, debris: "FabricGreen", inaccessible: true, Type: "CompleteLegs", remove: ["ClothLower"], LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Asset: "DuctTape", Color: "#55AA22", Group: "ItemLegs", hobble: true, power: 3, weight: 0, escapeChance: { "Struggle": 0.05, "Cut": 0.5, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "mummyRestraints": -99 }, playerTags: { "ItemFeetFull": 99, "ItemBootsFull": 99 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Hobbleskirts", "Will", "Wrapping"] },
    { removePrison: true, name: "MysticDuctTapeFeetMummy", unlimited: true, debris: "FabricGreen", inaccessible: true, Type: "CompleteFeet", Asset: "DuctTape", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Color: "#55AA22", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 3, weight: 0, escapeChance: { "Struggle": 0.05, "Cut": 0.5, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "mummyRestraints": -1 }, playerTags: { "ItemBootsFull": 99 }, minLevel: 0, allFloors: true, shrine: ["Charms", "Wrapping", "Will"] },
    { removePrison: true, name: "MysticDuctTapeBoots", unlimited: true, debris: "FabricGreen", inaccessible: true, Asset: "ToeTape", Type: "Full", Color: "#55AA22", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: 3, weight: 0, escapeChance: { "Struggle": 0.05, "Cut": 0.5, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "mummyRestraints": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Charms", "Wrapping", "Will"] },
    { inventory: true, name: "AutoTapeHands", unlimited: true, inaccessible: true, Asset: "DuctTape", Color: "#6E9FA3", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemHands",
        bindhands: 1.0, power: 6, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0. }, struggleMaxSpeed: { "Remove": 0.1 }, failSuffix: { "Remove": "Tape" },
        strictness: 0.1, strictnessZones: ["ItemHands"], limitChance: { Struggle: 0.12 },
        maxwill: 0.6, enemyTags: { "autoTape": 8 }, playerTags: { "ItemHandsFull": -4 }, minLevel: 8, allFloors: true, shrine: ["Tape"] },
    { removePrison: true, name: "AutoTapeArms", unlimited: true, accessible: true, Type: "Top", Asset: "DuctTape", Color: "#6E9FA3", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemArms",
        bindarms: true, power: 5, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "autoTape": 10 }, playerTags: { "ItemArmsFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Tape"] },
    { removePrison: true, name: "AutoTapeFeet", unlimited: true, accessible: true, Asset: "DuctTape", Color: "#6E9FA3", Group: "ItemFeet", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "autoTape": 10 }, playerTags: { "ItemLegsFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Tape"] },
    { removePrison: true, name: "AutoTapeBoots", unlimited: true, accessible: true, Asset: "ToeTape", Type: "Full", Color: "#6E9FA3", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "autoTape": 10 }, playerTags: { "ItemFeetFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Tape", "Wrapping"] },
    { removePrison: true, name: "AutoTapeLegs", unlimited: true, accessible: true, Type: "MostLegs", Asset: "DuctTape", Color: "#6E9FA3", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemLegs", hobble: true, power: 5, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "autoTape": 10 }, playerTags: { "ItemFeetFull": 8 }, minLevel: 0, allFloors: true, shrine: ["Tape"] },
    { removePrison: true, name: "AutoTapeHead", unlimited: true, inaccessible: true, Type: "Wrap", Asset: "DuctTape", Color: "#6E9FA3", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemHead", power: 5, blindfold: 3, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Tape"] },
    { removePrison: true, name: "AutoTapeMouth", unlimited: true, accessible: true, Asset: "DuctTape", Type: "Double", Color: "#6E9FA3", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemMouth", AssetGroup: "ItemMouth2", gag: 0.5, power: 5, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0 }, failSuffix: { "Remove": "Tape" },
        enemyTags: { "autoTape": 10 }, playerTags: { "ItemMouth1Full": 8 }, minLevel: 0, allFloors: true, shrine: ["Gags", "Tape"] },
    { removePrison: true, name: "ShadowHandMouth", unlimited: true, inaccessible: true, tether: 1.5, Asset: "DuctTape", Type: "Double", Color: ["#3c115c"], Group: "ItemMouth", AssetGroup: "ItemMouth3", gag: 0.5,
        power: 4, weight: 0, escapeChance: { "Struggle": 0.5, "Remove": -100 }, failSuffix: { "Struggle": "ShadowHand", "Remove": "ShadowHand" },
        enemyTags: { "shadowHands": 10, "shadowBolt": 10 }, playerTags: { "ItemMouth1Full": -9 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Rope", "Leather", "Metal", "Wrapping", "Shadow", "Illusion"],
        events: [{ trigger: "tick", type: "ShadowHandTether", requiredTag: "shadowHandEnemy", chance: 1.0, dist: 1.5 }, { trigger: "beforeStruggleCalc", type: "shadowBuff", inheritLinked: true }] },
    { removePrison: true, name: "ShadowHandArms", unlimited: true, LinkableBy: ["Shadow"], accessible: true, tether: 1.5, Asset: "DuctTape", Color: ["#3c115c"], Group: "ItemArms", bindarms: true,
        power: 4, weight: 0, escapeChance: { "Struggle": 0.35, "Remove": -100 }, failSuffix: { "Struggle": "ShadowHand", "Remove": "ShadowHand" },
        enemyTags: { "shadowHands": 10, "shadowBolt": 6 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Rope", "Leather", "Metal", "Tape", "Shadow", "Illusion"],
        events: [{ trigger: "tick", type: "ShadowHandTether", requiredTag: "shadowHandEnemy", chance: 1.0, dist: 1.5 }, { trigger: "beforeStruggleCalc", type: "shadowBuff", inheritLinked: true }] },
    { removePrison: true, name: "ShadowHandArmsHeavy", unlimited: true, inaccessible: true, tether: 1.5, Asset: "DuctTape", Type: "Top", Color: ["#3c115c"], Group: "ItemArms", bindarms: true, bindhands: 0.5,
        power: 5, weight: -9, escapeChance: { "Struggle": 0.1, "Remove": -100 }, failSuffix: { "Struggle": "ShadowHand", "Remove": "ShadowHand" },
        enemyTags: { "shadowHands": 1, "shadowBolt": 1 }, playerTags: { "ItemArmsFull": 9 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Rope", "Leather", "Metal", "Wrapping", "Shadow", "Illusion"],
        events: [{ trigger: "tick", type: "ShadowHandTether", requiredTag: "shadowHandEnemy", chance: 1.0, dist: 1.5 }, { trigger: "beforeStruggleCalc", type: "shadowBuff", inheritLinked: true }] },
    { removePrison: true, name: "ShadowHandLegs", unlimited: true, LinkableBy: ["Shadow"], accessible: true, tether: 1.5, Asset: "DuctTape", Color: ["#3c115c"], Group: "ItemLegs", hobble: true,
        power: 4, weight: 0, escapeChance: { "Struggle": 0.5, "Remove": -100 }, failSuffix: { "Struggle": "ShadowHand", "Remove": "ShadowHand" },
        enemyTags: { "shadowHands": 10, "shadowBolt": 1 }, playerTags: { "ItemArmsEmpty": -1 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Rope", "Leather", "Metal", "Tape", "Shadow", "Illusion"],
        events: [{ trigger: "tick", type: "ShadowHandTether", requiredTag: "shadowHandEnemy", chance: 1.0, dist: 1.5 }, { trigger: "beforeStruggleCalc", type: "shadowBuff", inheritLinked: true }] },
    { removePrison: true, name: "ShadowHandLegsHeavy", unlimited: true, inaccessible: true, tether: 1.5, Asset: "DuctTape", Color: ["#3c115c"], Group: "ItemLegs", Type: "MostLegs", hobble: true, blockfeet: true,
        power: 5, weight: -5, escapeChance: { "Struggle": 0.1, "Remove": -100 }, failSuffix: { "Struggle": "ShadowHand", "Remove": "ShadowHand" },
        enemyTags: { "shadowHands": 1, "shadowBolt": 1 }, playerTags: { "ItemLegsFull": 5, "ItemFeetFull": 3 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Rope", "Leather", "Metal", "Wrapping", "Shadow", "Illusion"],
        events: [{ trigger: "tick", type: "ShadowHandTether", requiredTag: "shadowHandEnemy", chance: 1.0, dist: 1.5 }, { trigger: "beforeStruggleCalc", type: "shadowBuff", inheritLinked: true }] },
    { removePrison: true, name: "ShadowHandCrotch", unlimited: true, accessible: true, tether: 1.5, Asset: "Ribbons", Color: ["#3c115c"], Group: "ItemPelvis", crotchrope: true, strictness: 0.15,
        power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Remove": -100 }, failSuffix: { "Struggle": "ShadowHand", "Remove": "ShadowHand" },
        enemyTags: { "shadowHands": 10, "shadowBolt": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Rope", "Leather", "Metal", "Wrapping", "Shadow", "Illusion"],
        events: [{ trigger: "tick", type: "ShadowHandTether", requiredTag: "shadowHandEnemy", chance: 1.0, dist: 1.5 }, { trigger: "beforeStruggleCalc", type: "shadowBuff", inheritLinked: true }] },
    { removePrison: true, name: "ShadowHandFeet", unlimited: true, accessible: true, tether: 1.5, Asset: "DuctTape", Color: ["#3c115c"], Group: "ItemFeet", blockfeet: true,
        power: 4, weight: 0, escapeChance: { "Struggle": 0.4, "Remove": -100 }, failSuffix: { "Struggle": "ShadowHand", "Remove": "ShadowHand" },
        enemyTags: { "shadowHands": 10, "shadowBolt": 2 }, playerTags: { "ItemLegsEmpty": -2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Rope", "Leather", "Metal", "Wrapping", "Shadow", "Illusion"],
        events: [{ trigger: "tick", type: "ShadowHandTether", requiredTag: "shadowHandEnemy", chance: 1.0, dist: 1.5 }, { trigger: "beforeStruggleCalc", type: "shadowBuff", inheritLinked: true }] },
    { removePrison: true, name: "SlimeBoots", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "ToeTape", Type: "Full", Color: "#9B49BD", Group: "ItemBoots", blockfeet: true, power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0, "Remove": 0 },
        events: [{ trigger: "tick", type: "slimeSpread", power: 0.04 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 1,
        failSuffix: { "Remove": "Slime" },
        factionColor: [[], [0]],
        enemyTags: { "slimeRestraints": 100, "slimeRestraintsRandom": 2, "slimeRestraintsRandomLight": 2 }, playerTags: {},
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Slime"], addTag: ["slime", "FeetLinked"] },
    { removePrison: true, name: "SlimeFeet", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "DuctTape", Type: "CompleteFeet", OverridePriority: 24, Color: "#9B49BD", Group: "ItemFeet", blockfeet: true, power: 4, weight: -100, escapeChance: { "Struggle": 0.3, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", power: 0.05 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 1,
        failSuffix: { "Remove": "Slime" },
        factionColor: [[], [0]],
        enemyTags: { "slimeRestraints": 100, "slimeRestraintsRandom": 101, "slimeRestraintsRandomLight": 101 }, playerTags: { "ItemBootsFull": 15 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Slime"], addTag: ["slime", "FeetLinked"] },
    { removePrison: true, name: "SlimeLegs", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, remove: ["ClothLower"], Asset: "SeamlessHobbleSkirt", Color: "#9B49BD", Group: "ItemLegs", hobble: true, power: 4, weight: -102, escapeChance: { "Struggle": 0.22, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", power: 0.07 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 1,
        failSuffix: { "Remove": "Slime" },
        factionColor: [[], [0]],
        enemyTags: { "slimeRestraints": 100, "slimeRestraintsRandom": 103, "slimeRestraintsRandomLight": 103 }, playerTags: { "ItemFeetFull": 2, "ItemBootsFull": 2 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Hobbleskirts", "Slime"], addTag: ["slime"] },
    { removePrison: true, name: "SlimeArms", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, remove: ["Bra"], Asset: "StraitLeotard", Modules: [0, 0, 0, 0], Color: ["#9B49BD", "#9B49BD", "#9B49BD"], Group: "ItemArms", bindarms: true, bindhands: 0.25, power: 6, weight: -102, escapeChance: { "Struggle": 0.2, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", power: 0.1 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 1,
        failSuffix: { "Remove": "Slime" },
        factionColor: [[], [0, 1, 2]],
        enemyTags: { "slimeRestraints": 100, "slimeRestraintsRandom": 103 }, playerTags: { "ItemFeetFull": 2, "ItemBootsFull": 2, "ItemLegsFull": 2 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Slime"], addTag: ["slime"] },
    { removePrison: true, name: "SlimeHands", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "DuctTape", Color: "#9B49BD", Group: "ItemHands", bindhands: 0.5, power: 1, weight: -102, escapeChance: { "Struggle": 0.4, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", power: 0.05 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 1,
        failSuffix: { "Remove": "Slime" },
        factionColor: [[], [0]],
        enemyTags: { "slimeRestraints": 100, "slimeRestraintsRandom": 103, "slimeRestraintsRandomLight": 103 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHeadFull": 1 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Slime"], addTag: ["slime"] },
    { removePrison: true, name: "SlimeMouth", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "LatexBallMuzzleGag", Color: "#9B49BD", Group: "ItemMouth", AssetGroup: "ItemMouth3", gag: 0.75, power: 4, weight: -102, escapeChance: { "Struggle": 0.22, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", power: 0.05 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 1,
        failSuffix: { "Remove": "Slime" },
        factionColor: [[], [0, 1, 2]],
        enemyTags: { "slimeRestraints": 100, "slimeRestraintsRandom": 103 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHandsFull": 1, "ItemArmsFull": 1 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Slime", "Gags"], addTag: ["slime"] },
    { removePrison: true, name: "SlimeHead", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "LeatherSlimMask", Color: "#9B49BD", Group: "ItemHead", gag: 0.5, blindfold: 4, power: 4, weight: -103, escapeChance: { "Struggle": 0.22, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", power: 0.05 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 1,
        failSuffix: { "Remove": "Slime" },
        factionColor: [[], [0]],
        enemyTags: { "slimeRestraints": 100, "slimeRestraintsRandom": 100 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHandsFull": 1, "ItemArmsFull": 1, "ItemMouth3Full": 1, "Unmasked": -1000 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Block_ItemMouth", "Slime"], addTag: ["slime"] },
    { inventory: true, unlimited: true, removePrison: true, name: "HardSlimeBoots", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "ToeTape", Type: "Full", Color: "#9B49BD", Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 0,
        escapeChance: { "Struggle": 0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        factionColor: [[], [0]],
        enemyTags: { "latexEncase": 100, "latexEncaseRandom": 103 }, playerTags: {},
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "SlimeHard"] },
    { inventory: true, unlimited: true, removePrison: true, name: "HardSlimeFeet", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "DuctTape", Type: "CompleteFeet", OverridePriority: 24, Color: "#9B49BD", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 6, weight: -100,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        factionColor: [[], [0]],
        enemyTags: { "latexEncase": 100, "latexEncaseRandom": 103 }, playerTags: { "ItemBootsFull": 15 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "SlimeHard"] },
    { inventory: true, unlimited: true, removePrison: true, name: "HardSlimeLegs", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, remove: ["ClothLower"], Asset: "SeamlessHobbleSkirt", Color: "#9B49BD", Group: "ItemLegs", hobble: true, power: 6, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        factionColor: [[], [0]],
        enemyTags: { "latexEncase": 100, "latexEncaseRandom": 103 }, playerTags: { "ItemFeetFull": 2, "ItemBootsFull": 2 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Hobbleskirts", "Wrapping", "SlimeHard"] },
    { inventory: true, unlimited: true, removePrison: true, name: "HardSlimeArms", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, remove: ["Bra"], Asset: "StraitLeotard", Modules: [0, 0, 0, 0], Color: ["#9B49BD", "#9B49BD", "#9B49BD"], Group: "ItemArms", bindarms: true, bindhands: 0.35, power: 8, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        factionColor: [[], [0, 1, 2]],
        enemyTags: { "latexEncase": 100, "latexEncaseRandom": 103 }, playerTags: { "ItemFeetFull": 2, "ItemBootsFull": 2, "ItemLegsFull": 2 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "SlimeHard", "Wrapping"] },
    { inventory: true, unlimited: true, removePrison: true, name: "HardSlimeHands", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "DuctTape", Color: "#9B49BD", Group: "ItemHands", bindhands: 0.65, power: 5, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        factionColor: [[], [0]],
        enemyTags: { "latexEncase": 100, "latexEncaseRandom": 103 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHeadFull": 1 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "SlimeHard"] },
    { inventory: true, unlimited: true, removePrison: true, name: "HardSlimeMouth", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, inaccessible: true, Asset: "KittyGag", LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], Color: ["#9B49BD", "#9B49BD", "#9B49BD"], Group: "ItemMouth", AssetGroup: "ItemMouth3", gag: 0.75, power: 6, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        factionColor: [[], [0, 1, 2]],
        enemyTags: { "latexEncase": 100, "latexEncaseRandom": 103 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHandsFull": 1, "ItemArmsFull": 1 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "SlimeHard", "Gags"] },
    { inventory: true, unlimited: true, removePrison: true, name: "HardSlimeHead", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "LeatherSlimMask", Color: "#9B49BD", Group: "ItemHead", gag: 0.5, blindfold: 4, power: 6, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        factionColor: [[], [0]],
        enemyTags: { "latexEncase": 100, "latexEncaseRandom": 103 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHandsFull": 1, "ItemArmsFull": 1, "ItemMouth3Full": 1, "Unmasked": -1000 },
        minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Block_ItemMouth", "SlimeHard"] },
    { removePrison: true, name: "ProtoSlimeBoots", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "ToeTape", Type: "Full", Color: "#404973", Group: "ItemBoots", blockfeet: true, power: 4, weight: 0, escapeChance: { "Struggle": 0.4, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", restraint: "Proto", power: 0.02 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 0.5,
        failSuffix: { "Remove": "Slime" }, enemyTags: { "moldRestraints": 100, "moldRestraintsRandom": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Slime"], addTag: ["slime", "FeetLinked"] },
    { removePrison: true, name: "ProtoSlimeFeet", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "DuctTape", Type: "CompleteFeet", OverridePriority: 24, Color: "#404973", Group: "ItemFeet", blockfeet: true, power: 4, weight: -100, escapeChance: { "Struggle": 0.4, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", restraint: "Proto", power: 0.03 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 0.5,
        failSuffix: { "Remove": "Slime" }, enemyTags: { "moldRestraints": 100, "moldRestraintsRandom": 101 }, playerTags: { "ItemBootsFull": 15 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Slime"], addTag: ["slime", "FeetLinked"] },
    { removePrison: true, name: "ProtoSlimeLegs", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, remove: ["ClothLower"], Asset: "SeamlessHobbleSkirt", Color: "#404973", Group: "ItemLegs", hobble: true, power: 4, weight: -102, escapeChance: { "Struggle": 0.3, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", restraint: "Proto", power: 0.02 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 0.5,
        failSuffix: { "Remove": "Slime" }, enemyTags: { "moldRestraints": 100, "moldRestraintsRandom": 103 }, playerTags: { "ItemFeetFull": 2, "ItemBootsFull": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Hobbleskirts", "Slime"], addTag: ["slime"] },
    { removePrison: true, name: "ProtoSlimeArms", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, remove: ["Bra"], Asset: "StraitLeotard", Modules: [0, 0, 0, 0], Color: ["#404973", "#404973", "#404973"], Group: "ItemArms", bindarms: true, bindhands: 0.2, power: 6, weight: -102, escapeChance: { "Struggle": 0.3, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", restraint: "Proto", power: 0.05 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 0.5,
        failSuffix: { "Remove": "Slime" }, enemyTags: { "moldRestraints": 100, "moldRestraintsRandom": 103 }, playerTags: { "ItemFeetFull": 2, "ItemBootsFull": 2, "ItemLegsFull": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Slime"], addTag: ["slime"] },
    { removePrison: true, name: "ProtoSlimeHands", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "DuctTape", Color: "#404973", Group: "ItemHands", bindhands: 0.4, power: 1, weight: -102, escapeChance: { "Struggle": 0.45, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", restraint: "Proto", power: 0.02 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 0.5,
        failSuffix: { "Remove": "Slime" }, enemyTags: { "moldRestraints": 100, "moldRestraintsRandom": 103 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHeadFull": 1 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Slime"], addTag: ["slime"] },
    { removePrison: true, name: "ProtoSlimeMouth", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "LatexBallMuzzleGag", Color: "#404973", Group: "ItemMouth", AssetGroup: "ItemMouth3", gag: 0.6, power: 4, weight: -102, escapeChance: { "Struggle": 0.3, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", restraint: "Proto", power: 0.02 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 0.5,
        failSuffix: { "Remove": "Slime" }, enemyTags: { "moldRestraints": 100, "moldRestraintsRandom": 103 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHandsFull": 1, "ItemArmsFull": 1 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Slime", "Gags"], addTag: ["slime"] },
    { removePrison: true, name: "ProtoSlimeHead", unlimited: true, debris: "Slime", inaccessible: true, linkCategory: "Slime", linkSize: 0.6, Asset: "LeatherSlimMask", Color: "#404973", Group: "ItemHead", gag: 0.3, blindfold: 4, power: 4, weight: -103, escapeChance: { "Struggle": 0.3, "Cut": 0, "Remove": 0 }, events: [{ trigger: "tick", type: "slimeSpread", restraint: "Proto", power: 0.02 }, { trigger: "remove", type: "slimeStop" }, { trigger: "beforeStruggleCalc", type: "boostWater", power: 0.1 }], slimeLevel: 0.5,
        failSuffix: { "Remove": "Slime" }, enemyTags: { "moldRestraints": 100, "moldRestraintsRandom": 100 }, playerTags: { "ItemFeetFull": 1, "ItemBootsFull": 1, "ItemLegsFull": 1, "ItemHandsFull": 1, "ItemArmsFull": 1, "ItemMouth3Full": 1, "Unmasked": -1000 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Block_ItemMouth", "Slime"], addTag: ["slime"] },
    { inventory: true, removePrison: true, name: "HardProtoSlimeBoots", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "ToeTape", Type: "Full", Color: "#404973", Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 0,
        escapeChance: { "Struggle": 0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "SlimeHard"] },
    { inventory: true, removePrison: true, name: "HardProtoSlimeFeet", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "DuctTape", Type: "CompleteFeet", OverridePriority: 24, Color: "#404973", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 6, weight: -100,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "SlimeHard"] },
    { inventory: true, removePrison: true, name: "HardProtoSlimeLegs", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, remove: ["ClothLower"], Asset: "SeamlessHobbleSkirt", Color: "#404973", Group: "ItemLegs", hobble: true, power: 6, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Hobbleskirts", "SlimeHard"] },
    { inventory: true, removePrison: true, name: "HardProtoSlimeArms", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, remove: ["Bra"], Asset: "StraitLeotard", Modules: [0, 0, 0, 0], Color: ["#404973", "#404973", "#404973"], Group: "ItemArms", bindarms: true, bindhands: 0.25, power: 8, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "SlimeHard"] },
    { inventory: true, removePrison: true, name: "HardProtoSlimeHands", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "DuctTape", Color: "#404973", Group: "ItemHands", bindhands: 0.5, power: 5, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "SlimeHard"] },
    { inventory: true, removePrison: true, name: "HardProtoSlimeMouth", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "KittyGag", Color: ["#404973", "#404973", "#404973"], Group: "ItemMouth", AssetGroup: "ItemMouth3", gag: 0.6, power: 6, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "SlimeHard", "Gags"] },
    { inventory: true, removePrison: true, name: "HardProtoSlimeHead", debris: "Slime", linkCategory: "Slime", linkSize: 0.6, LinkableBy: [...KDRubberLink], renderWhenLinked: [...KDRubberLink], inaccessible: true, Asset: "LeatherSlimMask", Color: "#404973", Group: "ItemHead", gag: 0.3, blindfold: 4, power: 6, weight: -102,
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0 }, failSuffix: { "Remove": "SlimeHard" },
        enemyTags: {}, playerTags: { "Unmasked": -1000 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Wrapping", "Block_ItemMouth", "SlimeHard"] },
    { removePrison: true, name: "GlueBoots", unlimited: true, debris: "Slime", inaccessible: true, Asset: "ToeTape", Type: "Full", Color: "#f0b541", Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: 1, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.0, "Remove": 0.05 },
        enemyTags: { "glueRestraints": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Slime"] },
    { removePrison: true, name: "GlueFeet", unlimited: true, debris: "Slime", inaccessible: true, Asset: "DuctTape", Type: "CompleteFeet", OverridePriority: 24, Color: "#f0b541", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 1, weight: -100, escapeChance: { "Struggle": 0.25, "Cut": 0.0, "Remove": 0.05 },
        enemyTags: { "glueRestraints": 100 }, playerTags: { "ItemBootsFull": 15 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Slime"] },
    { removePrison: true, name: "GlueLegs", unlimited: true, debris: "Slime", inaccessible: true, remove: ["ClothLower"], Asset: "SeamlessHobbleSkirt", Color: "#f0b541", Group: "ItemLegs", blockfeet: true, addTag: ["FeetLinked"], power: 1, weight: -102, escapeChance: { "Struggle": 0.2, "Cut": 0.0, "Remove": 0.05 },
        enemyTags: { "glueRestraints": 100 }, playerTags: { "ItemBootsFull": 2, "ItemFeetFull": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Hobbleskirts", "Slime"] },
    { inventory: true, sfx: "FutureLock", arousalMode: true, name: "CyberBelt", Asset: "FuturisticChastityBelt", Modules: [3, 1, 1, 1, 1], OverridePriority: 26,
        Color: ['#222222', '#499ed6', '#555555', '#000000', '#555555', '#b927a8', '#3868E8', '#555555', '#222222'],
        factionColor: [[0], [5], [1]],
        Group: "ItemPelvis", chastity: true, power: 20, weight: 0, DefaultLock: "Red",
        Security: {
            level_tech: 2,
        },
        maxwill: 0.4,
        escapeChance: { "Struggle": -1.3, "Cut": -0.8, "Remove": 1.0, "Pick": -0.35 },
        enemyTags: { "cyberdollchastity": 10 },
        playerTags: { "ItemVulvaEmpty": -5, "ItemVulvaPiercingsEmpty": -5 },
        minLevel: 7, allFloors: true, shrine: ["Metal", "Chastity", "Cyber", "CyberChastityL"] },
    { inventory: true, sfx: "FutureLock", arousalMode: true, trappable: true, name: "CyberBra", Asset: "FuturisticBra2", OverridePriority: 26,
        Color: ['#499ed6', '#555555', '#222222', '#ffffff', '#555555', '#000000', "#000000"], Group: "ItemBreast",
        factionColor: [[2, 5], [2], [0]],
        chastitybra: true, power: 15, weight: 0, DefaultLock: "Gold",
        Security: {
            level_tech: 2,
        },
        maxwill: 0.6,
        escapeChance: { "Struggle": -1.1, "Cut": -0.8, "Remove": 1.0, "Pick": -0.35 },
        enemyTags: { "cyberdollchastity": 10 },
        playerTags: {},
        minLevel: 4, allFloors: true, shrine: ["Metal", "Chastity", "Cyber", "CyberChastityU"] },
    { alwaysRender: true, sfx: "FutureLock", inventory: true, name: "ControlHarness", debris: "Chains", accessible: true, Asset: "FuturisticHarness", LinkableBy: [...KDHarnessLink], strictness: 0.1,
        Color: ['#499ed6', '#555555', '#555555', '#000000'],
        factionColor: [[], [], [0]],
        Group: "ItemTorso", power: 10, weight: 0,
        escapeChance: { "Struggle": -0.4, "Cut": -0.2, "Remove": 0.4, "Pick": 0.1 },
        DefaultLock: "Red",
        maxwill: 0.5,
        enemyTags: { "controlHarness": 20, "roboPrisoner": 10, "cyberdollrestraints": 100 },
        playerTags: {},
        minLevel: 7, allFloors: true, shrine: ["Metal", "Harnesses", "Cyber"],
        events: [
            { trigger: "postApply", type: "ControlHarness", power: 1, inheritLinked: true },
        ] },
    { inventory: true, sfx: "FutureLock", name: "TrackingCollar", debris: "Chains", accessible: true, Asset: "FuturisticCollar",
        Color: ['#499ed6', '#555555', '#b927a8', '#000000'],
        factionColor: [[], [2], [0]],
        Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.2, "Remove": 0.25, "Pick": -0.1 },
        maxwill: 0.5,
        enemyTags: { "controlHarness": 5, "roboPrisoner": 100, "cyberdollrestraints": 10 },
        playerTags: { "ItemNeckEmpty": 10 },
        minLevel: 0, allFloors: true, shrine: ["Metal", "Collars", "Cyber"],
        events: [
            { trigger: "playerAttack", type: "AlertEnemies", chance: 1.0, power: 10, sfx: "RobotBeep", inheritLinked: true },
        ] },
    {
        inventory: true, sfx: "FutureLock", name: "DollmakerVisor", accessible: true, Asset: "InteractiveVisor",
        curse: "DollLock",
        Color: ['#91023a'],
        Group: "ItemHead", LinkableBy: [...KDVisorLink],
        power: 40, weight: 0, escapeChance: { "Struggle": -0.6, "Cut": -1.0, "Remove": 0.5, "Pick": -0.5 },
        maxwill: 0.1,
        enemyTags: {},
        playerTags: {},
        events: [
            { trigger: "tick", type: "DollmakerMask", inheritLinked: true },
            { trigger: "calcBlind", type: "DollmakerMask", inheritLinked: true },
            { trigger: "kill", type: "DollmakerMask", inheritLinked: true },
            { trigger: "draw", type: "DollmakerMask", inheritLinked: true },
        ],
        minLevel: 0, allFloors: true, shrine: ["Visors", "Cyber"],
    },
    {
        inventory: true, sfx: "FutureLock", name: "DollmakerMask", inaccessible: true,
        curse: "DollLock",
        factionColor: [[2]], Color: ["#ff5277"], Group: "ItemHead", Asset: "DroneMask", LinkableBy: [...KDMaskLink],
        power: 50, weight: 0, escapeChance: { "Struggle": -0.6, "Cut": -1.0, "Remove": 0.5, "Pick": -0.5 },
        maxwill: 0.1,
        enemyTags: {},
        playerTags: {},
        events: [
            { trigger: "tick", type: "DollmakerMask", inheritLinked: true },
            { trigger: "calcBlind", type: "DollmakerMask", inheritLinked: true },
            { trigger: "kill", type: "DollmakerMask", inheritLinked: true },
            { trigger: "draw", type: "DollmakerMask", inheritLinked: true },
        ],
        minLevel: 0, allFloors: true, shrine: ["Masks", "Block_ItemMouth", "Cyber"],
    },
    { inventory: true, sfx: "FutureLock", name: "CyberBallGag", debris: "Belts", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink],
        Asset: "FuturisticHarnessBallGag", strictness: 0.35, gag: 0.65,
        Color: ['#499ed6', '#b927a8', '#222222', '#FFFFFF', '#000000'], Group: "ItemMouth", power: 12, weight: 0,
        factionColor: [[2], [1], [0]],
        maxwill: 0.75, escapeChance: { "Struggle": -0.4, "Cut": -0.2, "Remove": 0.05, "Pick": -0.1 },
        enemyTags: { "cyberdollrestraints": 10 },
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Gags", "BallGags", "Metal", "Cyber"] },
    { inventory: true, sfx: "FutureLock", name: "CyberPlugGag", debris: "Belts", LinkableBy: [...KDPlugGagLink], renderWhenLinked: [...KDPlugGagLink],
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        Asset: "FuturisticHarnessPanelGag", strictness: 0.35, gag: 1.0,
        Color: ['#499ed6', '#222222', '#555555', '#FFFFFF', '#000000'], Group: "ItemMouth", power: 15, weight: 0,
        factionColor: [[], [], [0]],
        maxwill: 0.75, escapeChance: { "Struggle": -0.4, "Cut": -0.2, "Remove": 0.05, "Pick": -0.1 },
        enemyTags: { "cyberdollrestraints": 10 },
        playerTags: {}, minLevel: 15, allFloors: true, shrine: ["Gags", "PlugGags", "Metal", "Cyber"] },
    { inventory: true, sfx: "FutureLock", name: "CyberMuzzle", debris: "Belts", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink],
        inaccessible: true,
        Asset: "FuturisticMuzzle", strictness: 0.35, gag: 0.5,
        Color: ['#499ed6', '#222222', '#555555', '#FFFFFF', '#000000'], Group: "ItemMouth", power: 12, weight: 0,
        factionColor: [[], [], [0]],
        maxwill: 0.25, escapeChance: { "Struggle": -0.25, "Cut": -0.8, "Remove": 0.05, "Pick": -0.25 },
        enemyTags: { "cyberdollheavy": 1 },
        playerTags: {}, minLevel: 9, allFloors: true, shrine: ["Gags", "FlatGags", "Metal", "Cyber", "ControlHMouth"] },
    { inventory: true, sfx: "FutureLock", name: "CyberDollJacket", inaccessible: true, remove: ["Bra"], Asset: "FuturisticStraitjacket",
        Modules: [1, 1, 1, 1],
        factionColor: [[0], [1], [3]],
        Color: ["#222222", "#b927a8", "#000000", "#499ed6", "#222222", "#000000"],
        Group: "ItemArms", bindarms: true, bindhands: 1.0, power: 15, weight: 0, strictness: 0.2,
        escapeChance: { "Struggle": -0.2, "Cut": -.3, "Remove": -0.3, "Pick": -0.1 },
        limitChance: { "Struggle": -0.2, "Cut": 0.3, "Remove": 0.1, "Unlock": 0.75 },
        maxwill: 0.1, DefaultLock: "Red",
        enemyTags: { "cyberdollheavy": 1 },
        playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Straitjackets", "Cyber"] },
    { inventory: true, sfx: "FutureLock", name: "CyberHeels", inaccessible: true, Asset: "FuturisticHeels2",
        factionColor: [[0], [4], [1]],
        Color: ["#222222", "#499ed6", "#ffffff", "Default", "#b927a8", "#222222", "#000000"],
        Group: "ItemBoots", hobble: true, power: 10, weight: 0,
        escapeChance: { "Struggle": -0.4, "Cut": -0.35, "Remove": 0.2, "Pick": -0.25 },
        maxwill: 0.25, enemyTags: { "cyberdollrestraints": 10 },
        playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Boots", "Cyber"] },
    { inventory: true, sfx: "FutureLock", name: "CyberAnkleCuffs", debris: "Chains", accessible: true, Asset: "FuturisticAnkleCuffs", Link: "CyberAnkleCuffs2", LinkableBy: [...KDBindable, ...KDDevices],
        Color: ["#499ed6", "#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [2], [0, 1]],
        Group: "ItemFeet", power: 12, weight: 0,
        escapeChance: { "Struggle": -0.8, "Cut": -0.65, "Remove": 0.25, "Pick": -0.15 },
        enemyTags: { "cyberdollcuffs": 6, "cyberdollrestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cyber", "Cuffs", "AnkleCuffsBase"],
        events: [
            { trigger: "hit", type: "linkItem", sfx: "FutureLock", chance: 0.0, subMult: 0.0, tags: ["lowwill"], noLeash: true }
        ] },
    { name: "CyberAnkleCuffs2", sfx: "FutureLock", accessible: true, Asset: "FuturisticAnkleCuffs", debris: "Chains", DefaultLock: "Red", Link: "CyberAnkleCuffs3", UnLink: "CyberAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], Type: "Chained",
        Color: ["#499ed6", "#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [2], [0, 1]],
        Group: "ItemFeet", hobble: true, power: 12, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.2, "Remove": -0.15, "Pick": 0 },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "ControlHAnkle"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" },
            { trigger: "hit", type: "linkItem", sfx: "FutureLock", chance: 0.0, subMult: 0.0, tags: ["lowwill"], noLeash: true }
        ] },
    { name: "CyberAnkleCuffs3", sfx: "FutureLock", accessible: true, Asset: "FuturisticAnkleCuffs", debris: "Chains", DefaultLock: "Red", UnLink: "CyberAnkleCuffs2", LinkableBy: [...KDBindable, ...KDDevices], Type: "Closed",
        Color: ["#499ed6", "#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [2], [0, 1]],
        Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 12, weight: 0,
        escapeChance: { "Struggle": -0.3, "Remove": -0.15, "Pick": -0.05 },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "ControlHAnkle"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }
        ] },
    { inventory: true, sfx: "FutureLock", name: "CyberLegCuffs", debris: "Chains", accessible: true, Asset: "FuturisticLegCuffs", Link: "CyberLegCuffs2", LinkableBy: [...KDBindable, ...KDDevices],
        Color: ["#499ed6", "#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [2], [0, 1]],
        Group: "ItemLegs", power: 12, weight: 0,
        escapeChance: { "Struggle": -0.8, "Cut": -0.65, "Remove": 0.25, "Pick": -0.15 },
        enemyTags: { "cyberdollcuffs": 6, "cyberdollrestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cyber", "Cuffs", "LegCuffsBase"],
        events: [
            { trigger: "hit", type: "linkItem", sfx: "FutureLock", chance: 0.0, subMult: 0.0, tags: ["lowwill"], noLeash: true }
        ] },
    { name: "CyberLegCuffs2", sfx: "FutureLock", accessible: true, Asset: "FuturisticLegCuffs", debris: "Chains", DefaultLock: "Red", UnLink: "CyberLegCuffs", LinkableBy: [...KDBindable, ...KDDevices], Type: "Closed",
        Color: ["#499ed6", "#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [2], [0, 1]],
        Group: "ItemLegs", hobble: true, power: 12, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.2, "Remove": -0.15, "Pick": 0 },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "ControlHLeg"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "postRemoval", type: "RequireBaseLegCuffs" }
        ] },
    { renderWhenLinked: ["Ties"], sfx: "FutureLock", nonbinding: true, inventory: true, name: "CyberArmCuffs", debris: "Chains", DefaultLock: "Red", accessible: true,
        Asset: "FuturisticCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "CyberArmCuffs2",
        Color: ["#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [1], [0]],
        Group: "ItemArms", bindarms: false, power: 12, weight: 0,
        escapeChance: { "Struggle": -0.8, "Cut": -0.65, "Remove": 0.25, "Pick": -0.15 },
        enemyTags: { "cyberdollcuffs": 20, "cyberdollrestraints": 6 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cuffs", "ArmCuffsBase", "Cyber"],
        maxwill: 0.8, events: [
            { trigger: "hit", type: "linkItem", sfx: "FutureLock", chance: 0.0, tags: ["lowwill"] },
            { trigger: "defeat", type: "linkItem", chance: 1.0 }
        ] },
    { name: "CyberArmCuffs2", sfx: "FutureLock", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "CyberArmCuffs3", UnLink: "CyberArmCuffs",
        Color: ["#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [1], [0]],
        Group: "ItemArms", bindarms: true, power: 12, weight: 0,
        escapeChance: { "Struggle": -0.2, "Remove": 0.2, "Pick": 0.1 },
        helpChance: { "Remove": 0.4 },
        enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "ControlHArm"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "hit", type: "linkItem", sfx: "FutureLock", chance: 0, tags: ["lowwill"] },
            { trigger: "postRemoval", type: "RequireBaseArmCuffs" },
            { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }
        ] },
    { name: "CyberArmCuffs3", sfx: "FutureLock", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "CyberArmCuffs4",
        Color: ["#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [1], [0]],
        Group: "ItemArms", bindarms: true, power: 12,
        weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.2, "Remove": -0.1, "Pick": 0 },
        helpChance: { "Remove": 0.4 },
        enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "ControlHArm"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "postRemoval", type: "RequireBaseArmCuffs" },
            { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }
        ] },
    { name: "CyberArmCuffs4", sfx: "FutureLock", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "CyberArmCuffs3", UnLink: "CyberArmCuffs",
        Color: ["#499ed6", "#b927a8", "#000000"],
        factionColor: [[], [1], [0]],
        Group: "ItemArms", bindarms: true, power: 12, weight: 0,
        escapeChance: { "Struggle": -0.3, "Remove": -0.15, "Pick": -0.05 },
        helpChance: { "Remove": 0.4 },
        enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "ControlHArm"],
        events: [{ trigger: "remove", type: "unlinkItem" },
            { trigger: "hit", type: "linkItem", sfx: "FutureLock", chance: 0, tags: ["lowwill"] },
            { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true },
            { trigger: "postRemoval", type: "RequireBaseArmCuffs" }
        ] },
    { inventory: true, name: "LatexStraitjacket", inaccessible: true, factionColor: [[0, 1, 2]], remove: ["Bra"], Asset: "StraitLeotard", Modules: [1, 1, 1, 1], Color: ["#499ed6", "#499ed6", "#499ed6"], Group: "ItemArms", bindarms: true, bindhands: 1.0, power: 7, weight: 0, strictness: 0.2,
        escapeChance: { "Struggle": 0.1, "Cut": 0.15, "Remove": 0.1, "Pick": 0.35 },
        limitChance: { "Struggle": 0.25, "Cut": 0.14, "Remove": 0.08, "Unlock": 0.75 },
        maxwill: 0.25, enemyTags: { "latexRestraintsHeavy": 3, "jailRestraints": 1 }, playerTags: { "posLatex": -1, "latexRage": 4, "ItemArmsEmpty": -10 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Straitjackets"] },
    { inventory: true, name: "LatexArmbinder", inaccessible: true, factionColor: [[0]], Asset: "SeamlessLatexArmbinder", strictness: 0.1, LinkableBy: [...KDArmbinderLink], Color: ["#499ed6"], Group: "ItemArms", bindarms: true, bindhands: 1.0, power: 7, weight: 0, escapeChance: { "Struggle": 0.15, "Cut": 0.15, "Remove": 0.1, "Pick": 0.35 },
        limitChance: { "Struggle": 0.2, "Cut": 0.1, "Remove": 0.85, "Unlock": 0.2 },
        maxwill: 0.35, enemyTags: { "latexRestraints": 5, "latexRestraintsForced": 15, "jailRestraints": 5 }, playerTags: { "posLatex": -1, "latexAnger": 1, "latexRage": 1, "ItemArmsEmpty": -10 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Armbinders"] },
    { renderWhenLinked: [...KDLegbinderRender], inventory: true, name: "LatexLegbinder", inaccessible: true, factionColor: [[0]], Asset: "SeamlessLegBinder", LinkableBy: [...KDLegbinderLink], Color: ["#499ed6"], Group: "ItemLegs", hobble: true, power: 7, weight: 0, escapeChance: { "Struggle": -0.05, "Cut": 0.15, "Remove": 0.1, "Pick": 0.35 },
        maxwill: 0.6, enemyTags: { "latexRestraintsHeavy": 6, "jailRestraints": 1, "latexStart": 10 }, playerTags: { "posLatex": -1, "latexAnger": 1, "latexRage": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Legbinders"] },
    { inventory: true, name: "LatexBoots", inaccessible: true, factionColor: [[0]], Asset: "HighThighBoots", Color: ["#3873C3"], Group: "ItemBoots", hobble: true, power: 6, weight: 0, escapeChance: { "Struggle": -0.15, "Cut": 0.12, "Remove": 0.07, "Pick": 0.25 },
        enemyTags: { "latexRestraints": 8, "latexBoots": 3, "jailRestraints": 1, "latexUniform": 12 }, playerTags: { "posLatex": -1, "latexAnger": 2, "latexRage": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex"] },
    { alwaysRender: true, inventory: true, name: "LatexCorset", linkCategory: "Corset", linkSize: 0.55, inaccessible: true, deepAccessible: true, factionColor: [[0]], OverridePriority: 25.9, Asset: "HeavyLatexCorset", LinkableBy: KDCorsetLink, strictness: 0.1, Color: ["#5196EF"], Group: "ItemTorso", power: 8, weight: 0, escapeChance: { "Struggle": -0.1, "Cut": 0.2, "Remove": 0.15, "Pick": 0.3 }, struggleMinSpeed: { "Remove": 0.05 }, struggleMaxSpeed: { "Remove": 0.1 },
        failSuffix: { "Remove": "Corset" }, enemyTags: { "latexRestraints": 7, "jailRestraints": 1, "latexUniform": 12 }, playerTags: { "ItemTorsoFull": -5, "posLatex": -1, "latexAnger": 2, "latexRage": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Corsets", "HeavyCorsets"] },
    { inventory: true, name: "LatexBallGag", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], factionColor: [[], [0]], Asset: "BallGag", gag: 0.75, Color: ["#4EA1FF", "Default"], Type: "Tight", Group: "ItemMouth", power: 7, weight: 0, escapeChance: { "Struggle": -0.05, "Cut": 0.04, "Remove": 0.4, "Pick": 0.25 },
        maxwill: 0.8, enemyTags: { "latexRestraints": 3, "latexGag": 10, "jailRestraints": 1 }, playerTags: { "posLatex": -1, "latexAnger": 2, "latexRage": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Gags", "BallGags"] },
    { inventory: true, name: "LatexOTNGag", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], factionColor: [[0], [0], [0]], Asset: "KittyGag", gag: 0.5, Color: ["#4EA1FF", "#4EA1FF", "#4EA1FF"], Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 4, weight: -6, escapeChance: { "Struggle": 0.05, "Cut": 0.18, "Remove": 0.1 },
        maxwill: 0.5, enemyTags: { "latexRestraints": 6 }, playerTags: { "ItemMouthFull": 6 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Gags", "FlatGags"] },
    { renderWhenLinked: ["Corsets", "Harnesses", ...KDBindable, "Latex", "Leather", "Metal", "Rope"], inventory: true, name: "LatexCatsuit", inaccessible: true, factionColor: [[0]], Asset: "SeamlessCatsuit", AssetGroup: "Suit", Color: ["#3873C3"],
        LinkableBy: ["Corsets", "Harnesses", ...KDBindable, "Ribbon"],
        Group: "ItemTorso", power: 7, weight: 0, escapeChance: { "Struggle": -1.0, "Cut": 0.1, "Remove": 0.05 },
        enemyTags: { "latexRestraintsHeavy": 6, "latexCatsuits": 12, "latexUniform": 12, "latexStart": 10 }, playerTags: { "posLatex": -1, "latexAnger": 2, "latexRage": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Suits"],
        alwaysDress: [
            { Item: "SeamlessCatsuit", Group: "Suit", Color: ['#3873C3'], override: true, factionColor: [[0]] },
            { Item: "SeamlessCatsuit", Group: "SuitLower", Color: ['#3873C3'], override: true, factionColor: [[0]] },
            { Item: "Catsuit", Group: "Gloves", Color: ['#3873C3'], override: true, factionColor: [[0]] }
        ],
        events: [
            { trigger: "beforeStruggleCalc", type: "latexDebuff", power: 0.15, inheritLinked: true }
        ]
    },
    { inventory: true, unlimited: true, name: "RedLatexOTNGag", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink],
        factionColor: [[2], [2], [2]], Asset: "KittyGag", gag: 0.5, Color: ["#ff5277", "#ff5277", "#ff5277"], Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 7, weight: -6,
        escapeChance: { "Struggle": -0.1, "Cut": -0.1, "Remove": -0.1 },
        maxwill: 0.8, enemyTags: { "redLatexBasic": 6 }, playerTags: { "ItemMouthFull": 6 }, minLevel: 0, allFloors: true, shrine: ["Latex", "RedLatex", "Gags", "FlatGags"] },
    { inventory: true, unlimited: true, name: "RedLatexBallGag", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], factionColor: [[], [0]], Asset: "BallGag", gag: 0.75, Color: ["#ff5277", "#882222"],
        Type: "Tight", Group: "ItemMouth", power: 6, weight: 0, escapeChance: { "Struggle": -0.1, "Cut": -0.1, "Remove": -0.1 },
        maxwill: 0.8, enemyTags: { "redLatexBasic": 5 }, playerTags: { "latexAnger": 2, "latexRage": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "RedLatex", "Gags", "BallGags"] },
    { inventory: true, unlimited: true, name: "RedLatexMask", LinkableBy: [...KDMaskLink],
        gag: 0.3, blindfold: 4, power: 7, weight: -6,
        factionColor: [[2]], Color: ["#ff5277"], Group: "ItemHead", Asset: "DroneMask",
        escapeChance: { "Struggle": -0.1, "Cut": -0.1, "Remove": -0.1 },
        maxwill: 0.8, enemyTags: { "redLatexBasic": 6 }, playerTags: { "ItemMouthFull": 6, "Unmasked": -1000 }, minLevel: 0, allFloors: true, shrine: ["Latex", "RedLatex", "Masks", "Block_ItemMouth"] },
    { inventory: true, unlimited: true, name: "RedLatexHands",
        Asset: "LatexElbowGloves", Color: "#ff5277", LinkableBy: ["Mittens"], Group: "ItemHands", AssetGroup: "Gloves",
        bindhands: 0.5, power: 10, weight: 0,
        affinity: { Remove: ["Hook"], }, struggleMinSpeed: { "Struggle": 0.1 },
        escapeChance: { "Struggle": -0.1, "Cut": -0.1, "Remove": -0.1 },
        maxwill: 0.4, enemyTags: { "redLatexBasic": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "RedLatex",] },
    { inventory: true, unlimited: true, name: "RedLatexBoots", LinkableBy: ["Boots"], renderWhenLinked: ["Boots"], deepAccessible: true, alwaysAccessible: true,
        hobble: true, power: 5, weight: 0,
        factionColor: [[2]], Color: ["#ff5277"], Group: "ItemBoots", AssetGroup: "Socks", Asset: "LatexSocks1",
        escapeChance: { "Struggle": -0.1, "Cut": -0.1, "Remove": -0.1 },
        maxwill: 0.8, enemyTags: { "redLatexBasic": 5 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "RedLatex", "Socks"] },
    { inventory: true, name: "WolfArmbinder", debris: "Belts", inaccessible: true, Asset: "SeamlessLatexArmbinder", strictness: 0.1, LinkableBy: [...KDArmbinderLink], Color: "#2E2E2E", Group: "ItemArms", bindarms: true, bindhands: 1.0, power: 7.5, weight: 0, escapeChance: { "Struggle": 0.05, "Cut": 0.15, "Remove": 0.07, "Pick": 0.2 },
        limitChance: { "Cut": 0.1, "Remove": 0.04, "Unlock": 0.2 },
        maxwill: 0.35, enemyTags: { "wolfRestraints": 5 }, playerTags: { "ItemArmsEmpty": -10 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Metal", "Armbinders"] },
    { inventory: true, name: "WolfCuffs", debris: "Chains", Asset: "MetalCuffs", accessible: true, linkCategory: "Cuffs", linkSize: 0.33, LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Color: "Default", Group: "ItemArms", bindarms: true, power: 5, weight: 2, DefaultLock: "Red",
        maxwill: 0.8, escapeChance: { "Struggle": -0.5, "Cut": -0.1, "Remove": 10, "Pick": 0.0 }, enemyTags: { "wolfCuffs": 8, "cuffsSpell": 100 }, playerTags: {}, minLevel: 5, allFloors: true, shrine: ["Metal", "Cuffs"] },
    { inventory: true, name: "WolfAnkleCuffs", debris: "Chains", accessible: true, Asset: "FuturisticAnkleCuffs", Link: "WolfAnkleCuffs2", LinkableBy: [...KDBindable], Type: "Chained", Color: ['#4F91DE', '#4F91DE', '#3F6945', '#000000'], Group: "ItemFeet", hobble: true, power: 8, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.4, "Remove": 0.4, "Pick": 0.15 },
        maxwill: 1.0, enemyTags: { "wolfRestraints": 7 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "AnkleCuffsBase"],
        events: [
            { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.3, subMult: 0.5, tags: ["lowwill"], noLeash: true },
            { trigger: "remotePunish", type: "RemoteLinkItem", sfx: "LightJingle", noLeash: true, enemyDialogue: "KDDialogueRemoteLinkCuffs", msg: "KDMsgRemoteLinkCuffs" },
        ] },
    { name: "WolfAnkleCuffs2", debris: "Chains", accessible: true, Asset: "FuturisticAnkleCuffs", UnLink: "WolfAnkleCuffs", LinkableBy: ["AnkleCuffsBase", ...KDBindable], Type: "Closed", Color: ['#4F91DE', '#4F91DE', '#3F6945', '#000000'], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 8, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.5, "Remove": 0.4, "Pick": 0.15 },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { alwaysRender: true, inventory: true, name: "WolfHarness", debris: "Belts", accessible: true, remove: ["Cloth"], Asset: "FuturisticHarness", LinkableBy: [...KDHarnessLink], strictness: 0.05, harness: true, Color: ['#4F91DE', '#346942', '#889FA7', "#000000"], Group: "ItemTorso", power: 4, weight: 0,
        escapeChance: { "Struggle": -0.15, "Cut": 0.2, "Remove": 0.1, "Pick": 0.35 },
        maxwill: 1.0, enemyTags: { "wolfRestraints": 6, "wolfGear": 6 }, playerTags: { "ItemTorsoFull": -5 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Harnesses"] },
    { inventory: true, name: "WolfBallGag", debris: "Belts", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink],
        Asset: "FuturisticHarnessBallGag", strictness: 0.35, gag: 0.65,
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        Color: ['#5edc73', '#428E4F', '#6E6E6E', '#FFFFFF', '#000000'], Group: "ItemMouth", power: 9, weight: 0,
        maxwill: 0.75, escapeChance: { "Struggle": -0.3, "Cut": 0.0, "Remove": 0.05, "Pick": 0.2 },
        enemyTags: { "wolfRestraints": 8 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Gags", "BallGags", "Metal"] },
    { inventory: true, name: "WolfCollar", debris: "Belts", accessible: true, Asset: "AutoShockCollar", Color: ['#6EAF81', '#6EAF81'], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 11, weight: 0, escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0.1, "Pick": -0.05 },
        maxwill: 0.5, enemyTags: { "wolfRestraints": 3, "wolfGear": 3, "wolfLeash": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Collars", "HighCollars"],
        events: [
            { trigger: "playerAttack", type: "PunishPlayer", chance: 0.25, stun: 2, warningchance: 1.0, damage: "electric", power: 2, sfx: "Shock", inheritLinked: true, },
            { trigger: "beforeStruggleCalc", type: "ShockForStruggle", chance: 0.75, stun: 2, warningchance: 0.6, damage: "electric", power: 2, sfx: "Shock", bind: 0.2, inheritLinked: true, },
            { trigger: "playerCast", type: "PunishPlayer", chance: 1.0, punishComponent: "Verbal", damage: "electric", power: 2, sfx: "Shock", inheritLinked: true, },
            { trigger: "remotePunish", type: "RemoteActivatedShock", chance: 0.1, stun: 2, damage: "electric", power: 1, sfx: "Shock", noLeash: true, inheritLinked: true, }
        ] },
    { inventory: true, removePrison: true, name: "WolfLeash", debris: "Belts", tether: 2.9, Asset: "CollarLeash", Color: "#44fF76", Group: "ItemNeckRestraints", leash: true, power: 1, weight: -99, harness: true,
        unlimited: true,
        events: [
            { trigger: "postRemoval", type: "RequireCollar" },
        ],
        escapeChance: { "Struggle": -0.3, "Cut": -0.2, "Remove": 0.4, "Pick": 0.35 }, enemyTags: { "wolfRestraints": 9, "wolfLeash": 10 }, playerTags: { "ItemNeckRestraintsFull": -2, "ItemNeckFull": 999 }, minLevel: 0, allFloors: true, shrine: [] },
    { inventory: true, name: "BindingDress", debris: "Fabric", inaccessible: true, remove: ["Cloth", "Bra"], Type: "Strap", Asset: "LeatherArmbinder", strictness: 0.25, Color: ['#473488'], Group: "ItemArms", LinkableBy: [...KDDressLink], bindarms: true, bindhands: 1.0, power: 8, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": 0.2, "Remove": -0.2, "Pick": 0.15 }, helpChance: { "Struggle": -0.1, "Cut": 0.2, "Remove": 0.075 },
        limitChance: { "Struggle": 0.125, "Cut": 0.125, "Remove": 0.1, "Unlock": 0.5 },
        alwaysDress: [
            { Item: "PleatedSkirt", Group: "ClothLower", Color: ['#6B48E0'], override: true },
            { Item: "SleevelessCatsuit", Group: "Suit", Color: ['#473488'], override: true },
            { Item: "CatsuitPanties", Group: "SuitLower", Color: ['#473488'], override: true }
        ],
        maxwill: 0.5, enemyTags: { "dressRestraints": 10, "bindingDress": 10 }, playerTags: { "ItemArmsEmpty": -10 }, minLevel: 0, allFloors: true, shrine: ["Latex", "BindingDress"] },
    { inventory: true, trappable: true, name: "DressGag", debris: "Fabric", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], Asset: "HarnessBallGag",
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        gag: 0.65, Type: "Tight", Color: ["#8762c7", "Default"], Group: "ItemMouth", power: 8, strictness: 0.2, weight: 5, magic: true,
        escapeChance: { "Struggle": -0.2, "Cut": 0.2, "Remove": 0.2, "Pick": 0.2 },
        maxwill: 0.6, enemyTags: { "dressRestraints": 3 }, playerTags: {}, minLevel: 2, allFloors: true, shrine: ["Rope", "Gags", "BallGags"] },
    { inventory: true, trappable: true, name: "DressMuzzle", debris: "Fabric", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], Asset: "MuzzleGag", gag: 0.3, Color: ["#6B48E0", "#39339c"], Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 9, strictness: 0.3, weight: 1, magic: true,
        escapeChance: { "Struggle": -0.4, "Cut": 0.15, "Remove": 0.2, "Pick": 0.1 }, DefaultLock: "Blue",
        maxwill: 0.1, enemyTags: { "dressRestraints": 3, "dressGags": 3 }, playerTags: { "ItemMouthEmpty": -10 }, minLevel: 6, allFloors: true, shrine: ["Rope", "Gags", "FlatGags"] },
    { alwaysRender: true, inventory: true, name: "DressCorset", debris: "Fabric", linkCategory: "Corset", linkSize: 0.55, inaccessible: true, factionColor: [[0]], OverridePriority: 26, Asset: "HeavyLatexCorset",
        LinkableBy: KDCorsetLink, strictness: 0.1, Color: ["#473488"], Group: "ItemTorso", power: 8, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": 0.2, "Remove": -0.2, "Pick": 0.15 }, helpChance: { "Struggle": -0.1, "Cut": 0.2, "Remove": 0.025 }, struggleMinSpeed: { "Remove": 0.05 }, struggleMaxSpeed: { "Remove": 0.1 },
        failSuffix: { "Remove": "Corset" }, enemyTags: { "dressRestraints": 1, "dressUniform": 12 }, playerTags: { "ItemTorsoFull": -5, "conjureAnger": 2, "conjureRage": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Corsets", "HeavyCorsets"],
        alwaysDress: [
            { Item: "AsymmetricSkirt", Group: "ClothLower", Color: ['#6B48E0'], override: true },
            { Item: "SleevelessCatsuit", Group: "Suit", Color: ['#473488'], override: true },
            { Item: "CatsuitPanties", Group: "SuitLower", Color: ['#F8BD01'], override: true }
        ], },
    { inventory: true, name: "DressBra", debris: "Fabric", inaccessible: true, Asset: "FuturisticBra2", Color: ['#6B48E0', '#F8BD01', '#6B48E0', '#6B48E0', '#F8BD01', '#6B48E0'], Group: "ItemBreast", LinkableBy: ["Ornate"], chastitybra: true, power: 8, weight: -2,
        Security: {
            level_key: 2,
            level_magic: 2,
        },
        escapeChance: { "Struggle": -0.5, "Cut": -0.05, "Remove": 0.4, "Pick": 0.15 }, bypass: true,
        maxwill: 0.9, enemyTags: { "dressRestraints": 10, "dressUniform": 10 }, playerTags: { "ItemNipplesFull": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Harnesses"] },
    { inventory: true, name: "AsylumJacket", debris: "Belts", Asset: "HighSecurityStraitJacket", Modules: [1, 2, 3], Color: ["#333333", "#333333", '#808080', '#808080'], LinkableBy: ["TransportJackets", "Wrapping"], Group: "ItemArms", power: 8, weight: 0, bindarms: true, bindhands: 1.0, strictness: 0.2,
        limitChance: { "Struggle": 0.12, "Cut": 0.03, "Remove": 0.1, "Unlock": 0.75 },
        escapeChance: { "Struggle": -0.175, "Cut": 0.15, "Remove": 0.1, "Pick": 0.15 },
        enemyTags: { "nurseRestraints": 5, "jacketSpell": 50 }, playerTags: { "ItemArmsFull": -2, "ItemArmsEmpty": -10 }, minLevel: 0, maxwill: 0.35, allFloors: true, shrine: ["Straitjackets", "Leather"] },
    { inventory: true, name: "TransportJacket", debris: "Belts", Asset: "TransportJacket", events: [{ type: "PrisonerJacket", trigger: "afterDress" }], Color: ["#808080", "#202020", "#808080", "#EEEEEE", "#202020", "#808080"],
        Group: "ItemArms", power: 10, weight: 0, bindarms: true, bindhands: 1.0, strictness: 0.3, LinkableBy: ["Wrapping"],
        limitChance: { "Struggle": 0.12, "Cut": 0.1, "Remove": 0.15, "Unlock": 0.75 },
        escapeChance: { "Struggle": -0.175, "Cut": 0.1, "Remove": 0.1, "Pick": 0.15 },
        enemyTags: { "nurseRestraints": 1 }, playerTags: { "ItemArmsEmpty": -10, "AsylumJacketWorn": 20 }, minLevel: 0, maxwill: 0.1, allFloors: true, shrine: ["Straitjackets", "TransportJackets", "Leather"] },
    { renderWhenLinked: [...KDLegbinderRender], inventory: true, name: "AsylumLegbinder", debris: "Belts", inaccessible: true, Asset: "LegBinder", LinkableBy: [...KDLegbinderLink], Color: "Default", Group: "ItemLegs", blockfeet: true,
        power: 6, weight: 2, escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": 0.3, "Pick": 0.25 }, enemyTags: { "nurseRestraints": 1 }, playerTags: { "ItemArmsFull": 3 },
        struggleMaxSpeed: { "Remove": 0.1 },
        minLevel: 0, allFloors: true, shrine: ["Leather", "Legbinders"] },
    { inventory: true, name: "AsylumMuzzle", debris: "Belts", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], gag: 0.4, Asset: "FuturisticMuzzle", Modules: [1, 1, 0], Group: "ItemMouth", AssetGroup: "ItemMouth3", Color: ["#814F21", "#814F21", "#814F21", "#814F21"], power: 8, weight: 2,
        escapeChance: { "Struggle": -0.14, "Cut": 0.18, "Remove": 0.25, "Pick": 0.2 }, maxwill: 0.9,
        enemyTags: { "nurseRestraints": 3 }, playerTags: { "ItemMouthFull": 1 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "FlatGags"] },
    { inventory: true, curse: "GhostLock", name: "MikoCollar", Asset: "HighCollar", Color: ["#ffffff", "#AA2222"], Group: "ItemNeck", LinkableBy: [...KDCollarLink], magic: true, power: 40, weight: 0, difficultyBonus: 10,
        escapeChance: { "Struggle": -100, "Cut": -0.8, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Collars", "HighCollars"],
        unlimited: true,
        events: [{ trigger: "kill", type: "MikoGhost" }],
    },
    { inventory: true, name: "MikoGag", Asset: "OTNPlugGag", debris: "Belts", LinkableBy: [...KDPlugGagLink], renderWhenLinked: [...KDPlugGagLink], Type: "Plug", gag: 1.0, Color: ["#ffffff", "#AA2222", "#ffffff"], Group: "ItemMouth", power: 9, weight: 2, DefaultLock: "Blue", magic: true,
        escapeChance: { "Struggle": -0.2, "Cut": 0.2, "Remove": 0.15, "Pick": 0.07 },
        maxwill: 0.6, enemyTags: { "mikoRestraints": 10 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "PlugGags"] },
    { inventory: true, name: "MikoDress", debris: "Fabric", inaccessible: true, remove: ["Cloth", "Bra"], Type: "Strap", Asset: "LeatherArmbinder", strictness: 0.25, Color: ['#ffffff'], Group: "ItemArms", LinkableBy: [...KDDressLink], bindarms: true, bindhands: 1.0, power: 8, weight: 0, DefaultLock: "Blue",
        escapeChance: { "Struggle": -0.2, "Cut": 0.2, "Remove": -0.2, "Pick": 0.15 }, helpChance: { "Struggle": -0.15, "Cut": 0.2, "Remove": 0.025 },
        limitChance: { "Struggle": 0.125, "Cut": 0.125, "Remove": 0.1, "Unlock": 0.5 },
        alwaysDress: [
            { Item: "PleatedSkirt", Group: "ClothLower", Color: ['#AA2222'], override: true },
            { Item: "SleevelessCatsuit", Group: "Suit", Color: ['#AA2222'], override: true },
            { Item: "LatexCorset1", Group: "Corset", Color: ['#ffffff'], override: true },
            { Item: "CatsuitPanties", Group: "SuitLower", Color: ['#AA2222'], override: true }
        ],
        maxwill: 0.5, enemyTags: { "mikoRestraints": 10 }, playerTags: { "ItemArmsEmpty": -10 }, minLevel: 0, allFloors: true, shrine: ["Latex", "BindingDress"] },
    { inventory: true, name: "ExpArmbinder", debris: "Belts", inaccessible: true, Asset: "BoxTieArmbinder", strictness: 0.08, LinkableBy: ["Wrapping"], Color: ["#415690", "#ffffff"], Group: "ItemArms", bindarms: true, bindhands: 1.0, power: 7, weight: 0,
        limitChance: { "Struggle": 0.15, "Cut": 0.1, "Remove": 0.035, "Unlock": 0.5 },
        escapeChance: { "Struggle": 0.1, "Cut": 0.15, "Remove": 0.1, "Pick": 0.35 },
        maxwill: 0.25, enemyTags: { "expRestraints": 5 }, playerTags: { "ItemArmsEmpty": -10 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Boxbinders"] },
    { alwaysRender: true, inventory: true, name: "ExpArmbinderHarness", debris: "Belts", accessible: true, Asset: "Corset4", Color: "#383E4D", Group: "ItemTorso", strictness: 0.1, power: 9, weight: -10, OverridePriority: 26, LinkableBy: [...KDHarnessLink],
        escapeChance: { "Struggle": 0.0, "Cut": 0.1, "Remove": 0.15 },
        maxwill: 0.6, enemyTags: { "expRestraints": 9 }, playerTags: { "Boxbinders": 20, "Armbinders": 20 }, minLevel: 7, allFloors: true, shrine: ["Latex", "ArmbinderHarness"],
        events: [{ trigger: "postRemoval", type: "armbinderHarness" }], requireSingleTagToEquip: ["Armbinders", "Boxbinders"] },
    { inventory: true, name: "ExpCollar", debris: "Belts", inaccessible: true, Asset: "LatexPostureCollar", gag: 0.4, Color: "#4E7DFF", Group: "ItemNeck", LinkableBy: [...KDCollarLink], factionColor: [[0]], power: 8, weight: -2, strictness: 0.05, escapeChance: { "Struggle": 0, "Cut": 0.15, "Remove": 0.2, "Pick": 0.25 },
        maxwill: 0.25, enemyTags: { "expRestraints": 2.1, "latexCollar": 1 }, playerTags: { "ItemMouthFull": 2, "ItemMouth2Full": 2, "ItemMouth3Full": 2 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Posture", "Collars", "HighCollars"] },
    { inventory: true, name: "ExpBoots", debris: "Belts", inaccessible: true, Asset: "BalletWedges", Color: "#748395", Group: "ItemBoots", LinkableBy: ["Wrapping"], hobble: true, power: 8, weight: 0, escapeChance: { "Struggle": -0.25, "Cut": 0.0, "Remove": 0.07, "Pick": 0.25 },
        maxwill: 0.9, enemyTags: { "expRestraints": 6, "latexBoots": 3, "wolfRestraints": 6, "blacksteelrestraints": 10 }, playerTags: {}, minLevel: 2, allFloors: true, shrine: ["Metal", "Boots"] },
    { inventory: true, name: "ExpAnkleCuffs", debris: "Chains", accessible: true, Asset: "FuturisticAnkleCuffs", Link: "ExpAnkleCuffs2", LinkableBy: [...KDBindable, ...KDDevices], Type: "Chained",
        Color: ["#92e8c0", "#171222", "#333333"], Group: "ItemFeet", hobble: true, power: 10, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.4, "Remove": 0.1, "Pick": 0.15 },
        enemyTags: { "expRestraints": 7, "blacksteelrestraints": 10, "blacksteelcuffs": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Blacksteel", "Cuffs", "AnkleCuffsBase"],
        events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "ExpAnkleCuffs2", accessible: true, Asset: "FuturisticAnkleCuffs", debris: "Chains", DefaultLock: "Red", UnLink: "ExpAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], Type: "Closed",
        Color: ["#92e8c0", "#171222", "#333333"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 10, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.5, "Remove": 0.1, "Pick": 0.15 },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Blacksteel", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { inventory: true, name: "BlacksteelLegCuffs", debris: "Chains", accessible: true, Asset: "FuturisticLegCuffs", DefaultLock: "Red", LinkableBy: ["Legbinders", "Hobbleskirts", "Belts", "Ties"], Type: "Chained",
        Color: ["#92e8c0", "#171222", "#333333"], Group: "ItemLegs", hobble: true, power: 10, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.5, "Remove": 0.2, "Pick": 0.25 },
        maxwill: 0.8, enemyTags: { "blacksteelrestraints": 6, "blacksteelcuffs": 6 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 6, allFloors: true, shrine: ["Metal", "Cuffs", "Blacksteel", "Elements"] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "BlacksteelArmCuffs", debris: "Chains", DefaultLock: "Red", accessible: true,
        Asset: "FuturisticCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "BlacksteelArmCuffs2",
        Color: ["#333333", "#171222", "#92e8c0",], Group: "ItemArms", bindarms: false, power: 10, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.5, "Remove": 0.25, "Pick": 0.35 }, enemyTags: { "blacksteelrestraints": 54, "blacksteelcuffs": 20 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cuffs", "ArmCuffsBase", "Blacksteel", "Elements"],
        maxwill: 0.8, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "defeat", type: "linkItem", chance: 1.0 }] },
    { name: "BlacksteelArmCuffs2", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "BlacksteelArmCuffs3", UnLink: "BlacksteelArmCuffs",
        Color: ["#333333", "#171222", "#92e8c0",],
        Group: "ItemArms", bindarms: true, power: 10, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.4, "Remove": 0.2, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Blacksteel", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { name: "BlacksteelArmCuffs3", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "BlacksteelArmCuffs4",
        Color: ["#333333", "#171222", "#92e8c0",], Group: "ItemArms", bindarms: true, power: 10,
        weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.2, "Cut": -0.4, "Remove": -0.1, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Blacksteel", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }] },
    { name: "BlacksteelArmCuffs4", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "BlacksteelArmCuffs3", UnLink: "BlacksteelArmCuffs",
        Color: ["#333333", "#171222", "#92e8c0",],
        Group: "ItemArms", bindarms: true, power: 10, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.4, "Remove": -0.15, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Blacksteel", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] }, { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }] },
    { inventory: true, name: "Stuffing", unlimited: true, debris: "Fabric", Asset: "ClothStuffing", LinkableBy: [...KDStuffingLink], Color: "Default", Group: "ItemMouth", power: -20, weight: 0, gag: 0.4,
        escapeChance: { "Struggle": 1, "Cut": 1, "Remove": 1 }, enemyTags: { "stuffedGag": 100, "clothRestraints": 12, "ribbonRestraints": 6 }, playerTags: {}, minLevel: 0,
        allFloors: true, shrine: ["Stuffing"] },
    { unlimited: true, inventory: true, renderWhenLinked: ["Boxbinders"], changeRenderType: { "ArmBind": "WristElbowHarnessTie" }, name: "WeakMagicRopeArms", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Color: "#ff88AA", LinkableBy: ["Boxbinders", "Wrapping"], Group: "ItemArms", bindarms: true, power: 0, weight: 1, escapeChance: { "Struggle": 0.3, "Cut": 0.67, "Remove": 0.2 },
        affinity: { Remove: ["Hook"], },
        failSuffix: { "Remove": "MagicRope" }, maxwill: 0.65, enemyTags: { "ropeMagicWeak": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Boxties"] },
    { unlimited: true, renderWhenLinked: [...KDLegRopesRender], inventory: true, name: "WeakMagicRopeLegs", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Type: "FullBinding", LinkableBy: [...KDLegRopesBind], Color: "#ff88AA", Group: "ItemLegs", hobble: true, power: 0, weight: 1,
        affinity: { Remove: ["Hook"], },
        failSuffix: { "Remove": "MagicRope" }, escapeChance: { "Struggle": 0.3, "Cut": 0.67, "Remove": 0.15 }, enemyTags: { "ropeMagicWeak": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure"] },
    { unlimited: true, inventory: true, name: "StrongMagicRopeCuffs", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Color: "#ff00dd", Type: "RopeCuffs", linkCategory: "Cuffs", linkSize: 0.33, LinkableBy: ["Boxbinders", "Armbinders", ...KDBindable, "Cuffs"], Group: "ItemArms", bindarms: true, power: 2, weight: 1, escapeChance: { "Struggle": 0.3, "Cut": 0.35, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"],
        affinity: { Remove: ["Hook"], },
        failSuffix: { "Remove": "MagicRope" }, maxwill: 1.0, enemyTags: { "ropeMagicStrong": 5 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Cuffs", "Conjure"] },
    { unlimited: true, inventory: true, name: "StrongMagicRopeCuffsAdv", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Color: "#ff00dd", Type: "RopeCuffs", linkCategory: "Cuffs", linkSize: 0.51, LinkableBy: ["Boxbinders", "Armbinders", ...KDBindable, "Cuffs"], Group: "ItemArms", bindarms: true, power: 2, weight: 1, escapeChance: { "Struggle": 0.2, "Cut": 0.35, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"],
        affinity: { Remove: ["Hook"], }, strictness: 0.1, strictnessZones: ["ItemHands"],
        failSuffix: { "Remove": "MagicRope" }, maxwill: 1.0, enemyTags: { "ropeMagicStrong": 7 }, playerTags: {}, minLevel: 9, allFloors: true, shrine: ["Rope", "Cuffs", "Conjure"] },
    { unlimited: true, renderWhenLinked: ["Boxbinders"], changeRenderType: { "ArmBind": "WristElbowHarnessTie" }, inventory: true, name: "StrongMagicRopeArms", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Color: "#ff00dd", LinkableBy: ["Boxbinders", "Wrapping"], Group: "ItemArms", bindarms: true, power: 6, weight: 1, escapeChance: { "Struggle": 0.15, "Cut": 0.2, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"],
        affinity: { Remove: ["Hook"], },
        failSuffix: { "Remove": "MagicRope" }, maxwill: 0.65, enemyTags: { "ropeMagicStrong": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Wristties"] },
    { unlimited: true, inventory: false, name: "StrongMagicRopeHogtie", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Color: "#ff00dd", Type: "Hogtied", Group: "ItemArms", bindarms: true, power: 8, weight: 1, escapeChance: { "Struggle": -0.1, "Cut": 0.15, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"],
        affinity: { Remove: ["Hook"], },
        maxwill: 0.25, enemyTags: { "ropeMagicHogtie": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Hogties", "Conjure"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "postRemoval", type: "replaceItem", list: ["StrongMagicRopeArms"], power: 6 }]
    },
    { unlimited: true, renderWhenLinked: [...KDLegRopesRender], inventory: true, name: "StrongMagicRopeLegs", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Type: "FullBinding", LinkableBy: [...KDLegRopesBind], Color: "#ff00dd", Group: "ItemLegs", hobble: true, power: 5, weight: 1,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.15, "Cut": 0.2, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"],
        failSuffix: { "Remove": "MagicRope" }, maxwill: 0.8, enemyTags: { "ropeMagicStrong": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure"] },
    { unlimited: true, inventory: true, name: "StrongMagicRopeFeet", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Color: "#ff00dd", LinkableBy: ["Wrapping"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 1,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.15, "Cut": 0.2, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"],
        failSuffix: { "Remove": "MagicRope" }, enemyTags: { "ropeMagicStrong": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure"] },
    { unlimited: true, inventory: true, name: "StrongMagicRopeCrotch", debris: "Ropes", accessible: true, factionColor: [[], [0]], crotchrope: true, strictness: 0.15, Asset: "HempRope", Type: "OverPanties", OverridePriority: 26, Color: "#ff00dd", Group: "ItemPelvis", power: 5, weight: 1,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.15, "Cut": 0.2, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"], enemyTags: { "ropeMagicStrong": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "crotchrope" }] },
    { unlimited: true, inventory: true, name: "StrongMagicRopeToe", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "ToeTie", OverridePriority: 26, LinkableBy: ["Wrapping"], Color: "#ff00dd", Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 1,
        affinity: { Remove: ["Hook"], },
        failSuffix: { "Remove": "MagicRope" }, escapeChance: { "Struggle": 0.15, "Cut": 0.2, "Remove": -0.1 }, specStruggleTypes: ["Remove", "Struggle"], enemyTags: { "ropeMagicStrong": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure"] },
    { unlimited: true, renderWhenLinked: ["Boxbinders"], changeRenderType: { "ArmBind": "WristElbowHarnessTie" }, inventory: true, name: "MithrilRopeArms", debris: "Ropes", accessible: true, Asset: "NylonRope", Color: "#ffffff", LinkableBy: ["Armbinders", "Wrapping"], Group: "ItemArms", bindarms: true, power: 6, weight: 1, magic: true,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0.05 }, specStruggleTypes: ["Remove", "Struggle"],
        maxwill: 0.7, enemyTags: { "mithrilRope": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Will", "Boxties"] },
    { unlimited: true, inventory: false, name: "MithrilRopeHogtie", debris: "Ropes", accessible: true, Asset: "HempRope", Color: "#ffffff", Type: "KneelingHogtie", Group: "ItemArms", bindarms: true, power: 8, weight: 1, magic: true,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": -0.1, "Cut": 0.15, "Remove": 0.05 }, specStruggleTypes: ["Remove", "Struggle"],
        maxwill: 0.15, enemyTags: { "mithrilRopeHogtie": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Hogties", "Will"],
        events: [{ trigger: "postRemoval", type: "replaceItem", list: ["MithrilRopeArms"], power: 6 }]
    },
    { unlimited: true, renderWhenLinked: [...KDLegRopesRender], inventory: true, name: "MithrilRopeLegs", debris: "Ropes", accessible: true, Asset: "NylonRope", LinkableBy: [...KDLegRopesBind], Color: "#ffffff", Group: "ItemLegs", hobble: true, power: 5, weight: 1, magic: true,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0.05 }, specStruggleTypes: ["Remove", "Struggle"], strictness: 0.1,
        maxwill: 0.8, enemyTags: { "mithrilRope": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Will"] },
    { unlimited: true, inventory: true, name: "MithrilRopeFeet", debris: "Ropes", accessible: true, Asset: "NylonRope", Color: "#ffffff", LinkableBy: ["Wrapping"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 1, magic: true,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0.05 }, specStruggleTypes: ["Remove", "Struggle"], strictness: 0.1,
        enemyTags: { "mithrilRope": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Will"] },
    { unlimited: true, inventory: true, name: "MithrilRopeHarness", debris: "Ropes", accessible: true, Asset: "NylonRopeHarness", Type: "Star", harness: true, OverridePriority: 26, Color: "#ffffff", Group: "ItemTorso", power: 5, weight: 1, magic: true,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0.05 }, specStruggleTypes: ["Remove", "Struggle"], strictness: 0.1,
        enemyTags: { "mithrilRope": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Will"] },
    { unlimited: true, inventory: true, name: "MithrilRopeCrotch", debris: "Ropes", accessible: true, crotchrope: true, strictness: 0.15, Asset: "HempRope", Type: "OverPanties", OverridePriority: 26, Color: "#ffffff", Group: "ItemPelvis", power: 5, weight: 1, magic: true,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0.05 }, specStruggleTypes: ["Remove", "Struggle"],
        enemyTags: { "mithrilRope": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Will"],
        events: [{ trigger: "struggle", type: "crotchrope" }] },
    { unlimited: true, inventory: true, name: "MithrilRopeToe", debris: "Ropes", accessible: true, Asset: "ToeTie", OverridePriority: 26, LinkableBy: ["Wrapping"], Color: "#ffffff", Group: "ItemBoots", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 1, magic: true,
        affinity: { Remove: ["Hook"], },
        escapeChance: { "Struggle": 0.1, "Cut": 0.2, "Remove": 0.05 }, specStruggleTypes: ["Remove", "Struggle"],
        enemyTags: { "mithrilRope": 2 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Will"] },
    { inventory: true, name: "MithrilLegCuffs", debris: "Chains", accessible: true, Asset: "FuturisticLegCuffs", LinkableBy: ["Legbinders", "Wrapping", "Hobbleskirts", "Belts"], Type: "Chained", Color: ['#888888', '#FFFFFF', '#CFBE88', '#000000'], Group: "ItemLegs", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 },
        maxwill: 0.6, enemyTags: { "mithrilRestraints": 6 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 7, allFloors: true, shrine: ["Metal", "Cuffs", "Will"] },
    { inventory: true, name: "MithrilAnkleCuffs", debris: "Chains", accessible: true, Asset: "FuturisticAnkleCuffs", LinkableBy: [...KDBindable], Link: "MithrilAnkleCuffs2", Type: "Chained", Color: ['#888888', '#FFFFFF', '#CFBE88', '#000000'], Group: "ItemFeet", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 }, enemyTags: { "mithrilRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "Will", "AnkleCuffsBase"],
        maxwill: 0.5, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "MithrilAnkleCuffs2", debris: "Chains", accessible: true, Asset: "FuturisticAnkleCuffs", LinkableBy: [...KDBindable], UnLink: "MithrilAnkleCuffs", Type: "Closed", Color: ['#888888', '#FFFFFF', '#CFBE88', '#000000'], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 }, enemyTags: { "mithrilRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "Will"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "MithrilArmCuffs", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "MithrilArmCuffs2", Color: ['#FFFFFF', '#CFBE88', '#000000'], Group: "ItemArms", bindarms: false, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.2, "Remove": 0.25, "Pick": 0.35 }, enemyTags: { "mithrilRestraints": 24 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cuffs", "Will", "ArmCuffsBase"],
        maxwill: 0.4, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "defeat", type: "linkItem", chance: 1.0 }] },
    { name: "MithrilArmCuffs2", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "MithrilArmCuffs3", UnLink: "MithrilArmCuffs", Color: ['#FFFFFF', '#CFBE88', '#000000'], Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": -0.3, "Remove": 0.2, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Will"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { name: "MithrilArmCuffs3", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "MithrilArmCuffs4", Color: ['#FFFFFF', '#CFBE88', '#000000'], Group: "ItemArms", bindarms: true, power: 9, weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.175, "Cut": -0.3, "Remove": -0.1, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Will"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }] },
    { name: "MithrilArmCuffs4", debris: "Chains", accessible: true, Asset: "FuturisticCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "MithrilArmCuffs3", UnLink: "MithrilArmCuffs", Color: ['#FFFFFF', '#CFBE88', '#000000'], Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": -0.3, "Remove": -0.15, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Will"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] }, { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }] },
    { inventory: true, name: "MithrilCollar", Asset: "ShinySteelCollar", Color: ['#C9B883', '#C9B883'], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 9, weight: -2,
        unlimited: true, escapeChance: { "Struggle": -0.1, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 },
        maxwill: 0.25, enemyTags: { "mithrilRestraints": 4 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Collars", "Will"] },
    { unlimited: true, removePrison: true, name: "StickySlime", debris: "Slime", Asset: "Web", Type: "Wrapped", Color: "#ff77ff", Group: "ItemArms", bindarms: true, bindhands: 0.5, power: 0.1, weight: 1, removeOnLeash: true, freeze: true, escapeChance: { "Struggle": 10, "Cut": 10, "Remove": 10 }, enemyTags: { "slime": 100 }, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Slime"] },
    { removePrison: true, name: "BarrelTrap", Asset: "SmallWoodenBox", Color: "Default", Group: "ItemDevices", power: 2, weight: 1, immobile: true, alwaysStruggleable: true, blindfold: 5, enclose: true,
        escapeChance: { "Struggle": 0.1, "Cut": 0.025, "Remove": 0.025, "Pick": -1.0, "Unlock": -1.0 },
        struggleMinSpeed: { "Struggle": 0.07, "Cut": 0.03, "Remove": 0.05 }, alwaysEscapable: ["Struggle"],
        struggleMaxSpeed: { "Struggle": 0.15, "Cut": 0.15, "Remove": 0.15 },
        helpChance: { "Remove": 0.4, "Pick": 0.2, "Unlock": 1.0 },
        limitChance: { "Struggle": 0.01, "Cut": 0, "Remove": 0.01, "Pick": 0, "Unlock": 0 },
        enemyTags: { "barrel": 100 }, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Furniture"], ignoreSpells: true, removeOnLeash: true, ignoreIfNotLeash: true,
        events: [{ trigger: "tick", type: "barrelDebuff", inheritLinked: true }, { trigger: "tick", type: "callGuardFurniture", inheritLinked: true }, { trigger: "playerMove", type: "removeOnMove", inheritLinked: true }] },
    { removePrison: true, name: "CageTrap", Asset: "Cage", Color: ['Default', 'Default', '#000000'], Group: "ItemDevices", power: 3, weight: 1, immobile: true, alwaysStruggleable: true,
        DefaultLock: "Red",
        escapeChance: { "Struggle": -0.2, "Cut": -0.2, "Remove": 0.35, "Pick": 0.33, "Unlock": 0.7 },
        helpChance: { "Remove": 0.5, "Pick": 0.5, "Unlock": 1.0 },
        enemyTags: { "cage": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Furniture"], ignoreSpells: true, removeOnLeash: true,
        events: [{ trigger: "tick", type: "cageDebuff", inheritLinked: true }, { trigger: "tick", type: "callGuardFurniture", inheritLinked: true }, { trigger: "playerMove", type: "removeOnMove", inheritLinked: true }] },
    { removePrison: true, name: "Sarcophagus", Asset: "DisplayCase", Color: ['Default'], Group: "ItemDevices", power: 10, weight: 1, immobile: true, alwaysStruggleable: true,
        DefaultLock: "Blue",
        escapeChance: { "Struggle": -0.2, "Cut": -0.2, "Remove": 0.35, "Pick": -0.5, "Unlock": 0.7 },
        helpChance: { "Remove": 0.5, "Pick": 0.5, "Unlock": 1.0 },
        enemyTags: { "sarcophagus": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Furniture", "Sarcophagus"], ignoreSpells: true, removeOnLeash: true,
        events: [{ trigger: "tick", type: "cageDebuff", inheritLinked: true }, { trigger: "tick", type: "callGuardFurniture", inheritLinked: true, chance: 0.04 }, { trigger: "playerMove", type: "removeOnMove", inheritLinked: true }] },
    { removePrison: true, name: "DisplayTrap", Asset: "TheDisplayFrame", Color: ['Default'], Group: "ItemDevices", power: 5, weight: 1, immobile: true, alwaysStruggleable: true,
        DefaultLock: "Red",
        bindarms: true,
        escapeChance: { "Struggle": -0.1, "Cut": -0.8, "Remove": 0.15, "Pick": -0.1, "Unlock": -0.1 },
        helpChance: { "Remove": 0.35, "Pick": 0.25, "Unlock": 0.5 },
        removeShrine: ["Hogties"],
        enemyTags: { "displaySpell": 100, "display": 100, "displaystand": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Furniture"], ignoreSpells: true, removeOnLeash: true,
        events: [{ trigger: "tick", type: "cageDebuff", inheritLinked: true }, { trigger: "tick", type: "callGuardFurniture", inheritLinked: true }, { trigger: "playerMove", type: "removeOnMove", inheritLinked: true }] },
    { removePrison: true, name: "DollStand", arousalMode: true, Asset: "OneBarPrison", Color: ['Default'], Group: "ItemDevices", power: 5, weight: 1, immobile: true, alwaysStruggleable: true,
        DefaultLock: "Red",
        escapeChance: { "Struggle": -0.1, "Cut": -0.6, "Remove": 0.5, "Pick": 0.1, "Unlock": -0.05 },
        helpChance: { "Remove": 0.8, "Pick": 0.35, "Unlock": 0.8 },
        removeShrine: ["Hogties"],
        enemyTags: { "dollstandSpell": 100, "dollstand": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Furniture"], ignoreSpells: true, removeOnLeash: true,
    },
    { removePrison: true, name: "DollStandSFW", Asset: "TheDisplayFrame", Color: ['Default'], Group: "ItemDevices", power: 5, weight: 1, immobile: true, alwaysStruggleable: true,
        DefaultLock: "Red",
        escapeChance: { "Struggle": -0.1, "Cut": -0.6, "Remove": 0.5, "Pick": 0.1, "Unlock": -0.05 },
        helpChance: { "Remove": 0.8, "Pick": 0.35, "Unlock": 0.8 },
        removeShrine: ["Hogties"],
        enemyTags: { "dollstandSpell": 100, "dollstand": 100 }, playerTags: { "arousalMode": -1000 }, minLevel: 0, allFloors: true, shrine: ["Furniture"], ignoreSpells: true, removeOnLeash: true,
    },
    { removePrison: true, name: "BedTrap", debris: "Belts", Asset: "Bed", Color: ["#523629", "#4c6885", "#808284"], Group: "ItemDevices", power: 2, weight: 1, immobile: true, alwaysStruggleable: true,
        escapeChance: { "Struggle": 0.2, "Cut": 0.2, "Remove": 0.05, "Pick": -1.0, "Unlock": -1.0 },
        struggleMinSpeed: { "Struggle": 0.025 }, alwaysEscapable: ["Struggle"],
        struggleMaxSpeed: { "Struggle": 0.05, "Cut": 0.03, "Remove": 0.05 }, helpChance: { "Remove": 0.4, "Pick": 0.2, "Unlock": 1.0 },
        limitChance: { "Struggle": 0.01, "Cut": 0, "Remove": 0.01, "Pick": 0, "Unlock": 0 },
        alwaysDress: [
            { Item: "BedStraps", Group: "ItemAddon", Color: ['Default'], override: false },
        ],
        enemyTags: { "bed": 100 }, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Furniture"], ignoreSpells: true, removeOnLeash: true,
        events: [{ trigger: "tick", type: "callGuardFurniture", inheritLinked: true }, { trigger: "playerMove", type: "removeOnMove", inheritLinked: true }] },
    { inventory: true, name: "HighsecArmbinder", debris: "Belts", strictness: 0.1, Asset: "LeatherArmbinder", inaccessible: true, LinkableBy: [...KDArmbinderLink], Type: "Strap", Group: "ItemArms", bindarms: true, bindhands: 1.0, Color: "#333333",
        limitChance: { "Unlock": 0.2 }, power: 7, weight: 2,
        escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": 0.35, "Pick": 0.2 }, enemyTags: { "leatherRestraintsHeavy": 4, "armbinderSpell": 100 }, playerTags: { "ItemArmsEmpty": -10 }, minLevel: 8, allFloors: true, shrine: ["Leather", "Armbinders"] },
    { inventory: true, name: "HighsecShackles", debris: "Chains", Asset: "SteelAnkleCuffs", Type: "Chained", LinkableBy: [...KDBindable, ...KDDevices], Group: "ItemFeet", hobble: true, Color: ["Default", "Default"], power: 6, weight: 2,
        escapeChance: { "Struggle": -0.5, "Cut": -0.5, "Remove": 1.1, "Pick": 0.3 }, enemyTags: {}, playerTags: {}, minLevel: 7, allFloors: true, shrine: ["Metal", "Cuffs"] },
    { inventory: true, name: "HighsecBallGag", debris: "Belts", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], factionColor: [[], [0]], Asset: "HarnessBallGag",
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        strictness: 0.2, gag: 0.65, Type: "Tight", Color: ["Default", "Default"], Group: "ItemMouth", power: 8, weight: 2,
        escapeChance: { "Struggle": -0.25, "Cut": -0.05, "Remove": 0.5, "Pick": 0.25 }, enemyTags: { "ballGagRestraints": 4, "gagSpell": 100 }, playerTags: {}, minLevel: 5, allFloors: true, shrine: ["Leather", "Latex", "Gags", "BallGags"] },
    { renderWhenLinked: [...KDLegbinderRender], inventory: true, name: "HighsecLegbinder", debris: "Belts", Asset: "LegBinder", inaccessible: true, LinkableBy: [...KDLegbinderLink], Color: "Default", Group: "ItemLegs", blockfeet: true,
        power: 8, weight: 2, escapeChance: { "Struggle": -0.1, "Cut": 0.1, "Remove": 0.35, "Pick": 0.25 }, enemyTags: { "legbinderSpell": 10 }, playerTags: {}, minLevel: 0, allFloors: true,
        shrine: ["Leather", "Legbinders"] },
    { inventory: true, arousalMode: true, name: "PrisonBelt", Asset: "PolishedChastityBelt", OverridePriority: 26, Color: "#444444", Group: "ItemPelvis", LinkableBy: ["Ornate"], chastity: true,
        Security: {
            level_key: 2,
            level_tech: 1,
        },
        power: 8, weight: 2, escapeChance: { "Struggle": -0.5, "Cut": -0.30, "Remove": 100.0, "Pick": 0.25 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Chastity"] },
    { inventory: true, arousalMode: true, name: "PrisonBelt2", Asset: "OrnateChastityBelt", OverridePriority: 26, Color: ["#272727", "#AA0000"], Group: "ItemPelvis", chastity: true,
        Security: {
            level_key: 3,
            level_magic: 2,
        },
        power: 9, weight: 2, escapeChance: { "Struggle": -0.5, "Cut": -0.30, "Remove": 100.0, "Pick": 0.22 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Chastity", "Ornate"] },
    { alwaysRender: true, inventory: true, name: "TrapArmbinderHarness", debris: "Belts", Asset: "LeatherHarness", accessible: true, Color: "Default", Group: "ItemTorso", OverridePriority: 26, LinkableBy: [...KDHarnessLink], power: 3, strictness: 0.1, weight: -100, escapeChance: { "Struggle": -0.1, "Cut": 0.25, "Remove": 0.25, "Pick": 0.15 },
        enemyTags: { "leatherRestraintsHeavy": 2, "armbinderSpell": 1, "harnessSpell": 1 }, playerTags: { "ItemArmsEmpty": -1000, "Armbinders": 100 }, minLevel: 4, allFloors: true, shrine: ["Leather", "ArmbinderHarness"],
        maxwill: 0.6, events: [{ trigger: "postRemoval", type: "armbinderHarness" }], requireSingleTagToEquip: ["Armbinders", "Boxbinders"] },
    { renderWhenLinked: ["Belts"], inventory: true, trappable: true, name: "TrapArmbinder", debris: "Belts", inaccessible: true, strictness: 0.1, Asset: "LeatherArmbinder", LinkableBy: [...KDArmbinderLink], Type: "WrapStrap", Group: "ItemArms", Color: "Default", bindarms: true, bindhands: 1.0, power: 6, weight: 2,
        limitChance: { "Struggle": 0.15, "Cut": 0.1, "Unlock": 0.2 },
        maxwill: 0.25, escapeChance: { "Struggle": 0.1, "Cut": 0.5, "Remove": 0.35, "Pick": 0.5 }, enemyTags: { "trap": 100, "leatherRestraintsHeavy": 6, "armbinderSpell": 10 }, playerTags: { "ItemArmsEmpty": -8 }, minLevel: 4, allFloors: true, shrine: ["Leather", "Armbinders"] },
    { inventory: true, trappable: true, name: "TrapCuffs", debris: "Chains", Asset: "MetalCuffs", accessible: true, linkCategory: "Cuffs", linkSize: 0.33, LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Group: "ItemArms",
        Color: "Default", bindarms: true, power: 2, weight: 2, DefaultLock: "Red",
        escapeChance: { "Struggle": -0.5, "Cut": -0.1, "Remove": 10, "Pick": 0.5 }, enemyTags: { "trap": 100, "cuffsSpell": 10 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"] },
    { inventory: true, trappable: true, name: "TrapYoke", Asset: "Yoke", accessible: true, Group: "ItemArms",
        Color: "Default", bindarms: true, power: 6, weight: 0, DefaultLock: "Red",
        escapeChance: { "Struggle": -0.5, "Cut": -0.5, "Remove": 10, "Pick": -0.15, "Unlock": -0.15 },
        helpChance: { "Pick": 0.5, "Unlock": 1.0 }, enemyTags: { "trap": 9, "yokeSpell": 10, "Unchained": -9 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Yokes"] },
    { alwaysRender: true, inventory: true, trappable: true, name: "TrapHarness", debris: "Belts", strictness: 0.05, Asset: "LeatherStrapHarness", accessible: true, LinkableBy: [...KDHarnessLink], OverridePriority: 26, Color: "#222222", Group: "ItemTorso", power: 2, weight: 2,
        escapeChance: { "Struggle": 0.1, "Cut": 0.3, "Remove": 0.8, "Pick": 0.4 }, enemyTags: { "trap": 100, "leatherRestraintsHeavy": 6, "harnessSpell": 10 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Harnesses"] },
    { inventory: true, trappable: true, name: "TrapGag", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], Asset: "BallGag", factionColor: [[], [0]], gag: 0.35, Type: "Tight", Color: ["Default", "Default"], Group: "ItemMouth", power: 3, weight: 2,
        maxwill: 0.6, escapeChance: { "Struggle": 0.35, "Cut": 0.45, "Remove": 0.3, "Pick": 0.4 }, enemyTags: { "trap": 100, "leatherRestraintsHeavy": 6, "gagSpell": 8 }, playerTags: {}, minLevel: 0, allFloors: true,
        shrine: ["Leather", "Latex", "Gags", "BallGags"] },
    { inventory: true, trappable: true, name: "TrapBlindfold", debris: "Belts", Asset: "LeatherBlindfold", LinkableBy: [...KDBlindfoldLink], renderWhenLinked: [...KDBlindfoldLink], Color: "Default", Group: "ItemHead", power: 3, weight: 2,
        maxwill: 0.5, blindfold: 2, escapeChance: { "Struggle": 0.4, "Cut": 0.6, "Remove": 0.3, "Pick": 0.4 }, enemyTags: { "trap": 100, "leatherRestraintsHeavy": 6, "ropeAuxiliary": 4, "blindfoldSpell": 10 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Blindfolds"] },
    { inventory: true, trappable: true, name: "TrapBoots", debris: "Belts", Asset: "BalletHeels", Color: "Default", Group: "ItemBoots", hobble: true, power: 3, weight: 2,
        maxwill: 0.9, escapeChance: { "Struggle": 0.15, "Cut": 0.45, "Remove": 0.4, "Pick": 0.4 }, enemyTags: { "trap": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Boots"] },
    { inventory: true, trappable: true, name: "TrapLegirons", debris: "Chains", Asset: "Irish8Cuffs", LinkableBy: ["Wrapping", "Belts"], Color: "Default", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 4, weight: 2,
        escapeChance: { "Struggle": -0.5, "Cut": -0.4, "Remove": 10, "Pick": 0.5 }, enemyTags: { "trap": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"] },
    { inventory: true, arousalMode: true, trappable: true, name: "TrapBelt", Asset: "PolishedChastityBelt", OverridePriority: 26, Color: "Default", Group: "ItemPelvis", LinkableBy: ["Ornate"], chastity: true,
        power: 5, weight: 0, DefaultLock: "Red",
        Security: {
            level_key: 2,
        },
        maxwill: 0.75, escapeChance: { "Struggle": -0.5, "Cut": -0.10, "Remove": 10.0, "Pick": 0.35 }, enemyTags: { "trap": 10, 'machineChastity': 2, "maidRestraints": 6, "maidRestraintsLight": 6, "genericChastity": 12, "chastitySpell": 10, }, playerTags: { "ItemVulvaEmpty": -4, "ItemVulvaPiercingsEmpty": -4 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Chastity"] },
    { inventory: true, arousalMode: true, trappable: true, name: "BlacksteelBelt", Asset: "PolishedChastityBelt", OverridePriority: 26, Color: "#333333", Group: "ItemPelvis", LinkableBy: ["Ornate"], chastity: true,
        power: 10, weight: 0, DefaultLock: "Blue",
        Security: {
            level_key: 2,
        },
        maxwill: 0.75, escapeChance: { "Struggle": -0.6, "Cut": -0.50, "Remove": 10.0, "Pick": 0.2 }, enemyTags: { "trap": 10, 'machineChastity': 2, "maidRestraints": 9, "maidRestraintsLight": 6, "genericChastity": 32, "blacksteelrestraints": 12, "blacksteelchastity": 50, "chastitySpell": 30, }, playerTags: { "ItemVulvaEmpty": -4, "ItemVulvaPiercingsEmpty": -4 }, minLevel: 9, allFloors: true, shrine: ["Metal", "Chastity"] },
    { inventory: true, arousalMode: true, trappable: true, name: "BlacksteelBra", Asset: "FuturisticBra2", OverridePriority: 26, Color: ['#333333', '#999999', '#333333', '#333333', '#999999', '#333333'], Group: "ItemBreast",
        chastitybra: true, power: 7, weight: 0, DefaultLock: "Blue",
        Security: {
            level_tech: 1,
            level_key: 2,
        },
        escapeChance: { "Struggle": -0.6, "Cut": -0.5, "Remove": 10.0, "Pick": 0.1 }, enemyTags: { "genericChastity": 8, "blacksteelrestraints": 4, "blacksteelBra": 8, "blacksteelchastity": 25, "roboAngry": 6 }, playerTags: {}, minLevel: 9, allFloors: true, shrine: ["Metal", "Chastity", "Ornate"] },
    { inventory: true, arousalMode: true, trappable: true, name: "MagicBelt", Asset: "PolishedChastityBelt", OverridePriority: 26, Color: "#8f60b1", Group: "ItemPelvis", LinkableBy: ["Ornate"], chastity: true,
        power: 7, weight: 0,
        Security: {
            level_magic: 1,
        },
        maxwill: 0.75, escapeChance: { "Struggle": -1.0, "Cut": -0.10, "Remove": 10.0, "Pick": 0.5 }, magic: true, DefaultLock: "Purple",
        enemyTags: { "magicBelt": 4, "magicBeltForced": 10, "chastitySpell": 5, }, playerTags: { "ItemVulvaEmpty": -4, "ItemVulvaPiercingsEmpty": -4 }, minLevel: 12, allFloors: true, shrine: ["Metal", "Chastity"] },
    { inventory: true, arousalMode: true, name: "TrapBeltProto", Asset: "FuturisticChastityBelt", Modules: [3, 1, 1, 1, 1], OverridePriority: 26, Color: ['#5E5E6B', '#4A5FC1', '#CD9F0E', '#43B2BA', '#A68009', '#F8BD01', '#3868E8', '#A68009', '#FFC81D'],
        Group: "ItemPelvis", LinkableBy: ["Ornate"], chastity: true, power: 15, weight: 0, DefaultLock: "Red",
        Security: {
            level_tech: 1,
            level_key: 3,
        },
        maxwill: 0.75, escapeChance: { "Struggle": -0.8, "Cut": -0.50, "Remove": 1.0, "Pick": -0.1 }, enemyTags: { "protoRestraints": 10, 'machineChastity': 8, "roboAngry": 10 }, playerTags: { "ItemVulvaEmpty": -5, "ItemVulvaPiercingsEmpty": -5 }, minLevel: 7, allFloors: true, shrine: ["Metal", "Chastity"] },
    { inventory: true, arousalMode: true, trappable: true, name: "TrapBra", Asset: "PolishedChastityBra", debris: "Chains", OverridePriority: 26, Color: "Default", Group: "ItemBreast", LinkableBy: ["Ornate"], chastitybra: true,
        power: 4, weight: 0, DefaultLock: "Red",
        Security: {
            level_key: 2,
        },
        maxwill: 0.75, escapeChance: { "Struggle": -0.5, "Cut": -0.10, "Remove": 10.0, "Pick": 0.35 }, enemyTags: { "trap": 10, "maidRestraints": 6, "maidRestraintsLight": 6, "genericChastity": 10 }, playerTags: { "ItemNipplesEmpty": -5 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Chastity"] },
    { inventory: true, trappable: true, name: "TrapMittens", debris: "Belts", inaccessible: true, Asset: "LeatherMittens", Color: "Default", Group: "ItemHands", bindhands: 1.0, power: 5, weight: 0,
        maxwill: 0.5, escapeChance: { "Struggle": 0.05, "Cut": 0.4, "Remove": 0.15, "Pick": 1.0 }, enemyTags: { "leatherRestraintsHeavy": 6, "mittensSpell": 10 }, playerTags: { "ItemHandsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Mittens"] },
    { inventory: true, arousalMode: true, trappable: true, name: "TrapBelt2", Asset: "OrnateChastityBelt", OverridePriority: 26, Color: ["#272727", "#D3B24B"], Group: "ItemPelvis", LinkableBy: ["Shadow"], chastity: true,
        power: 9, weight: 0, DefaultLock: "Gold",
        Security: {
            level_magic: 2,
            level_key: 3,
        },
        escapeChance: { "Struggle": -0.5, "Cut": -0.125, "Remove": 10.0, "Pick": 0.1 }, enemyTags: { "genericChastity": 8, "ornateChastity": 8 }, playerTags: {}, minLevel: 4, allFloors: true, shrine: ["Metal", "Chastity", "Ornate"] },
    { inventory: true, arousalMode: true, trappable: true, name: "TrapBra2", Asset: "FuturisticBra2", OverridePriority: 26, Color: ['#5E5E6B', '#F8BD01', '#5E5E6B', '#5E5E6B', '#F8BD01', '#5E5E6B'], Group: "ItemBreast",
        chastitybra: true, power: 9, weight: 0, DefaultLock: "Gold",
        Security: {
            level_magic: 2,
            level_key: 3,
        },
        escapeChance: { "Struggle": -0.5, "Cut": -0.125, "Remove": 10.0, "Pick": 0.1 }, enemyTags: { "genericChastity": 8, "ornateChastity": 8, "roboAngry": 10 }, playerTags: {}, minLevel: 4, allFloors: true, shrine: ["Metal", "Chastity", "Ornate"] },
    { renderWhenLinked: ["Chastity"], inventory: true, arousalMode: true, name: "WolfPanties", debris: "Belts", inaccessible: true, Asset: "SciFiPleasurePanties", strictness: 0.05, Color: ["#4F91DE", "#2E2E2E", "#3b7d4f", "#2f5753", "#4F91DE", "#4F91DE", "#000000"], Group: "ItemPelvis", LinkableBy: ["Chastity"], power: 4,
        weight: 0, escapeChance: { "Struggle": 0.05, "Cut": 0.3, "Remove": 0.05, "Pick": 0.35 }, escapeMult: 3.0, vibeLocation: "ItemVulva",
        linkedVibeTags: ["teaser"], allowRemote: true, events: [
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 2, time: 20, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 1, time: 48, edgeOnly: true, cooldown: { "normal": 120, "tease": 20 }, chance: 0.02 },
            { trigger: "tick", type: "PeriodicDenial", power: 2, time: 42, edgeOnly: true, cooldown: { "normal": 100, "tease": 20 }, chance: 0.03 },
            { trigger: "tick", type: "PeriodicTeasing", power: 3, time: 14, edgeOnly: false, cooldown: { "normal": 140, "tease": 20 }, chance: 0.01 },
        ],
        maxwill: 0.5, enemyTags: { "wolfRestraints": 6, "wolfGear": 6 }, playerTags: { "ItemPelvisFull": -5, "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Latex", "Panties", "Vibes"] },
    { inventory: true, arousalMode: true, name: "NippleClamps", unlimited: true, Asset: "HeartPasties", Color: "Default", Group: "ItemNipples", power: 3, weight: 0,
        vibeLocation: "ItemNipples",
        escapeChance: { "Struggle": -10, "Cut": -0.05, "Remove": 0.5, "Pick": 0.25 }, failSuffix: { "Struggle": "Clamps" },
        maxwill: 1.0, enemyTags: { "dressRestraints": 5, "genericToys": 5, "maidRestraints": 3, "maidRestraintsLight": 1, "roboAngry": 10, "teasetoys": 3 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, maxLevel: 8, allFloors: true, shrine: ["Vibes"], linkedVibeTags: ["teaser", "piercings"],
        allowRemote: true, events: [
            { trigger: "playerAttack", type: "MotionSensitive", chance: 0.5, msg: "KDPunishAttack" },
            { trigger: "punish", type: "PunishSelf", power: 1, time: 24, edgeOnly: true },
        ] },
    { inventory: true, arousalMode: true, name: "NippleClamps2", unlimited: true, Asset: "HeartPasties", Color: "Default", Group: "ItemNipples", power: 3, weight: 0,
        vibeLocation: "ItemNipples",
        escapeChance: { "Struggle": -10, "Cut": -0.05, "Remove": 0.5, "Pick": 0.25 }, failSuffix: { "Struggle": "Clamps" },
        maxwill: 1.0, enemyTags: { "dressRestraints": 3, "genericToys": 3, "maidRestraints": 2, "maidRestraintsLight": 1, "roboAngry": 10, "teasetoys": 2 }, playerTags: { "NoVibes": -1000 }, minLevel: 4, allFloors: true, shrine: ["Vibes"], linkedVibeTags: ["teaser", "piercings"],
        allowRemote: true, events: [
            { trigger: "playerAttack", type: "MotionSensitive", chance: 0.5, msg: "KDPunishAttack" },
            { trigger: "struggle", type: "VibeOnStruggle", chance: 0.5, msg: "KDPunishStruggle" },
            { trigger: "punish", type: "PunishSelf", power: 1, time: 24, edgeOnly: true },
        ] },
    { inventory: true, arousalMode: true, name: "NippleClamps3", unlimited: true, Asset: "HeartPasties", Color: "Default", Group: "ItemNipples", power: 3, weight: 0,
        vibeLocation: "ItemNipples",
        escapeChance: { "Struggle": -10, "Cut": -0.05, "Remove": 0.5, "Pick": 0.25 }, failSuffix: { "Struggle": "Clamps" },
        maxwill: 1.0, enemyTags: { "dressRestraints": 1, "genericToys": 1, "maidRestraints": 1, "roboAngry": 10, "teasetoys": 1 }, playerTags: { "NoVibes": -1000 }, minLevel: 8, allFloors: true, shrine: ["Vibes"], linkedVibeTags: ["teaser", "piercings"],
        allowRemote: true, events: [
            { trigger: "playerAttack", type: "MotionSensitive", chance: 1.0, msg: "KDPunishAttack" },
            { trigger: "struggle", type: "VibeOnStruggle", chance: 1.0, msg: "KDPunishStruggle" },
            { trigger: "sprint", type: "MotionSensitive", chance: 0.5, msg: "KDPunishSprint" },
            { trigger: "punish", type: "PunishSelf", power: 1, time: 24, edgeOnly: true },
        ] },
    { inventory: true, arousalMode: true, name: "TrapVibe", Asset: "TapedClitEgg", Color: "Default", Group: "ItemVulvaPiercings", power: 1, weight: 2,
        failSuffix: { "Struggle": "Egg" },
        escapeChance: { "Struggle": 0.15 }, enemyTags: { "trap": 100, "maidRestraintsLight": 5, "genericToys": 2, "teasetoys": 2 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes"], linkedVibeTags: ["teaser"], vibeLocation: "ItemVulvaPiercings",
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "playerCast", type: "MagicallySensitive" },
            { trigger: "punish", type: "PunishSelf", power: 1, time: 24, edgeOnly: true },
        ] },
    { inventory: true, arousalMode: true, name: "TrapVibeProto", Asset: "TapedClitEgg", Color: "Default", Group: "ItemVulvaPiercings", power: 1, weight: 2,
        failSuffix: { "Struggle": "Egg" },
        escapeChance: { "Struggle": 0.25 }, enemyTags: { "protoToys": 2, "roboAngry": 10 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes"], linkedVibeTags: ["teaser", "piercings"], vibeLocation: "ItemVulvaPiercings",
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "playerCast", type: "MagicallySensitive" },
            { trigger: "punish", type: "PunishSelf", power: 3, time: 12, edgeOnly: true },
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 1, time: 48, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 2, time: 20, edgeOnly: true, cooldown: { "normal": 90, "tease": 20 }, chance: 0.02 },
            { trigger: "tick", type: "PeriodicTeasing", power: 3, time: 15, edgeOnly: false, cooldown: { "normal": 90, "tease": 20 }, chance: 0.02 },
        ] },
    { inventory: true, arousalMode: true, name: "MaidVibe", Asset: "TapedClitEgg", Color: "Default", Group: "ItemVulvaPiercings", power: 4, weight: 2, escapeChance: { "Struggle": 0.15 },
        failSuffix: { "Struggle": "Egg" },
        enemyTags: { "maidVibeRestraints": 1000, "maidVibeRestraintsLimited": 100 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes"], linkedVibeTags: ["teaser"], vibeLocation: "ItemVulva",
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "playerCast", type: "MagicallySensitive", chance: 0.5 },
            { trigger: "punish", type: "PunishSelf", power: 2, time: 12, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 2, time: 32, edgeOnly: true, cooldown: { "normal": 90, "tease": 20 }, chance: 0.015 },
        ] },
    { inventory: true, arousalMode: true, name: "TrapPlug", unlimited: true, Asset: "VibratingDildo", Color: "Default", Group: "ItemVulva", plugSize: 1.0, power: 3, weight: 2,
        failSuffix: { "Struggle": "Plug" },
        escapeChance: { "Struggle": 0.25 }, enemyTags: { "trap": 10, "maidRestraintsLight": 2, "genericToys": 2, 'machinePlug': 5 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes", "Plugs"], linkedVibeTags: ["plugs"],
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 2, time: 12, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 1, time: 12, edgeOnly: true, cooldown: { "normal": 60, "tease": 20 }, chance: 0.02 },
            { trigger: "tick", type: "PeriodicDenial", power: 1, time: 36, edgeOnly: false, cooldown: { "normal": 60, "tease": 20 }, chance: 0.02 },
            { trigger: "tick", type: "PeriodicTeasing", power: 3, time: 16, edgeOnly: false, cooldown: { "normal": 60, "tease": 20 }, chance: 0.02 },
        ] },
    { inventory: true, arousalMode: true, name: "TrapPlug2", unlimited: true, Asset: "VibratingDildo", Color: "Default", Group: "ItemVulva", plugSize: 1.0, power: 4, weight: 2,
        failSuffix: { "Struggle": "Plug" },
        escapeChance: { "Struggle": 0.25 }, enemyTags: { "trap": 0, 'machinePlug': 5, "teasetoys": 2 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes", "Plugs"], linkedVibeTags: ["plugs"],
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 2, time: 12, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 1, time: 24, edgeOnly: true, cooldown: { "normal": 30, "tease": 8 }, chance: 0.05 },
        ] },
    { inventory: true, arousalMode: true, name: "TrapPlug3", unlimited: true, Asset: "VibratingDildo", Color: "Default", Group: "ItemVulva", plugSize: 1.0, power: 5, weight: 2,
        failSuffix: { "Struggle": "Plug" },
        escapeChance: { "Struggle": 0.25 }, enemyTags: { "trap": 0, 'machinePlug': 5, "teasetoys": 2 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes", "Plugs"], linkedVibeTags: ["plugs"],
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 2, time: 12, edgeOnly: true },
            { trigger: "tick", type: "PeriodicDenial", power: 2, time: 36, cooldown: { "normal": 150, "tease": 40 }, chance: 0.05 },
        ] },
    { inventory: true, arousalMode: true, name: "TrapPlug4", unlimited: true, Asset: "VibratingDildo", Color: "Default", Group: "ItemVulva", plugSize: 1.0, power: 5, weight: 1,
        failSuffix: { "Struggle": "Plug" },
        escapeChance: { "Struggle": 0.25 }, enemyTags: { "trap": 0, 'machinePlug': 2 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes", "Plugs"], linkedVibeTags: ["plugs"],
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 2, time: 12, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 3, time: 20, edgeOnly: false, cooldown: { "normal": 40, "tease": 20 }, chance: 0.01 },
            { trigger: "tick", type: "PeriodicDenial", power: 2, time: 30, edgeOnly: true, cooldown: { "normal": 70, "tease": 20 }, chance: 0.02 },
            { trigger: "tick", type: "PeriodicTeasing", power: 4, time: 10, edgeOnly: false, cooldown: { "normal": 90, "tease": 5 }, chance: 0.03 },
        ] },
    { inventory: true, arousalMode: true, name: "TrapPlug5", unlimited: true, Asset: "VibratingDildo", Color: "Default", Group: "ItemVulva", plugSize: 1.0, power: 5, weight: 1,
        failSuffix: { "Struggle": "Plug" },
        escapeChance: { "Struggle": 0.25 }, enemyTags: { "trap": 0, 'machinePlug': 2, "intensetoys": 2 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes", "Plugs"], linkedVibeTags: ["plugs"],
        allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 2, time: 12, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 2, time: 36, edgeOnly: false, cooldown: { "normal": 60, "tease": 30 }, chance: 0.05 },
            { trigger: "tick", type: "PeriodicTeasing", power: 4, time: 24, edgeOnly: false, cooldown: { "normal": 90, "tease": 15 }, chance: 0.03 },
        ] },
    { inventory: true, arousalMode: true, name: "SteelPlugF", Asset: "VibratingDildo", Color: "#ffffff", Group: "ItemVulva", plugSize: 1.5, power: 1, weight: 2,
        escapeChance: { "Struggle": 0.35 }, enemyTags: { "plugSpell": 1 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Plugs"],
        events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
        ],
        failSuffix: { "Struggle": "Plug" },
    },
    { inventory: true, arousalMode: true, name: "SteelPlugR", Asset: "VibratingDildoPlug", Color: "#ffffff", Group: "ItemButt", plugSize: 1.5, power: 1, weight: 2,
        escapeChance: { "Struggle": 0.35 }, enemyTags: { "plugSpell": 1, 'machinePlug': 4 }, playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Plugs"],
        events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
        ],
        failSuffix: { "Struggle": "Plug" },
    },
    { inventory: true, arousalMode: true, name: "RearVibe1", Asset: "VibratingDildo", Color: "Default", Group: "ItemButt", plugSize: 1.0, power: 5, weight: 1, escapeChance: { "Struggle": 0.25 },
        enemyTags: { "genericToys": 1, "rearToys": 10 },
        playerTags: { "NoVibes": -1000 }, minLevel: 0, allFloors: true, shrine: ["Vibes", "Plugs"],
        failSuffix: { "Struggle": "Plug" },
        linkedVibeTags: ["plugs"], allowRemote: true, events: [
            { trigger: "beforeStruggleCalc", type: "vibeStruggle", inheritLinked: true },
            { trigger: "remoteVibe", type: "RemoteActivatedVibe", power: 2, time: 12, edgeOnly: true },
            { trigger: "tick", type: "PeriodicTeasing", power: 1, time: 30, edgeOnly: true, cooldown: { "normal": 120, "tease": 20 }, chance: 0.02 },
        ] },
    { inventory: true, name: "MagicGag", Asset: "BallGag", debris: "Belts", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], factionColor: [[], [0]], gag: 0.35, Type: "Tight", Color: ["Default", "Default"], Group: "ItemMouth", DefaultLock: "Red", power: 3, weight: 2,
        escapeChance: { "Struggle": 0.0, "Cut": 0.45, "Remove": 0.65, "Pick": 0.3 },
        maxwill: 0.9, enemyTags: { "ballGagRestraints": 4, "gagSpell": 10 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Latex", "Gags", "BallGags"] },
    { inventory: true, name: "MagicGag2", Asset: "BallGag", debris: "Belts", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], factionColor: [[], [0]], gag: 0.45, Type: "Tight", Color: ["Default", "##ff00ff"], Group: "ItemMouth", DefaultLock: "Purple", magic: true, power: 5, weight: 2,
        escapeChance: { "Struggle": -0.1, "Cut": 0.12, "Remove": 0.45, "Pick": 0.25 },
        enemyTags: { "ballGagRestraintsMagic": 4, "gagSpellStrong": 10 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "BallGags", "Conjure"] },
    { inventory: true, trappable: true, name: "PanelGag", debris: "Belts", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], Asset: "HarnessPanelGag", gag: 0.7,
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        Color: "#888888", Group: "ItemMouth", AssetGroup: "ItemMouth2", power: 5, strictness: 0.2, weight: 2,
        escapeChance: { "Struggle": 0, "Cut": 0.3, "Remove": 0.4, "Pick": 0.3 },
        maxwill: 0.6, enemyTags: { "leatherRestraintsHeavy": 8, "ropeAuxiliary": 4 }, playerTags: {}, minLevel: 4, allFloors: true, shrine: ["Leather", "Gags", "FlatGags"] },
    { inventory: true, trappable: true, name: "HarnessGag", debris: "Belts", Asset: "HarnessBallGag", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink],
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.15, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.1, requiredTag: "Blindfolds" },
        ],
        gag: 0.65, Type: "Tight", Color: ["Default", "Default"], Group: "ItemMouth", power: 4, strictness: 0.2, weight: 3,
        escapeChance: { "Struggle": 0.05, "Cut": 0.3, "Remove": 0.4, "Pick": 0.35 },
        maxwill: 0.6, enemyTags: { "leatherRestraints": 1, "leatherRestraintsHeavy": 1, "ropeAuxiliary": 8 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "BallGags"] },
    { inventory: true, name: "PanelPlugGag", Asset: "OTNPlugGag", debris: "Belts", LinkableBy: [...KDPlugGagLink], renderWhenLinked: [...KDPlugGagLink], Type: "Plug", gag: 1.0,
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        Color: ["#888888", "#444444", "#aaaaaa"], Group: "ItemMouth", strictness: 0.4, power: 7, weight: 1,
        escapeChance: { "Struggle": -0.1, "Cut": 0.2, "Remove": 0.15, "Pick": 0.07 },
        maxwill: 0.2, enemyTags: { "leatherRestraintsHeavy": 10, "ropeAuxiliary": 1 }, playerTags: {}, minLevel: 8, allFloors: true, shrine: ["Leather", "Gags", "PlugGags"] },
    { inventory: true, name: "ClothGag", LinkableBy: [...KDBallGagLink], debris: "Fabric", renderWhenLinked: [...KDBallGagLink], Asset: "ClothGag", gag: 0.35, Type: "Knotted", Color: "#959595", Group: "ItemMouth", AssetGroup: "ItemMouth2", power: 0.1, weight: 2, escapeChance: { "Struggle": 0.5, "Cut": 1.0, "Remove": 0.8 },
        maxwill: 0.75, enemyTags: { "clothRestraints": 8, "ropeAuxiliary": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Gags", "BallGags"] },
    { inventory: true, name: "ClothGagOver", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], Asset: "ClothGag", gag: 0.35, Type: "OTN", Color: "#959595", Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 0.1, weight: 2, escapeChance: { "Struggle": 0.5, "Cut": 1.0, "Remove": 0.8 },
        maxwill: 0.75, enemyTags: { "clothRestraints": 4, "ropeAuxiliary": 1 }, debris: "Fabric", playerTags: { "ItemMouthEmpty": -4, "ItemMouth2Empty": -4 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Gags", "FlatGags"] },
    { inventory: true, name: "ClothBlindfold", Asset: "ClothBlindfold", debris: "Fabric", Color: "#959595", LinkableBy: [...KDTapeLink], renderWhenLinked: [...KDTapeRender], Group: "ItemHead", power: 0.1, weight: 2, escapeChance: { "Struggle": 0.5, "Cut": 1.0, "Remove": 0.8 },
        affinity: { Struggle: ["Sticky", "Hook"], Remove: ["Hook"], },
        maxwill: 0.85, blindfold: 1, enemyTags: { "clothRestraints": 8, "ropeAuxiliary": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Blindfolds"] },
    { inventory: true, name: "KittyGag", Asset: "KittyHarnessPanelGag", debris: "Belts", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], gag: 0.6,
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        Color: ["#FFFFFF", "#FFFFFF", "#000000", "#E496E7"], Group: "ItemMouth", AssetGroup: "ItemMouth2", power: 5, weight: 2, escapeChance: { "Struggle": 0, "Cut": 0.3, "Remove": 0.25, "Pick": 0.2 },
        enemyTags: { "kittyRestraints": 8 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "FlatGags", "Will"] },
    { inventory: true, name: "KittyMuzzle", debris: "Belts", Asset: "KittyGag", gag: 0.4, Color: ["#FFFFFF", "#000000", "#E496E7"], Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 5, weight: -6, escapeChance: { "Struggle": -0.1, "Cut": 0.18, "Remove": 0.4, "Pick": 0.2 },
        maxwill: 0.9, enemyTags: { "kittyRestraints": 6 }, playerTags: { "ItemMouth2Full": 4, "ItemMouthFull": 4 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "FlatGags", "Will"] },
    { inventory: true, name: "KittyBlindfold", debris: "Belts", Asset: "KittyBlindfold", blindfold: 2, LinkableBy: [...KDBlindfoldLink], renderWhenLinked: [...KDBlindfoldLink], Color: ["#FFFFFF", "#000000", "#E48FE9"], Group: "ItemHead", power: 5, weight: 2, escapeChance: { "Struggle": 0.1, "Cut": 0.3, "Remove": 0.25, "Pick": 0.2 },
        enemyTags: { "kittyRestraints": 8 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "Will"] },
    { inventory: true, name: "KittyPaws", debris: "Belts", Asset: "PawMittens", Color: ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#B38295"], Group: "ItemHands", bindhands: 1.0, power: 5, weight: 2, escapeChance: { "Struggle": 0.1, "Cut": 0.3, "Remove": 0.3, "Pick": 0.2 },
        maxwill: 0.9, enemyTags: { "kittyRestraints": 8 }, playerTags: {}, minLevel: 4, allFloors: true, shrine: ["Leather", "Mittens", "Will"] },
    { inventory: true, name: "KittySuit", debris: "Belts", Asset: "BitchSuit", Color: "Default", Group: "ItemArms", DefaultLock: "Red", bindarms: true, bindhands: 1.0, addTag: ["ForceKneel"], power: 11, weight: 0, escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": -0.1, "Pick": 0.15 },
        events: [
            { trigger: "defeat", type: "Kittify" },
        ],
        helpChance: { "Remove": 0.1 }, maxwill: 0.15, enemyTags: { "kittyRestraints": 3 }, playerTags: {}, minLevel: 7, allFloors: true, shrine: ["Latex", "Petsuits", "Will"] },
    { inventory: true, name: "MagicPetsuit", inaccessible: true, debris: "Belts", Asset: "StrictLeatherPetCrawler", magic: true, Color: "Default", Group: "ItemArms", bindarms: true, bindhands: 1.0, addTag: ["ForceKneel"], power: 12, weight: 0, escapeChance: { "Struggle": -0.15, "Cut": 0.12, "Remove": -0.05, "Pick": 0.15 },
        helpChance: { "Remove": 0.2 }, maxwill: 0.15, enemyTags: { "petsuitSpell": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Leather", "Petsuits", "Conjure"] },
    { inventory: true, name: "KittyPetSuit", inaccessible: true, debris: "Belts", Asset: "BitchSuit", Color: "Default", Group: "ItemArms", DefaultLock: "Blue", bindarms: true, bindhands: 1.0, blockfeet: true, addTag: ["ForceKneel"], power: 14, weight: 0, escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": -0.1, "Pick": 0.15 },
        alwaysDress: [
            { Item: "KittenEars2", Group: "HairAccessory2", Color: ['Default'], override: false, useHairColor: true, },
            { Item: "TailStrap", Group: "TailStraps", Color: ['Default'], override: false, useHairColor: true, },
        ],
        helpChance: { "Remove": 0.01 }, maxwill: 0.15, enemyTags: { "kittyRestraints": 0 }, playerTags: {}, minLevel: 7, allFloors: true, shrine: ["Latex", "Petsuits", "Will"] },
    { inventory: true, name: "WristShackles", debris: "Chains", Asset: "WristShackles", linkCategory: "Cuffs", linkSize: 0.33, LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Group: "ItemArms", Color: "Default", bindarms: true, Type: "Behind", power: 1, weight: 2, escapeChance: { "Struggle": -0.05, "Cut": -0.25, "Remove": 10, "Pick": 5 }, enemyTags: { "shackleRestraints": 7, "handcuffer": 6, "Unchained": -8 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"] },
    { inventory: true, name: "LegShackles", debris: "Chains", Asset: "LeatherLegCuffs", LinkableBy: ["Legbinders", "Hobbleskirts", "Belts", "Ties"], Group: "ItemLegs", hobble: true, Type: "Chained", Color: ["Default", "#888888", "#AAAAAA"], power: 3, weight: 2, escapeChance: { "Struggle": -0.1, "Cut": -0.3, "Remove": 10, "Pick": 5 }, enemyTags: { "shackleRestraints": 2 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"] },
    { inventory: true, name: "FeetShackles", debris: "Chains", Asset: "SteelAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], Link: "FeetShackles2", Group: "ItemFeet", hobble: true, Type: "Chained", Color: ["Default", "Default"], power: 5, weight: 2, escapeChance: { "Struggle": -0.1, "Cut": -0.3, "Remove": 10, "Pick": 5 }, enemyTags: { "shackleRestraints": 2 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"],
        events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { inventory: true, name: "AnkleShackles", debris: "Chains", Asset: "SteelAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], Link: "FeetShackles2", Group: "ItemFeet", hobble: true, Type: "Chained", Color: ["Default", "Default"], power: 5, weight: -9999, escapeChance: { "Struggle": -0.1, "Cut": -0.3, "Remove": 10, "Pick": 5 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"],
        events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "FeetShackles2", debris: "Chains", Asset: "SteelAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], UnLink: "FeetShackles", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], Type: "Closed", Color: ["Default", "Default"], power: 5, weight: 2, escapeChance: { "Struggle": -0.05, "Cut": -0.3, "Remove": 10, "Pick": 5 }, enemyTags: { "shackleRestraints": 2 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }] },
    { inventory: true, name: "SteelMuzzleGag", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], gag: 0.3, Asset: "MuzzleGag", Group: "ItemMouth", AssetGroup: "ItemMouth3", Color: "#999999",
        power: 3, weight: 2, escapeChance: { "Struggle": -0.3, "Cut": -0.25, "Remove": 10, "Pick": 5 }, enemyTags: { "shackleGag": 1 }, playerTags: { "ItemMouthFull": 1 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Gags", "FlatGags"] },
    { name: "ComfyGag", gag: 0.5, Asset: "MuzzleGag", Group: "ItemMouth", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], AssetGroup: "ItemMouth3", Color: "#cccccc", power: 1, weight: 4, escapeChance: { "Struggle": 0.2, "Cut": 0.2, "Remove": 0.4, "Pick": 5 }, maxwill: 0.9,
        enemyTags: { "comfyRestraints": 1 }, playerTags: { "ItemMouthFull": 1 }, minLevel: 0, allFloors: true, shrine: ["Gags", "FlatGags", "Illusion"] },
    { name: "ComfyStraitjacket", Asset: "HighSecurityStraitJacket", Modules: [0, 2, 1], Color: ['#cccccc', '#cccccc', '#cccccc'], Group: "ItemArms", power: 3, weight: 1, bindarms: true, bindhands: 0.9,
        limitChance: { "Struggle": 0.2, "Cut": 0.07, "Remove": 0.35, "Unlock": 0.75 },
        escapeChance: { "Struggle": 0.2, "Cut": 0.2, "Remove": 0.4, "Pick": 5 }, enemyTags: { "comfyRestraints": 1 }, playerTags: {}, minLevel: 0, maxwill: 0.35,
        allFloors: true, shrine: ["Straitjackets", "Illusion"] },
    { curse: "5Keys", name: "GhostCollar", Asset: "OrnateCollar", Group: "ItemNeck", LinkableBy: [...KDCollarLink], magic: true, Color: ["#555555", "#AAAAAA"], power: 20, weight: 0, difficultyBonus: 30,
        escapeChance: { "Struggle": -100, "Cut": -0.8, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [] },
    { renderWhenLinked: ["Ties"], inventory: true, name: "SturdyLeatherBeltsArms", debris: "Belts", accessible: true, Asset: "SturdyLeatherBelts", LinkableBy: ["Wrapping", "Ties"], Type: "Three", Color: "Default", Group: "ItemArms", bindarms: true, power: 2.5, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": 0.5, "Remove": 0.22 },
        maxwill: 0.9, enemyTags: { "leatherRestraints": 6 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Belts", "ArmBind"] },
    { renderWhenLinked: ["Ties"], inventory: true, name: "SturdyLeatherBeltsFeet", debris: "Belts", accessible: true, Asset: "SturdyLeatherBelts", LinkableBy: ["Wrapping", "Ties"], Type: "Three", Color: "Default", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 2, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": 0.5, "Remove": 0.5 },
        maxwill: 1.0, enemyTags: { "leatherRestraints": 6 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Belts", "LegBind"] },
    { renderWhenLinked: ["Legbinders", "Hobbleskirts", "Ties"], accessible: true, inventory: true, name: "SturdyLeatherBeltsLegs", debris: "Belts", Asset: "SturdyLeatherBelts", LinkableBy: ["Wrapping", "Legbinders", "Hobbleskirts", "Ties"], Type: "Two", Color: "Default", Group: "ItemLegs", hobble: true, power: 2, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": 0.5, "Remove": 0.5 },
        maxwill: 0.8, enemyTags: { "leatherRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Belts", "LegBind"] },
    { inventory: true, name: "AsylumAnkleCuffs", debris: "Belts", Asset: "LeatherAnkleCuffs", LinkableBy: ["Wrapping", "Ties", "Belts"], Link: "AsylumAnkleCuffs2", Type: "Chained", Color: ["Default", "#814F21", "Default"], Group: "ItemFeet", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.35, "Pick": 0.25 }, enemyTags: { "nurseRestraints": 3, "nurseCuffRestraints": 5, "leathercuffsSpell": 3 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 2, allFloors: true, shrine: ["Leather", "Cuffs", "AnkleCuffsBase"],
        maxwill: 1.0, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "AsylumAnkleCuffs2", debris: "Belts", Asset: "LeatherAnkleCuffs", LinkableBy: ["Wrapping", "Ties", "Belts"], UnLink: "AsylumAnkleCuffs", Type: "Closed", Color: ["Default", "#814F21", "Default"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.35, "Pick": 0.25 }, enemyTags: {}, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { inventory: true, name: "AsylumLegCuffs", debris: "Belts", Asset: "LeatherLegCuffs", LinkableBy: ["Legbinders", "Ties", "Belts", "Hobbleskirts"], Type: "Chained", Color: ["Default", "#814F21", "Default"], Group: "ItemLegs", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.3, "Pick": 0.25 },
        maxwill: 0.8, enemyTags: { "nurseRestraints": 3, "nurseCuffRestraints": 5, "leathercuffsSpell": 3 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 2, allFloors: true, shrine: ["Leather", "Cuffs"] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "AsylumArmCuffs", debris: "Belts", Color: ["#814F21", "Default"], accessible: true, Asset: "LeatherCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "AsylumArmCuffs2", Group: "ItemArms", bindarms: false, power: 8, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.25, "Pick": 0.35 }, enemyTags: { "nurseRestraints": 3, "nurseCuffRestraints": 5, "leathercuffsSpell": 3 }, playerTags: { "ItemArmsFull": -2, "Unchained": 9 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Cuffs", "ArmCuffsBase"],
        maxwill: 1.0, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "defeat", type: "linkItem", chance: 1.0 }] },
    { name: "AsylumArmCuffs2", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Wrist", Color: ["#814F21", "Default"], LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "AsylumArmCuffs3", UnLink: "AsylumArmCuffs", Group: "ItemArms", bindarms: true, power: 6, weight: 0,
        escapeChance: { "Struggle": 0, "Cut": -0.15, "Remove": 0.2, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { name: "AsylumArmCuffs3", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Both", Color: ["#814F21", "Default"], LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "AsylumArmCuffs4", Group: "ItemArms", bindarms: true, power: 5, weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.1, "Cut": -0.15, "Remove": -0.1, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }] },
    { name: "AsylumArmCuffs4", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Elbow", Color: ["#814F21", "Default"], LinkableBy: [...KDElbowBind, ...KDBindable], Link: "AsylumArmCuffs3", UnLink: "AsylumArmCuffs", Group: "ItemArms", bindarms: true, power: 7, weight: 0,
        escapeChance: { "Struggle": 0, "Cut": -0.175, "Remove": -0.15, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] }, { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }] },
    { inventory: true, name: "LeatherAnkleCuffs", debris: "Belts", Asset: "LeatherAnkleCuffs", LinkableBy: ["Wrapping", "Ties", "Belts"], Link: "LeatherAnkleCuffs2", Type: "Chained", Color: ["Default", "Default", "Default"], Group: "ItemFeet", hobble: true, power: 4, weight: 0,
        escapeChance: { "Struggle": 0.1, "Cut": 0.1, "Remove": 0.25, "Pick": 0.25 }, enemyTags: { "leatherRestraintsHeavy": 4, "dragonRestraints": 6, "handcuffer": 10, "leathercuffsSpell": 8 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Cuffs", "AnkleCuffsBase"],
        maxwill: 1.0, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "LeatherAnkleCuffs2", debris: "Belts", Asset: "LeatherAnkleCuffs", LinkableBy: ["Wrapping", "Ties", "Belts"], UnLink: "LeatherAnkleCuffs", Type: "Closed", Color: ["Default", "Default", "Default"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 4, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": -0.1, "Remove": 0.15, "Pick": 0.25 }, enemyTags: {}, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { inventory: true, name: "LeatherLegCuffs", debris: "Belts", Asset: "LeatherLegCuffs", LinkableBy: ["Legbinders", "Ties", "Belts", "Hobbleskirts"], Type: "Chained", Color: ["Default", "Default", "Default"], Group: "ItemLegs", hobble: true, power: 4, weight: 0,
        escapeChance: { "Struggle": 0.1, "Cut": 0.1, "Remove": 0.3, "Pick": 0.3 },
        maxwill: 0.8, enemyTags: { "leatherRestraints": 6, "handcuffer": 2, "leathercuffsSpell": 8 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Leather", "Cuffs"] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "LeatherArmCuffs", debris: "Belts", accessible: true, Asset: "LeatherCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "LeatherArmCuffs2", Color: ['Default', 'Default'], Group: "ItemArms", bindarms: false, power: 3, weight: 0,
        escapeChance: { "Struggle": 0.1, "Cut": 0.1, "Remove": 0.25, "Pick": 0.35 }, enemyTags: { "leatherRestraintsHeavy": 4, "dragonRestraints": 6, "handcuffer": 10, "leathercuffsSpell": 8 }, playerTags: { "ItemArmsFull": -2, "Unchained": 9 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Cuffs", "ArmCuffsBase"],
        maxwill: 1.0, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "defeat", type: "linkItem", chance: 1.0 }] },
    { name: "LeatherArmCuffs2", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "LeatherArmCuffs3", UnLink: "LeatherArmCuffs", Color: ['Default', 'Default'], Group: "ItemArms", bindarms: true, power: 4, weight: 0,
        escapeChance: { "Struggle": 0, "Cut": -0.1, "Remove": 0.2, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { name: "LeatherArmCuffs3", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "LeatherArmCuffs4", Color: ['Default', 'Default'], Group: "ItemArms", bindarms: true, power: 5, weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.1, "Cut": -0.1, "Remove": -0.1, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }] },
    { name: "LeatherArmCuffs4", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "LeatherArmCuffs3", UnLink: "LeatherArmCuffs", Color: ['Default', 'Default'], Group: "ItemArms", bindarms: true, power: 4, weight: 0,
        escapeChance: { "Struggle": 0, "Cut": -0.125, "Remove": -0.15, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] }, { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "SteelArmCuffs", debris: "Chains", accessible: true, Asset: "SteelCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "SteelArmCuffs2", Color: ['Default', 'Default'], Group: "ItemArms", bindarms: false, power: 4, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": -0.5, "Remove": 0.15, "Pick": 0.25 }, enemyTags: { "steelCuffs": 4 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cuffs", "ArmCuffsBase"],
        maxwill: 0.9, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.4 }, { trigger: "defeat", type: "linkItem", chance: 1.0 }] },
    { name: "SteelArmCuffs2", debris: "Chains", accessible: true, Asset: "SteelCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], UnLink: "SteelArmCuffs", Color: ['Default', 'Default'], Group: "ItemArms", bindarms: true, power: 4, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.5, "Remove": 0.2, "Pick": 0.15 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "MagneticArmCuffs", debris: "Chains", accessible: true, Asset: "SteelCuffs", linkCategory: "Cuffs", linkSize: 0.55,
        LinkableBy: [...KDDevices, ...KDBindable], Link: "MagneticArmCuffs2", Color: ['#444444', '#444444'], Group: "ItemArms", bindarms: false, power: 5, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.5, "Remove": 0.15, "Pick": 0.15 }, enemyTags: { "magnetCuffs": 10 }, playerTags: { "ItemArmsFull": -4 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "ArmCuffsBase", "Elements"],
        maxwill: 0.9, events: [
            { trigger: "beforePlayerDamage", type: "linkItemOnDamageType", sfx: "LightJingle", damage: "electric", chance: 1.0, requiredTag: "locked" },
            { trigger: "beforePlayerDamage", type: "lockItemOnDamageType", sfx: "LightJingle", damage: "electric", chance: 1.0, lock: "Blue" },
            { trigger: "defeat", type: "linkItem", chance: 1.0 }
        ] },
    { name: "MagneticArmCuffs2", debris: "Chains", accessible: true, Asset: "SteelCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], UnLink: "MagneticArmCuffs", Color: ['#444444', '#444444'],
        Group: "ItemArms", bindarms: true, power: 5, weight: 0, helpChance: { "Remove": 0.25 },
        escapeChance: { "Struggle": 0.05, "Remove": -0.2 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { inventory: true, nonbinding: true, name: "MagneticAnkleCuffs", Asset: "SteelAnkleCuffs", debris: "Chains", LinkableBy: [...KDBindable, ...KDDevices], Link: "MagneticAnkleCuffs2", Color: "#444444", Group: "ItemFeet", power: 5, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.25, "Remove": 0.1, "Pick": 0.15 },
        enemyTags: { "magnetCuffs": 5 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "AnkleCuffsBase", "Elements"],
        maxwill: 0.8, events: [
            { trigger: "beforePlayerDamage", type: "linkItemOnDamageType", sfx: "LightJingle", damage: "electric", chance: 1.0, requiredTag: "locked" },
            { trigger: "beforePlayerDamage", type: "lockItemOnDamageType", sfx: "LightJingle", damage: "electric", chance: 1.0, lock: "Blue" },
            { trigger: "defeat", type: "linkItem", chance: 1.0 }
        ] },
    { name: "MagneticAnkleCuffs2", debris: "Chains", Asset: "SteelAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], UnLink: "MagneticAnkleCuffs", Type: "Closed", Color: "#444444", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 0,
        escapeChance: { "Struggle": 0.05, "Remove": 0.05 }, helpChance: { "Remove": 0.25 },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "ScaleArmCuffs", debris: "Belts", accessible: true, Asset: "LeatherCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "ScaleArmCuffs2", Color: ["#9B1818", "#675F50"], Group: "ItemArms", bindarms: false, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.25, "Pick": 0.35 }, enemyTags: { "dragonRestraints": 1 }, playerTags: { "ItemArmsFull": 2 }, minLevel: 7, allFloors: true, shrine: ["Leather", "Cuffs", "ArmCuffsBase"],
        maxwill: 0.7, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "defeat", type: "linkItem", chance: 1.0 }] },
    { name: "ScaleArmCuffs2", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "ScaleArmCuffs3", UnLink: "ScaleArmCuffs", Color: ["#9B1818", "#675F50"], Group: "ItemArms", bindarms: true, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.1, "Cut": -0.15, "Remove": 0.2, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { name: "ScaleArmCuffs3", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "ScaleArmCuffs4", Color: ["#9B1818", "#675F50"], Group: "ItemArms", bindarms: true, power: 7, weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.15, "Cut": -0.15, "Remove": -0.1, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }] },
    { name: "ScaleArmCuffs4", debris: "Belts", accessible: true, Asset: "LeatherCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "ScaleArmCuffs3", UnLink: "ScaleArmCuffs", Color: ["#9B1818", "#675F50"], Group: "ItemArms", bindarms: true, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.15, "Cut": -0.15, "Remove": -0.15, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] }, { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }] },
    { inventory: true, name: "MaidJacket", debris: "Belts", Asset: "Bolero", Color: ["#191919", "#A3A3A3"], Group: "ItemArms", bindarms: true, bindhands: 1.0, power: 7.5, weight: 0, strictness: 0.2,
        LinkableBy: [...KDJacketLink], renderWhenLinked: [...KDJacketRender],
        limitChance: { "Struggle": 0.12, "Cut": 0.03, "Remove": 0.1, "Unlock": 0.75 },
        escapeChance: { "Struggle": -0.175, "Cut": 0.1, "Remove": 0.15, "Pick": 0.15 },
        maxwill: 0.3, enemyTags: { "maidRestraints": 5, "maidRestraintsNonChastity": 10, "noMaidJacket": -5 }, playerTags: { "ItemArmsEmpty": -9 }, minLevel: 7, allFloors: true, shrine: ["Latex", "Straitjackets", "Illusion"] },
    { inventory: true, name: "MaidDress", debris: "Fabric", inaccessible: true, Type: "Strap", Asset: "LeatherArmbinder", strictness: 0.25, Color: ['#191919'], Group: "ItemArms", LinkableBy: [...KDDressLink], bindarms: true, bindhands: 1.0, power: 8.5, weight: 0,
        escapeChance: { "Struggle": -0.175, "Cut": 0.1, "Remove": -0.2, "Pick": 0.15 },
        helpChance: { "Remove": 0.075 },
        limitChance: { "Struggle": 0.12, "Cut": 0.03, "Remove": 0.1, "Unlock": 0.75 },
        alwaysDress: [
            { Item: "SleevelessCatsuit", Group: "Suit", Color: "#aaaaaa", override: true },
            { Item: "MaidApron2", Group: "Cloth", Color: "Default", override: true },
            { Item: "FullLatexBra2", Group: "Bra", Color: ["#333333", "#aaaaaa"], override: true },
            { Item: "Pantyhose2", Group: "SuitLower", Color: "#939393", override: true },
            { Item: "LaceBands", Group: "Bracelet", Color: ['Default', '#151515'], override: true },
            { Item: "MageSkirt", Group: "ClothLower", Color: ["#676767", "#2E2E2E"], override: true },
            { Item: "Corset4", Group: "Corset", Color: "#4B4B4B", override: true },
            { Item: "Band1", Group: "Hat", Color: "#767676", override: true },
            { Item: "Shoes5", Group: "Shoes", Color: "#575757", override: true },
            { Item: "Socks6", Group: "Socks", Color: ['#080808', 'Default'], override: true }
        ], maxwill: 0.3, enemyTags: { "maidRestraints": 3, "maidRestraintsNonChastity": 5 }, playerTags: { "ItemArmsEmpty": -10 }, minLevel: 7, allFloors: true, shrine: ["Latex", "Armbinders", "BindingDress", "Illusion"] },
    { inventory: true, name: "MaidBelt", debris: "Belts", Asset: "LeatherBelt", Color: "#DBDBDB", Group: "ItemLegs", LinkableBy: ["Wrapping", "Legbinders", "Hobbleskirts", "Ties"], hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": 0.05, "Remove": 0.1, "Pick": 0.25 },
        maxwill: 1.0, enemyTags: { "maidRestraints": 10, "maidRestraintsNonChastity": 10, "maidRestraintsLight": 1 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 2, allFloors: true, shrine: ["Leather", "Belts"] },
    { inventory: true, name: "MaidAnkleCuffs", debris: "Chains", Asset: "SteelAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], Link: "MaidAnkleCuffs2", Type: "Chained", Color: "Default", Group: "ItemFeet", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.25, "Remove": 0.1, "Pick": 0.15 },
        enemyTags: { "maidRestraints": 7, "maidRestraintsNonChastity": 10, "steelCuffs": 5 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cuffs", "AnkleCuffsBase", "Illusion"],
        maxwill: 0.8, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "MaidAnkleCuffs2", debris: "Chains", Asset: "SteelAnkleCuffs", LinkableBy: [...KDBindable, ...KDDevices], UnLink: "MaidAnkleCuffs", Type: "Closed", Color: "Default", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 9, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.25, "Remove": 0.1, "Pick": 0.15 },
        enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "Illusion"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { inventory: true, name: "MaidCollar", debris: "Belts", Asset: "HighCollar", Color: ["#C9C9C9", "#FFFFFF"], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 11, weight: 0,
        escapeChance: { "Struggle": -0.3, "Cut": -0.25, "Remove": 0.4, "Pick": -0.1 },
        unlimited: true,
        maxwill: 0.25, enemyTags: { "maidRestraints": 3, "maidRestraintsNonChastity": 10, "maidCollar": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Collars", "HighCollars", "Illusion"] },
    { inventory: true, name: "MaidGag", debris: "Belts", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], gag: 0.75,
        Asset: "MuzzleGag", Color: "Default", Group: "ItemMouth", AssetGroup: "ItemMouth2", power: 8, weight: 0,
        limitChance: { "Struggle": 0.12 },
        escapeChance: { "Struggle": -0.18, "Cut": 0.05, "Remove": 0.33, "Pick": 0.15 },
        maxwill: 0.75, enemyTags: { "maidRestraints": 7, "maidRestraintsNonChastity": 10, }, playerTags: {}, minLevel: 4, allFloors: true, shrine: ["Leather", "Gags", "FlatGags", "Illusion"] },
    { inventory: true, arousalMode: true, name: "MaidCBelt", Asset: "PolishedChastityBelt", OverridePriority: 26, Color: "Default", Group: "ItemPelvis", LinkableBy: ["Ornate"], chastity: true, power: 9, weight: 0,
        Security: {
            level_key: 3,
        },
        escapeChance: { "Struggle": -0.5, "Cut": -0.25, "Remove": 0.5, "Pick": 0.12 },
        maxwill: 0.75, enemyTags: { "maidVibeRestraints": 200, "maidVibeRestraintsLimited": 100, "maidChastityBelt": 200 }, playerTags: { "ItemVulvaEmpty": -50, "ItemVulvaPiercingsEmpty": -50 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Chastity", "Illusion"] },
    { inventory: true, name: "DragonArmbinder", debris: "Belts", inaccessible: true, Asset: "BoxTieArmbinder", strictness: 0.08, LinkableBy: ["Wrapping"], Color: ["#9B1818", "#ffffff"], Group: "ItemArms", bindarms: true, bindhands: 1.0, power: 7, weight: 0,
        escapeChance: { "Struggle": 0.0, "Cut": -0.05, "Remove": 0.1, "Pick": 0.25 },
        limitChance: { "Struggle": 0.1, "Remove": 0.1, "Pick": 0.05, "Unlock": 0.5 },
        maxwill: 0.25, enemyTags: { "dragonRestraints": 2 }, playerTags: { "ItemArmsEmpty": -10 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Boxbinders"] },
    { inventory: true, name: "DragonStraps", debris: "Belts", Asset: "ThinLeatherStraps", LinkableBy: ["Boxbinders"], Color: "#9B1818", Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.175, "Cut": -0.05, "Remove": 0.1, "Pick": 0.25 },
        maxwill: 0.7, enemyTags: { "dragonRestraints": 6 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Leather", "Belts"] },
    { inventory: true, name: "DragonLegCuffs", debris: "Belts", Asset: "LeatherLegCuffs", LinkableBy: ["Legbinders", "Ties", "Belts", "Hobbleskirts"], Type: "Chained", Color: ["Default", "#9B1818", "#675F50"], Group: "ItemLegs", hobble: true, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.3, "Pick": 0.25 },
        maxwill: 0.8, enemyTags: { "dragonRestraints": 6 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Leather", "Cuffs"] },
    { inventory: true, name: "DragonAnkleCuffs", debris: "Belts", Asset: "LeatherAnkleCuffs", LinkableBy: [...KDBindable], Link: "DragonAnkleCuffs2", Type: "Chained", Color: ["Default", "#9B1818", "#675F50"], Group: "ItemFeet", hobble: true, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.3, "Pick": 0.25 }, enemyTags: { "dragonRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 2, allFloors: true, shrine: ["Leather", "Cuffs", "AnkleCuffsBase"],
        maxwill: 1.0, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "DragonAnkleCuffs2", debris: "Chains", Asset: "LeatherAnkleCuffs", LinkableBy: [...KDBindable], UnLink: "DragonAnkleCuffs", Type: "Closed", Color: ["Default", "#9B1818", "#675F50"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.05, "Remove": 0.3, "Pick": 0.25 }, enemyTags: { "dragonRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Cuffs"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { inventory: true, name: "DragonBoots", debris: "Belts", Asset: "BalletWedges", Color: "#424242", Group: "ItemBoots", hobble: true, power: 7, weight: 0,
        escapeChance: { "Struggle": 0.025, "Cut": -0.05, "Remove": 0.05, "Pick": 0.25 },
        enemyTags: { "dragonRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 2, allFloors: true, shrine: ["Leather", "Boots"] },
    { inventory: true, name: "DragonBallGag", debris: "Belts", LinkableBy: [...KDBallGagLink], renderWhenLinked: [...KDBallGagLink], gag: 0.65, Asset: "FuturisticHarnessBallGag",
        events: [
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.2, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.15, requiredTag: "Blindfolds" },
        ],
        strictness: 0.3, Color: ['#680000', '#680000', '#680000', '#680000', '#680000'], Group: "ItemMouth", power: 7, weight: 0,
        escapeChance: { "Struggle": -0.5, "Cut": -0.05, "Remove": 0.1, "Pick": 0.25 },
        maxwill: 0.6, enemyTags: { "dragonRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 7, allFloors: true, shrine: ["Leather", "Latex", "Gags", "BallGags"] },
    { inventory: true, name: "DragonMuzzleGag", debris: "Belts", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], gag: 0.3, Asset: "StitchedMuzzleGag", Color: "#9B1818", Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 7, weight: -6,
        escapeChance: { "Struggle": 0.05, "Cut": 0.0, "Remove": 0.1 },
        maxwill: 0.75, enemyTags: { "dragonRestraints": 6 }, playerTags: { "ItemMouthFull": 4, "ItemMouth2Full": 4 }, minLevel: 0, allFloors: true, shrine: ["Leather", "Gags", "FlatGags"] },
    { inventory: true, name: "DragonCollar", debris: "Belts", Asset: "LatexCollar2", Color: "#9B1818", Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 9, weight: 4,
        escapeChance: { "Struggle": -0.2, "Cut": -0.1, "Remove": 0.1 },
        unlimited: true,
        maxwill: 0.25, enemyTags: { "dragonRestraints": 6, "dragonCollar": 4 }, playerTags: { "ItemNeckFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Collars"] },
    { inventory: true, name: "ObsidianLegCuffs", debris: "Chains", accessible: true, Asset: "OrnateLegCuffs", LinkableBy: ["Legbinders", "Hobbleskirts", "Belts", "Ties"], Type: "Chained", Color: ["#675F50", "#171222", "#9B63C5"], Group: "ItemLegs", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.6, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 },
        maxwill: 0.8, enemyTags: { "obsidianRestraints": 6, "obsidianCuffs": 6 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 7, allFloors: true, shrine: ["Metal", "Cuffs", "Obsidian", "Elements"] },
    { inventory: true, name: "ObsidianAnkleCuffs", debris: "Chains", accessible: true, Asset: "OrnateAnkleCuffs", LinkableBy: [...KDBindable], Link: "ObsidianAnkleCuffs2", Type: "Chained", Color: ["#675F50", "#171222", "#9B63C5"], Group: "ItemFeet", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.6, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 }, enemyTags: { "obsidianRestraints": 6, "obsidianCuffs": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "AnkleCuffsBase", "Obsidian"],
        maxwill: 1.0, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }] },
    { name: "ObsidianAnkleCuffs2", debris: "Chains", accessible: true, Asset: "OrnateAnkleCuffs", LinkableBy: ["AnkleCuffsBase", ...KDBindable], UnLink: "ObsidianAnkleCuffs", Type: "Closed", Color: ["#675F50", "#171222", "#9B63C5"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 9, weight: 0,
        escapeChance: { "Struggle": -0.6, "Cut": -0.3, "Remove": 0.2, "Pick": 0.25 }, enemyTags: {}, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "Obsidian", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "ObsidianArmCuffs", debris: "Chains", DefaultLock: "Purple", accessible: true, Asset: "OrnateCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "ObsidianArmCuffs2", Color: ["#171222", "#9B63C5"], Group: "ItemArms", bindarms: false, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.6, "Cut": -0.2, "Remove": 0.25, "Pick": 0.35 }, enemyTags: { "obsidianRestraints": 24, "obsidianCuffs": 20 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cuffs", "ArmCuffsBase", "Obsidian", "Elements"],
        maxwill: 0.8, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "defeat", type: "linkItem", chance: 1.0 }] },
    { name: "ObsidianArmCuffs2", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "ObsidianArmCuffs3", UnLink: "ObsidianArmCuffs", Color: ["#171222", "#9B63C5"],
        Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.3, "Remove": 0.2, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Obsidian", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { name: "ObsidianArmCuffs3", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "ObsidianArmCuffs4", Color: ["#171222", "#9B63C5"], Group: "ItemArms", bindarms: true, power: 9,
        weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.2, "Cut": -0.3, "Remove": -0.1, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Obsidian", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }] },
    { name: "ObsidianArmCuffs4", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "ObsidianArmCuffs3", UnLink: "ObsidianArmCuffs", Color: ["#171222", "#9B63C5"],
        Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.3, "Remove": -0.15, "Pick": 0.25 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Obsidian", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] }, { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }] },
    { inventory: true, name: "ObsidianGag", debris: "Chains", gag: 0.75, Asset: "MuzzleGag", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], Color: ["#1C1847", "#1C1847"], Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 9, weight: -7, escapeChance: { "Struggle": -0.2, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 },
        maxwill: 0.7, enemyTags: { "obsidianRestraints": 8 }, playerTags: { "ItemMouth3Full": -2, "ItemMouth2Full": 2, "ItemMouth1Full": 2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Gags", "Obsidian", "Elements", "FlatGags"] },
    { inventory: true, name: "ObsidianCollar", debris: "Chains", Asset: "OrnateCollar", Color: ["#171222", "#9B63C5"], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 9, weight: -2, escapeChance: { "Struggle": -0.2, "Cut": -0.2, "Remove": 0.2, "Pick": 0.25 },
        maxwill: 0.25, enemyTags: { "obsidianRestraints": 4, "obsidianCuffs": 100 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Collars", "Obsidian", "Elements", "HighCollars"],
        unlimited: true,
        events: [
            { trigger: "beforeStruggleCalc", type: "obsidianDebuff", power: 0.15, inheritLinked: true }
        ] },
    { inventory: true, name: "CrystalLegCuffs", debris: "Chains", accessible: true, Asset: "OrnateLegCuffs", LinkableBy: ["Legbinders", "Hobbleskirts", "Belts", "Ties"], Type: "Chained", Color: ["#675F50", "#a694cb", "#ff5277"], Group: "ItemLegs", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": 0.0, "Remove": 0.2, "Pick": 0.35 },
        maxwill: 0.8, enemyTags: { "crystalRestraints": 6 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 7,
        allFloors: true, shrine: ["Metal", "Cuffs", "Crystal", "Elements"],
        events: [{ trigger: "tick", type: "crystalDrain", power: -0.034, inheritLinked: true }, { trigger: "struggle", type: "crystalPunish" }] },
    { inventory: true, name: "CrystalAnkleCuffs", debris: "Chains", accessible: true, Asset: "OrnateAnkleCuffs", LinkableBy: [...KDBindable], Link: "CrystalAnkleCuffs2", Type: "Chained", Color: ["#675F50", "#a694cb", "#ff5277"], Group: "ItemFeet", hobble: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": 0, "Remove": 0.2, "Pick": 0.35 }, enemyTags: { "crystalRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "Crystal", "Elements", "AnkleCuffsBase"],
        maxwill: 1.0, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true }, { trigger: "tick", type: "crystalDrain", power: -0.033, inheritLinked: true }, { trigger: "struggle", type: "crystalPunish" }] },
    { name: "CrystalAnkleCuffs2", debris: "Chains", accessible: true, Asset: "OrnateAnkleCuffs", LinkableBy: [...KDBindable], UnLink: "CrystalAnkleCuffs", Type: "Closed", Color: ["#675F50", "#a694cb", "#ff5277"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": -0.1, "Remove": 0.2, "Pick": 0.35 }, enemyTags: {}, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs", "Crystal", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "struggle", type: "crystalPunish" }, { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "CrystalArmCuffs", debris: "Chains", accessible: true, Asset: "OrnateCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "CrystalArmCuffs2", Color: ["#a694cb", "#ff5277"], Group: "ItemArms", bindarms: false, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": 0, "Remove": 0.25, "Pick": 0.45 }, enemyTags: { "crystalRestraints": 24 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 4, allFloors: true, shrine: ["Metal", "Cuffs", "Crystal", "Elements", "ArmCuffsBase"],
        maxwill: 0.6, events: [{ trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "defeat", type: "linkItem", chance: 1.0 }, { trigger: "tick", type: "crystalDrain", power: -0.034, inheritLinked: true }, { trigger: "struggle", type: "crystalPunish" }] },
    { name: "CrystalArmCuffs2", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "CrystalArmCuffs3", UnLink: "CrystalArmCuffs", Color: ["#a694cb", "#ff5277"], Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.15, "Cut": -0.1, "Remove": 0.2, "Pick": 0.35 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Crystal", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] }, { trigger: "struggle", type: "crystalPunish" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }] },
    { name: "CrystalArmCuffs3", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "CrystalArmCuffs4", Color: ["#a694cb", "#ff5277"], Group: "ItemArms", bindarms: true, power: 9, weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.2, "Cut": -0.1, "Remove": -0.1, "Pick": 0.35 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Crystal", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "struggle", type: "crystalPunish" }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }, { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }] },
    { name: "CrystalArmCuffs4", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "CrystalArmCuffs3", UnLink: "CrystalArmCuffs", Color: ["#a694cb", "#ff5277"], Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.15, "Cut": -0.1, "Remove": -0.15, "Pick": 0.35 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs", "Crystal", "Elements"],
        events: [{ trigger: "remove", type: "unlinkItem" }, { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] }, { trigger: "struggle", type: "crystalPunish" }, { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true }, { trigger: "postRemoval", type: "RequireBaseArmCuffs" }] },
    { inventory: true, name: "BanditLegCuffs", debris: "Chains", accessible: true, Asset: "OrnateLegCuffs", LinkableBy: ["Legbinders", "Hobbleskirts", "Belts", "Ties"], Type: "Chained", Color: ["#aaaaaa", "#f0b541", "#ff5277"], Group: "ItemLegs", hobble: true, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": 0.2, "Pick": 0.35 },
        maxwill: 0.8, enemyTags: { "banditMagicRestraints": 6 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 7,
        allFloors: true, shrine: ["Metal", "Cuffs"],
        events: [
            { trigger: "struggle", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
            { trigger: "playerAttack", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
        ] },
    { inventory: true, name: "BanditAnkleCuffs", debris: "Chains", accessible: true, Asset: "OrnateAnkleCuffs", LinkableBy: [...KDBindable], Link: "BanditAnkleCuffs2", Type: "Chained", Color: ["#675F50", "#f0b541", "#ff5277"], Group: "ItemFeet", hobble: true, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": 0.2, "Pick": 0.35 }, enemyTags: { "banditMagicRestraints": 6 }, playerTags: { "ItemFeetFull": -2 }, minLevel: 2, allFloors: true, shrine: ["Metal", "Cuffs", "AnkleCuffsBase"],
        maxwill: 1.0, events: [
            { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.2, subMult: 0.5, tags: ["lowwill"], noLeash: true },
            { trigger: "struggle", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
            { trigger: "playerAttack", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
        ] },
    { name: "BanditAnkleCuffs2", debris: "Chains", accessible: true, Asset: "OrnateAnkleCuffs", LinkableBy: [...KDBindable], UnLink: "BanditAnkleCuffs", Type: "Closed", Color: ["#675F50", "#f0b541", "#ff5277"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 8, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": 0.2, "Pick": 0.35 }, enemyTags: {}, playerTags: { "ItemFeetFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Cuffs"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "struggle", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
            { trigger: "postRemoval", type: "RequireBaseAnkleCuffs" }
        ] },
    { renderWhenLinked: ["Ties"], nonbinding: true, inventory: true, name: "BanditArmCuffs", debris: "Chains", accessible: true, Asset: "OrnateCuffs", linkCategory: "Cuffs", linkSize: 0.55, LinkableBy: [...KDDevices, ...KDBindable], Link: "BanditArmCuffs2", Color: ["#f0b541", "#ff5277"], Group: "ItemArms", bindarms: false, power: 7, weight: 0,
        escapeChance: { "Struggle": -0.2, "Cut": 0.1, "Remove": 0.25, "Pick": 0.45 }, enemyTags: { "banditMagicRestraints": 24 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 2, allFloors: true, shrine: ["Metal", "Cuffs", "ArmCuffsBase"],
        maxwill: 0.6, events: [
            { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] },
            { trigger: "defeat", type: "linkItem", chance: 1.0 },
            { trigger: "struggle", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
            { trigger: "playerAttack", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
        ] },
    { name: "BanditArmCuffs2", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Wrist", LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Link: "BanditArmCuffs3", UnLink: "BanditArmCuffs", Color: ["#f0b541", "#ff5277"], Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.15, "Cut": -0.15, "Remove": 0.2, "Pick": 0.35 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.33, tags: ["lowwill"] },
            { trigger: "struggle", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
            { trigger: "postRemoval", type: "RequireBaseArmCuffs" },
            { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.08, inheritLinked: true }
        ] },
    { name: "BanditArmCuffs3", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Both", LinkableBy: [...KDElbowBind, ...KDBindable], UnLink: "BanditArmCuffs4", Color: ["#f0b541", "#ff5277"], Group: "ItemArms", bindarms: true, power: 9, weight: 0, strictness: 0.1,
        escapeChance: { "Struggle": -0.2, "Cut": -0.15, "Remove": -0.1, "Pick": 0.35 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "struggle", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
            { trigger: "postRemoval", type: "RequireBaseArmCuffs" },
            { trigger: "beforeStruggleCalc", type: "wristCuffsBlock", power: 0.12, inheritLinked: true }
        ] },
    { name: "BanditArmCuffs4", debris: "Chains", accessible: true, Asset: "OrnateCuffs", Type: "Elbow", LinkableBy: [...KDElbowBind, ...KDBindable], Link: "BanditArmCuffs3", UnLink: "BanditArmCuffs", Color: ["#f0b541", "#ff5277"], Group: "ItemArms", bindarms: true, power: 9, weight: 0,
        escapeChance: { "Struggle": -0.15, "Cut": -0.15, "Remove": -0.15, "Pick": 0.35 }, helpChance: { "Remove": 0.4 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: ["Metal", "Cuffs"],
        events: [
            { trigger: "remove", type: "unlinkItem" },
            { trigger: "hit", type: "linkItem", sfx: "LightJingle", chance: 0.5, tags: ["lowwill"] },
            { trigger: "struggle", type: "PunishPlayer", chance: 0.33, stun: 2, warningchance: 1.0, damage: "crush", power: 3, sfx: "SoftShield", msg: "KinkyDungeonPunishPlayerBandit", inheritLinked: true },
            { trigger: "beforeStruggleCalc", type: "elbowCuffsBlock", inheritLinked: true },
            { trigger: "postRemoval", type: "RequireBaseArmCuffs" }
        ] },
    { unlimited: true, removePrison: true, name: "IceArms", debris: "Ice", sfx: "Freeze", Asset: "Ribbons", LinkableBy: ["Armbinders", "Wrapping"], Type: "Heavy", Color: "#5DA9E5", Group: "ItemArms", bindarms: true, power: 4, weight: 0, magic: true, escapeChance: { "Struggle": 0.15, "Cut": 0.05, "Remove": 0 }, enemyTags: { "iceRestraints": 4 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Ties", "Ice", "Elements"],
        maxwill: 0.8, events: [{ trigger: "tick", type: "iceDrain", power: -0.025, inheritLinked: true }] },
    { unlimited: true, removePrison: true, name: "IceLegs", debris: "Ice", sfx: "Freeze", Asset: "Ribbons", LinkableBy: ["Legbinders", "Hobbleskirts", "Wrapping"], Type: "MessyWrap", Color: "#5DA9E5", Group: "ItemLegs", hobble: true, power: 4, weight: 0, magic: true, escapeChance: { "Struggle": 0.15, "Cut": 0.05, "Remove": 0 }, enemyTags: { "iceRestraints": 4 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Ties", "Ice", "Elements"],
        events: [{ trigger: "tick", type: "iceDrain", power: -0.025, inheritLinked: true }] },
    { unlimited: true, removePrison: true, name: "IceHarness", debris: "Ice", sfx: "Freeze", Asset: "Ribbons", Type: "Harness2", Color: "#5DA9E5", Group: "ItemTorso", power: 1, weight: 0, magic: true, escapeChance: { "Struggle": 0.15, "Cut": 0.05, "Remove": 0 }, enemyTags: { "iceRestraints": 4 }, playerTags: { "ItemTorsoFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Ties", "Ice", "Elements"],
        events: [{ trigger: "tick", type: "iceDrain", power: -0.025, inheritLinked: true }] },
    { unlimited: true, removePrison: true, name: "IceGag", debris: "Ice", gag: 0.35, sfx: "Freeze", Asset: "Ribbons", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], Color: "#5DA9E5", Group: "ItemMouth", power: 4, weight: 0, magic: true, escapeChance: { "Struggle": 0.15, "Cut": 0.05, "Remove": 0 }, enemyTags: { "iceRestraints": 4 }, playerTags: { "ItemMouthFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Wrapping", "Ice", "Elements"],
        maxwill: 0.7, events: [{ trigger: "tick", type: "iceDrain", power: -0.025, inheritLinked: true }] },
    { removePrison: true, name: "CableArms", debris: "Chains", sfx: "FutureLock", Asset: "NylonRope", changeRenderType: { "ArmBind": "WristElbowHarnessTie" },
        LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Color: ["#333333"], Group: "ItemArms", bindarms: true, power: 6, weight: 0, magic: false,
        escapeChance: { "Struggle": 0.1, "Cut": 0.00, "Remove": 0.25, "Pick": 0.3 },
        maxwill: 0.8, enemyTags: { "hitechCables": 4 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 6, allFloors: true, shrine: ["Metal", "Ties"] },
    { renderWhenLinked: [...KDLegRopesRender], removePrison: true, name: "CableLegs", debris: "Chains", sfx: "FutureLock", Asset: "NylonRope", Type: "KneesThighs", LinkableBy: [...KDLegRopesBind], Color: ["#333333", "#333333"], Group: "ItemLegs", hobble: true, power: 6, weight: 0, magic: false,
        escapeChance: { "Struggle": 0.1, "Cut": 0.0, "Remove": 0.25, "Pick": 0.3 }, enemyTags: { "hitechCables": 4 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 6, allFloors: true, shrine: ["Metal", "Ties"] },
    { renderWhenLinked: ["HeavyCorsets"], removePrison: true, name: "CableHarness", sfx: "FutureLock", Asset: "NylonRopeHarness", OverridePriority: 27, Color: ["#333333", "#333333"], Type: "Harness", Group: "ItemTorso", power: 2, strictness: 0.05, weight: 0, magic: false,
        escapeChance: { "Struggle": 0.1, "Cut": 0.0, "Remove": 0.25, "Pick": 0.3 }, enemyTags: { "hitechCables": 4 }, playerTags: { "ItemTorsoFull": -2 }, minLevel: 6, allFloors: true, shrine: ["Metal", "Ties"] },
    { removePrison: true, name: "NylonCableArms", debris: "Chains", sfx: "FutureLock", Asset: "NylonRope", changeRenderType: { "ArmBind": "WristElbowHarnessTie" }, maxLevel: 6,
        LinkableBy: [...KDElbowBind, ...KDBoxBind, ...KDBindable], Color: ["#222222"], Group: "ItemArms", bindarms: true, power: 6, weight: 0, magic: false,
        escapeChance: { "Struggle": 0.12, "Cut": 0.2, "Remove": 0.3, "Pick": 0.35 },
        maxwill: 0.8, enemyTags: { "hitechCables": 4 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Ties"] },
    { renderWhenLinked: [...KDLegRopesRender], removePrison: true, name: "NylonCableLegs", debris: "Chains", sfx: "FutureLock", Asset: "NylonRope", Type: "KneesThighs", maxLevel: 6,
        LinkableBy: [...KDLegRopesBind], Color: ["#222222", "#222222"], Group: "ItemLegs", hobble: true, power: 6, weight: 0, magic: false,
        escapeChance: { "Struggle": 0.12, "Cut": 0.2, "Remove": 0.3, "Pick": 0.35 }, enemyTags: { "hitechCables": 4 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Ties"] },
    { renderWhenLinked: ["HeavyCorsets"], removePrison: true, name: "NylonCableHarness", sfx: "FutureLock", Asset: "NylonRopeHarness", OverridePriority: 27, maxLevel: 6,
        Color: ["#222222", "#222222"], Type: "Harness", Group: "ItemTorso", power: 2, strictness: 0.05, weight: 0, magic: false,
        escapeChance: { "Struggle": 0.12, "Cut": 0.2, "Remove": 0.3, "Pick": 0.35 }, enemyTags: { "hitechCables": 4 }, playerTags: { "ItemTorsoFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Metal", "Ties"] },
    { unlimited: true, inventory: true, removePrison: true, name: "RibbonArms", debris: "Fabric", sfx: "MagicSlash", Asset: "Ribbons", Color: "#a583ff", Group: "ItemArms", bindarms: true, power: 6, weight: 0, magic: true,
        escapeChance: { "Struggle": 0.15, "Cut": 0.3, "Remove": 0.2, }, struggleMaxSpeed: { "Remove": 0.15 }, struggleMinSpeed: { "Struggle": 0.1 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.8, enemyTags: { "magicRibbons": 4, "lowWeightRibbons": 1 }, playerTags: { "ItemArmsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Ribbons", "Wristties"] },
    { unlimited: true, inventory: true, removePrison: true, name: "RibbonLegs", debris: "Fabric", sfx: "MagicSlash", Asset: "DuctTape", Color: "#a583ff", Group: "ItemLegs", hobble: true, power: 7, weight: 0, magic: true,
        affinity: { Remove: ["Hook"], }, struggleMinSpeed: { "Struggle": 0.1 },
        escapeChance: { "Struggle": 0.07, "Cut": 0.3, "Remove": 0.15 }, enemyTags: { "magicRibbons": 4, "lowWeightRibbons": 1 }, struggleMaxSpeed: { "Remove": 0.15 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Ribbons"] },
    { unlimited: true, inventory: true, removePrison: true, name: "RibbonFeet", debris: "Fabric", sfx: "MagicSlash", Asset: "DuctTape", Color: "#a583ff", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 7, weight: 0, magic: true,
        affinity: { Remove: ["Hook"], }, struggleMinSpeed: { "Struggle": 0.1 },
        escapeChance: { "Struggle": 0.07, "Cut": 0.3, "Remove": 0.15 }, enemyTags: { "magicRibbons": 4, "lowWeightRibbons": 1 }, struggleMaxSpeed: { "Remove": 0.15 }, playerTags: { "ItemLegsFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Ribbons"] },
    { unlimited: true, inventory: true, removePrison: true, name: "RibbonHarness", debris: "Fabric", sfx: "MagicSlash", Asset: "Ribbons", Type: "Harness2", Color: "#a583ff", Group: "ItemTorso", power: 6, strictness: 0.05, weight: 0, magic: true,
        affinity: { Remove: ["Hook"], }, struggleMinSpeed: { "Struggle": 0.1 },
        escapeChance: { "Struggle": 0.07, "Cut": 0.3, "Remove": 0.15 }, struggleMaxSpeed: { "Remove": 0.15 }, enemyTags: { "magicRibbons": 4, "lowWeightRibbons": 1 }, playerTags: { "ItemTorsoFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Ribbons"] },
    { unlimited: true, inventory: true, removePrison: true, name: "RibbonCrotch", debris: "Fabric", sfx: "MagicSlash", Asset: "Ribbons", Color: "#a583ff", Group: "ItemPelvis", power: 5, crotchrope: true, strictness: 0.15, weight: 0, magic: true,
        affinity: { Remove: ["Hook"], }, struggleMinSpeed: { "Struggle": 0.1 },
        escapeChance: { "Struggle": 0.15, "Cut": 0.35, "Remove": 0.25 }, struggleMaxSpeed: { "Remove": 0.2 }, enemyTags: { "magicRibbons": 4, "lowWeightRibbons": 1 }, playerTags: { "ItemTorsoFull": -2 }, minLevel: 0,
        allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Ribbons"], events: [{ trigger: "struggle", type: "crotchrope" }] },
    { unlimited: true, inventory: true, name: "RibbonHands", Asset: "DuctTape", debris: "Fabric", Color: "#a583ff", LinkableBy: ["Mittens"], Group: "ItemHands", bindhands: 0.7, power: 5, weight: 0, magic: true,
        affinity: { Remove: ["Hook"], }, struggleMinSpeed: { "Struggle": 0.1 },
        escapeChance: { "Struggle": 0, "Cut": 0.4, "Remove": 0.5 }, struggleMaxSpeed: { "Remove": 0.1 },
        maxwill: 0.3, enemyTags: { "magicRibbonsHarsh": 1 }, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Conjure", "Ribbons"] },
    { unlimited: true, inventory: true, name: "RibbonMouth", Asset: "DuctTape", debris: "Fabric", Color: "#9573ef", Type: "Cover", LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], Group: "ItemMouth", AssetGroup: "ItemMouth2", gag: 0.5, power: 5, weight: 0, magic: true, escapeChance: { "Struggle": 0.0, "Cut": 0.4, "Remove": 0.4 }, struggleMaxSpeed: { "Remove": 0.15 },
        affinity: { Remove: ["Hook"], }, struggleMinSpeed: { "Struggle": 0.1 },
        enemyTags: { "magicRibbons": 4, "lowWeightRibbons": 1 }, playerTags: { "ItemMouth1Full": 8 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Wrapping", "Conjure", "Ribbons"] },
    { inventory: true, name: "CableGag", Asset: "DeepthroatGag", debris: "Belts", gag: 1.0, sfx: "FutureLock", Color: "Default", LinkableBy: [...KDPlugGagLink], renderWhenLinked: [...KDPlugGagLink], Group: "ItemMouth", power: 5, weight: 2, escapeChance: { "Struggle": -0.12, "Cut": 0.0, "Remove": 0.5, "Pick": 0.3 },
        maxwill: 0.6, enemyTags: { "cableGag": 3 }, playerTags: {}, minLevel: 6, allFloors: true, shrine: ["Metal", "Gags", "PlugGags"] },
    { inventory: true, name: "NylonCableGag", Asset: "DeepthroatGag", debris: "Belts", gag: 0.8, sfx: "FutureLock", Color: "#222222", LinkableBy: [...KDPlugGagLink], renderWhenLinked: [...KDPlugGagLink], Group: "ItemMouth", power: 5, weight: 2, escapeChance: { "Struggle": -0.07, "Cut": 0.2, "Remove": 0.5, "Pick": 0.35 },
        maxwill: 0.6, enemyTags: { "cableGag": 3 }, playerTags: {}, minLevel: 0, maxLevel: 6, allFloors: true, shrine: ["Metal", "Gags", "PlugGags"] },
    { unlimited: true, renderWhenLinked: ["Boxbinders"], changeRenderType: { "ArmBind": "WristElbowHarnessTie" }, inventory: true, name: "RopeSnakeArms", debris: "Ropes", accessible: true, factionColor: [[], [0]],
        Asset: "HempRope", Color: "Default", LinkableBy: ["Boxbinders", "Wrapping"], Group: "ItemArms", bindarms: true, power: 1.5, weight: 0, escapeChance: { "Struggle": 0.25, "Cut": 0.45, "Remove": 0.1 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.7, enemyTags: { "ropeRestraints": 4 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Boxties"] },
    { unlimited: true, inventory: true, name: "RopeSnakeCuffs", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Type: "RopeCuffs", Color: "Default", linkCategory: "Cuffs", linkSize: 0.33,
        LinkableBy: ["Boxbinders", "Armbinders", ...KDBindable, "Cuffs"], Group: "ItemArms", bindarms: true, power: 1, weight: 0, escapeChance: { "Struggle": 0.4, "Cut": 0.67, "Remove": 0.3 },
        affinity: { Remove: ["Hook"], },
        maxwill: 1.0, enemyTags: { "ropeRestraints": 8 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Cuffs"] },
    { unlimited: true, inventory: true, name: "RopeSnakeCuffsAdv", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Type: "RopeCuffs", Color: "Default", linkCategory: "Cuffs", linkSize: 0.51,
        LinkableBy: ["Boxbinders", "Armbinders", ...KDBindable, "Cuffs"], Group: "ItemArms", bindarms: true, power: 1, weight: 0, escapeChance: { "Struggle": 0.25, "Cut": 0.67, "Remove": 0.2 },
        affinity: { Remove: ["Hook"], }, strictness: 0.05, strictnessZones: ["ItemHands"],
        maxwill: 1.0, enemyTags: { "ropeRestraints": 8 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 5, allFloors: true, shrine: ["Rope", "Cuffs"] },
    { unlimited: true, renderWhenLinked: ["Armbinders", "Belts"], inventory: true, name: "RopeSnakeArmsWrist", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Type: "WristElbowHarnessTie",
        LinkableBy: ["Armbinders", "Wrapping", "Belts"], Color: "Default", Group: "ItemArms", bindarms: true, power: 1.5, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.45, "Remove": 0.2 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.7, enemyTags: { "ropeRestraintsWrist": 4 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Wristties"] },
    { unlimited: true, inventory: false, name: "RopeSnakeHogtie", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Type: "Hogtied", Color: "Default", Group: "ItemArms", bindarms: true, power: 6, weight: 0,
        escapeChance: { "Struggle": 0.05, "Cut": 0.15, "Remove": 0.0 }, affinity: { Remove: ["Hook"], },
        maxwill: 0.25, enemyTags: { "ropeRestraintsHogtie": 12 }, playerTags: {}, minLevel: 2, allFloors: true, shrine: ["Rope", "Ties", "Hogties"],
        events: [{ trigger: "postRemoval", type: "replaceItem", list: ["RopeSnakeArmsWrist"], power: 6 }]
    },
    { unlimited: true, renderWhenLinked: ["Wrapping", "Belts"], inventory: true, name: "RopeSnakeFeet", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Color: "Default", LinkableBy: ["Wrapping", "Belts"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 1, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.5, "Remove": 0.15 },
        affinity: { Remove: ["Hook"], },
        maxwill: 1.0, enemyTags: { "ropeRestraints": 4 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties"] },
    { unlimited: true, renderWhenLinked: [...KDLegRopesRender], inventory: true, name: "RopeSnakeLegs", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRope", Type: "FullBinding", LinkableBy: [...KDLegRopesBind], Color: "Default", Group: "ItemLegs", hobble: true, power: 1, weight: 0, escapeChance: { "Struggle": 0.25, "Cut": 0.45, "Remove": 0.15 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.6, enemyTags: { "ropeRestraints": 4 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties"] },
    { unlimited: true, renderWhenLinked: ["Harnesses", "HeavyCorsets"], inventory: true, name: "RopeSnakeTorso", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRopeHarness", Type: "Waist", Color: "Default", Group: "ItemTorso", power: 1, weight: 0, harness: true, escapeChance: { "Struggle": 0.1, "Cut": 0.67, "Remove": 0.3 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.9, enemyTags: { "ropeRestraints2": 4 }, playerTags: { "ItemTorsoFull": -3 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties"] },
    { unlimited: true, renderWhenLinked: ["Harnesses", "HeavyCorsets"], inventory: true, name: "RopeSnakeHarness", debris: "Ropes", accessible: true, factionColor: [[], [0]], Asset: "HempRopeHarness", Type: "Star", strictness: 0.1, OverridePriority: 26, Color: "Default", Group: "ItemTorso", power: 2, weight: 0, harness: true, escapeChance: { "Struggle": 0.1, "Cut": 0.67, "Remove": 0.3 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.75, enemyTags: { "ropeRestraints2": 1 }, playerTags: { "ItemTorsoFull": 5 }, minLevel: 3, allFloors: true, shrine: ["Rope", "Ties", "Harnesses"] },
    { unlimited: true, renderWhenLinked: ["ChastityBelts"], inventory: true, name: "RopeSnakeCrotch", debris: "Ropes", accessible: true, factionColor: [[], [0]], crotchrope: true, strictness: 0.15, Asset: "HempRope", Type: "OverPanties", LinkableBy: ["ChastityBelts"], OverridePriority: 26, Color: "Default", Group: "ItemPelvis", power: 1, weight: 0,
        affinity: { Remove: ["Hook"], },
        maxwill: 0.75, escapeChance: { "Struggle": 0.1, "Cut": 0.67, "Remove": 0.15 }, enemyTags: { "ropeRestraints2": 4 }, playerTags: { "ItemPelvisFull": -3 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties"],
        events: [{ trigger: "struggle", type: "crotchrope" }] },
    { unlimited: true, renderWhenLinked: ["Boxbinders"], debris: "Steam", changeRenderType: { "ArmBind": "WristElbowHarnessTie" }, inventory: true, name: "CelestialRopeArms", accessible: true, Asset: "HempRope", Color: ["#aaaa67"], LinkableBy: ["Boxbinders", "Wrapping"], Group: "ItemArms", bindarms: true, power: 2, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": 0.3, "Remove": 0.1 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.7, enemyTags: { "celestialRopes": 4 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Holy", "Will", "Boxties"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "celestialRopePunish" }] },
    { unlimited: true, inventory: true, name: "CelestialRopeCuffs", debris: "Steam", accessible: true, Asset: "HempRope", Type: "RopeCuffs", Color: ["#ffff90"], linkCategory: "Cuffs", linkSize: 0.33, LinkableBy: ["Boxbinders", "Armbinders", ...KDBindable, "Cuffs"], Group: "ItemArms", bindarms: true, power: 1, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.4, "Remove": 0.3 },
        affinity: { Remove: ["Hook"], },
        maxwill: 1.0, enemyTags: { "celestialRopes": 8 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Cuffs", "Holy", "Will"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "celestialRopePunish" }] },
    { unlimited: true, inventory: true, name: "CelestialRopeCuffsAdv", debris: "Steam", accessible: true, Asset: "HempRope", Type: "RopeCuffs", Color: ["#ffff90"], linkCategory: "Cuffs", linkSize: 0.51, LinkableBy: ["Boxbinders", "Armbinders", ...KDBindable, "Cuffs"], Group: "ItemArms", bindarms: true, power: 1, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": 0.4, "Remove": 0.2 },
        affinity: { Remove: ["Hook"], }, strictness: 0.1, strictnessZones: ["ItemHands"],
        maxwill: 1.0, enemyTags: { "celestialRopes": 10 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 7, allFloors: true, shrine: ["Rope", "Cuffs", "Holy", "Will"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "celestialRopePunish" }] },
    { unlimited: true, inventory: true, name: "CelestialRopeFeet", debris: "Steam", accessible: true, Asset: "NylonRope", Color: ["#aaaa67", "#aaaa67"], LinkableBy: ["Wrapping"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 1, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": 0.3, "Remove": 0.15 },
        affinity: { Remove: ["Hook"], },
        maxwill: 1.0, enemyTags: { "celestialRopes": 4 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Holy", "Will"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "celestialRopePunish" }] },
    { unlimited: true, renderWhenLinked: [...KDLegRopesRender], inventory: true, name: "CelestialRopeLegs", debris: "Steam", accessible: true, Asset: "NylonRope", LinkableBy: [...KDLegRopesBind], Color: ["#aaaa67", "#aaaa67"], Group: "ItemLegs", hobble: true, power: 1, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": 0.35, "Remove": 0.15 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.6, enemyTags: { "celestialRopes": 4 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Holy", "Will"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "celestialRopePunish" }] },
    { unlimited: true, inventory: true, name: "CelestialRopeTorso", debris: "Steam", accessible: true, OverridePriority: 27, Asset: "NylonRopeHarness", Type: "Harness", Color: ["#aaaa67", "#aaaa67"], Group: "ItemTorso", power: 1, weight: 0, harness: true, escapeChance: { "Struggle": 0.1, "Cut": 0.3, "Remove": 0.1 },
        affinity: { Remove: ["Hook"], },
        maxwill: 0.9, enemyTags: { "celestialRopes": 4 }, playerTags: { "ItemTorsoFull": -3 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Holy", "Will"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "celestialRopePunish" }] },
    { unlimited: true, inventory: true, name: "CelestialRopeCrotch", debris: "Steam", accessible: true, crotchrope: true, strictness: 0.15, Asset: "HempRope", Type: "OverPanties", OverridePriority: 26, Color: ["#ffff90", "#aaaa67"], Group: "ItemPelvis", power: 1, weight: 0,
        affinity: { Remove: ["Hook"], },
        maxwill: 0.75, escapeChance: { "Struggle": 0.1, "Cut": 0.35, "Remove": 0.15 }, enemyTags: { "celestialRopes": 4 }, playerTags: { "ItemPelvisFull": -3 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Holy", "Will"],
        failSuffix: { "Remove": "MagicRope" }, events: [{ trigger: "struggle", type: "celestialRopePunish" }, { trigger: "struggle", type: "crotchrope" }] },
    { unlimited: true, removePrison: true, name: "VinePlantArms", accessible: true, Asset: "NylonRope", Color: ["#006722", "#006722"], Group: "ItemArms", debris: "Vines",
        affinity: { Remove: ["Hook"], },
        bindarms: true, power: 0.1, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.8, "Remove": 0.2 }, enemyTags: { "vineRestraints": 4 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Vines", "Will"] },
    { unlimited: true, removePrison: true, name: "VinePlantFeet", accessible: true, Asset: "NylonRope", Color: ["#006722", "#006722"], Group: "ItemFeet", debris: "Vines",
        affinity: { Remove: ["Hook"], },
        blockfeet: true, addTag: ["FeetLinked"], power: 0.1, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.8, "Remove": 0.2 }, enemyTags: { "vineRestraints": 4 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Vines", "Will"] },
    { unlimited: true, removePrison: true, name: "VinePlantLegs", accessible: true, Asset: "NylonRope", Color: ["#006722", "#006722"], Group: "ItemLegs", debris: "Vines",
        affinity: { Remove: ["Hook"], },
        hobble: true, power: 0.1, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.8, "Remove": 0.2 }, enemyTags: { "vineRestraints": 4 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Vines", "Will"] },
    { unlimited: true, removePrison: true, name: "VinePlantTorso", accessible: true, Asset: "NylonRopeHarness", Type: "Diamond", OverridePriority: 26, Color: ["#006722", "#006722"], Group: "ItemTorso", debris: "Vines",
        affinity: { Remove: ["Hook"], },
        harness: true, power: 0.1, weight: 0, strictness: 0.05, escapeChance: { "Struggle": 0.3, "Cut": 0.8, "Remove": 0.2 }, enemyTags: { "vineRestraints": 4 }, playerTags: { "ItemTorsoFull": -3 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Ties", "Vines", "Will"] },
    { inventory: true, name: "ChainArms", debris: "Chains", accessible: true, sfx: "Chain", Asset: "Chains", Type: "WristElbowHarnessTie", LinkableBy: ["Armbinders", "Wrapping"], Color: "Default", Group: "ItemArms", bindarms: true, power: 5, weight: 0, escapeChance: { "Struggle": 0.1, "Cut": -0.1, "Remove": 0.3, "Pick": 1.5 },
        maxwill: 0.8, enemyTags: { "chainRestraints": 2 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Wristties"] },
    { inventory: true, name: "ChainLegs", debris: "Chains", accessible: true, sfx: "Chain", Asset: "Chains", Type: "Strict", Color: "Default", LinkableBy: ["Legbinders", "Hobbleskirts"], Group: "ItemLegs", hobble: true, power: 5, weight: 0, escapeChance: { "Struggle": 0.15, "Cut": -0.1, "Remove": 0.3, "Pick": 1.5 }, enemyTags: { "chainRestraints": 2 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal"] },
    { inventory: true, name: "ChainFeet", debris: "Chains", accessible: true, sfx: "Chain", Asset: "Chains", Color: "Default", LinkableBy: ["Wrapping", "Belts"], Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 5, weight: 0, escapeChance: { "Struggle": 0.03, "Cut": -0.1, "Remove": 0.3, "Pick": 1.5 }, enemyTags: { "chainRestraints": 2 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal"] },
    { inventory: true, name: "ChainCrotch", debris: "Chains", accessible: true, sfx: "Chain", Asset: "CrotchChain", crotchrope: true, strictness: 0.15, strictnessZones: ["ItemVulva", "ItemVulvaPiercings", "ItemButt"], OverridePriority: 26, Color: "Default", Group: "ItemTorso", power: 3, weight: 0, harness: true, escapeChance: { "Struggle": 0.03, "Cut": -0.1, "Remove": 0.3, "Pick": 1.5 }, enemyTags: { "chainRestraints": 2 }, playerTags: { "ItemPelvisFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal"] },
    { unlimited: true, inventory: true, removePrison: true, sfx: "Chain", name: "MagicChainArms", debris: "Chains", accessible: true, Asset: "Chains", LinkableBy: ["Armbinders", "Wrapping"], Type: "WristElbowHarnessTie", Color: "#aa00aa", Group: "ItemArms", bindarms: true, power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": -0.1, "Remove": -0.05 },
        failSuffix: { "Remove": "MagicChain" }, maxwill: 0.9, enemyTags: { "chainRestraintsMagic": 2 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Conjure", "Wristties"] },
    { unlimited: true, inventory: true, removePrison: true, sfx: "Chain", name: "MagicChainLegs", debris: "Chains", accessible: true, Asset: "Chains", LinkableBy: ["Legbinders", "Hobbleskirts"], Type: "Strict", Color: "#aa00aa", Group: "ItemLegs", hobble: true, power: 4, weight: 0,
        failSuffix: { "Remove": "MagicChain" }, escapeChance: { "Struggle": 0.3, "Cut": -0.1, "Remove": -0.05 }, enemyTags: { "chainRestraintsMagic": 2 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Conjure"] },
    { unlimited: true, inventory: true, removePrison: true, sfx: "Chain", name: "MagicChainFeet", debris: "Chains", accessible: true, Asset: "Chains", LinkableBy: ["Wrapping"], Color: "#aa00aa", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 4, weight: 0,
        failSuffix: { "Remove": "MagicChain" }, escapeChance: { "Struggle": 0.2, "Cut": -0.1, "Remove": -0.05 }, enemyTags: { "chainRestraintsMagic": 2 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Conjure"] },
    { unlimited: true, inventory: true, removePrison: true, sfx: "Chain", name: "MagicChainCrotch", debris: "Chains", accessible: true, crotchrope: true, strictness: 0.15, strictnessZones: ["ItemVulva", "ItemVulvaPiercings", "ItemButt"], Asset: "CrotchChain", OverridePriority: 26, Color: "#aa00aa", Group: "ItemTorso", power: 2, weight: 0,
        failSuffix: { "Remove": "MagicChain" }, escapeChance: { "Struggle": 0.2, "Cut": -0.1, "Remove": -0.05 }, enemyTags: { "chainRestraintsMagic": 2 }, playerTags: { "ItemPelvisFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Conjure"],
        events: [{ trigger: "struggle", type: "crotchrope" }] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "ShadowChainArms", debris: "Chains", accessible: true, Asset: "Chains", LinkableBy: ["Boxbinders", "Wrapping"], Type: "BoxTie", Color: "#000000", Group: "ItemArms", bindarms: true, power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": -0.1, "Remove": -0.1 },
        maxwill: 0.9, enemyTags: { "shadowRestraints": 2 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "ShadowChainLegs", debris: "Chains", accessible: true, Asset: "Chains", LinkableBy: ["Legbinders", "Hobbleskirts"], Type: "Strict", Color: "#000000", Group: "ItemLegs", hobble: true, power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": -0.1, "Remove": -0.1 }, enemyTags: { "shadowRestraints": 2 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "ShadowChainFeet", debris: "Chains", accessible: true, Asset: "Chains", LinkableBy: ["Wrapping"], Color: "#000000", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 4, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": -0.1, "Remove": -0.1 }, enemyTags: { "shadowRestraints": 2 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "ShadowChainCrotch", debris: "Chains", accessible: true, crotchrope: true, strictness: 0.15, strictnessZones: ["ItemVulva", "ItemVulvaPiercings", "ItemButt"], Asset: "CrotchChain", OverridePriority: 26, Color: "#000000", Group: "ItemTorso", power: 2, weight: 0, escapeChance: { "Struggle": 0.2, "Cut": -0.1, "Remove": -0.1 }, enemyTags: { "shadowRestraints": 2 }, playerTags: { "ItemPelvisFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"],
        events: [{ trigger: "struggle", type: "crotchrope" }] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "GhostChainArms", accessible: true, Asset: "Chains", LinkableBy: ["Boxbinders", "Wrapping"], Type: "BoxTie", Color: "#cccccc", Group: "ItemArms", bindarms: true, power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.2, "Remove": 0.1 },
        maxwill: 0.9, enemyTags: { "ghostRestraints": 2 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "GhostChainLegs", accessible: true, Asset: "Chains", LinkableBy: ["Legbinders", "Hobbleskirts"], Type: "Strict", Color: "#cccccc", Group: "ItemLegs", hobble: true, power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.2, "Remove": 0.1 }, enemyTags: { "ghostRestraints": 2 }, playerTags: { "ItemLegsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "GhostChainFeet", accessible: true, Asset: "Chains", LinkableBy: ["Wrapping"], Color: "#cccccc", Group: "ItemFeet", blockfeet: true, addTag: ["FeetLinked"], power: 4, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.2, "Remove": 0.1 }, enemyTags: { "ghostRestraints": 2 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"] },
    { unlimited: true, removePrison: true, sfx: "Chain", name: "GhostChainCrotch", accessible: true, crotchrope: true, strictness: 0.15, strictnessZones: ["ItemVulva", "ItemVulvaPiercings", "ItemButt"], Asset: "CrotchChain", OverridePriority: 26, Color: "#cccccc", Group: "ItemTorso", power: 2, weight: 0, escapeChance: { "Struggle": 0.3, "Cut": 0.2, "Remove": 0.1 }, enemyTags: { "ghostRestraints": 2 }, playerTags: { "ItemPelvisFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Chains", "Ties", "Metal", "Illusion"],
        events: [{ trigger: "struggle", type: "crotchrope" }] },
    { removePrison: true, divine: true, name: "DivineCuffs", accessible: true, Asset: "FuturisticCuffs", LinkableBy: ["Boxbinders", "Armbinders", ...KDBindable], DefaultLock: "Gold", Type: "Wrist", Color: ['#6AB0ED', '#AE915C', '#FFFFFF'], Group: "ItemArms", bindarms: true, power: 50, weight: 0,
        specStruggleTypes: ["Struggle"], escapeChance: { "Struggle": -99, "Cut": -99, "Remove": -99 }, enemyTags: { "divineRestraints": 2 }, playerTags: { "ItemArmsFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Metal", "Latex", "Leather"] },
    { removePrison: true, divine: true, name: "DivineAnkleCuffs", accessible: true, Asset: "FuturisticAnkleCuffs", LinkableBy: [...KDBindable], DefaultLock: "Gold", Color: ['#AE915C', '#71D2EE', '#AE915C', '#000000'], Group: "ItemFeet", Type: "Closed", blockfeet: true, addTag: ["FeetLinked"], power: 50, weight: 0,
        specStruggleTypes: ["Struggle"], escapeChance: { "Struggle": -99, "Cut": -99, "Remove": -99 }, enemyTags: { "divineRestraints": 2 }, playerTags: { "ItemFeetFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Metal", "Latex", "Leather"] },
    { removePrison: true, divine: true, name: "DivineMuzzle", accessible: true, gag: 1.0, Asset: "FuturisticMuzzle", Modules: [0, 1, 1], LinkableBy: [...KDFlatGagLink], renderWhenLinked: [...KDFlatGagLink], Color: ['#AE915C', '#AE915C', '#CAA562', '#5FBEE8'], DefaultLock: "Gold", Group: "ItemMouth", AssetGroup: "ItemMouth3", power: 30, weight: 0,
        specStruggleTypes: ["Struggle"], escapeChance: { "Struggle": -99, "Cut": -99, "Remove": -99 }, enemyTags: { "divineRestraints": 2 }, playerTags: { "ItemPelvisFull": -1 }, minLevel: 0, allFloors: true, shrine: ["Rope", "Metal", "Latex", "Leather"] },
    { inventory: true, name: "BasicCollar", debris: "Belts", linkCategory: "BasicCollar", accessible: true, Asset: "LeatherCollar", Color: ["#000000", "Default"], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 1, weight: 0, escapeChance: { "Struggle": -0.2, "Cut": 0.15, "Remove": 0.5, "Pick": 0.1 },
        maxwill: 0.25,
        unlimited: true, enemyTags: { "leashing": 0.001, "maidCollar": -1, "dragonRestraints": -1, "mithrilRestraints": -1 }, playerTags: { "ItemNeckFull": -2 }, minLevel: 0, maxLevel: 3, allFloors: true, shrine: ["Collars", "Leather"] },
    { inventory: true, name: "SteelCollar", linkCategory: "BasicCollar", accessible: true, Asset: "SlenderSteelCollar", Color: ["Default"], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 3, weight: 0, escapeChance: { "Struggle": -0.5, "Cut": -0.4, "Remove": 0.5, "Pick": 0.05 },
        maxwill: 0.25,
        unlimited: true, enemyTags: { "leashing": 0.001, "maidCollar": -1, "dragonRestraints": -1, "mithrilRestraints": -1 }, playerTags: { "ItemNeckFull": -2, "Unchained": -1, "Damsel": 1 }, minLevel: 2, allFloors: true, shrine: ["Collars", "Metal"] },
    { inventory: true, name: "MagicCollar", debris: "Belts", linkCategory: "BasicCollar", accessible: true, Asset: "LeatherCollar", Color: ["#000000", "#6E5B38"], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 2, weight: 0, magic: true, escapeChance: { "Struggle": -0.5, "Cut": -0.1, "Remove": 0.25, "Pick": 0.05 },
        maxwill: 0.25,
        unlimited: true, enemyTags: { "leashing": 0.001, "maidCollar": -1, "dragonRestraints": -1, "mithrilRestraints": -1 }, playerTags: { "ItemNeckFull": -2, "Damsel": -1 }, minLevel: 2, allFloors: true, shrine: ["Collars", "Conjure"] },
    { inventory: true, name: "KittyCollar", debris: "Belts", linkCategory: "BasicCollar", accessible: true, Asset: "LeatherCollarBell", Color: ["Default"], Group: "ItemNeck", LinkableBy: [...KDCollarLink], power: 5, weight: 0, magic: true, escapeChance: { "Struggle": -0.5, "Cut": -0.25, "Remove": 0.25, "Pick": 0.05 },
        maxwill: 0.25,
        unlimited: true, enemyTags: { "kittyRestraints": 0.001, "kittyCollar": 10, "maidCollar": -1, "dragonRestraints": -1, "mithrilRestraints": -1 }, playerTags: { "ItemNeckFull": -2 }, minLevel: 0, allFloors: true, shrine: ["Collars", "Will"],
    },
    { inventory: true, removePrison: true, alwaysKeep: true, showInQuickInv: true, good: true, name: "PotionCollar", accessible: true, Asset: "SlenderSteelCollar", Color: ["#6E5B38"], Group: "ItemNeck", power: 1, weight: 0, escapeChance: { "Struggle": -0.2, "Cut": -0.1, "Remove": 0.5, "Pick": 0.15 }, potionCollar: true, allowPotions: true,
        enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: [] },
    { inventory: true, removePrison: true, alwaysKeep: true, showInQuickInv: true, good: true, name: "SlimeWalkers", debris: "Belts", inaccessible: true, Asset: "BalletHeels", Color: "#ff00ff", Group: "ItemBoots", hobble: true, power: 1, weight: 0, slimeWalk: true,
        escapeChance: { "Struggle": 0.15, "Cut": 0.45, "Remove": 0.4, "Pick": 0.9 }, enemyTags: {}, playerTags: {}, minLevel: 0, floors: KDMapInit([]), shrine: [] },
    { inventory: true, removePrison: true, name: "BasicLeash", tether: 2.9, Asset: "CollarLeash", Color: "Default", Group: "ItemNeckRestraints", leash: true, power: 1, weight: -99, harness: true,
        unlimited: true,
        events: [
            { trigger: "postRemoval", type: "RequireCollar" }
        ],
        escapeChance: { "Struggle": -0.1, "Cut": 0.2, "Remove": 0.5, "Pick": 1.25 }, enemyTags: { "leashing": 1 }, playerTags: { "ItemNeckRestraintsFull": -2, "ItemNeckFull": 99 }, minLevel: 0, allFloors: true, shrine: [] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, arousalMode: true, enchanted: true, name: "EnchantedBelt", Asset: "PolishedChastityBelt", OverridePriority: 26, Color: "#AE915C", Group: "ItemPelvis", chastity: true, power: 25, weight: 0,
        Security: {
            level_key: 4,
            level_magic: 4,
            level_tech: 4,
        },
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        LinkableBy: ["Ornate"],
        events: [
            { trigger: "calcMiscast", type: "ReduceMiscastFlat", power: 0.3, requireEnergy: true },
            { trigger: "tick", type: "RegenStamina", power: 1, requireEnergy: true, energyCost: 0.0005 },
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, arousalMode: true, enchanted: true, name: "EnchantedBra", Asset: "PolishedChastityBra", OverridePriority: 26, Color: "#AE915C", Group: "ItemBreast", chastitybra: true, power: 25, weight: 0,
        Security: {
            level_key: 4,
            level_magic: 4,
            level_tech: 4,
        },
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        LinkableBy: ["Ornate"],
        events: [
            { trigger: "beforeDamage", type: "ModifyDamageFlat", power: -1, requireEnergy: true, energyCost: 0.01, inheritLinked: true }
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, name: "EnchantedHeels", Asset: "BalletWedges", Color: "#AE915C", Group: "ItemBoots", hobble: true, power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        events: [
            { trigger: "tick", type: "ApplySlowLevelBuff", power: -2, requireEnergy: true, energyCost: 0.0005, inheritLinked: true },
            { type: "ShadowHeel", trigger: "playerAttack", requireEnergy: true, energyCost: 0.00225, inheritLinked: true },
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, name: "EnchantedBlindfold", Asset: "PaddedBlindfold", Color: ["#AE915C", "#262626"], Group: "ItemHead", blindfold: 5, power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        LinkableBy: [...KDBlindfoldLink],
        events: [
            { trigger: "calcEvasion", type: "BlindFighting", requireEnergy: true, inheritLinked: true },
            { trigger: "tick", type: "AccuracyBuff", power: 1.0, requireEnergy: true, inheritLinked: true },
            { trigger: "beforePlayerAttack", type: "BoostDamage", power: 1, requireEnergy: true, energyCost: 0.001125, inheritLinked: true },
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, name: "EnchantedAnkleCuffs", Asset: "SteelAnkleCuffs", Type: "Chained", Color: ["#AE915C", "#B0B0B0"], Group: "ItemFeet", power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        LinkableBy: [...KDBindable, ...KDDevices], renderWhenLinked: [...KDBindable],
        events: [
            { trigger: "tick", type: "EnchantedAnkleCuffs" },
            { trigger: "tick", type: "AllyHealingAura", aoe: 3.9, power: 1.5, inheritLinked: true },
            { trigger: "tick", type: "EvasionBuff", power: 0.25, requireEnergy: true, inheritLinked: true },
            { trigger: "miss", type: "EnergyCost", requireEnergy: true, energyCost: 0.0075, inheritLinked: true }
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, inventoryAs: "EnchantedAnkleCuffs", name: "EnchantedAnkleCuffs2", Asset: "SteelAnkleCuffs", Type: "Closed", blockfeet: true, addTag: ["FeetLinked"], Color: ["#AE915C", "#B0B0B0"], Group: "ItemFeet", power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        LinkableBy: [...KDBindable, ...KDDevices], renderWhenLinked: [...KDBindable],
        events: [
            { trigger: "tick", type: "EnchantedAnkleCuffs2", requireEnergy: true, inheritLinked: true }
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, name: "EnchantedMuzzle", gag: 1.0, Asset: "FuturisticMuzzle", Modules: [1, 1, 2], Color: ['#AE915C', '#AE915C', '#CAA562', '#000000'],
        Group: "ItemMouth", power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["AncientMuzzle", "FlatGags"],
        events: [
            { trigger: "tick", type: "SneakBuff", power: 1.15, requireEnergy: true, inheritLinked: true },
            { trigger: "tick", type: "RegenMana", power: 1.0, requireEnergy: true, energyCost: 0.0025, inheritLinked: true },
            { trigger: "beforeDamageEnemy", type: "AddDamageStealth", power: 7.0, requireEnergy: true, energyCost: 0.0015, inheritLinked: true },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.25, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.2, requiredTag: "Blindfolds" },
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, name: "EnchantedBallGag", gag: 0.6, Asset: "FuturisticHarnessBallGag", Color: ['#AE915C', '#AE915C', '#424242', "#CAA562", '#000000'],
        Group: "ItemMouth", power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: ["Flat"],
        LinkableBy: [...KDBallGagLink, "AncientMuzzle"], renderWhenLinked: [...KDBallGagLink],
        events: [
            { trigger: "calcMiscast", type: "ReduceMiscastFlat", power: 0.3, requireEnergy: true, inheritLinked: true },
            { trigger: "tick", type: "RegenMana", power: 1.0, requireEnergy: true, energyCost: 0.0025, inheritLinked: true },
            { trigger: "beforeDamageEnemy", type: "MultiplyDamageStatus", power: 1.3, requireEnergy: true, energyCost: 0.0025, inheritLinked: true },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagRemoveBlindfold", StruggleType: "Remove", power: 0.25, requiredTag: "Blindfolds" },
            { trigger: "beforeStruggleCalc", type: "struggleDebuff", msg: "KDHarnessGagStruggleBlindfold", StruggleType: "Struggle", power: 0.2, requiredTag: "Blindfolds" },
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, name: "EnchantedArmbinder", inaccessible: true, Asset: "FuturisticArmbinder", Type: "Tight", Color: ['#AE915C', '#AE915C', '#424242', "#424242", '#000000'],
        Group: "ItemArms", power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        LinkableBy: [...KDArmbinderLink], renderWhenLinked: [...KDArmbinderLink],
        events: [
            { trigger: "tick", type: "spellRange", power: 0.5, requireEnergy: true },
            { trigger: "beforeDamageEnemy", type: "MultiplyDamageMagic", power: 1.4, requireEnergy: true, energyCost: 0.00002, inheritLinked: true }
        ] },
    { curse: "MistressKey", enchantedDrain: 0.00001, inventory: true, enchanted: true, name: "EnchantedMittens", Asset: "FuturisticMittens", bindhands: 1.0,
        Color: ['#B6A262', '#B6A262', '#424242', '#000000'], Group: "ItemHands", power: 25, weight: 0,
        escapeChance: { "Struggle": -100, "Cut": -100, "Remove": -100 }, enemyTags: {}, playerTags: {}, minLevel: 0, allFloors: true, shrine: [],
        LinkableBy: ["Tape", "Mittens"],
        events: [
            { trigger: "beforeDamageEnemy", type: "MultiplyDamageMagic", power: 1.4, requireEnergy: true, energyCost: 0.000025, inheritLinked: true }
        ] },
];
(() => {
    let afterload = KDModsAfterLoad;
    KDModsAfterLoad = () => {
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "Breastplate",
            Group: "ItemBreast",
            Asset: "PolishedChastityBra",
            OverridePriority: 27,
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            debris: "Belts",
            escapeChance: {
                "Struggle": 10,
                "Cut": -0.5,
                "Remove": 10
            },
            shrine: ["Armor", "ChestArmor", "MetalArmor"],
            armor: true,
            protection: 1,
            events: [
                { trigger: "tick", type: "restraintBlock", power: 1, inheritLinked: true },
                { trigger: "tick", type: "sneakBuff", power: -0.15, inheritLinked: true },
            ],
        }, "Breastplate", "Rock-solid and form-fitting.", "Provides minor protection against enemy attacks. Decreases stealth."), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "Bustier",
            Group: "ItemTorso",
            Asset: "LeatherCorsetTop1",
            AssetGroup: "Corset",
            debris: "Belts",
            OverridePriority: 27,
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": 0.1,
                "Cut": 0.1,
                "Remove": 0.4,
            },
            shrine: ["Armor", "TorsoArmor"],
            armor: true,
            protection: 1,
            strictness: 0.05,
            protectionCursed: true,
            events: [
                { trigger: "tick", type: "restraintBlock", power: 1, inheritLinked: true },
            ],
        }, "Adventuring Corset", "Protects your organs and your sense of style.", "Provides minor protection against enemy attacks at the cost of flexibility."), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "ChainTunic",
            Group: "ItemTorso",
            Asset: "Bodice1",
            AssetGroup: "Cloth",
            Color: ["#808080", "#808080", "#808080"],
            OverridePriority: 27,
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            debris: "Chains",
            escapeChance: {
                "Struggle": -0.1,
                "Cut": -0.35,
                "Remove": 0.35,
            },
            protection: 2,
            protectionCursed: true,
            strictness: 0.08,
            shrine: ["Armor", "TorsoArmor", "MetalArmor"],
            armor: true,
            events: [
                { trigger: "tick", type: "armorBuff", power: 1.0, inheritLinked: true },
                { trigger: "tick", type: "restraintBlock", power: 2.5, inheritLinked: true },
                { trigger: "tick", type: "evasionBuff", power: -0.5, inheritLinked: true },
                { trigger: "tick", type: "sneakBuff", power: -0.5, inheritLinked: true },
            ],
        }, "Chainmail Tank Top", "Cumbersome, but effective!", "Provides +10 armor and protection against enemy attacks. Decreases stealth/evasion and makes struggling harder."), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "SteelArmor",
            Group: "ItemTorso",
            Asset: "MistressTop",
            AssetGroup: "Cloth",
            Color: ["Default"],
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": -0.5,
                "Cut": -0.5,
                "Remove": 0.15,
            },
            shrine: ["Armor", "TorsoArmor", "MetalArmor"],
            armor: true,
            debris: "Belts",
            protection: 3,
            protectionCursed: true,
            strictness: 0.15,
            displayPower: 10,
            events: [
                { trigger: "tick", type: "armorBuff", power: 0.5, inheritLinked: true },
                { trigger: "tick", type: "restraintBlock", power: 5, inheritLinked: true },
            ],
        }, "Light Plate Armor", "Knight in shining rest-err, armor!", "Provides +5 armor and high protection. No impact to stealth or evasion"), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "MageArmor",
            Group: "ItemTorso",
            Asset: "GrandMage",
            AssetGroup: "Cloth",
            Color: ["#5555ff"],
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": 0,
                "Cut": -0.5,
                "Remove": 0.25,
            },
            shrine: ["Armor", "Robe"],
            armor: true,
            debris: "Belts",
            protection: 1,
            displayPower: 10,
            events: [
                { trigger: "perksBonus", type: "spellDamage", power: 0.3, inheritLinked: true },
                { trigger: "tick", type: "spellWardBuff", power: 1, inheritLinked: true },
            ],
        }, "Wizard's Robe", "I have the power!", "+30% spell damage and +10 spell ward"), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "SteelSkirt",
            Group: "ItemLegs",
            Asset: "LatexSkirt2",
            AssetGroup: "ClothLower",
            Color: ["#ffffff"],
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": -0.5,
                "Cut": -0.5,
                "Remove": 0.35,
            },
            shrine: ["Armor", "PelvisArmor", "MetalArmor"],
            armor: true,
            protection: 2,
            debris: "Belts",
            protectionCursed: true,
            displayPower: 8,
            events: [
                { trigger: "tick", type: "armorBuff", power: 0.5, inheritLinked: true },
                { trigger: "tick", type: "restraintBlock", power: 5, inheritLinked: true },
            ],
        }, "Armored Skirt", "Knight in shining rest-err, armor!", "Provides +5 armor and high protection. No impact to stealth or evasion"), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "Gauntlets",
            Group: "ItemHands",
            Asset: "FingerlessGloves",
            AssetGroup: "Gloves",
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": 10,
                "Cut": -0.5,
                "Remove": 10
            },
            shrine: ["Armor", "GlovesArmor", "MetalArmor"],
            armor: true,
            debris: "Belts",
            protection: 1,
            events: [
                { trigger: "tick", type: "armorBuff", power: 0.5, inheritLinked: true },
                { trigger: "tick", type: "restraintBlock", power: 1, inheritLinked: true },
                { trigger: "playerAttack", type: "armorNoise", chance: 1, dist: 8, sfx: "Chain", msg: "KinkyDungeonPunishPlayerArmor", inheritLinked: true },
                { trigger: "playerCast", type: "armorNoise", chance: 1, dist: 11, punishComponent: "Arms", sfx: "Chain", msg: "KinkyDungeonPunishPlayerArmor", inheritLinked: true },
            ],
        }, "Gauntlets", "Gloves with an iron grip.", "Provides +5 armor and minor protection against enemy attacks. Makes noise when attacking."), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "LeatherGloves",
            Group: "ItemHands",
            Asset: "BikerGloves",
            AssetGroup: "Gloves",
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": 10,
                "Cut": 0.1,
                "Remove": 10
            },
            shrine: ["Armor", "GlovesArmor"],
            armor: true,
            debris: "Belts",
            protection: 1,
        }, "Leather Gloves", "Protecting you in style.", "Provides minor protection against enemy attacks."), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "Bracers",
            Group: "ItemArms",
            Asset: "SteelCuffs",
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": 10,
                "Cut": -0.5,
                "Remove": 10
            },
            shrine: ["Armor", "ArmArmor", "MetalArmor"],
            armor: true,
            debris: "Belts",
            protection: 1,
        }, "Steel Bracers", "Dependable protection for the average adventurer.", "Provides minor protection against enemy attacks."), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "SteelBoots",
            Group: "ItemBoots",
            Asset: "Boots1",
            AssetGroup: "Shoes",
            Color: ["#444444", "#222222"],
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": 10,
                "Cut": -0.5,
                "Remove": 10
            },
            shrine: ["Armor", "BootsArmor", "MetalArmor"],
            armor: true,
            protection: 1,
            debris: "Belts",
            events: [
                { trigger: "tick", type: "armorBuff", power: 0.5, inheritLinked: true },
                { trigger: "tick", type: "restraintBlock", power: 1, inheritLinked: true },
                { trigger: "tick", type: "sneakBuff", power: -0.35, inheritLinked: true },
            ],
        }, "Armored Boots", "Noisy, but fashionable!", "Provides +5 armor and protection against enemy attacks. Decreases stealth."), [...KDCurseVariantList.Basic]);
        KinkyDungeonAddCursedVariants(KinkyDungeonCreateRestraint({
            name: "LeatherBoots",
            Group: "ItemBoots",
            Asset: "WoollyBootsTall",
            AssetGroup: "Shoes",
            Color: ["#808080"],
            showInQuickInv: true, good: true,
            alwaysKeep: true,
            escapeChance: {
                "Struggle": 10,
                "Cut": 0.1,
                "Remove": 10
            },
            shrine: ["Armor", "BootsArmor"],
            armor: true,
            debris: "Belts",
            protection: 1,
        }, "Hide Boots", "For stepping into all kinds of trouble!", "Provides minor protection against enemy attacks."), [...KDCurseVariantList.Basic]);
        afterload();
    };
})();
let KDLocks = {
    "Red": {
        lockmult: 2.0,
        pickable: true,
        pick_time: 1.0,
        pick_diff: 0.0,
        canPick: (data) => {
            return true;
        },
        doPick: (data) => {
            return true;
        },
        failPick: (data) => {
            return "Fail";
        },
        breakChance: (data) => {
            return KDRandom() < KinkyDungeonKeyGetPickBreakChance();
        },
        unlockable: true,
        key: "Red",
        canUnlock: (data) => {
            return KinkyDungeonRedKeys > 0;
        },
        doUnlock: (data) => {
            KinkyDungeonRedKeys -= 1;
            return true;
        },
        removeKeys: (data) => {
            KinkyDungeonRedKeys -= 1;
        },
        failUnlock: (data) => {
            return "Fail";
        },
        levelStart: (item) => {
        },
        shrineImmune: false,
        commandlevel: 0,
        command_lesser: () => { return 0.0; },
        command_greater: () => { return 0.0; },
        command_supreme: () => { return 0.0; },
        loot_special: false,
        loot_locked: true,
    },
    "Red_Med": {
        lockmult: 2.1,
        pickable: true,
        pick_time: 1.0,
        pick_diff: 0.0,
        pick_lim: 0.15,
        canPick: (data) => {
            return true;
        },
        doPick: (data) => {
            return true;
        },
        failPick: (data) => {
            return "Fail";
        },
        breakChance: (data) => {
            return KDRandom() < KinkyDungeonKeyGetPickBreakChance();
        },
        unlockable: true,
        key: "Red",
        canUnlock: (data) => {
            return KinkyDungeonRedKeys > 0;
        },
        doUnlock: (data) => {
            KinkyDungeonRedKeys -= 1;
            return true;
        },
        removeKeys: (data) => {
            KinkyDungeonRedKeys -= 1;
        },
        failUnlock: (data) => {
            return "Fail";
        },
        levelStart: (item) => {
        },
        shrineImmune: false,
        commandlevel: 0,
        command_lesser: () => { return 0.0; },
        command_greater: () => { return 0.0; },
        command_supreme: () => { return 0.0; },
        loot_special: false,
        loot_locked: true,
    },
    "Red_Hi": {
        lockmult: 2.2,
        pickable: true,
        pick_time: 1.0,
        pick_diff: 0.0,
        pick_lim: 0.3,
        canPick: (data) => {
            return true;
        },
        doPick: (data) => {
            return true;
        },
        failPick: (data) => {
            return "Fail";
        },
        breakChance: (data) => {
            return KDRandom() < KinkyDungeonKeyGetPickBreakChance();
        },
        unlockable: true,
        key: "Red",
        canUnlock: (data) => {
            return KinkyDungeonRedKeys > 0;
        },
        doUnlock: (data) => {
            KinkyDungeonRedKeys -= 1;
            return true;
        },
        removeKeys: (data) => {
            KinkyDungeonRedKeys -= 1;
        },
        failUnlock: (data) => {
            return "Fail";
        },
        levelStart: (item) => {
        },
        shrineImmune: false,
        commandlevel: 0,
        command_lesser: () => { return 0.0; },
        command_greater: () => { return 0.0; },
        command_supreme: () => { return 0.0; },
        loot_special: false,
        loot_locked: true,
    },
    "Blue": {
        lockmult: 3.0,
        penalty: {
            "Struggle": 0.1,
            "Cut": 0.15,
        },
        pickable: false,
        pick_time: 0.0,
        pick_diff: 0.0,
        canPick: (data) => {
            return false;
        },
        doPick: (data) => {
            return false;
        },
        failPick: (data) => {
            return "Break";
        },
        breakChance: (data) => {
            return true;
        },
        unlockable: true,
        key: "Blue",
        canUnlock: (data) => {
            return KinkyDungeonBlueKeys > 0;
        },
        doUnlock: (data) => {
            return true;
        },
        removeKeys: (data) => {
            KinkyDungeonBlueKeys -= 1;
        },
        failUnlock: (data) => {
            return "Fail";
        },
        levelStart: (item) => {
        },
        shrineImmune: false,
        commandlevel: 0,
        command_lesser: () => { return 0.0; },
        command_greater: () => { return 0.0; },
        command_supreme: () => { return 0.0; },
        loot_special: true,
        loot_locked: false,
    },
    "Gold": {
        lockmult: 3.25,
        penalty: {
            "Struggle": 0.2,
            "Cut": 0.3,
        },
        pickable: false,
        pick_time: 0.0,
        pick_diff: 0.0,
        canPick: (data) => {
            return false;
        },
        doPick: (data) => {
            return false;
        },
        failPick: (data) => {
            return "Break";
        },
        breakChance: (data) => {
            return true;
        },
        unlockable: true,
        key: "Mistress",
        canUnlock: (data) => {
            return KinkyDungeonItemCount("MistressKey") > 0;
        },
        doUnlock: (data) => {
            return true;
        },
        removeKeys: (data) => {
            KinkyDungeonChangeConsumable(KinkyDungeonFindConsumable("MistressKey"), -1);
        },
        failUnlock: (data) => {
            return "Fail";
        },
        levelStart: (item) => {
            if ((MiniGameKinkyDungeonLevel >= item.lockTimer || !item.lockTimer || item.lockTimer >= KinkyDungeonMaxLevel)) {
                KinkyDungeonLock(item, "Blue");
                KinkyDungeonSendTextMessage(8, TextGet("KinkyDungeonGoldLockRemove"), "yellow", 2);
            }
        },
        shrineImmune: false,
        commandlevel: 0,
        command_lesser: () => { return 0.0; },
        command_greater: () => { return 0.0; },
        command_supreme: () => { return 0.0; },
        loot_special: true,
        loot_locked: false,
    },
    "Purple": {
        lockmult: 2.5,
        pickable: false,
        pick_time: 0.0,
        pick_diff: 0.0,
        canPick: (data) => {
            return false;
        },
        doPick: (data) => {
            return false;
        },
        failPick: (data) => {
            return "Fail";
        },
        breakChance: (data) => {
            return false;
        },
        unlockable: false,
        key: "Blue",
        canUnlock: (data) => {
            return false;
        },
        doUnlock: (data) => {
            return true;
        },
        removeKeys: (data) => {
        },
        failUnlock: (data) => {
            return "Fail";
        },
        levelStart: (item) => {
        },
        shrineImmune: false,
        commandlevel: 1,
        command_lesser: () => { return 1.0; },
        command_greater: () => { return 3.0; },
        command_supreme: () => { return 10.0; },
        loot_special: false,
        loot_locked: true,
    },
};
let KDControlHarnessCategories = {
    "Cuffs": {
        activateCount: 3,
        activateTags: ["ArmCuffsBase", "LegCuffsBase", "AnkleCuffsBase"],
        activateFunction: (e, item, data, invItems) => {
            let upgradedTags = ["ControlHArm", "ControlHAnkle", "ControlHLeg"];
            if (upgradedTags.some((tag) => { return KinkyDungeonPlayerTags.get(tag) != true; })) {
                KinkyDungeonSendTextMessage(4, TextGet("KDControlHarnessCuffsActivate"), "#ffffff", 1);
                for (let rName of ["CyberArmCuffs2", "CyberArmCuffs3", "CyberAnkleCuffs2", "CyberAnkleCuffs3", "CyberLegCuffs2"]) {
                    if (KinkyDungeonPlayerTags.get("Item_" + rName))
                        continue;
                    let newRestraint = KinkyDungeonGetRestraintByName(rName);
                    if (!KinkyDungeonPlayerTags.get("LinkTo_" + rName))
                        continue;
                    if (KDToggles.Sound)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/RobotEngage.ogg");
                    KinkyDungeonAddRestraint(newRestraint, item.tightness, true, "", false, undefined, undefined, undefined, item.faction);
                }
            }
        },
        updateFunction: (e, item, data, invItems) => {
            let upgradedTags = ["ControlHArm", "ControlHAnkle", "ControlHLeg"];
            if (upgradedTags.some((tag) => { return KinkyDungeonPlayerTags.get(tag) != true; })) {
                KinkyDungeonSendTextMessage(4, TextGet("KDControlHarnessCuffsUpdate")
                    .replace("RESTRAINTNAME", TextGet("Restraint" + data.item.name))
                    .replace("PERCENT", "" + Math.round(100 * invItems.length / 3)), "#ffffff", 1);
            }
        },
    },
    "Chastity": {
        activateCount: 2,
        activateTags: ["CyberChastityL", "CyberChastityU"],
        activateFunction: (e, item, data, invItems) => {
            if (!KinkyDungeonStatsChoice.get("arousalMode"))
                return;
            let fillGroups = ["ItemVulva", "ItemVulvaPiercings", "ItemButt", "ItemNipples"];
            if (fillGroups.some((group) => { return !KinkyDungeonGetRestraintItem(group); })) {
                let Mode = CommonRandomItemFromList("", ["Edge", "Deny", "Fullpower"]);
                if (KinkyDungeonGetRestraintItem("ItemVulva"))
                    Mode = "Extra";
                KinkyDungeonSendTextMessage(4, TextGet("KDControlHarnessChastityActivate")
                    .replace("CHASTITYMODE", TextGet("KDControlHarnessChastityMode_" + Mode)), "#ffffff", 1);
                let addList = ["RearVibe1", "TrapVibeProto", "NippleClamps"];
                if (Mode == "Edge")
                    addList.push("TrapPlug2");
                else if (Mode == "Deny")
                    addList.push("TrapPlug3");
                else if (Mode == "Fullpower")
                    addList.push("TrapPlug5");
                for (let rName of addList) {
                    let newRestraint = KinkyDungeonGetRestraintByName(rName);
                    if (KinkyDungeonGetRestraintItem(KDRestraint(newRestraint).Group))
                        continue;
                    if (KDToggles.Sound)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/RobotEngage.ogg");
                    KinkyDungeonAddRestraint(newRestraint, item.tightness, true, "", false, undefined, undefined, undefined, item.faction);
                }
            }
        },
        updateFunction: (e, item, data, invItems) => {
            if (!KinkyDungeonStatsChoice.get("arousalMode"))
                return;
            let fillGroups = ["ItemVulva", "ItemVulvaPiercings", "ItemButt", "ItemNipples"];
            if (fillGroups.some((group) => { return !KinkyDungeonGetRestraintItem(group); })) {
                KinkyDungeonSendTextMessage(4, TextGet("KDControlHarnessChastityUpdate")
                    .replace("RESTRAINTNAME", TextGet("Restraint" + data.item.name))
                    .replace("PERCENT", "" + Math.round(100 * invItems.length / 3)), "#ffffff", 1);
            }
        },
    },
};
let KinkyDungeonKilledEnemy = null;
let KinkyDungeonAlert = 0;
let KDBrawlerAmount = 1.0;
let KDClumsyAmount = 0.7;
let KDUnfocusedParams = {
    AmountMin: 0.9,
    AmountMax: 0.6,
    ThreshMin: 0.1,
    ThreshMax: 0.9,
};
let KDDodgeAmount = 0.75;
let KinkyDungeonMissChancePerBlind = 0.1;
let KinkyDungeonMissChancePerSlow = 0.1;
let KinkyDungeonBullets = [];
let KinkyDungeonBulletsVisual = new Map();
let KinkyDungeonBulletsID = {};
let KDVulnerableDmg = 1.0;
let KDVulnerableDmgMult = 0.33;
let KDVulnerableHitMult = 1.33;
let KDPacifistReduction = 0.1;
let KDRiggerDmgBoost = 0.2;
let KDRiggerBindBoost = 0.3;
let KDStealthyDamageMult = 0.7;
let KDStealthyEvaMult = 0.8;
let KDResilientDamageMult = 0.7;
let KDStealthyEnemyCountMult = 1.7;
let KDBoundPowerMult = 0.4;
let KDBerserkerAmp = 0.3;
let KDUnstableAmp = 0.6;
let KinkyDungeonOpenObjects = KinkyDungeonTransparentObjects;
let KinkyDungeonMeleeDamageTypes = ["unarmed", "crush", "slash", "pierce", "grope", "pain", "chain", "tickle"];
let KinkyDungeonTeaseDamageTypes = ["tickle", "charm", "grope", "pain", "happygas", "poison", "drain", "souldrain"];
let KinkyDungeonStunDamageTypes = ["fire", "electric", "stun"];
let KinkyDungeonBindDamageTypes = ["chain", "glue"];
let KinkyDungeonFreezeDamageTypes = ["ice"];
let KinkyDungeonSlowDamageTypes = ["crush", "slash", "pierce", "frost", "cold", "poison"];
let KinkyDungeonVulnerableDamageTypes = ["tickle", "acid", "magicbind"];
let KDDamageBinds = {
    "glue": "Slime",
    "ice": "Ice",
    "frost": "Ice",
    "crush": "Metal",
};
let KDSpellTagBinds = {
    "rope": "Rope",
    "leather": "Leather",
    "chain": "Metal",
    "metal": "Metal",
    "vine": "Vine",
    "nature": "Vine",
};
let KinkyDungeonDamageTypesExtension = {
    "tickle": "charm",
    "grope": "charm",
    "pain": "charm",
    "happygas": "charm",
    "charm": "soul",
};
let KinkyDungeonBindingDamageTypes = ["chain", "glue", "magicbind"];
let KinkyDungeonDistractDamageTypes = ["tickle", "grope", "happygas", "charm"];
let KinkyDungeonMasochistDamageTypes = ["crush", "pain", "unarmed", "electric", "shock", "fire", "magicbind", "glue", "chain", "souldrain", "drain"];
let KinkyDungeonPlayerWeapon = null;
let KinkyDungeonPlayerWeaponLastEquipped = "";
let KinkyDungeonPlayerDamageDefault = { name: "", dmg: 2, chance: 0.9, type: "unarmed", unarmed: true, rarity: 0, shop: false, sfx: "Unarmed" };
let KinkyDungeonPlayerDamage = KinkyDungeonPlayerDamageDefault;
let KinkyDungeonDamageTypes = {
    acid: { name: "acid", color: "#c8d45d", bg: "black" },
    cold: { name: "cold", color: "#554bd4", bg: "black" },
    ice: { name: "ice", color: "#00D8FF", bg: "black" },
    frost: { name: "ice", color: "#00D8FF", bg: "black" },
    fire: { name: "fire", color: "#FF6A00", bg: "black" },
    poison: { name: "poison", color: "#00D404", bg: "black" },
    happygas: { name: "happygas", color: "#E27CD0", bg: "black" },
    charm: { name: "charm", color: "#E27CD0", bg: "black" },
    soul: { name: "soul", color: "#E27CD0", bg: "black" },
    drain: { name: "soul", color: "#E27CD0", bg: "black" },
    souldrain: { name: "soul", color: "#E27CD0", bg: "black" },
    electric: { name: "electric", color: "#FFD800", bg: "black" },
    glue: { name: "glue", color: "#E200D0", bg: "black" },
    stun: { name: "stun", color: "white", bg: "black" },
    chain: { name: "chain", color: "white", bg: "black" },
    tickle: { name: "tickle", color: "white", bg: "black" },
    crush: { name: "crush", color: "white", bg: "black" },
    grope: { name: "grope", color: "white", bg: "black" },
    slash: { name: "slash", color: "white", bg: "black" },
    pierce: { name: "pierce", color: "white", bg: "black" },
    pain: { name: "pain", color: "white", bg: "black" },
    unarmed: { name: "unarmed", color: "white", bg: "black" },
    magic: { name: "magic", color: "#00FF90", bg: "black" },
    melee: { name: "melee", color: "#aaaaaa", bg: "black" },
    spell: { name: "spell", color: "#00FF90", bg: "black" },
};
function KDWeapon(item) {
    return KinkyDungeonWeapons[item.name];
}
function KinkyDungeonFindWeapon(Name) {
    for (let con of Object.values(KinkyDungeonWeapons)) {
        if (con.name == Name)
            return con;
    }
    return undefined;
}
function KinkyDungeonWeaponCanCut(RequireInteract, MagicOnly) {
    if (KinkyDungeonPlayerWeapon
        && KinkyDungeonWeapons[KinkyDungeonPlayerWeapon].cutBonus != undefined
        && (!MagicOnly || KinkyDungeonWeapons[KinkyDungeonPlayerWeapon].magic != undefined)
        && (!RequireInteract || !KinkyDungeonIsHandsBound(false, false, 0.55)))
        return true;
    if (KinkyDungeonPlayerBuffs) {
        for (let b of Object.values(KinkyDungeonPlayerBuffs)) {
            if (b && b.tags && (b.tags.includes("allowCutMagic") || (!MagicOnly && b.tags.includes("allowCut"))))
                return true;
        }
    }
    return false;
}
function KDSetWeapon(Weapon, forced) {
    if (!Weapon)
        Weapon = 'Unarmed';
    KinkyDungeonEvasionPityModifier = 0;
    KinkyDungeonPlayerWeapon = Weapon;
    if (!forced)
        KinkyDungeonPlayerWeaponLastEquipped = Weapon;
}
function KinkyDungeonGetPlayerWeaponDamage(HandsFree, NoOverride) {
    let flags = {
        KDDamageHands: true.valueOf,
    };
    if (!NoOverride)
        KinkyDungeonSendEvent("calcDamage", { flags: flags });
    let damage = KinkyDungeonPlayerDamageDefault;
    KinkyDungeonPlayerDamage = {};
    let weapon = KinkyDungeonWeapons[KinkyDungeonPlayerWeapon];
    if (weapon && weapon.noHands)
        HandsFree = true;
    if (!HandsFree || (KinkyDungeonStatsChoice.get("Brawler") && !KinkyDungeonPlayerWeapon)) {
        damage = KinkyDungeonPlayerDamageDefault;
        if (!NoOverride)
            KDSetWeapon('Unarmed', true);
    }
    else if (KinkyDungeonPlayerWeapon && KinkyDungeonWeapons[KinkyDungeonPlayerWeapon]) {
        damage = KinkyDungeonWeapons[KinkyDungeonPlayerWeapon];
    }
    Object.assign(KinkyDungeonPlayerDamage, damage);
    let handBondage = KDHandBondageTotal();
    if (handBondage && (flags.KDDamageHands || weapon.unarmed) && (!weapon || !weapon.noHands || weapon.unarmed)) {
        KinkyDungeonPlayerDamage.chance *= 0.5 + Math.max(0, 0.5 * Math.min(1, handBondage));
    }
    if (KinkyDungeonStatsChoice.get("Brawler") && !KinkyDungeonPlayerDamage.name) {
        KinkyDungeonPlayerDamage.dmg += KDBrawlerAmount;
    }
    else {
        if (KinkyDungeonSlowLevel > 1 && (!KinkyDungeonPlayerDamage.name || weapon.unarmed)) {
            KinkyDungeonPlayerDamage.dmg /= 2;
        }
    }
    if ((KinkyDungeonPlayer.Pose.includes("Hogtied") || KinkyDungeonPlayer.Pose.includes("Kneel")) && (flags.KDDamageHands || weapon.unarmed) && (!weapon || !weapon.noHands || weapon.unarmed)) {
        KinkyDungeonPlayerDamage.chance /= 1.5;
    }
    return KinkyDungeonPlayerDamage;
}
let KinkyDungeonEvasionPityModifier = 0;
let KinkyDungeonEvasionPityModifierIncrementPercentage = 0.5;
function KinkyDungeonGetEvasion(Enemy, NoOverride, IsSpell, IsMagic, cost) {
    let flags = {
        KDEvasionHands: true,
        KDEvasionSight: true,
        KDEvasionDeaf: true,
        KDEvasionSlow: true,
    };
    let data = { enemy: Enemy,
        isSpell: IsSpell,
        isMagic: IsMagic,
        flags: flags,
        cost: cost,
        hitmult: 1.0,
    };
    if (!NoOverride)
        KinkyDungeonSendEvent("calcEvasion", data);
    let hitChance = (Enemy && Enemy.buffs) ? KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(Enemy.buffs, "Evasion")) : 1.0;
    hitChance *= data.hitmult;
    if (KinkyDungeonStatsChoice.get("Clumsy"))
        hitChance *= KDClumsyAmount;
    if (KinkyDungeonStatsChoice.get("Unfocused")) {
        let amount = 1;
        let dist = KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax;
        if (dist >= KDUnfocusedParams.ThreshMin) {
            amount = KDUnfocusedParams.AmountMin + (KDUnfocusedParams.AmountMax - KDUnfocusedParams.AmountMin) * (dist - KDUnfocusedParams.ThreshMin) / (KDUnfocusedParams.ThreshMax - KDUnfocusedParams.ThreshMin);
        }
        if (amount != 1)
            hitChance *= amount;
    }
    if (Enemy && Enemy.Enemy && Enemy.Enemy.evasion && ((!(Enemy.stun > 0) && !(Enemy.freeze > 0)) || Enemy.Enemy.alwaysEvade || Enemy.Enemy.evasion < 0))
        hitChance *= Math.max(0, (Enemy.aware ? KinkyDungeonMultiplicativeStat(Enemy.Enemy.evasion) : Math.max(1, KinkyDungeonMultiplicativeStat(Enemy.Enemy.evasion))));
    if (Enemy && Enemy.Enemy && Enemy.Enemy.tags.ghost && (IsMagic || (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.magic)))
        hitChance = Math.max(hitChance, 1.0);
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Accuracy")) {
        hitChance *= KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Accuracy"));
    }
    if (!IsSpell)
        hitChance *= KinkyDungeonPlayerDamage.chance;
    if (Enemy && Enemy.bind > 0)
        hitChance *= 3;
    else if (Enemy && Enemy.slow > 0)
        hitChance *= 2;
    if (Enemy && (Enemy.stun > 0 || Enemy.freeze > 0))
        hitChance *= 5;
    else {
        if (Enemy && Enemy.distraction > 0)
            hitChance *= 1 + Math.min(1, Enemy.distraction / Enemy.Enemy.maxhp);
        if (Enemy)
            hitChance *= 1 + 0.25 * KDBoundEffects(Enemy);
    }
    if (Enemy && Enemy.vulnerable)
        hitChance *= KDVulnerableHitMult;
    if (!IsSpell) {
        if (flags.KDEvasionSight)
            hitChance = Math.min(hitChance, Math.max(0.1, hitChance - Math.min(3, KinkyDungeonBlindLevel) * KinkyDungeonMissChancePerBlind));
        if (flags.KDEvasionSlow && KinkyDungeonPlayerDamage && !KinkyDungeonPlayerDamage.name && KinkyDungeonSlowLevel > 0)
            hitChance *= 1.0 - Math.max(0.5, KinkyDungeonMissChancePerSlow * KinkyDungeonSlowLevel);
    }
    return hitChance;
}
function KinkyDungeonAggro(Enemy, Spell, Attacker, Faction) {
    if (Enemy && Enemy.Enemy && (!Spell || !Spell.enemySpell) && (!Faction || Faction == "Player") && !(Enemy.rage > 0) && (!Attacker || Attacker.player || Attacker.Enemy.allied)) {
        if ((Enemy.playWithPlayer || !KDHostile(Enemy)) && KDCanDom(Enemy)) {
            KDAddThought(Enemy.id, "Embarrassed", 5, 1);
            Enemy.distraction = (Enemy.distraction || 0) + Enemy.Enemy.maxhp * 0.1;
            KDAddOpinion(Enemy, 10);
        }
        else {
            if (Enemy && !Enemy.Enemy.allied) {
                KinkyDungeonSetFlag("PlayerCombat", 8);
                KinkyDungeonAggroAction('attack', { enemy: Enemy });
            }
        }
    }
}
function KDPlayerEvasionPenalty() {
    let evasionPenalty = .25 * KinkyDungeonSlowLevel;
    return evasionPenalty;
}
function KinkyDungeonPlayerEvasion() {
    let playerEvasionMult = 1.0;
    let playerEvasionPenalty = KDPlayerEvasionPenalty();
    let val = playerEvasionMult * KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Evasion") - playerEvasionPenalty);
    return val;
}
function KinkyDungeonGetPlayerStat(stat, mult) {
    let data = {
        mult: mult,
        stat: !mult ? KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, stat) : KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, stat)),
    };
    KinkyDungeonSendEvent("calcPlayer" + stat, data);
    return data.stat;
}
function KDRestraintBlockPower(block, power) {
    return KinkyDungeonMultiplicativeStat(block / Math.max(1, power));
}
function KinkyDungeonEvasion(Enemy, IsSpell, IsMagic, Attacker) {
    let hitChance = KinkyDungeonGetEvasion(Enemy, undefined, IsSpell, IsMagic, true);
    if (KDHostile(Enemy) && KinkyDungeonStatsChoice.get("Stealthy")) {
        hitChance *= KDStealthyEvaMult;
    }
    if (!Enemy)
        KinkyDungeonSleepTime = 0;
    KinkyDungeonAggro(Enemy, undefined, Attacker);
    if (KDRandom() < hitChance + KinkyDungeonEvasionPityModifier) {
        KinkyDungeonEvasionPityModifier = 0;
        return true;
    }
    if (Enemy) {
        KinkyDungeonEvasionPityModifier += KinkyDungeonEvasionPityModifierIncrementPercentage * hitChance;
    }
    return false;
}
let KDDamageEquivalencies = {
    "frost": "ice",
    "happygas": "charm",
    "souldrain": "soul",
    "drain": "soul",
    "shock": "electric",
};
function KinkyDungeonGetImmunity(tags, type, resist) {
    let t = type;
    if (KDDamageEquivalencies[type])
        t = KDDamageEquivalencies[type];
    for (let i = 0; i < 10 && KinkyDungeonDamageTypesExtension[t]; i++) {
        if (KinkyDungeonDamageTypesExtension[t] && resist != "weakness" && resist != "severeweakness")
            t = KinkyDungeonDamageTypesExtension[t];
    }
    if (tags && (tags[t + resist]
        || ((KinkyDungeonMeleeDamageTypes.includes(t) && (type != "unarmed" || !resist.includes("weakness"))) && tags["melee" + resist])
        || (!KinkyDungeonMeleeDamageTypes.includes(t) && tags["magic" + resist])))
        return true;
    return false;
}
let KDDamageQueue = [];
function KDArmorFormula(DamageAmount, Armor) {
    if (DamageAmount <= 0)
        return 1;
    if (Armor < 0)
        return Math.min(3, (DamageAmount - Armor) / DamageAmount);
    return DamageAmount / (DamageAmount + Armor);
}
function KinkyDungeonDamageEnemy(Enemy, Damage, Ranged, NoMsg, Spell, bullet, attacker, Delay, noAlreadyHit) {
    if (bullet && !noAlreadyHit) {
        if (!bullet.alreadyHit)
            bullet.alreadyHit = [];
        if (bullet.alreadyHit.includes(Enemy.id))
            return 0;
        bullet.alreadyHit.push(Enemy.id);
    }
    let predata = {
        aggro: false,
        faction: "Enemy",
        enemy: Enemy,
        spell: Spell,
        bullet: bullet,
        attacker: attacker,
        type: (Damage) ? Damage.type : 0,
        bufftype: (Damage) ? Damage.type : 0,
        time: (Damage) ? Damage.time : 0,
        dmg: (Damage) ? Damage.damage : 0,
        bind: (Damage) ? Damage.bind : 0,
        bindType: (Damage) ? Damage.bindType : 0,
        flags: (Damage) ? Damage.flags : undefined,
        boundBonus: (Damage) ? Damage.boundBonus : 0,
        bindEff: (Damage) ? Damage.bindEff : 0,
        distract: (Damage) ? Damage.distract : 0,
        distractEff: (Damage) ? Damage.distractEff : 0,
        incomingDamage: Damage,
        dmgDealt: 0,
        freezebroke: false,
        froze: 0,
        vulnerable: (Enemy.vulnerable || (KDHostile(Enemy) && !Enemy.aware)) && Damage && !Damage.novulnerable && (!Enemy.Enemy.tags || !Enemy.Enemy.tags.nonvulnerable),
    };
    if (KDDamageEquivalencies[predata.type])
        predata.bufftype = KDDamageEquivalencies[predata.type];
    if (attacker) {
        if (attacker.player)
            predata.faction = "Player";
        else if (attacker.Enemy)
            predata.faction = KDGetFaction(attacker);
    }
    else if (bullet) {
        if (bullet.bullet.faction)
            predata.faction = bullet.bullet.faction;
        else if (bullet.bullet.spell && bullet.bullet.spell.enemySpell)
            predata.faction = "Enemy";
        else
            predata.faction = "Player";
    }
    else if (Spell) {
        if (Spell.enemySpell)
            predata.faction = "Enemy";
        else
            predata.faction = "Player";
    }
    KinkyDungeonSendEvent("beforeDamageEnemy", predata);
    if (!predata.dmg)
        predata.dmg = 0;
    let effect = false;
    let resistStun = 0;
    let resistSlow = 0;
    let resistDamage = 0;
    let spellResist = (Damage && Enemy.Enemy.armor && !KinkyDungeonMeleeDamageTypes.includes(predata.type)) ? Enemy.Enemy.spellResist : 0;
    if (KinkyDungeonGetBuffedStat(Enemy.buffs, "SpellResist"))
        spellResist += KinkyDungeonGetBuffedStat(Enemy.buffs, "SpellResist");
    let armor = (Damage && Enemy.Enemy.armor && KinkyDungeonMeleeDamageTypes.includes(predata.type)) ? Enemy.Enemy.armor : 0;
    if (KinkyDungeonGetBuffedStat(Enemy.buffs, "Armor"))
        armor += KinkyDungeonGetBuffedStat(Enemy.buffs, "Armor");
    if (KinkyDungeonGetBuffedStat(Enemy.buffs, "ArmorBreak"))
        armor -= Math.min(Math.max(0, armor), KinkyDungeonGetBuffedStat(Enemy.buffs, "ArmorBreak"));
    if (Enemy.freeze > 0 && Damage && KinkyDungeonMeleeDamageTypes.includes(predata.type)) {
        predata.dmg *= 2;
    }
    let miss = !(!Damage || !Damage.evadeable || KinkyDungeonEvasion(Enemy, (true && Spell), !KinkyDungeonMeleeDamageTypes.includes(predata.type), attacker));
    if (Damage && !miss) {
        if (KinkyDungeonStatsChoice.get("Pacifist") && KDHostile(Enemy) && Enemy.Enemy.bound && !KinkyDungeonTeaseDamageTypes.includes(predata.type) && predata.type != "glue" && predata.type != "chain") {
            predata.dmg *= KDPacifistReduction;
        }
        KDUpdatePerksBonus();
        let DamageAmpBonusPerks = KDDamageAmpPerks
            + (KinkyDungeonMeleeDamageTypes.includes(predata.type) ? KDDamageAmpPerksMelee : 0)
            + (Spell && !Spell.allySpell && !Spell.enemySpell ? KDDamageAmpPerksSpell : 0);
        let damageAmp = KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(Enemy.buffs, "DamageAmp") - (KDHostile(Enemy) && (!attacker || attacker.player) ? (DamageAmpBonusPerks) : 0));
        let buffreduction = KinkyDungeonGetBuffedStat(Enemy.buffs, "DamageReduction");
        let buffresist = KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(Enemy.buffs, predata.bufftype + "DamageResist"));
        buffresist *= KinkyDungeonMeleeDamageTypes.includes(predata.type) ?
            KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(Enemy.buffs, "meleeDamageResist"))
            : KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(Enemy.buffs, "magicDamageResist"));
        let buffType = predata.bufftype + "DamageBuff";
        let buffAmount = 1 + (KDHostile(Enemy) ? KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, buffType) : 0);
        predata.dmg *= buffAmount;
        predata.dmg *= buffresist;
        if (predata.type == "fire" && Enemy.freeze > 0) {
            predata.dmg *= 1.4;
        }
        if (damageAmp)
            predata.dmg *= damageAmp;
        let time = predata.time ? predata.time : 0;
        if (spellResist && !KinkyDungeonMeleeDamageTypes.includes(predata.type)) {
            if (time)
                time = Math.max(0, Math.ceil(time * KDArmorFormula(predata.dmg, spellResist)));
            predata.dmg = Math.max(0, predata.dmg * KDArmorFormula(predata.dmg, spellResist));
        }
        if (Enemy.Enemy.tags) {
            if (KinkyDungeonGetImmunity(Enemy.Enemy.tags, predata.type, "severeweakness"))
                resistDamage = -2;
            else if (KinkyDungeonGetImmunity(Enemy.Enemy.tags, predata.type, "weakness"))
                resistDamage = -1;
            else if (KinkyDungeonGetImmunity(Enemy.Enemy.tags, predata.type, "immune"))
                resistDamage = 2;
            else if (KinkyDungeonGetImmunity(Enemy.Enemy.tags, predata.type, "resist"))
                resistDamage = 1;
            if (Enemy.Enemy.tags.unstoppable)
                resistStun = 2;
            else if (Enemy.Enemy.tags.unflinching)
                resistStun = 1;
            if (Enemy.Enemy.tags.unslowable)
                resistSlow = 2;
            else if (Enemy.Enemy.tags.slowresist)
                resistSlow = 1;
        }
        if (Enemy.boundLevel > 0 && (KinkyDungeonTeaseDamageTypes.includes(predata.type) || Damage.tease)) {
            let eff = KDBoundEffects(Enemy);
            let mult = 1.0;
            if (eff > 0) {
                mult += 0.5;
            }
            if (eff > 3) {
                mult += 0.5;
            }
            predata.dmg *= mult;
        }
        if (Enemy.boundLevel > 0 && Damage && Damage.boundBonus) {
            let eff = KDBoundEffects(Enemy);
            predata.dmg += Damage.boundBonus * eff;
        }
        let killed = Enemy.hp > 0;
        let forceKill = false;
        if (predata.type != "inert" && resistDamage < 2) {
            if (resistDamage == 1 || (resistStun > 0 && predata.type == "stun")) {
                predata.dmgDealt = Math.max(predata.dmg * KDArmorFormula(predata.dmg, armor), 0);
                predata.dmgDealt = predata.dmgDealt * 0.5;
            }
            else if (resistDamage == -1) {
                if (predata.dmg > 0)
                    predata.dmgDealt = Math.max(predata.dmg + 0.5, predata.dmg * 1.5);
                else
                    predata.dmgDealt = 0;
                predata.dmgDealt = Math.max(predata.dmgDealt * KDArmorFormula(predata.dmg, armor), 0);
            }
            else if (resistDamage == -2) {
                predata.dmgDealt = Math.max(predata.dmg + 1, predata.dmg * 2);
                predata.dmgDealt = Math.max(predata.dmgDealt * KDArmorFormula(predata.dmg, armor), 0);
            }
            else {
                predata.dmgDealt = Math.max(predata.dmg * KDArmorFormula(predata.dmg, armor), 0);
            }
            if (Enemy.Enemy.tags && Enemy.Enemy.tags.playerinstakill && attacker && attacker.player)
                predata.dmgDealt = Enemy.hp;
            else if (buffreduction && predata.dmgDealt > 0) {
                predata.dmgDealt = Math.max(predata.dmgDealt - buffreduction, 0);
                KinkyDungeonTickBuffTag(Enemy.buffs, "damageTaken", 1);
                KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Shield.ogg");
            }
            if (Enemy.freeze > 0 && predata.dmgDealt > 0) {
                if ((KinkyDungeonMeleeDamageTypes.includes(predata.type))) {
                    Enemy.freeze = 0;
                }
                else if (!["ice", "frost"].includes(predata.type)) {
                    Enemy.freeze = Math.max(0, Enemy.freeze - predata.dmgDealt * (predata.type == "fire" ? 0.75 : 0.25));
                }
                if (Enemy.freeze == 0) {
                    predata.freezebroke = true;
                }
            }
            if (KDHostile(Enemy)) {
                if (KinkyDungeonStatsChoice.get("Stealthy"))
                    predata.dmgDealt *= KDStealthyDamageMult;
                if (KinkyDungeonStatsChoice.get("ResilientFoes"))
                    predata.dmgDealt *= KDResilientDamageMult;
            }
            KinkyDungeonSendEvent("duringDamageEnemy", predata);
            if (Spell && Spell.hitsfx)
                KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + Spell.hitsfx + ".ogg");
            else if (!(Spell && Spell.hitsfx) && predata.dmgDealt > 0 && bullet)
                KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/DealDamage.ogg");
            if (Damage && Damage.damage) {
                if (predata.faction == "Player" || KinkyDungeonVisionGet(Enemy.x, Enemy.y) > 0)
                    KDDamageQueue.push({ floater: Math.round(Math.min(predata.dmgDealt, Enemy.hp) * 10), Entity: Enemy, Color: "#ff4444", Delay: Delay });
            }
            Enemy.hp -= predata.dmgDealt;
            if (Enemy.hp > 0 && Enemy.hp <= 0.51 && predata.dmgDealt > 2.01 && !forceKill && KDBoundEffects(Enemy) < 4)
                Enemy.hp = 0;
            if (predata.dmgDealt > 0)
                Enemy.revealed = true;
        }
        if ((resistStun < 2 && resistDamage < 2) && (KinkyDungeonStunDamageTypes.includes(predata.type))) {
            effect = true;
            if (!Enemy.stun)
                KDAddThought(Enemy.id, "Status", 5, 1);
            if (!Enemy.stun)
                Enemy.stun = 0;
            if (resistStun == 1 || resistDamage == 1)
                Enemy.stun = Math.max(Enemy.stun, Math.min(Math.floor(time / 2), time - 1));
            else
                Enemy.stun = Math.max(Enemy.stun, time);
        }
        if ((resistStun < 2 && resistDamage < 2) && (KinkyDungeonFreezeDamageTypes.includes(predata.type))) {
            effect = true;
            if (!Enemy.freeze)
                KDAddThought(Enemy.id, "Freeze", 5, 1);
            if (!(Enemy.freeze > 0))
                Enemy.freeze = 0;
            let preFreeze = Enemy.freeze > 0;
            if (resistDamage == 1 || resistStun == 1)
                Enemy.freeze = Math.max(Enemy.freeze, Math.min(Math.floor(time / 2), time - 1));
            else
                Enemy.freeze = Math.max(Enemy.freeze, time);
            predata.froze = (Enemy.freeze > 0 && !preFreeze) ? Enemy.freeze : 0;
        }
        if ((resistStun < 2 && resistDamage < 2) && (KinkyDungeonBindDamageTypes.includes(predata.type))) {
            effect = true;
            if (!Enemy.bind)
                Enemy.bind = 0;
            if (resistDamage == 1 || resistStun == 1)
                Enemy.bind = Math.max(Enemy.bind, Math.min(Math.floor(time / 2), time - 1));
            else
                Enemy.bind = Math.max(Enemy.bind, time);
        }
        if ((predata.dmg || predata.bind) && Enemy.Enemy.bound && (resistDamage < 2) && (predata.bind || KinkyDungeonBindingDamageTypes.includes(predata.type))) {
            effect = true;
            if (!Enemy.boundLevel)
                Enemy.boundLevel = 0;
            let efficiency = predata.bindEff ? predata.bindEff : 1.0;
            if (resistStun == -2) {
                efficiency *= 2;
            }
            else if (resistStun == -1) {
                efficiency *= 1.5;
            }
            if (resistDamage == 1 || resistStun == 1) {
                efficiency *= 0.75;
            }
            if (resistDamage == 2) {
                efficiency *= 0.5;
            }
            if (resistStun == 2) {
                efficiency *= 0.5;
            }
            if (predata.vulnerable || Enemy.boundLevel > Enemy.Enemy.maxhp) {
                efficiency *= 2;
            }
            if (!(Enemy.boundLevel > 0)) {
                let Thought = "Annoyed";
                if (KDStrictPersonalities.includes(Enemy.personality))
                    Thought = "Struggle";
                else if (KDLoosePersonalities.includes(Enemy.personality))
                    Thought = "Embarrassed";
                KDAddThought(Enemy.id, Thought, 5, 2);
            }
            let amt = efficiency * (predata.bind ? predata.bind : predata.dmg);
            if (predata.vulnerable && efficiency * (predata.bind ? predata.bind : predata.dmg) > 0.01 && Enemy.boundLevel < Enemy.Enemy.maxhp * 0.4) {
                amt += Enemy.Enemy.maxhp * 0.2;
            }
            if (amt > 0 && !predata.bindType) {
                if (KDDamageBinds[predata.type])
                    predata.bindType = KDDamageBinds[predata.type];
                else if (Spell) {
                    if (Spell.tags) {
                        for (let t of Spell.tags) {
                            if (KDSpellTagBinds[t]) {
                                predata.bindType = KDSpellTagBinds[t];
                                break;
                            }
                        }
                    }
                }
            }
            KDTieUpEnemy(Enemy, amt, predata.bindType, predata.dmg);
        }
        if ((predata.dmg || predata.distract) && Enemy.Enemy.bound && (resistDamage < 2)
            && (predata.distract || KinkyDungeonDistractDamageTypes.includes(predata.type) || (KDLoosePersonalities.includes(Enemy.personality) && KinkyDungeonMasochistDamageTypes.includes(predata.type)))) {
            if (!Enemy.distraction)
                Enemy.distraction = 0;
            if (Enemy.distraction < Enemy.Enemy.maxhp) {
                effect = true;
                let efficiency = predata.distractEff ? predata.distractEff : 1.0;
                efficiency *= 1;
                if (resistDamage == 1) {
                    efficiency *= 0.75;
                }
                if (resistDamage == 2) {
                    efficiency *= 0.5;
                }
                if (predata.vulnerable || Enemy.boundLevel > 0) {
                    efficiency *= 1 + Math.min(1, predata.vulnerable ? 1 : Enemy.boundLevel / Enemy.Enemy.maxhp);
                }
                if (!(Enemy.distraction > 0)) {
                    let Thought = "Embarrassed";
                    if (KDStrictPersonalities.includes(Enemy.personality))
                        Thought = "Angry";
                    else if (KDLoosePersonalities.includes(Enemy.personality))
                        Thought = "Play";
                    KDAddThought(Enemy.id, Thought, 5, 2);
                }
                Enemy.distraction += efficiency * (predata.distract ? predata.distract : predata.dmg);
                if (predata.vulnerable && efficiency * (predata.distract ? predata.distract : predata.dmg) > 0.01 && Enemy.distraction < Enemy.Enemy.maxhp * 0.5) {
                    Enemy.distraction += Enemy.Enemy.maxhp * 0.25;
                }
            }
        }
        if (!forceKill && KDBoundEffects(Enemy) > 3 && (Enemy.hp < 0 || (Enemy.hp <= Enemy.Enemy.maxhp * 0.1))) {
            if ((predata.faction == "Player" || KinkyDungeonVisionGet(Enemy.x, Enemy.y) > 0) && Enemy.hp > 0.001) {
                let Thought = "GiveUp";
                if (KDStrictPersonalities.includes(Enemy.personality))
                    Thought = "Fire";
                else if (KDLoosePersonalities.includes(Enemy.personality))
                    Thought = "Play";
                if (!(Enemy.boundLevel > 0))
                    KDAddThought(Enemy.id, Thought, 6, 3);
                KDAddThought(Enemy.id, Thought, 6, 3);
                KDDamageQueue.push({ floater: TextGet("KDHelpless"), Entity: { x: Enemy.x - 0.5 + Math.random(), y: Enemy.y - 0.5 + Math.random() }, Color: "white", Time: 2, Delay: Delay });
            }
            if (killed)
                Enemy.hp = 0.001;
        }
        if ((resistSlow < 2 && resistDamage < 2) && (KinkyDungeonSlowDamageTypes.includes(predata.type))) {
            effect = true;
            if (!Enemy.slow)
                KDAddThought(Enemy.id, "Annoyed", 5, 1);
            if (!Enemy.slow)
                Enemy.slow = 0;
            if (resistSlow == 1 || resistDamage == 1)
                Enemy.slow = Math.max(Enemy.slow, Math.min(Math.floor(time / 2), time - 1));
            else
                Enemy.slow = Math.max(Enemy.slow, time);
        }
        if ((resistDamage < 2) && (KinkyDungeonVulnerableDamageTypes.includes(predata.type))) {
            effect = true;
            if (!Enemy.vulnerable)
                KDAddThought(Enemy.id, "Status", 4, 1);
            if (!Enemy.vulnerable)
                Enemy.vulnerable = 0;
            if (resistDamage == 1)
                Enemy.vulnerable = Math.max(Enemy.vulnerable, Math.min(Math.floor(time / 2), time - 1));
            else
                Enemy.vulnerable = Math.max(Enemy.vulnerable, time);
        }
    }
    if (KDBoundEffects(Enemy) > 3) {
        if (!Enemy.vulnerable)
            Enemy.vulnerable = 0;
        Enemy.vulnerable = Math.max(Enemy.vulnerable, 1);
    }
    predata.aggro = predata.type != "heal" && predata.type != "inert" && (!Spell || !Spell.allySpell) && (!bullet || !bullet.spell || !bullet.spell.allySpell);
    KinkyDungeonSendEvent("afterDamageEnemy", predata);
    let atkname = (Spell) ? TextGet("KinkyDungeonSpell" + Spell.name) : TextGet("KinkyDungeonBasicAttack");
    let damageName = TextGet("KinkyDungeonDamageType" + predata.type);
    if (!NoMsg && !Spell)
        atkname = TextGet("KinkyDungeonBasicDamage");
    if (Enemy.hp <= 0) {
        KinkyDungeonKilledEnemy = Enemy;
    }
    let mod = "";
    if (resistDamage == 1)
        mod = "Weak";
    if (resistDamage == 2)
        mod = "Immune";
    if (resistDamage == -1)
        mod = "Strong";
    if (resistDamage == -2)
        mod = "VeryStrong";
    if (Damage && !mod && spellResist > 0 && !KinkyDungeonMeleeDamageTypes.includes(predata.type))
        mod = "SpellResist";
    if (predata.faction == "Player" || predata.faction == "Rage") {
        if (!Enemy.playerdmg)
            Enemy.playerdmg = 0.01;
        Enemy.playerdmg += predata.dmgDealt;
    }
    if (!NoMsg && (predata.dmgDealt > 0 || !Spell || effect) && (!Damage || Damage.damage > 0))
        KinkyDungeonSendActionMessage(4 + predata.dmgDealt * 0.01, (Damage && predata.dmgDealt > 0) ?
            TextGet((Ranged) ? "PlayerRanged" + mod : "PlayerAttack" + mod).replace("TargetEnemy", TextGet("Name" + Enemy.Enemy.name)).replace("AttackName", atkname).replace("DamageDealt", "" + Math.round(predata.dmgDealt * 10)).replace("DamageType", ("" + damageName).toLowerCase())
            : TextGet("PlayerMiss" + ((Damage && !miss) ? "Armor" : "")).replace("TargetEnemy", TextGet("Name" + Enemy.Enemy.name)), (Damage && (predata.dmg > 0 || effect)) ? "orange" : "#ff0000", 2, undefined, undefined, Enemy);
    if (Enemy && Enemy.Enemy && KDAmbushAI(Enemy) && Spell) {
        Enemy.ambushtrigger = true;
    }
    if (!Damage && predata.type != "inert" && predata.dmgDealt <= 0) {
        KDAddThought(Enemy.id, "Laugh", 4, 1);
        KDDamageQueue.push({ floater: TextGet("KDMissed"), Entity: { x: Enemy.x - 0.5 + Math.random(), y: Enemy.y - 0.5 + Math.random() }, Color: "white", Time: 2, Delay: Delay });
        if (KDRandom() < actionDialogueChanceIntense)
            KinkyDungeonSendDialogue(Enemy, TextGet("KinkyDungeonRemindJail" + (Enemy.Enemy.playLine ? Enemy.Enemy.playLine : "") + "MissedMe").replace("EnemyName", TextGet("Name" + Enemy.Enemy.name)), KDGetColor(Enemy), 4, 5, false, true);
        if (KDToggles.Sound && Enemy.Enemy.cueSfx && Enemy.Enemy.cueSfx.Miss) {
            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + Enemy.Enemy.cueSfx.Miss + ".ogg");
        }
    }
    else if (Damage && Damage.damage > 0 && predata.type != "inert" && predata.dmgDealt <= 0 && !miss) {
        if (predata.faction == "Player" || KinkyDungeonVisionGet(Enemy.x, Enemy.y) > 0) {
            KDAddThought(Enemy.id, "Laugh", 5, 3);
            if (KDRandom() < actionDialogueChanceIntense)
                KinkyDungeonSendDialogue(Enemy, TextGet("KinkyDungeonRemindJail" + (Enemy.Enemy.playLine ? Enemy.Enemy.playLine : "") + "MissedMe").replace("EnemyName", TextGet("Name" + Enemy.Enemy.name)), KDGetColor(Enemy), 4, 5, false, true);
            KDDamageQueue.push({ floater: TextGet("KDBlocked"), Entity: { x: Enemy.x - 0.5 + Math.random(), y: Enemy.y - 0.5 + Math.random() }, Color: "white", Time: 2, Delay: Delay });
        }
        let type = KinkyDungeonMeleeDamageTypes.includes(predata.type) ? "Block" : "Resist";
        if (KDToggles.Sound && Enemy.Enemy.cueSfx && Enemy.Enemy.cueSfx[type]) {
            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + Enemy.Enemy.cueSfx[type] + ".ogg");
        }
    }
    else if (predata.dmgDealt > 0 && KDToggles.Sound && Enemy.Enemy.cueSfx && Enemy.Enemy.cueSfx.Damage) {
        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + Enemy.Enemy.cueSfx.Damage + ".ogg");
        if (KDRandom() < actionDialogueChance)
            KinkyDungeonSendDialogue(Enemy, TextGet("KinkyDungeonRemindJail" + (Enemy.Enemy.playLine ? Enemy.Enemy.playLine : "") + "Hit").replace("EnemyName", TextGet("Name" + Enemy.Enemy.name)), KDGetColor(Enemy), 4, 5);
    }
    if (predata.aggro)
        KinkyDungeonAggro(Enemy, Spell, attacker, predata.faction);
    if (predata.dmg > 0) {
        KinkyDungeonTickBuffTag(Enemy.buffs, "takeDamage", 1);
        KinkyDungeonSetEnemyFlag(Enemy, "wander", 0);
    }
    return predata.dmg;
}
function KinkyDungeonDisarm(Enemy, suff) {
    if (!KinkyDungeonPlayerDamage || KinkyDungeonPlayerDamage.unarmed)
        return false;
    if (!Enemy) {
        console.log("Error processing disarm! Please report!");
        return false;
    }
    if (KDRandom() < KinkyDungeonWeaponGrabChance) {
        let slots = [];
        for (let X = -Math.ceil(1); X <= Math.ceil(1); X++)
            for (let Y = -Math.ceil(1); Y <= Math.ceil(1); Y++) {
                if ((X != 0 || Y != 0) && KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(Enemy.x + X, Enemy.y + Y))) {
                    slots.push({ x: Enemy.x + X, y: Enemy.y + Y });
                    for (let XX = -Math.ceil(1); XX <= Math.ceil(1); XX++)
                        for (let YY = -Math.ceil(1); YY <= Math.ceil(1); YY++) {
                            if ((Math.abs(X + XX) > 1 || Math.abs(Y + YY) > 1) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(Enemy.x + XX + X, Enemy.y + YY + Y))) {
                                slots.push({ x: Enemy.x + XX + X, y: Enemy.y + YY + Y });
                            }
                        }
                }
            }
        let foundslot = null;
        for (let C = 0; C < 100; C++) {
            let slot = slots[Math.floor(KDRandom() * slots.length)];
            if (slot && KinkyDungeonNoEnemy(slot.x, slot.y, true)
                && Math.max(Math.abs(KinkyDungeonPlayerEntity.x - slot.x), Math.abs(KinkyDungeonPlayerEntity.y - slot.y)) > 1.5
                && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(slot.x, slot.y))) {
                foundslot = { x: slot.x, y: slot.y };
                C = 100;
            }
            else
                slots.splice(C, 1);
        }
        if (foundslot) {
            let weapon = KinkyDungeonPlayerDamage.name;
            let dropped = { x: foundslot.x, y: foundslot.y, name: weapon };
            KDSetWeapon('Unarmed', true);
            KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
            KinkyDungeonInventoryRemove(KinkyDungeonInventoryGetWeapon(weapon));
            KinkyDungeonGroundItems.push(dropped);
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonDisarm" + (suff ? suff : "")), "#ff0000", 2);
            return true;
        }
    }
    return false;
}
function KinkyDungeonAttackEnemy(Enemy, Damage) {
    let disarm = false;
    if (Enemy.Enemy && Enemy.Enemy.disarm && Enemy.disarmflag > 0) {
        if (Enemy.stun > 0 || Enemy.freeze > 0 || Enemy.blind > 0 || (Enemy.playWithPlayer && !Enemy.hostile))
            Enemy.disarmflag = 0;
        else if (Enemy.Enemy && Enemy.Enemy.disarm && Enemy.disarmflag >= 0.97 && KinkyDungeonPlayerDamage && !KinkyDungeonPlayerDamage.unarmed) {
            Enemy.disarmflag = 0;
            disarm = true;
        }
    }
    let evaded = KinkyDungeonEvasion(Enemy, undefined, undefined, KinkyDungeonPlayerEntity);
    let dmg = Damage;
    let buffdmg = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackDmg");
    let predata = {
        targetX: Enemy.x,
        targetY: Enemy.y,
        enemy: Enemy,
        evaded: evaded,
        miss: !evaded,
        disarm: disarm,
        eva: !disarm && evaded,
        Damage: Damage,
        buffdmg: buffdmg,
        vulnConsumed: false,
        vulnerable: (Enemy.vulnerable || (KDHostile(Enemy) && !Enemy.aware)) && dmg && !dmg.novulnerable && (!Enemy.Enemy.tags || !Enemy.Enemy.tags.nonvulnerable),
    };
    KinkyDungeonSendEvent("beforePlayerAttack", predata);
    if (predata.buffdmg)
        dmg.damage = Math.max(0, dmg.damage + predata.buffdmg);
    if (predata.vulnerable && (predata.eva)) {
        predata.vulnConsumed = true;
        let dmgBonus = Math.max(Math.min(2 * dmg.damage, KDVulnerableDmg), dmg.damage * KDVulnerableDmgMult);
        dmg.damage = Math.max(0, dmg.damage + dmgBonus);
        KinkyDungeonSendTextMessage(4, TextGet((Enemy.vulnerable || Enemy.distraction > Enemy.Enemy.maxhp) ? "KinkyDungeonVulnerable" : "KinkyDungeonUnseen")
            .replace("AMOUNT", "" + Math.round(10 * dmgBonus))
            .replace("EnemyName", TextGet("Name" + Enemy.Enemy.name)), "lightgreen", 2);
    }
    let hp = Enemy.hp;
    KinkyDungeonDamageEnemy(Enemy, (predata.eva) ? dmg : null, undefined, undefined, undefined, undefined, KinkyDungeonPlayerEntity);
    if (predata.eva && KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.sfx) {
        if (KDToggles.Sound)
            KDDamageQueue.push({ sfx: KinkyDungeonRootDirectory + "Audio/" + KinkyDungeonPlayerDamage.sfx + ".ogg" });
    }
    else if (!predata.eva)
        if (KDToggles.Sound)
            KDDamageQueue.push({ sfx: KinkyDungeonRootDirectory + "Audio/Miss.ogg" });
    if (disarm) {
        KinkyDungeonDisarm(Enemy);
    }
    if (!KinkyDungeonPlayerDamage || !KinkyDungeonPlayerDamage.silent || !(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Silence") > 0)) {
        if (Enemy && hp < Enemy.Enemy.maxhp) {
            KinkyDungeonAlert = 4;
        }
        else {
            KinkyDungeonAlert = 2;
        }
    }
    else {
        if (!KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Silence") || KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Silence") < 2) {
            if (KinkyDungeonAlert) {
                KinkyDungeonAlert = 2;
            }
            else {
                KinkyDungeonAlert = 1;
            }
        }
        else if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Silence") < 3) {
        }
    }
    if (Enemy.Enemy && Enemy.Enemy.disarm && !disarm && KinkyDungeonPlayerDamage && !KinkyDungeonPlayerDamage.unarmed) {
        if (!Enemy.disarmflag)
            Enemy.disarmflag = 0;
        Enemy.disarmflag += Enemy.Enemy.disarm;
    }
    let data = {
        targetX: Enemy.x,
        targetY: Enemy.y,
        enemy: Enemy,
        miss: !evaded,
        disarm: disarm,
        damage: Damage,
        vulnConsumed: predata.vulnConsumed,
    };
    KinkyDungeonSendEvent("playerAttack", data);
    KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "damage", 1);
    KinkyDungeonTickBuffTag(Enemy.buffs, "incomingHit", 1);
    if (predata.eva)
        KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "hit", 1);
    KinkyDungeonSendEvent("afterPlayerAttack", data);
    if (data.vulnConsumed) {
        Enemy.vulnerable = 0;
    }
}
let KDBulletWarnings = [];
let KDUniqueBulletHits = new Map();
function KDUpdateBulletEffects(b, d) {
    if (!b.bullet.noInteractTiles) {
        let rad = b.bullet.aoe || 0.5;
        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                if (AOECondition(b.x, b.y, b.x + X, b.y + Y, rad, KDBulletAoEMod(b)) && (X != 0 || Y != 0)) {
                    KDEffectTileInteractions(b.x + X, b.y + Y, b, d);
                }
            }
    }
}
function KinkyDungeonUpdateBullets(delta, Allied) {
    var _a;
    if (Allied)
        KDUniqueBulletHits = new Map();
    if (delta > 0)
        for (let b of KinkyDungeonBullets) {
            if ((Allied && b.bullet && b.bullet.spell && !b.bullet.spell.enemySpell) || (!Allied && !(b.bullet && b.bullet.spell && !b.bullet.spell.enemySpell))) {
                KinkyDungeonSendEvent("bulletTick", { bullet: b, delta: delta, allied: Allied });
                if (b.bullet && b.bullet.dot) {
                    KinkyDungeonBulletDoT(b);
                }
                if (b.bullet.cast && b.bullet.spell && b.bullet.spell.castDuringDelay && (!b.bullet.cast.chance || KDRandom() < b.bullet.cast.chance) && b.time > 1) {
                    let xx = b.bullet.cast.tx;
                    let yy = b.bullet.cast.ty;
                    if (b.bullet.cast.targetID) {
                        let enemy = KinkyDungeonFindID(b.bullet.cast.targetID);
                        if (enemy) {
                            xx = enemy.x;
                            yy = enemy.y;
                        }
                    }
                    let castingSpell = KinkyDungeonFindSpell(b.bullet.cast.spell, true);
                    if (b.bullet.cast.spread) {
                        let xxx = xx + Math.round(-b.bullet.cast.spread + 2 * b.bullet.cast.spread * KDRandom());
                        let yyy = yy + Math.round(-b.bullet.cast.spread + 2 * b.bullet.cast.spread * KDRandom());
                        if (xxx != b.x || yyy != b.y || castingSpell.type != 'bolt') {
                            xx = xxx;
                            yy = yyy;
                        }
                    }
                    if (castingSpell.type != 'bolt') {
                        if (!xx)
                            xx = b.x;
                        if (!yy)
                            yy = b.y;
                    }
                    else if (xx == b.x && yy == b.y) {
                        for (let i = 0; i < 20; i++) {
                            xx = b.x + Math.floor(KDRandom() * 3 - 1);
                            yy = b.y + Math.floor(KDRandom() * 3 - 1);
                            if (xx != b.x || yy != b.y)
                                i = 1000;
                            else if (i > 19) {
                                xx = b.x + 1;
                                yy = b.y + 0;
                            }
                        }
                    }
                    KinkyDungeonCastSpell(xx, yy, castingSpell, undefined, undefined, b);
                    if (b.bullet.cast.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + b.bullet.cast.sfx + ".ogg");
                }
            }
        }
    if (Allied) {
        KDBulletWarnings = [];
    }
    for (let E = 0; E < KinkyDungeonBullets.length; E++) {
        let b = KinkyDungeonBullets[E];
        if ((Allied && b.bullet && b.bullet.spell && !b.bullet.spell.enemySpell) || (!Allied && !(b.bullet && b.bullet.spell && !b.bullet.spell.enemySpell))) {
            let d = delta;
            let first = true;
            let justBorn = false;
            let trailSquares = [];
            let startx = b.x;
            let starty = b.y;
            let end = false;
            let mod = (b.bullet.spell && !b.bullet.spell.slowStart && (b.bullet.spell.fastStart || (b.bullet.spell.speed > b.bullet.spell.range * 0.8 && b.bullet.spell.speed > 1) || (!b.bullet.spell.enemySpell && !b.bullet.spell.allySpell && (b.vx != 0 || b.vy != 0)))) ? 1 : 0;
            KDBulletEffectTiles(b);
            KDUpdateBulletEffects(b, 0);
            let dt = 0.1;
            while (d >= 0.05) {
                dt = (d - Math.max(0, d - 1)) / Math.sqrt(Math.max(1, b.vx * b.vx + b.vy * b.vy));
                if (!first && delta > 0) {
                    if (b.born >= 0) {
                        b.born -= dt;
                        justBorn = true;
                    }
                    if (b.born < mod) {
                        b.xx += b.vx * dt;
                        b.yy += b.vy * dt;
                        b.time -= dt;
                    }
                    if (b.bullet.spell && (b.trail || b.trailEffectTile) && (b.x != Math.round(b.xx) || b.y != Math.round(b.yy) || (b.bullet.spell && b.bullet.spell.trailOnSelf))
                        && !trailSquares.includes(Math.round(b.xx) + "," + Math.round(b.yy))) {
                        if (KinkyDungeonBulletTrail(b)) {
                            trailSquares.push(Math.round(b.xx) + "," + Math.round(b.yy));
                        }
                    }
                    b.x = Math.round(b.xx);
                    b.y = Math.round(b.yy);
                    d -= dt;
                }
                else
                    first = false;
                let outOfRange = false;
                let endTime = false;
                if (b.bullet && b.bullet.origin) {
                    let dist = Math.sqrt((b.bullet.origin.x - b.x) * (b.bullet.origin.x - b.x) + (b.bullet.origin.y - b.y) * (b.bullet.origin.y - b.y));
                    if (dist > b.bullet.range)
                        outOfRange = true;
                    if (dist >= b.bullet.range)
                        endTime = true;
                }
                let outOfTime = (b.bullet.lifetime != 0 && b.time <= 0.001);
                end = false;
                let checkCollision = (b.bullet.faction == "Player" && (b.x != KinkyDungeonPlayerEntity.x || b.y != KinkyDungeonPlayerEntity.y))
                    || justBorn || (b.x != startx || b.y != starty) || (!b.vx && !b.vy) || (KDistEuclidean(b.vx, b.vy) < 0.9);
                if ((checkCollision && !KinkyDungeonBulletsCheckCollision(b, undefined, undefined, delta - d, false)) || outOfTime || outOfRange) {
                    if (!(b.bullet.spell && ((!b.bullet.trail && (b.bullet.spell.piercing || (b.bullet.spell.pierceEnemies && KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(b.x, b.y))))) || (b.bullet.trail && b.bullet.spell.piercingTrail))) || outOfRange || outOfTime)
                        end = true;
                    if (end) {
                        d = 0;
                        KinkyDungeonBullets.splice(E, 1);
                        KinkyDungeonBulletsID[b.spriteID] = null;
                        KinkyDungeonSendEvent("bulletDestroy", { bullet: b, target: undefined, outOfRange: outOfRange, outOfTime: outOfTime });
                        E -= 1;
                    }
                    if (!((outOfTime || outOfRange) && b.bullet.spell && ((!b.bullet.trail && b.bullet.spell.nonVolatile) || (b.bullet.trail && b.bullet.spell.nonVolatileTrail))))
                        KinkyDungeonBulletHit(b, 1.0, outOfTime, outOfRange, d, dt, end);
                }
                if (endTime)
                    b.time = 0;
                KinkyDungeonUpdateSingleBulletVisual(b, end);
            }
            if (!end || (b.bullet.spell && b.bullet.spell.alwaysWarn)) {
                KinkyDungeonSendEvent("bulletAfterTick", { bullet: b, delta: delta, allied: Allied });
                KinkyDungeonUpdateSingleBulletVisual(b, end);
                let show = (KDFactionRelation("Player", b.bullet.faction) < 0.5 || (b.bullet.spell && b.bullet.spell.playerEffect) || b.bullet.playerEffect || (b.bullet.spell && b.bullet.spell.alwaysWarn))
                    && !(b.bullet.spell && b.bullet.spell.hideWarnings)
                    && ((b.bullet.spell && b.bullet.spell.alwaysWarn)
                        || (b.bullet.hit == "lingering" || (b.bullet.spell && b.bullet.name == b.bullet.spell.name && (b.bullet.spell.onhit == "aoe" || b.bullet.spell.onhit == "dot")))
                        || ((b.lifetime > 0 || b.lifetime == undefined) && b.bullet.damage && b.bullet.damage.type && b.bullet.damage.type != "heal" && b.bullet.damage.type != "inert"));
                let bxx = b.xx;
                let byy = b.yy;
                let bx = b.x;
                let by = b.y;
                let btime = b.time;
                let bborn = b.born;
                d = delta;
                first = true;
                startx = bx;
                starty = by;
                b.warnings = [];
                while (d > 0.1) {
                    if (!first && delta > 0) {
                        dt = 0.5 * (d - Math.max(0, d - 1)) / Math.sqrt(Math.max(1, b.vx * b.vx + b.vy * b.vy));
                        if (bborn >= 0)
                            bborn -= dt;
                        if (bborn < mod) {
                            bxx += b.vx * dt;
                            byy += b.vy * dt;
                            btime -= dt;
                        }
                        bx = Math.round(bxx);
                        by = Math.round(byy);
                        d -= dt;
                    }
                    else
                        first = false;
                    let outOfRange = false;
                    if (b.bullet && b.bullet.origin) {
                        let dist = Math.sqrt((b.bullet.origin.x - bx) * (b.bullet.origin.x - bx) + (b.bullet.origin.y - by) * (b.bullet.origin.y - by));
                        if (dist > b.bullet.range)
                            outOfRange = true;
                    }
                    let outOfTime = (b.bullet.lifetime != 0 && ((!b.bullet.damage && btime <= 0.001) || ((b.bullet.damage) && btime <= 1.001)));
                    let checkCollision = (bx != startx || by != starty)
                        || (!b.vx && !b.vy) || (KDistEuclidean(b.vx, b.vy) < 0.9) || b.bullet.aoe;
                    if (outOfTime || outOfRange) {
                        d = 0;
                    }
                    if ((!(outOfTime || outOfRange) || ((_a = b.bullet.spell) === null || _a === void 0 ? void 0 : _a.alwaysWarn)) && checkCollision) {
                        let rad = b.bullet.aoe ? b.bullet.aoe : ((b.bullet.spell && b.bullet.spell.aoe && b.bullet.name == b.bullet.spell.name) ? b.bullet.spell.aoe : 0);
                        for (let xx = bx - Math.floor(rad); xx <= bx + Math.ceil(rad); xx++) {
                            for (let yy = by - Math.floor(rad); yy <= by + Math.ceil(rad); yy++) {
                                if (AOECondition(bx, by, xx, yy, rad, KDBulletAoEMod(b))) {
                                    if (show && !KDBulletWarnings.some((w) => { return w.x == xx && w.y == yy; }))
                                        KDBulletWarnings.push({ x: xx, y: yy, color: b.bullet.spell ? (b.bullet.spell.color ? b.bullet.spell.color : "#ff0000") : "#ff0000" });
                                    if (!b.warnings.includes(xx + "," + yy)) {
                                        b.warnings.push(xx + "," + yy);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!b.bullet.piercing && !b.bullet.pierceEnemies && !b.bullet.noDoubleHit)
                b.alreadyHit = undefined;
        }
    }
}
function KinkyDungeonUpdateSingleBulletVisual(b, end, delay) {
    if (b.spriteID && !b.bullet.noSprite) {
        let bb = KinkyDungeonBulletsVisual.get(b.spriteID);
        let scale = bb ? bb.scale : 0;
        let alpha = bb ? bb.alpha : 0;
        let dd = bb ? bb.delay : delay;
        let spinAngle = bb ? bb.spinAngle : 0;
        let visx = bb ? bb.visual_x : b.visual_x;
        let visy = bb ? bb.visual_y : b.visual_y;
        if (visx == undefined)
            visx = b.xx;
        if (visy == undefined)
            visy = b.yy;
        let temp = (!b.vx && !b.vy && b.time <= 1 && !b.bullet.hit);
        KinkyDungeonBulletsVisual.set(b.spriteID, { end: end, temporary: temp, spin: b.bullet.bulletSpin, spinAngle: spinAngle, name: b.bullet.name, spriteID: b.spriteID, size: b.bullet.width ? b.bullet.width : 1, aoe: (b.bullet.spell && b.bullet.spell.aoe) ? b.bullet.spell.aoe : undefined, vx: b.vx, vy: b.vy, xx: b.xx, yy: b.yy, visual_x: visx, visual_y: visy, updated: true, scale: scale, alpha: alpha, delay: dd });
    }
}
function KinkyDungeonUpdateBulletVisuals(delta) {
    if (delta > 0)
        for (let b of KinkyDungeonBulletsVisual.entries()) {
            if (b[1].updated) {
                b[1].updated = false;
            }
            else if (!b[1].end || b[1].alpha <= 0.01)
                KinkyDungeonBulletsVisual.delete(b[0]);
        }
}
let KinkyDungeonCurrentTick = 0;
function KinkyDungeonUpdateBulletsCollisions(delta, Catchup) {
    for (let E = 0; E < KinkyDungeonBullets.length; E++) {
        let b = KinkyDungeonBullets[E];
        if ((!Catchup && !b.secondary) || (Catchup && b.secondary)) {
            if (!KinkyDungeonBulletsCheckCollision(b, b.time >= 0, undefined, undefined, !(b.bullet.faction == "Player" || (!b.vx && !b.vy) || b.bullet.aoe || (KDistEuclidean(b.vx, b.vy) < 0.9)))) {
                if (!(b.bullet.spell && (b.bullet.spell.piercing || (b.bullet.spell.pierceEnemies && KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(b.x, b.y)))))) {
                    KinkyDungeonBullets.splice(E, 1);
                    KinkyDungeonBulletsID[b.spriteID] = null;
                    KinkyDungeonUpdateSingleBulletVisual(b, true);
                    KinkyDungeonSendEvent("bulletDestroy", { bullet: b, target: undefined, outOfRange: false, outOfTime: false });
                    E -= 1;
                }
                KinkyDungeonBulletHit(b, 1);
            }
        }
    }
}
function KDCheckCollideableBullets(entity, force) {
    for (let E = 0; E < KinkyDungeonBullets.length; E++) {
        let b = KinkyDungeonBullets[E];
        if (b.x == entity.x && b.y == entity.y && b.bullet && b.bullet.damage
            && (b.time > 1
                && (!entity.player || !(b.vx != 0 || b.vy != 0)))) {
            let pierce = b.bullet.spell && (b.bullet.spell.piercing || b.bullet.spell.pierceEnemies);
            let noDirect = b.bullet.spell && (b.bullet.spell.noDirectDamage);
            if (noDirect && b.bullet.damage.damage != 0)
                continue;
            if (pierce && b.bullet.damage.damage != 0)
                continue;
            if (!KDBulletCanHitEntity(b, entity) && !force)
                continue;
            if (entity.player)
                KDBulletHitPlayer(b, KinkyDungeonPlayerEntity);
            else
                KDBulletHitEnemy(b, entity, 0, b.bullet.NoMsg);
            if (!pierce) {
                KinkyDungeonBullets.splice(E, 1);
                KinkyDungeonBulletsID[b.spriteID] = null;
                KinkyDungeonUpdateSingleBulletVisual(b, true);
                KinkyDungeonSendEvent("bulletDestroy", { bullet: b, target: undefined, outOfRange: false, outOfTime: false });
                E -= 1;
            }
            KinkyDungeonBulletHit(b, 1);
        }
    }
}
function KinkyDungeonBulletHit(b, born, outOfTime, outOfRange, d, dt, end) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    if (d > 0 && (b.vx || b.vy) && end) {
        let tt = KinkyDungeonMapGet(b.x, b.y);
        if (!KinkyDungeonMovableTilesEnemy.includes(tt)) {
            b.xx -= b.vx * dt;
            b.yy -= b.vy * dt;
            b.x = Math.round(b.xx);
            b.y = Math.round(b.yy);
        }
    }
    if (b.bullet.hit && b.bullet.spell && b.bullet.hit != b.bullet.spell.secondaryhit && b.bullet.spell.landsfx) {
        if (KDToggles.Sound && (b.bullet.faction == "Player" || KinkyDungeonVisionGet(b.x, b.y) > 0)) {
            KDDamageQueue.push({ sfx: KinkyDungeonRootDirectory + "Audio/" + b.bullet.spell.landsfx + ".ogg" });
        }
    }
    KinkyDungeonSendEvent("beforeBulletHit", { bullet: b, target: undefined, outOfRange: outOfRange, outOfTime: outOfTime });
    if (b.bullet.cast && (!b.bullet.cast.chance || KDRandom() < b.bullet.cast.chance) && (!b.bullet.spell || !b.bullet.spell.noCastOnHit)) {
        let xx = b.bullet.cast.tx;
        let yy = b.bullet.cast.ty;
        if (b.bullet.cast.targetID) {
            let enemy = KinkyDungeonFindID(b.bullet.cast.targetID);
            if (enemy) {
                xx = enemy.x;
                yy = enemy.y;
            }
        }
        if (!xx)
            xx = b.x;
        if (!yy)
            yy = b.y;
        KinkyDungeonCastSpell(xx, yy, KinkyDungeonFindSpell(b.bullet.cast.spell, true), undefined, undefined, b);
    }
    if (b.bullet.hit == "") {
        let newB = { born: born, time: 1, x: b.x, y: b.y, vx: 0, vy: 0, xx: b.x, yy: b.y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Hit" + CommonTime(),
            bullet: {
                bulletColor: (_a = b.bullet.spell) === null || _a === void 0 ? void 0 : _a.hitColor, bulletLight: (_b = b.bullet.spell) === null || _b === void 0 ? void 0 : _b.hitLight,
                bulletSpin: (_c = b.bullet.spell) === null || _c === void 0 ? void 0 : _c.hitSpin,
                hitevents: b.bullet.spell.hitevents,
                faction: b.bullet.faction, lifetime: 1, passthrough: true, name: b.bullet.name + "Hit", width: b.bullet.width, height: b.bullet.height
            } };
        KinkyDungeonBullets.push(newB);
        KinkyDungeonUpdateSingleBulletVisual(newB, false, d);
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    else if (b.bullet.hit == "buff" || b.bullet.hit == "buffonly" || b.bullet.hit == "buffnoAoE") {
        if (b.bullet.hit == "buff") {
            let newB = { born: born, time: 1, x: b.x, y: b.y, vx: 0, vy: 0, xx: b.x, yy: b.y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Hit" + CommonTime(),
                bullet: {
                    bulletColor: (_d = b.bullet.spell) === null || _d === void 0 ? void 0 : _d.hitColor, bulletLight: (_e = b.bullet.spell) === null || _e === void 0 ? void 0 : _e.hitLight,
                    bulletSpin: (_f = b.bullet.spell) === null || _f === void 0 ? void 0 : _f.hitSpin,
                    faction: b.bullet.faction, lifetime: 1, passthrough: true,
                    hitevents: b.bullet.spell.hitevents, name: b.bullet.name + "Hit", width: b.bullet.width, height: b.bullet.height
                } };
            KinkyDungeonBullets.push(newB);
            KinkyDungeonUpdateSingleBulletVisual(newB, false, d);
        }
        if (b.bullet.spell) {
            let aoe = b.bullet.spell.aoe ? b.bullet.spell.aoe : 0.5;
            if (b.bullet.hit == "buffnoAoE")
                aoe = 0.5;
            if (b.bullet.spell && (b.bullet.spell.playerEffect || b.bullet.playerEffect) && AOECondition(b.x, b.y, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, aoe, KDBulletAoEMod(b))) {
                KinkyDungeonPlayerEffect(KinkyDungeonPlayerEntity, b.bullet.damage.type, b.bullet.playerEffect ? b.bullet.playerEffect : b.bullet.spell.playerEffect, b.bullet.spell, b.bullet.faction, b);
            }
            for (let enemy of KinkyDungeonEntities) {
                if (((enemy.x == b.x && enemy.y == b.y) || (b.bullet.spell && aoe && AOECondition(b.x, b.y, enemy.x, enemy.y, aoe, KDBulletAoEMod(b))))) {
                    for (let buff of b.bullet.spell.buffs) {
                        if (buff.enemies
                            && (!buff.noAlly || !b.bullet.faction || KDFactionRelation(b.bullet.faction, KDGetFaction(enemy)) < 0.5)
                            && (!buff.onlyAlly || !b.bullet.faction || KDFactionRelation(b.bullet.faction, KDGetFaction(enemy)) >= 0.5)) {
                            if (!enemy.buffs)
                                enemy.buffs = {};
                            KinkyDungeonApplyBuff(enemy.buffs, buff);
                        }
                    }
                }
            }
        }
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    else if (b.bullet.hit == "aoe") {
        let newB = { secondary: true, born: born, time: b.bullet.spell.lifetime, x: b.x, y: b.y, vx: 0, vy: 0, xx: b.x, yy: b.y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Hit" + CommonTime(),
            bullet: { faction: b.bullet.faction, spell: b.bullet.spell, bulletColor: (_g = b.bullet.spell) === null || _g === void 0 ? void 0 : _g.hitColor, bulletLight: (_h = b.bullet.spell) === null || _h === void 0 ? void 0 : _h.hitLight,
                bulletSpin: (_j = b.bullet.spell) === null || _j === void 0 ? void 0 : _j.hitSpin, damage: {
                    damage: (b.bullet.spell.aoedamage) ? b.bullet.spell.aoedamage : b.bullet.spell.power, type: b.bullet.spell.damage,
                    hitevents: b.bullet.spell.hitevents,
                    distract: b.bullet.spell.distract, distractEff: b.bullet.spell.distractEff, bindEff: b.bullet.spell.bindEff,
                    bind: b.bullet.spell.bind, bindType: b.bullet.spell.bindType, time: b.bullet.spell.time
                }, aoe: b.bullet.spell.aoe, lifetime: b.bullet.spell.lifetime, passthrough: true, name: b.bullet.name + "Hit", width: b.bullet.width, height: b.bullet.height } };
        KinkyDungeonBullets.push(newB);
        KinkyDungeonUpdateSingleBulletVisual(newB, false, d);
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    else if (b.bullet.hit == "instant") {
        if (!KinkyDungeonBulletsCheckCollision(b, true, true, d)) {
            if (!(b.bullet.spell && (b.bullet.spell.piercing || (b.bullet.spell.pierceEnemies && KinkyDungeonTransparentObjects.includes(KinkyDungeonMapGet(b.x, b.y)))))) {
                let ind = KinkyDungeonBullets.indexOf(b);
                if (ind > -1)
                    KinkyDungeonBullets.splice(ind, 1);
                KinkyDungeonBulletsID[b.spriteID] = null;
                KinkyDungeonUpdateSingleBulletVisual(b, true, d);
                KinkyDungeonSendEvent("bulletDestroy", { bullet: b, target: undefined, outOfRange: outOfRange, outOfTime: outOfTime });
            }
        }
        let newB = { born: born, time: 1, x: b.x, y: b.y, vx: 0, vy: 0, xx: b.x, yy: b.y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Hit" + CommonTime(), bullet: {
                hitevents: b.bullet.spell.hitevents,
                bulletColor: (_k = b.bullet.spell) === null || _k === void 0 ? void 0 : _k.hitColor, bulletLight: (_l = b.bullet.spell) === null || _l === void 0 ? void 0 : _l.hitLight,
                bulletSpin: (_m = b.bullet.spell) === null || _m === void 0 ? void 0 : _m.hitSpin,
                faction: b.bullet.faction, lifetime: 1, passthrough: true, name: b.bullet.name + "Hit", width: b.bullet.width, height: b.bullet.height
            } };
        KinkyDungeonBullets.push(newB);
        KinkyDungeonUpdateSingleBulletVisual(newB, false);
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    else if (b.bullet.hit == "lingering") {
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
        let rad = (b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0;
        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                if (AOECondition(b.x, b.y, b.x + X, b.y + Y, rad, KDBulletAoEMod(b))) {
                    let dd = KDistEuclidean(X, Y) / rad;
                    let LifetimeBonus = (b.bullet.spell.lifetimeHitBonus) ? Math.floor(KDRandom() * b.bullet.spell.lifetimeHitBonus) : 0;
                    let newB = { delay: dd, born: born, time: b.bullet.spell.lifetime + LifetimeBonus, x: b.x + X, y: b.y + Y, vx: 0, vy: 0, xx: b.x + X, yy: b.y + Y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Hit" + CommonTime(),
                        bullet: { faction: b.bullet.faction, spell: b.bullet.spell, block: (b.bullet.blockhit ? b.bullet.blockhit : 0),
                            bulletColor: (_o = b.bullet.spell) === null || _o === void 0 ? void 0 : _o.hitColor, bulletLight: (_p = b.bullet.spell) === null || _p === void 0 ? void 0 : _p.hitLight, hit: (_q = b.bullet.spell) === null || _q === void 0 ? void 0 : _q.secondaryhit,
                            bulletSpin: (_r = b.bullet.spell) === null || _r === void 0 ? void 0 : _r.hitSpin,
                            effectTileLinger: b.bullet.spell.effectTileLinger, effectTileDurationModLinger: b.bullet.spell.effectTileDurationModLinger,
                            hitevents: b.bullet.spell.hitevents,
                            damage: {
                                damage: b.bullet.spell.power, type: b.bullet.spell.damage, bind: b.bullet.spell.bind, bindType: b.bullet.spell.bindType, time: b.bullet.spell.time,
                                distract: b.bullet.spell.distract, distractEff: b.bullet.spell.distractEff, bindEff: b.bullet.spell.bindEff,
                            }, lifetime: b.bullet.spell.lifetime + LifetimeBonus, name: b.bullet.name + "Hit", width: 1, height: 1 } };
                    KinkyDungeonBullets.push(newB);
                    KinkyDungeonUpdateSingleBulletVisual(newB, false, dd);
                }
            }
    }
    else if (b.bullet.hit == "heal") {
        let newB = { born: born, time: b.bullet.spell.lifetime, x: b.x, y: b.y, vx: 0, vy: 0, xx: b.x, yy: b.y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Hit" + CommonTime(),
            bullet: { faction: b.bullet.faction, spell: b.bullet.spell, bulletColor: (_s = b.bullet.spell) === null || _s === void 0 ? void 0 : _s.hitColor, bulletLight: (_t = b.bullet.spell) === null || _t === void 0 ? void 0 : _t.hitLight,
                bulletSpin: (_u = b.bullet.spell) === null || _u === void 0 ? void 0 : _u.hitSpin,
                damage: {
                    damage: (b.bullet.spell.aoedamage) ? b.bullet.spell.aoedamage : b.bullet.spell.power, type: b.bullet.spell.damage,
                    hitevents: b.bullet.spell.hitevents,
                    distract: b.bullet.spell.distract, distractEff: b.bullet.spell.distractEff, bindEff: b.bullet.spell.bindEff,
                    bind: b.bullet.spell.bind, bindType: b.bullet.spell.bindType, time: b.bullet.spell.time
                }, aoe: b.bullet.spell.aoe, lifetime: b.bullet.spell.lifetime, passthrough: true, name: b.bullet.name + "Hit", width: b.bullet.width, height: b.bullet.height } };
        KinkyDungeonBullets.push(newB);
        KinkyDungeonUpdateSingleBulletVisual(newB, false);
        if (b.bullet.spell && (b.bullet.spell.playerEffect || b.bullet.playerEffect) && AOECondition(b.x, b.y, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, b.spell.aoe, KDBulletAoEMod(b))) {
            KinkyDungeonPlayerEffect(KinkyDungeonPlayerEntity, b.bullet.damage.type, b.bullet.playerEffect ? b.bullet.playerEffect : b.bullet.spell.playerEffect, b.bullet.spell, b.bullet.faction, b);
        }
        for (let enemy of KinkyDungeonEntities) {
            if ((b.reflected
                || (!b.bullet.spell || !b.bullet.faction
                    || (!KDFactionHostile(b.bullet.faction, enemy))))
                && ((enemy.x == b.x && enemy.y == b.y) || (b.bullet.spell && b.bullet.spell.aoe &&
                    AOECondition(b.x, b.y, enemy.x, enemy.y, b.bullet.spell.aoe, KDBulletAoEMod(b))))) {
                let origHP = enemy.hp;
                enemy.hp = Math.min(enemy.hp + b.bullet.spell.power, enemy.Enemy.maxhp);
                if (b.bullet.faction == "Player" || KinkyDungeonVisionGet(enemy.x, enemy.y) > 0)
                    KinkyDungeonSendFloater(enemy, `+${Math.round((enemy.hp - origHP) * 10)}`, "#ffaa00", 3);
                if (b.bullet.faction == "Player")
                    KDHealRepChange(enemy, enemy.hp - origHP);
            }
        }
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    else if (b.bullet.hit == "cast" && b.bullet.spell && b.bullet.spell.spellcasthit) {
        let cast = b.bullet.spell.spellcasthit;
        let rad = (b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0;
        if (cast.countPerCast) {
            for (let cc = 0; cc < cast.countPerCast; cc++) {
                let spell = KinkyDungeonFindSpell(cast.spell, true);
                let xx = b.x + Math.round(rad * (1 - 2 * KDRandom()));
                let yy = b.y + Math.round(rad * (1 - 2 * KDRandom()));
                KinkyDungeonCastSpell(xx, yy, spell, undefined, undefined, b);
            }
        }
        else {
            for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                    if (AOECondition(b.x, b.y, b.x + X, b.y + Y, rad, KDBulletAoEMod(b)) && (!cast.chance || KDRandom() < cast.chance)) {
                        let spell = KinkyDungeonFindSpell(cast.spell, true);
                        let xx = b.x + X;
                        let yy = b.y + Y;
                        KinkyDungeonCastSpell(xx, yy, spell, undefined, undefined, b);
                    }
                }
        }
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    else if (b.bullet.hit == "teleport") {
        if (KinkyDungeonMovableTilesSmartEnemy.includes(KinkyDungeonMapGet(b.x, b.y))) {
            let newB = { born: born, time: b.bullet.spell.lifetime, x: b.x, y: b.y, vx: 0, vy: 0, xx: b.x, yy: b.y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Hit" + CommonTime(),
                bullet: { faction: b.bullet.faction, spell: b.bullet.spell,
                    bulletColor: (_v = b.bullet.spell) === null || _v === void 0 ? void 0 : _v.hitColor, bulletLight: (_w = b.bullet.spell) === null || _w === void 0 ? void 0 : _w.hitLight,
                    bulletSpin: (_x = b.bullet.spell) === null || _x === void 0 ? void 0 : _x.hitSpin,
                    damage: {
                        damage: (b.bullet.spell.aoedamage) ? b.bullet.spell.aoedamage : b.bullet.spell.power, type: b.bullet.spell.damage, boundBonus: b.bullet.spell.boundBonus,
                        hitevents: b.bullet.spell.hitevents,
                        distract: b.bullet.spell.distract, distractEff: b.bullet.spell.distractEff, bindEff: b.bullet.spell.bindEff,
                        bind: b.bullet.spell.bind, bindType: b.bullet.spell.bindType, time: b.bullet.spell.time
                    }, aoe: b.bullet.spell.aoe, lifetime: b.bullet.spell.lifetime, passthrough: true, name: b.bullet.name + "Hit", width: b.bullet.width, height: b.bullet.height } };
            KinkyDungeonBullets.push(newB);
            KinkyDungeonUpdateSingleBulletVisual(newB, false);
            KinkyDungeonMoveTo(b.x, b.y, true);
        }
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    else if (b.bullet.hit == "summon") {
        if (b.bullet.effectTile) {
            KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTile, b.bullet.effectTileDurationMod, (b.bullet.spell.effectTileAoE ? b.bullet.spell.effectTileAoE : ((b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0.5)), undefined, b.bullet.spell.effectTileDensity, KDBulletAoEMod(b));
        }
    }
    if (b.bullet.summon && b.bullet.summon) {
        let created = 0;
        let type = "";
        for (let sum of b.bullet.summon) {
            if (!sum.chance || KDRandom() < sum.chance) {
                let summonType = sum.name;
                if (!type)
                    type = summonType;
                let count = sum.count ? sum.count : 1;
                let rad = (b.bullet.spell.aoe) ? b.bullet.spell.aoe : 0;
                if (count > 0) {
                    let faction = (b.bullet.spell && b.bullet.spell.defaultFaction) ? undefined : b.bullet.faction;
                    if (!faction && b.bullet.spell && b.bullet.spell.enemySpell)
                        faction = "Enemy";
                    else if (!faction && b.bullet.spell && b.bullet.spell.allySpell)
                        faction = "Player";
                    if (b.bullet.faction)
                        faction = b.bullet.faction;
                    if (sum.faction)
                        faction = sum.faction;
                    let e = KinkyDungeonSummonEnemy(b.x, b.y, summonType, count, rad, sum.strict, sum.time ? sum.time : undefined, sum.hidden, sum.goToTarget, faction, faction && KDFactionRelation("Player", faction) <= -0.5, sum.minRange, undefined, undefined, sum.hideTimer, undefined, KDBulletAoEMod(b), sum.bound ? b.bullet.source : undefined, sum.weakBinding);
                    created += e;
                }
            }
        }
        if (!b.bullet.spell || !b.bullet.spell.noSumMsg) {
            if (created == 1)
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonSummonSingle" + type), "white", 2, undefined, undefined, b);
            else if (created > 1)
                KinkyDungeonSendTextMessage(8, TextGet("KinkyDungeonSummonMulti" + type).replace("SummonCount", "" + created), "white", 3, undefined, undefined, b);
        }
    }
}
function KinkyDungeonSummonEnemy(x, y, summonType, count, rad, strict, lifetime, hidden, goToTarget, faction, hostile, minrad, startAware, noBullet, hideTimer, pathfind, mod, boundTo, weakBinding) {
    let slots = [];
    for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
        for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
            if (AOECondition(x, y, x + X, y + Y, rad, mod) && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                if ((x + X > 0 && y + Y > 0 && x + X < KinkyDungeonGridWidth && y + Y < KinkyDungeonGridHeight))
                    slots.push({ x: X, y: Y });
            }
        }
    if (slots.length == 0)
        return 0;
    let created = 0;
    let maxcounter = 0;
    let Enemy = KinkyDungeonGetEnemyByName(summonType);
    for (let C = 0; C < count && (KinkyDungeonEntities.length < 300 || faction == "Player" || faction == "Ambush" || faction == "Prisoner") && maxcounter < count * 30; C++) {
        let slot = slots[Math.floor(KDRandom() * slots.length)];
        if (Enemy && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(x + slot.x, y + slot.y))
            && (KinkyDungeonNoEnemy(x + slot.x, y + slot.y, true) || (KinkyDungeonNoEnemy(x + slot.x, y + slot.y, false) && Enemy.noblockplayer && KDistChebyshev(x + slot.x - KinkyDungeonPlayerEntity.x, y + slot.y - KinkyDungeonPlayerEntity.y) < 1.5))
            && (!strict || KinkyDungeonCheckPath(x, y, x + slot.x, y + slot.y, false))
            && (!hidden || (KinkyDungeonVisionGet(x + slot.x, y + slot.y) < 1))) {
            let path = (hidden || pathfind) ? KinkyDungeonFindPath(x + slot.x, y + slot.y, goToTarget ? KinkyDungeonTargetX : x, goToTarget ? KinkyDungeonTargetY : y, false, false, false, Enemy.tags.opendoors ? KinkyDungeonMovableTilesSmartEnemy : KinkyDungeonMovableTilesEnemy) : null;
            if ((!hidden && !pathfind) || path) {
                let e = { summoned: true, boundTo: boundTo, weakBinding: weakBinding, faction: faction, hostile: hostile ? 100 : undefined, hideTimer: hideTimer, rage: Enemy.summonRage ? 9999 : undefined, Enemy: Enemy, id: KinkyDungeonGetEnemyID(), gx: goToTarget ? KinkyDungeonTargetX : undefined, gy: goToTarget ? KinkyDungeonTargetY : undefined,
                    x: x + slot.x, y: y + slot.y, hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0, lifetime: lifetime, maxlifetime: lifetime, path: path };
                KDProcessCustomPatron(Enemy, e);
                KDAddEntity(e);
                if (!noBullet) {
                    let spell = KinkyDungeonFindSpell("Summon", true);
                    if (spell) {
                        KinkyDungeonCastSpell(e.x, e.y, spell, undefined, undefined, undefined);
                    }
                }
                if (startAware) {
                    e.vp = 2;
                    e.aware = true;
                }
                created += 1;
            }
        }
        else
            C -= 1;
        maxcounter += 1;
    }
    return created;
}
function KinkyDungeonBulletDoT(b) {
    KinkyDungeonBulletHit(b, 1.1);
}
function KinkyDungeonBulletTrail(b) {
    var _a, _b, _c;
    let avoidPoint = b.bullet.spell.noTrailOnPlayer ? { x: KinkyDungeonPlayerEntity.x, y: KinkyDungeonPlayerEntity.y } : null;
    let trail = false;
    if (b.bullet.spell.trail) {
        if (b.bullet.spell.trail == "lingering" && !b.bullet.trail) {
            let aoe = b.bullet.spell.trailspawnaoe ? b.bullet.spell.trailspawnaoe : 0.0;
            let rad = Math.ceil(aoe / 2);
            for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                    if (AOECondition(b.x, b.y, b.x + X, b.y + Y, rad, KDBulletTrailAoEMod(b)) && KDRandom() < b.bullet.spell.trailChance && (!avoidPoint || avoidPoint.x != X + b.x || avoidPoint.y != Y + b.y)) {
                        trail = true;
                        let newB = { born: 0, time: b.bullet.spell.trailLifetime + (b.bullet.spell.trailLifetimeBonus ? Math.floor(KDRandom() * b.bullet.spell.trailLifetimeBonus) : 0), x: b.x + X, y: b.y + Y, vx: 0, vy: 0, xx: b.x + X, yy: b.y + Y, spriteID: KinkyDungeonGetEnemyID() + b.bullet.name + "Trail" + CommonTime(),
                            bullet: { faction: b.bullet.faction, trail: true, hit: b.bullet.spell.trailHit, spell: b.bullet.spell, playerEffect: b.bullet.spell.trailPlayerEffect,
                                bulletColor: (_a = b.bullet.spell) === null || _a === void 0 ? void 0 : _a.trailColor, bulletLight: (_b = b.bullet.spell) === null || _b === void 0 ? void 0 : _b.trailLight,
                                bulletSpin: (_c = b.bullet.spell) === null || _c === void 0 ? void 0 : _c.hitSpin, damage: {
                                    damage: b.bullet.spell.trailPower, type: b.bullet.spell.trailDamage, boundBonus: b.bullet.spell.boundBonus,
                                    hitevents: b.bullet.spell.hitevents,
                                    distract: b.bullet.spell.distract, distractEff: b.bullet.spell.distractEff, bindEff: b.bullet.spell.bindEff,
                                    bind: b.bullet.spell.trailBind, bindType: b.bullet.spell.bindType, time: b.bullet.spell.trailTime
                                }, lifetime: b.bullet.spell.trailLifetime, name: b.bullet.name + "Trail", width: 1, height: 1 } };
                        KinkyDungeonBullets.push(newB);
                        KinkyDungeonUpdateSingleBulletVisual(newB, false);
                    }
                }
        }
        else if (b.bullet.spell.trail == "cast" && !b.bullet.trail && b.bullet.spell && b.bullet.spell.trailcast) {
            let aoe = b.bullet.spell.trailspawnaoe ? b.bullet.spell.trailspawnaoe : 0.0;
            let rad = Math.ceil(aoe / 2);
            for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                    if (AOECondition(b.x, b.y, b.x + X, b.y + Y, rad, KDBulletTrailAoEMod(b)) && KDRandom() < b.bullet.spell.trailChance && (!avoidPoint || avoidPoint.x != X + b.x || avoidPoint.y != Y + b.y)) {
                        trail = true;
                        let cast = b.bullet.spell.trailcast;
                        let spell = KinkyDungeonFindSpell(cast.spell, true);
                        if (spell) {
                            KinkyDungeonCastSpell(b.x + X, b.y + Y, spell, undefined, undefined, undefined);
                        }
                    }
                }
        }
    }
    if (b.bullet.effectTileTrail) {
        KDCreateAoEEffectTiles(b.x, b.y, b.bullet.effectTileTrail, b.bullet.effectTileDurationModTrail, (b.bullet.spell.effectTileTrailAoE) ? b.bullet.spell.effectTileTrailAoE : 0.5, avoidPoint, b.bullet.spell.effectTileDensityTrail, KDBulletTrailAoEMod(b));
    }
    return trail;
}
function KinkyDungeonBulletsCheckCollision(bullet, AoE, force, d, inWarningOnly, delta) {
    let mapItem = KinkyDungeonMapGet(bullet.x, bullet.y);
    if (!bullet.bullet.passthrough && !bullet.bullet.piercing && !KinkyDungeonOpenObjects.includes(mapItem))
        return false;
    KDBulletEffectTiles(bullet);
    if (bullet.bullet.noEnemyCollision && !(bullet.bullet && bullet.bullet.alwaysCollideTags))
        return true;
    if (bullet.delay && !d)
        d = bullet.delay;
    let hitEnemy = false;
    if (bullet.bullet.damage && (bullet.time > 0 || force)) {
        if ((AoE || (bullet.vx != 0 || bullet.vy != 0))) {
            if (bullet.bullet.aoe ? KDBulletAoECanHitEntity(bullet, KinkyDungeonPlayerEntity) : KDBulletCanHitEntity(bullet, KinkyDungeonPlayerEntity, inWarningOnly)) {
                if (!bullet.bullet.spell || bullet.born < 1 || (bullet.vx == 0 && bullet.vy == 0) || bullet.bullet.spell.enemySpell) {
                    if (!(!bullet.secondary && bullet.bullet.spell && bullet.bullet.spell.noDirectDamage))
                        KDBulletHitPlayer(bullet, KinkyDungeonPlayerEntity);
                    hitEnemy = true;
                }
            }
            let nomsg = bullet.bullet && bullet.bullet.spell && bullet.bullet.spell.enemyspell && !bullet.reflected;
            for (let enemy of KinkyDungeonEntities) {
                let overrideCollide = !bullet.bullet.aoe ? false : (bullet.bullet.spell && bullet.bullet.alwaysCollideTags && bullet.bullet.alwaysCollideTags.some((tag) => { return enemy.Enemy.tags[tag]; }));
                if (bullet.bullet.aoe ? KDBulletAoECanHitEntity(bullet, enemy) : KDBulletCanHitEntity(bullet, enemy, inWarningOnly, overrideCollide)) {
                    if (!(!bullet.secondary && bullet.bullet.spell && bullet.bullet.spell.noDirectDamage)) {
                        KDBulletHitEnemy(bullet, enemy, d, nomsg);
                        nomsg = true;
                    }
                    hitEnemy = true;
                }
            }
            KDUpdateBulletEffects(bullet, d);
        }
    }
    if (!bullet.bullet.aoe && hitEnemy)
        return false;
    if (!(bullet.bullet.block > 0) && bullet.vx != 0 || bullet.vy != 0) {
        for (let b2 of KinkyDungeonBullets) {
            if (b2 != bullet && b2.bullet.block > 0 && b2.x == bullet.x && b2.y == bullet.y) {
                b2.bullet.block -= bullet.bullet.damage.damage;
                if (b2.bullet.block <= 0)
                    b2.bullet.block = -1;
                return false;
            }
        }
    }
    else if (bullet.bullet.block == -1)
        return false;
    if (bullet.bullet.lifetime == -1)
        return false;
    if (!bullet.bullet.passthrough && !KinkyDungeonOpenObjects.includes(mapItem))
        return false;
    return true;
}
function KDBulletAoECanHitEntity(bullet, enemy) {
    if (enemy.player) {
        return (bullet.bullet.spell && (bullet.bullet.spell.playerEffect || bullet.bullet.playerEffect)
            && AOECondition(bullet.x, bullet.y, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, bullet.bullet.aoe || 0.5, KDBulletAoEMod(bullet)))
            && (!bullet.bullet.spell || !bullet.bullet.spell.noUniqueHits || !KDUniqueBulletHits.get(KDBulletID(bullet, KinkyDungeonPlayerEntity)));
    }
    else {
        return (bullet.reflected
            || (!bullet.bullet.spell || !bullet.bullet.faction
                || (!KDFactionFavorable(bullet.bullet.faction, enemy) && (!bullet.bullet.damage || bullet.bullet.damage.type != "heal"))
                || (!KDFactionHostile(bullet.bullet.faction, enemy) && (bullet.bullet.damage && bullet.bullet.damage.type == "heal"))))
            && AOECondition(bullet.x, bullet.y, enemy.x, enemy.y, bullet.bullet.aoe || 0.5, KDBulletAoEMod(bullet))
            && (!bullet.bullet.spell || !bullet.bullet.spell.noUniqueHits || !KDUniqueBulletHits.get(KDBulletID(bullet, enemy)));
    }
}
function KDBulletCanHitEntity(bullet, enemy, inWarningOnly, overrideCollide) {
    if (enemy.player) {
        return bullet.bullet.spell && (bullet.bullet.spell.playerEffect || bullet.bullet.playerEffect)
            && (!bullet.bullet.noEnemyCollision || (bullet.bullet.spell && bullet.bullet.alwaysCollideTags && bullet.bullet.alwaysCollideTags.includes("PlayerChar")))
            && KinkyDungeonPlayerEntity.x == bullet.x && KinkyDungeonPlayerEntity.y == bullet.y
            && (!inWarningOnly || (bullet.warnings && bullet.warnings.includes(KinkyDungeonPlayerEntity.lastx + "," + KinkyDungeonPlayerEntity.lasty)))
            && (!bullet.bullet.spell || !bullet.bullet.spell.noUniqueHits || !KDUniqueBulletHits.get(KDBulletID(bullet, KinkyDungeonPlayerEntity)));
    }
    else {
        return (enemy.x == bullet.x && enemy.y == bullet.y) && (bullet.reflected || overrideCollide
            || (!bullet.bullet.spell || !bullet.bullet.faction
                || (!KDFactionFavorable(bullet.bullet.faction, enemy) && (!bullet.bullet.damage || bullet.bullet.damage.type != "heal"))
                || (!KDFactionHostile(bullet.bullet.faction, enemy) && (bullet.bullet.damage && bullet.bullet.damage.type == "heal"))))
            && (!bullet.bullet.noEnemyCollision || overrideCollide)
            && (!inWarningOnly || (bullet.warnings && bullet.warnings.includes(enemy.lastx + "," + enemy.lasty)))
            && (!bullet.bullet.spell || !bullet.bullet.spell.noUniqueHits || !KDUniqueBulletHits.get(KDBulletID(bullet, enemy)));
    }
}
function KDBulletEffectTiles(bullet) {
    if (bullet.bullet.spell && bullet.bullet.spell.type == "dot") {
        if (bullet.bullet.spell.effectTileDoT) {
            KDCreateAoEEffectTiles(bullet.x, bullet.y, bullet.bullet.spell.effectTileDoT, bullet.bullet.spell.effectTileDurationModDoT, (bullet.bullet.spell.effectTileAoE ? bullet.bullet.spell.effectTileAoE : ((bullet.bullet.spell.aoe) ? bullet.bullet.spell.aoe : 0.5)), undefined, bullet.bullet.spell.effectTileDensityDoT, KDBulletAoEMod(bullet));
        }
    }
    if (bullet.bullet.effectTileLinger) {
        if (bullet.bullet.effectTileLinger) {
            KDCreateEffectTile(bullet.x, bullet.y, bullet.bullet.effectTileLinger, bullet.bullet.effectTileDurationModLinger);
        }
    }
}
function KDBulletHitPlayer(bullet, player) {
    let pf = bullet.bullet.playerEffect ? bullet.bullet.playerEffect : bullet.bullet.spell.playerEffect;
    if (pf) {
        KinkyDungeonPlayerEffect(KinkyDungeonPlayerEntity, bullet.bullet.damage.type, pf, bullet.bullet.spell, bullet.bullet.faction, bullet);
        KDUniqueBulletHits.set(KDBulletID(bullet, player), true);
    }
}
function KDBulletHitEnemy(bullet, enemy, d, nomsg) {
    KinkyDungeonSendEvent("bulletHitEnemy", { bullet: bullet, enemy: enemy });
    KDUniqueBulletHits.set(KDBulletID(bullet, enemy), true);
    if (bullet.bullet.damage.type == "heal") {
        let origHP = enemy.hp;
        enemy.hp = Math.min(enemy.hp + bullet.bullet.spell.power, enemy.Enemy.maxhp);
        if (bullet.bullet.faction == "Player" || KinkyDungeonVisionGet(enemy.x, enemy.y) > 0)
            KinkyDungeonSendFloater(enemy, `+${Math.round((enemy.hp - origHP) * 10)}`, "#ffaa00", 3);
        if (bullet.bullet.faction == "Player")
            KDHealRepChange(enemy, enemy.hp - origHP);
    }
    else if (bullet.bullet.faction == "Player" || KinkyDungeonVisionGet(enemy.x, enemy.y) > 0)
        KinkyDungeonDamageEnemy(enemy, bullet.bullet.damage, true, nomsg, bullet.bullet.spell, bullet, undefined, d);
}
function KDBulletID(bullet, enemy) {
    if (enemy.player)
        return (bullet.name) + (bullet.bullet.spell) + "_player";
    return (bullet.name) + (bullet.bullet.spell) + "_" + (enemy.id);
}
function KinkyDungeonLaunchBullet(x, y, targetx, targety, speed, bullet, miscast) {
    let direction = (!targetx && !targety) ? 0 : Math.atan2(targety, targetx);
    let vx = (targetx != 0 && targetx != undefined) ? Math.cos(direction) * speed : 0;
    let vy = (targety != 0 && targety != undefined) ? Math.sin(direction) * speed : 0;
    let lifetime = bullet.lifetime;
    if (miscast) {
        vx = 0;
        vy = 0;
    }
    let b = { born: 1, time: lifetime, x: x, y: y, vx: vx, vy: vy, xx: x, yy: y, spriteID: KinkyDungeonGetEnemyID() + bullet.name + CommonTime(), bullet: bullet, trail: bullet.spell.trail, trailEffectTile: bullet.spell.effectTileTrail };
    KinkyDungeonBullets.push(b);
    KinkyDungeonUpdateSingleBulletVisual(b, false);
    return b;
}
function KinkyDungeonDrawFight(canvasOffsetX, canvasOffsetY, CamX, CamY) {
    for (let damage of KDDamageQueue) {
        if (!damage.Delay || KDTimescale * (performance.now() - KDLastTick) > damage.Delay) {
            if (damage.sfx && KDToggles.Sound)
                KinkyDungeonPlaySound(damage.sfx);
            if (damage.floater) {
                KinkyDungeonSendFloater(damage.Entity, damage.floater, damage.Color, damage.Time);
            }
            KDDamageQueue.splice(KDDamageQueue.indexOf(damage), 1);
        }
    }
    for (let t of KDBulletWarnings) {
        let tx = t.x;
        let ty = t.y;
        if (tx >= CamX && ty >= CamY && tx < CamX + KinkyDungeonGridWidthDisplay && ty < CamY + KinkyDungeonGridHeightDisplay && KinkyDungeonVisionGet(tx, ty) > 0) {
            KDDraw(kdgameboard, kdpixisprites, tx + "," + ty + "_w" + t.color, KinkyDungeonRootDirectory + "WarningColorSpell.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                tint: string2hex(t.color || "#ff5555"),
                zIndex: 1.31,
                alpha: 0.75,
            });
            KDDraw(kdgameboard, kdpixisprites, tx + "," + ty + "_w_b" + t.color, KinkyDungeonRootDirectory + "WarningBacking.png", (tx - CamX) * KinkyDungeonGridSizeDisplay, (ty - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                tint: string2hex(t.color || "#ff5555"),
                zIndex: -0.2,
                alpha: 0.6
            });
        }
    }
    for (let bullet of KinkyDungeonBulletsVisual.values()) {
        if (!bullet.delay || KDTimescale * (performance.now() - KDLastTick) > bullet.delay) {
            let sprite = bullet.name;
            let dd = KinkyDungeonUpdateVisualPosition(bullet, KinkyDungeonDrawDelta);
            let tx = bullet.visual_x;
            let ty = bullet.visual_y;
            let scale = bullet.scale != undefined ? bullet.scale : 1.0;
            let alpha = bullet.alpha != undefined ? bullet.alpha : 1.0;
            let aoe = bullet.aoe ? Number(bullet.aoe) : 3;
            if ((bullet.end) && dd == 0 && (!bullet.scale || bullet.scale <= 0.0)) {
                KinkyDungeonBulletsVisual.delete(bullet.spriteID);
            }
            else if (bullet.xx >= CamX && bullet.yy >= CamY && bullet.xx < CamX + KinkyDungeonGridWidthDisplay && bullet.yy < CamY + KinkyDungeonGridHeightDisplay
                && (KinkyDungeonVisionGet(Math.round(tx), Math.round(ty)) > 0 || KDistChebyshev(tx - KinkyDungeonPlayerEntity.x, ty - KinkyDungeonPlayerEntity.y) < aoe) && alpha > 0) {
                if (!bullet.end && bullet.temporary && alpha >= 1.0 && scale >= 1.0) {
                    bullet.end = true;
                }
                KDDraw(kdgameboard, kdpixisprites, bullet.spriteID, KinkyDungeonRootDirectory + "Bullets/" + sprite + ".png", (tx - CamX + 0.5) * KinkyDungeonGridSizeDisplay, (ty - CamY + 0.5) * KinkyDungeonGridSizeDisplay, bullet.size * scale * KinkyDungeonGridSizeDisplay, bullet.size * scale * KinkyDungeonGridSizeDisplay, (!bullet.vy && !bullet.vx) ? bullet.spinAngle : bullet.spinAngle + Math.atan2(bullet.vy, bullet.vx), {
                    alpha: alpha,
                    zIndex: -0.01,
                }, true);
            }
            bullet.delay = undefined;
        }
    }
}
function KinkyDungeonSendWeaponEvent(Event, data) {
    if (!KDMapHasEvent(KDEventMapWeapon, Event))
        return;
    if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.events) {
        for (let e of KinkyDungeonPlayerDamage.events) {
            if (e.trigger == Event && (!e.requireEnergy || ((!e.energyCost && KDGameData.AncientEnergyLevel > 0) || (e.energyCost && KDGameData.AncientEnergyLevel > e.energyCost)))) {
                KinkyDungeonHandleWeaponEvent(Event, e, KinkyDungeonPlayerDamage, data);
            }
        }
    }
}
function KinkyDungeonSendBulletEvent(Event, b, data) {
    if (!KDMapHasEvent(KDEventMapBullet, Event))
        return;
    if (b && b.bullet && b.bullet.events)
        for (let e of b.bullet.events) {
            if (e.trigger == Event) {
                KinkyDungeonHandleBulletEvent(Event, e, b, data);
            }
        }
    if (b && b.bullet && b.bullet.hitevents)
        for (let e of b.bullet.hitevents) {
            if (e.trigger == Event) {
                KinkyDungeonHandleBulletEvent(Event, e, b, data);
            }
        }
}
function KDHealRepChange(enemy, amount) {
    if (enemy.hostile && amount > 0) {
        if (enemy.hp >= enemy.Enemy.maxhp - 0.5) {
            enemy.hostile = 0;
        }
    }
    else if ((!enemy.allied || enemy.allied <= 400) && amount > 0) {
        if (enemy.hp <= 0.25 * enemy.Enemy.maxhp && enemy.allied <= 400) {
            enemy.allied = 400;
        }
        else if (enemy.allied < 15)
            enemy.allied = 15;
    }
    let amountRep = amount * 0.001;
    if (KDHostile(enemy))
        amountRep *= 0.5;
    else if (KDFactionRelation("Player", KDGetFactionOriginal(enemy)) > 0.45)
        amountRep *= 0;
    else if (KDFactionRelation("Player", KDGetFactionOriginal(enemy)) > 0.35)
        amountRep *= 0.25;
    else if (KDFactionRelation("Player", KDGetFactionOriginal(enemy)) > 0.25)
        amountRep *= 0.5;
    if (amountRep > 0 && !KinkyDungeonHiddenFactions.includes(KDGetFactionOriginal(enemy))) {
        if (amountRep > 0.01)
            amountRep = 0.01;
        KinkyDungeonChangeFactionRep(KDGetFactionOriginal(enemy), amountRep);
    }
}
function KDApplyGenBuffs(entity, buff, time) {
    let buffs = KDBuffReference[buff];
    if (buffs && entity) {
        for (let b of buffs) {
            let newBuff = Object.assign({}, b);
            if (newBuff && time)
                newBuff.duration = time;
            KinkyDungeonApplyBuffToEntity(entity, newBuff);
        }
    }
}
function KDSilenceEnemy(enemy, time) {
    if (!enemy.silence)
        enemy.silence = 0;
    enemy.silence = Math.max(time, enemy.silence);
}
function KDBlindEnemy(enemy, time) {
    if (!enemy.blind)
        enemy.blind = 0;
    enemy.blind = Math.max(time, enemy.blind);
}
function KDDisarmEnemy(enemy, time) {
    if (!enemy.disarm)
        enemy.disarm = 0;
    enemy.disarm = Math.max(time, enemy.disarm);
}
let KDPrereqs = {
    "NoChastity": (enemy, e, data) => { return KDEntityBuffedStat(enemy, "Chastity") < 0.01; },
    "blinded": (enemy, e, data) => { return enemy.blind > 0; },
    "silenced": (enemy, e, data) => { return enemy.silence > 0; },
    "disarmed": (enemy, e, data) => { return enemy.disarm > 0; },
    "bound": (enemy, e, data) => { return enemy.boundLevel > 0; },
    "Waiting": (enemy, e, data) => { return (enemy && !enemy.player) ? enemy.idle : KinkyDungeonLastTurnAction == "Wait"; },
    "damageType": (enemy, e, data) => {
        var _a, _b, _c;
        switch (e.kind) {
            case "melee": return KinkyDungeonMeleeDamageTypes.includes((_a = data.Damage) === null || _a === void 0 ? void 0 : _a.type);
            case "magic": return !KinkyDungeonMeleeDamageTypes.includes((_b = data.Damage) === null || _b === void 0 ? void 0 : _b.type);
        }
        return ((_c = data.Damage) === null || _c === void 0 ? void 0 : _c.type) == 'e.kind';
    },
};
function KDCheckPrereq(enemy, prereq, e, data) {
    if (!prereq)
        return true;
    if (KDPrereqs[prereq])
        return KDPrereqs[prereq](enemy, e, data);
    return false;
}
function KDBulletAoEMod(b) {
    var _a, _b, _c;
    return ((_a = b === null || b === void 0 ? void 0 : b.bullet) === null || _a === void 0 ? void 0 : _a.aoetype) || ((_c = (_b = b === null || b === void 0 ? void 0 : b.bullet) === null || _b === void 0 ? void 0 : _b.spell) === null || _c === void 0 ? void 0 : _c.aoetype);
}
function KDBulletTrailAoEMod(b) {
    var _a, _b, _c;
    return ((_a = b === null || b === void 0 ? void 0 : b.bullet) === null || _a === void 0 ? void 0 : _a.aoetypetrail) || ((_c = (_b = b === null || b === void 0 ? void 0 : b.bullet) === null || _b === void 0 ? void 0 : _b.spell) === null || _c === void 0 ? void 0 : _c.aoetypetrail);
}
function AOECondition(bx, by, xx, yy, rad, modifier = "") {
    switch (modifier) {
        case "vert":
            if (bx != xx)
                return false;
            break;
        case "horiz":
            if (by != yy)
                return false;
            break;
        case "cross":
            if (by != yy && bx != xx)
                return false;
            break;
        case "box":
            return KDistChebyshev(bx - xx, by - yy) <= rad;
    }
    return KDistEuclidean(bx - xx, by - yy) <= rad;
}
function KDCreateParticle(xx, yy, name) {
    let newB = { born: 0, time: 2, x: Math.round(xx), y: Math.round(yy), vx: 0, vy: 0, xx: xx, yy: yy, spriteID: KinkyDungeonGetEnemyID() + name + CommonTime(),
        bullet: { faction: "Rage", spell: undefined, damage: undefined, lifetime: 2, passthrough: true, name: name, width: 1, height: 1 } };
    KinkyDungeonBullets.push(newB);
    KinkyDungeonUpdateSingleBulletVisual(newB, false);
}
function KDDealEnvironmentalDamage(x, y, aoe, Damage, Attacker) {
    for (let enemy of KDNearbyEnemies(x, y, aoe)) {
        KinkyDungeonDamageEnemy(enemy, Damage, true, true, undefined, undefined, Attacker, 0.1);
    }
    if (KinkyDungeonPlayerEntity.x == x && KinkyDungeonPlayerEntity.y == y) {
        KinkyDungeonPlayerEffect(KinkyDungeonPlayerEntity, Damage.type, { name: "EnvDamage", power: Damage.damage, damage: Damage.type }, undefined, KDGetFaction(Attacker), undefined);
    }
}
let KinkyDungeonStatStaminaCostAttack = -1.0;
let KinkyDungeonWeapons = {
    "Unarmed": { name: "Unarmed", dmg: 2, chance: 0.9, type: "unarmed", unarmed: true, rarity: 0, shop: false, noequip: true, sfx: "Unarmed" },
    "Knife": { name: "Knife", dmg: 2.4, chance: 0.9, staminacost: 1.5, type: "slash", unarmed: false, rarity: 1, cutBonus: 0.05, shop: true, sfx: "Unarmed", light: true },
    "EnchKnife": { name: "EnchKnife", dmg: 2.6, chance: 0.9, staminacost: 1.5, type: "cold", unarmed: false, rarity: 1, cutBonus: 0.05, magic: true, shop: true, sfx: "MagicSlash", light: true },
    "Dirk": { name: "Dirk", dmg: 2.8, chance: 1.0, staminacost: 1.8, type: "slash", unarmed: false, rarity: 2, shop: true, cutBonus: 0.05, light: true, sfx: "LightSwing",
        events: [
            { type: "ChangeDamageUnaware", trigger: "beforePlayerAttack", power: 5.5, damage: "pierce" },
        ],
    },
    "Sword": { name: "Sword", dmg: 3, chance: 1.5, staminacost: 2.4, type: "slash", unarmed: false, rarity: 2, shop: false, cutBonus: 0.01, sfx: "LightSwing" },
    "Katana": { name: "Katana", dmg: 3, chance: 1.5, staminacost: 3.0, type: "slash", unarmed: false, rarity: 3, shop: true, cutBonus: 0.01, sfx: "LightSwing",
        events: [
            { type: "Patience", trigger: "tick", power: 11, buffType: "KatanaCharge", color: "#ffffff" },
            { type: "KatanaBoost", trigger: "beforePlayerAttack", power: 0.25, sfx: "Fwoosh" },
        ]
    },
    "DarkKatana": { name: "DarkKatana", dmg: 3, chance: 2.0, staminacost: 2.6, type: "cold", unarmed: false, rarity: 4, shop: false, magic: true, cutBonus: 0.01, sfx: "LightSwing",
        events: [
            { type: "DamageMultInShadow", trigger: "beforePlayerAttack", power: 2.0, sfx: "Fwoosh" },
        ]
    },
    "MagicSword": { name: "MagicSword", dmg: 3, chance: 2, staminacost: 2.3, type: "slash", unarmed: false, rarity: 4, shop: false, magic: true, cutBonus: 0.1, sfx: "LightSwing" },
    "Flamberge": { name: "Flamberge", dmg: 2.0, chance: 1.0, staminacost: 2.8, type: "slash", unarmed: false, rarity: 3, shop: true, cutBonus: 0.1, sfx: "FireSpell", magic: true,
        events: [{ type: "ElementalEffect", trigger: "playerAttack", power: 2.0, damage: "fire" }, { type: "WeaponLight", trigger: "getLights", power: 5 }],
        special: { type: "ignite" }, },
    "Foil": { name: "Foil", dmg: 0.8, chance: 1.5, staminacost: 1.5, type: "pierce", unarmed: false, rarity: 3, shop: true, sfx: "Miss",
        events: [
            { type: "ChangeDamageVulnerable", trigger: "beforePlayerAttack", power: 3.0, damage: "pierce" },
        ],
    },
    "Rapier": { name: "Rapier", dmg: 2.5, chance: 1.3, staminacost: 3.0, type: "slash", unarmed: false, rarity: 3, shop: true, sfx: "LightSwing",
        events: [
            { type: "ChangeDamageVulnerable", trigger: "beforePlayerAttack", power: 5.0, damage: "pierce" },
        ],
    },
    "Axe": { name: "Axe", dmg: 4, chance: 1.0, staminacost: 4, type: "slash", unarmed: false, rarity: 2, shop: false, sfx: "HeavySwing",
        events: [{ type: "Cleave", trigger: "playerAttack", power: 2, damage: "slash" }] },
    "MagicAxe": { name: "MagicAxe", dmg: 4, chance: 1.0, staminacost: 4, type: "cold", unarmed: false, rarity: 4, magic: true, shop: false, cutBonus: 0.2, sfx: "HeavySwing",
        events: [{ type: "Cleave", trigger: "playerAttack", power: 2, damage: "cold", time: 3 }, { type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "cold", time: 3 }] },
    "Hammer": { name: "Hammer", dmg: 5, chance: 1.0, staminacost: 6, type: "crush", unarmed: false, rarity: 2, shop: true, sfx: "HeavySwing", cutBonus: 0.01,
        events: [{ type: "Knockback", trigger: "playerAttack", dist: 1 }] },
    "MagicHammer": { name: "MagicHammer", dmg: 6, chance: 1.0, staminacost: 5.5, type: "crush", unarmed: false, rarity: 4, magic: true, shop: false, cutBonus: 0.2, sfx: "HeavySwing",
        events: [{ type: "Knockback", trigger: "playerAttack", dist: 1 }] },
    "IceBreaker": { name: "IceBreaker", dmg: 4.3, chance: 1.2, staminacost: 4, type: "crush", unarmed: false, rarity: 4, magic: true, shop: false, sfx: "HeavySwing",
        events: [{ type: "MultiplyDamageFrozen", trigger: "beforeDamageEnemy", power: 1.5 }] },
    "StormBreaker": { name: "StormBreaker", dmg: 4, chance: 1.0, staminacost: 5, type: "crush", unarmed: false, rarity: 4, magic: true, shop: false, sfx: "HeavySwing",
        events: [
            { type: "StormBreakerDamage", trigger: "playerAttack", power: 4.0, sfx: "Shock", aoe: 1.5, damage: "electric" },
            { type: "StormBreakerCharge", trigger: "beforePlayerDamage", power: 1.5, damageTrigger: "electric", color: "#3de1ff" },
        ] },
    "Flail": { name: "Flail", dmg: 2.5, chance: 1.25, staminacost: 3.0, type: "crush", unarmed: false, rarity: 2, shop: true, sfx: "LightSwing",
        events: [{ type: "Cleave", trigger: "playerAttack", power: 1, damage: "crush" }] },
    "MagicFlail": { name: "MagicFlail", dmg: 3, chance: 1.25, staminacost: 3.0, type: "crush", unarmed: false, rarity: 4, magic: true, shop: false, sfx: "LightSwing",
        events: [{ type: "Cleave", trigger: "playerAttack", power: 3, damage: "crush" }] },
    "Spear": { name: "Spear", dmg: 4.0, chance: 1.0, staminacost: 3.3, type: "pierce", unarmed: false, rarity: 2, shop: false, sfx: "LightSwing",
        events: [{ type: "Pierce", trigger: "playerAttack", power: 4.0, damage: "pierce" }] },
    "MagicSpear": { name: "MagicSpear", dmg: 4.0, chance: 1.5, staminacost: 3.3, type: "pierce", unarmed: false, rarity: 4, magic: true, shop: true, sfx: "LightSwing",
        events: [{ type: "Pierce", trigger: "playerAttack", power: 4.0, damage: "pierce", dist: 2 }] },
    "StaffFlame": { name: "StaffFlame", dmg: 4, chance: 0.85, staminacost: 5.0, type: "fire", unarmed: false, rarity: 3, shop: true, sfx: "MagicSlash", magic: true,
        events: [{ type: "Buff", trigger: "tick", power: 0.15, buffType: "fireDamageBuff" }],
        special: { type: "ignite" }, },
    "StaffChain": { name: "StaffChain", dmg: 3, bindEff: 1.25, bindType: "Metal", chance: 1.1, staminacost: 3.0, type: "chain", unarmed: false, rarity: 3, shop: true, sfx: "Chain", magic: true,
        events: [{ type: "Buff", trigger: "tick", power: 0.1, buffType: "chainDamageBuff" },
            { type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "chain", time: 2 }] },
    "StaffGlue": { name: "StaffGlue", dmg: 3, bindEff: 1.5, bindType: "Slime", chance: 1.0, staminacost: 4.0, type: "glue", unarmed: false, rarity: 3, shop: true, sfx: "MagicSlash", magic: true,
        events: [{ type: "Buff", trigger: "tick", power: 0.1, buffType: "glueDamageBuff" }] },
    "StaffElectric": { name: "StaffElectric", dmg: 3, chance: 1.1, staminacost: 4.0, type: "electric", unarmed: false, rarity: 3, shop: true, sfx: "Shock", magic: true,
        events: [{ type: "Buff", trigger: "tick", power: 0.1, buffType: "electricDamageBuff" }, { type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "electric", time: 3, chance: 0.1 }] },
    "StaffPermafrost": { name: "StaffPermafrost", dmg: 4, chance: 1.0, staminacost: 4.0, type: "ice", unarmed: false, rarity: 3, shop: true, sfx: "MagicSlash", magic: true,
        events: [{ type: "Buff", trigger: "tick", power: 0.1, buffType: "iceDamageBuff" },
            { type: "Buff", trigger: "tick", power: 0.1, buffType: "frostDamageBuff" },
            { type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "ice", time: 4, chance: 0.15 },
            { type: "MultiplyTime", trigger: "beforeDamageEnemy", power: 1.5, damage: "ice" }] },
    "StaffBind": { name: "StaffBind", dmg: 2.3, bindEff: 1, bindType: "Metal", chance: 1.0, staminacost: 3.0, type: "chain", unarmed: false, rarity: 4, shop: true, sfx: "Chain", magic: true,
        events: [
            { type: "Buff", trigger: "tick", power: 0.2, buffType: "chainDamageBuff" },
            { type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "chain", time: 4 }
        ] },
    "StaffIncineration": { name: "StaffIncineration", dmg: 6, chance: 0.7, staminacost: 5.0, type: "fire", unarmed: false, rarity: 4, shop: true, sfx: "MagicSlash", magic: true,
        events: [
            { type: "Buff", trigger: "tick", power: 0.25, buffType: "fireDamageBuff" },
            { type: "AoEDamageBurning", trigger: "tick", aoe: 10, power: 0.5, damage: "fire" }
        ],
        special: { type: "ignite" }, },
    "StaffStorm": { name: "StaffStorm", dmg: 4.5, chance: 1.0, staminacost: 4.5, type: "electric", unarmed: false, rarity: 4, shop: true, sfx: "Shock", magic: true,
        events: [
            { type: "Buff", trigger: "tick", power: 0.2, buffType: "electricDamageBuff" },
            { type: "EchoDamage", trigger: "beforeDamageEnemy", aoe: 2.99, power: 1.5, damage: "electric" }
        ] },
    "StaffDoll": { name: "StaffDoll", dmg: 3.0, chance: 1.0, staminacost: 4.0, type: "soul", unarmed: false, rarity: 4, shop: true, sfx: "MagicSlash", magic: true,
        events: [
            { type: "Buff", trigger: "tick", power: 0.15, buffType: "glueDamageBuff" },
            { type: "Dollmaker", trigger: "capture" }
        ] },
    "StaffFrostbite": { name: "StaffFrostbite", dmg: 4, chance: 1.0, staminacost: 4.0, type: "ice", unarmed: false, rarity: 4, shop: true, sfx: "MagicSlash", magic: true,
        events: [{ type: "Buff", trigger: "tick", power: 0.2, buffType: "iceDamageBuff" },
            { type: "Buff", trigger: "tick", power: 0.2, buffType: "frostDamageBuff" },
            { type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "ice", time: 4, chance: 0.25 },
            { type: "AoEDamageFrozen", trigger: "tick", aoe: 10, power: 0.5, damage: "ice" }] },
    "ArcaneCrystal": { name: "ArcaneCrystal", dmg: 3.3, chance: 0.8, staminacost: 3.0, type: "cold", noHands: true, unarmed: false, novulnerable: true, magic: true, rarity: 2, shop: true, sfx: "Laser",
        events: [{ type: "WeaponLight", trigger: "getLights", power: 3.5, color: "#6700ff" }] },
    "Slimethrower": { name: "Slimethrower", dmg: 3.5, chance: 1.0, staminacost: 6.0, type: "crush", unarmed: false, rarity: 10, shop: false, sfx: "HeavySwing",
        special: { type: "spell", spell: "Slimethrower", requiresEnergy: true, energyCost: 0.015 } },
    "EscortDrone": { name: "EscortDrone", dmg: 1.5, chance: 1.0, staminacost: 0.0, type: "electric", noHands: true, unarmed: false, rarity: 10, shop: false, sfx: "Laser",
        events: [{ type: "ElementalEffect", trigger: "playerAttack", power: 0, chance: 0.33, damage: "electric", time: 4 }, { type: "WeaponLight", trigger: "getLights", power: 4 }] },
    "BoltCutters": { name: "BoltCutters", dmg: 3.5, staminacost: 3.8, chance: 1.0, type: "crush", unarmed: false, rarity: 3, shop: false, cutBonus: 0.3, sfx: "Unarmed",
        events: [{ type: "DamageToTag", trigger: "playerAttack", requiredTag: "lock", power: 7, damage: "slash", chance: 1.0 }] },
    "Pickaxe": { name: "Pickaxe", dmg: 3, chance: 1.0, staminacost: 3.0, type: "pierce", unarmed: false, rarity: 3, shop: true, sfx: "LightSwing",
        events: [{ type: "ApplyBuff", trigger: "playerAttack", buff: { id: "ArmorDown", type: "ArmorBreak", duration: 6, power: -1.5, player: true, enemies: true, tags: ["debuff", "armor"] } }] },
    "Torch": { name: "Torch", dmg: 1.5, chance: 0.75, type: "fire", unarmed: false, rarity: 1, shop: true, sfx: "FireSpell",
        events: [{ type: "WeaponLight", trigger: "getLights", power: 6 }],
        special: { type: "ignite" }, },
    "Feather": { name: "Feather", dmg: 0.5, chance: 2.0, staminacost: 0.5, distract: 2, type: "tickle", unarmed: false, rarity: 1, shop: true, sfx: "Tickle" },
    "Crop": { name: "Crop", dmg: 2.5, chance: 1.0, staminacost: 2.0, distract: 3, type: "pain", tease: true, unarmed: false, rarity: 2, shop: true, sfx: "Whip" },
    "IceCube": { name: "IceCube", dmg: 1.5, chance: 1.0, staminacost: 1.0, distract: 1, type: "ice", tease: true, unarmed: false, rarity: 1, shop: true, sfx: "Freeze",
        events: [{ type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "ice", time: 3, chance: 0.1 }] },
    "Rope": { name: "Rope", dmg: 1.0, bind: 5, chance: 1.0, staminacost: 1.0, type: "chain", unarmed: false, rarity: 1, shop: true, sfx: "Struggle", bindType: "Rope" },
    "VibeWand": { name: "VibeWand", dmg: 2.0, chance: 1.0, staminacost: 1.5, type: "charm", unarmed: false, rarity: 1, shop: true, sfx: "Vibe",
        playSelfBonus: 4,
        playSelfMsg: "KinkyDungeonPlaySelfVibeWand",
        playSelfSound: "Vibe",
        events: [{ type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "stun", time: 2, chance: 0.2 }] },
    "Scissors": { name: "Scissors", dmg: 1.2, chance: 1.8, staminacost: 0.7, type: "slash", unarmed: false, rarity: 2, shop: true, light: true, cutBonus: 0.1, sfx: "Cut" },
    "Blaster": { name: "Blaster", dmg: 1, chance: 1.0, staminacost: 0.5, type: "tickle", unarmed: false, rarity: 5, shop: false, sfx: "Shock",
        special: { type: "spell", spell: "BlasterBlast", requiresEnergy: true, energyCost: 0.005, range: 8 } },
    "MoiraiScissors": { name: "MoiraiScissors", dmg: 1.5, chance: 1.1, staminacost: 1.5, type: "slash", unarmed: false, rarity: 10, shop: false, magic: true, cutBonus: 0.2, sfx: "Cut",
        events: [
            { type: "DoubleStrike", trigger: "afterPlayerAttack", requireEnergy: true, energyCost: 0.005 },
            { type: "ConvertBindingToDamage", trigger: "afterPlayerAttack", power: 1.0, bind: 3.0, damage: "soul" },
        ],
    },
    "Dreamcatcher": { name: "Dreamcatcher", dmg: 2.5, chance: 1.0, staminacost: 1.5, type: "cold", unarmed: false, rarity: 10, shop: false, magic: true, cutBonus: 0.15, sfx: "Fwoosh",
        events: [
            { type: "Dreamcatcher", trigger: "playerAttack", time: 20, requireEnergy: true, energyCost: 0.03 },
            { type: "ElementalDreamcatcher", trigger: "playerAttack", power: 3.0, damage: "soul" },
        ],
    },
    "MessengerOfLove": { name: "MessengerOfLove", dmg: 2, chance: 0.75, staminacost: 1, type: "crush", unarmed: false, rarity: 10, shop: false, magic: true, sfx: "Unarmed",
        special: { type: "spell", spell: "HeartArrow", requiresEnergy: true, energyCost: 0.05, range: 50 },
    },
    "Dragonslaver": { name: "Dragonslaver", dmg: 3.5, chance: 1.25, staminacost: 2.5, type: "slash", unarmed: false, rarity: 10, shop: false, cutBonus: 0.1, sfx: "LightSwing",
        events: [{ type: "CastSpell", spell: "BeltStrike", trigger: "playerAttack", requireEnergy: true, energyCost: 0.008 }],
        special: { type: "hitorspell", spell: "BeltStrike", requiresEnergy: true, energyCost: 0.0075, range: 2.99 } },
    "Arbiter": { name: "Arbiter", dmg: 4, bindEff: 1.1, chance: 2.0, bindType: "Metal", staminacost: 3, type: "chain", unarmed: false, rarity: 10, shop: false, magic: true, sfx: "HeavySwing",
        events: [
            { type: "BuffMulti", trigger: "tick", power: 0.25, buffTypes: [
                    "glueDamageBuff",
                    "chainDamageBuff",
                ] },
            { type: "DamageToSummons", trigger: "playerAttack", power: 4, damage: "cold", chance: 1.0 }
        ],
        special: { type: "spell", spell: "Disarm", requiresEnergy: true, energyCost: 0.025, range: 3.99 } },
    "BondageBuster": { name: "BondageBuster", dmg: 1, chance: 1.0, staminacost: 0.5, type: "tickle", unarmed: false, rarity: 10, shop: false, sfx: "Shock",
        events: [
            { type: "ElementalEffect", trigger: "playerAttack", power: 0, time: 4, damage: "tickle" },
            { type: "Charge", trigger: "tick", power: 11, buffType: "BondageBustCharge", color: "#ffff00" },
            { type: "BondageBustBoost", trigger: "spellCast", power: 0.25, sfx: "Shock", energyCost: 0.0025 },
        ],
        special: { type: "spell", spell: "BondageBust", requiresEnergy: true, energyCost: 0.005, range: 4 } },
    "TheEncaser": { name: "TheEncaser", dmg: 4, chance: 1.0, bindType: "Slime", staminacost: 3.0, type: "glue", unarmed: false, rarity: 10, shop: false, magic: true, sfx: "MagicSlash",
        events: [{ type: "ElementalEffect", trigger: "playerAttack", power: 0, damage: "glue", time: 2 }],
        special: { type: "spell", selfCast: true, spell: "SlimeForm", requiresEnergy: true, energyCost: 0.025 } },
    "FourSeasons": { name: "FourSeasons", dmg: 4, chance: 1.0, staminacost: 4.0, type: "cold", unarmed: false, rarity: 10, shop: false, magic: true, sfx: "Fwoosh",
        events: [
            { type: "BuffMulti", trigger: "tick", power: 0.25, buffTypes: [
                    "fireDamageBuff",
                    "iceDamageBuff",
                    "frostDamageBuff",
                    "acidDamageBuff",
                    "electricDamageBuff",
                    "crushDamageBuff",
                    "gravityDamageBuff",
                    "stunDamageBuff",
                ] }
        ],
        special: { type: "spell", selfCast: true, spell: "AvatarForm", requiresEnergy: true, energyCost: 0.05 } },
};
let KinkyDungeonInputQueue = [];
function KDProcessInput(type, data) {
    let Result = null;
    let loose = null;
    let msg = "";
    let success = 0;
    let tile = null;
    KDUpdateEnemyCache = true;
    switch (type) {
        case "move":
            KinkyDungeonToggleAutoDoor = data.AutoDoor;
            KinkyDungeonToggleAutoPass = data.AutoPass;
            KinkyDungeonToggleAutoSprint = data.sprint;
            KinkyDungeonSuppressSprint = data.SuppressSprint;
            KinkyDungeonMove(data.dir, data.delta, data.AllowInteract, data.SuppressSprint);
            break;
        case "setMoveDirection":
            KinkyDungeonMoveDirection = data.dir;
            break;
        case "tick":
            if (data.sleep == 10 && (KDGameData.PrisonerState == 'jail' || KDGameData.PrisonerState == 'parole') && KinkyDungeonPlayerInCell()) {
                KDKickEnemies(KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y));
            }
            if (data.sleep && KinkyDungeonStatWill < KinkyDungeonStatWillMax * KDGetSleepWillFraction())
                KinkyDungeonChangeWill(KinkyDungeonStatWillMax / KDMaxStatStart * KDSleepRegenWill, false);
            KinkyDungeonAdvanceTime(data.delta, data.NoUpdate, data.NoMsgTick);
            break;
        case "tryCastSpell": {
            KDDelayedActionPrune(["Action", "Cast"]);
            let sp = data.spell ? data.spell : KinkyDungeonFindSpell(data.spellname, true);
            if (!data.spell)
                data.spell = sp;
            if (sp) {
                let res = KinkyDungeonCastSpell(data.tx, data.ty, sp, data.enemy, data.player, data.bullet, undefined, data);
                if (res.result == "Cast" && sp.sfx) {
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + sp.sfx + ".ogg");
                }
                if (res.result != "Fail") {
                    KinkyDungeonAdvanceTime(res.data.delta);
                }
                KinkyDungeonInterruptSleep();
                Result = res.result;
                return Result;
            }
            return "Fail";
        }
        case "struggle":
            KDDelayedActionPrune(["Action", "Struggle"]);
            return KinkyDungeonStruggle(data.group, data.type, data.index);
        case "struggleCurse": {
            KDDelayedActionPrune(["Action", "Struggle"]);
            let item = KinkyDungeonGetRestraintItem(data.group);
            if (data.index) {
                let surfaceItems = KDDynamicLinkListSurface(item);
                if (surfaceItems[data.index])
                    item = surfaceItems[data.index];
                else
                    console.log("Error! Please report the item combination and screenshot to Ada!");
            }
            KinkyDungeonCurseStruggle(item, data.curse);
            break;
        }
        case "curseUnlock":
            KDDelayedActionPrune(["Action", "Struggle"]);
            KinkyDungeonCurseUnlock(data.group, data.index, data.curse);
            break;
        case "toggleSpell":
            KinkyDungeonSpellChoicesToggle[data.i] = !KinkyDungeonSpellChoicesToggle[data.i];
            KinkyDungeonSendEvent("toggleSpell", { index: data.i, spell: KinkyDungeonSpells[KinkyDungeonSpellChoices[data.i]] }, KinkyDungeonSpells[KinkyDungeonSpellChoices[data.i]]);
            if (KinkyDungeonSpellChoicesToggle[data.i] && KinkyDungeonSpells[KinkyDungeonSpellChoices[data.i]].costOnToggle) {
                if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(KinkyDungeonSpells[KinkyDungeonSpellChoices[data.i]]))) {
                    KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(KinkyDungeonSpells[KinkyDungeonSpellChoices[data.i]]));
                }
                else
                    KinkyDungeonSpellChoicesToggle[data.i] = false;
            }
            break;
        case "consumable":
            KDModalArea = false;
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = null;
            KinkyDungeonAttemptConsumable(data.item, data.quantity);
            break;
        case "switchWeapon": {
            KDDelayedActionPrune(["Action", "SwitchWeapon"]);
            let oldweapon = KinkyDungeonPlayerWeapon;
            KDGameData.PreviousWeapon = oldweapon;
            KDSetWeapon(data.weapon);
            KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
            if (KinkyDungeonStatsChoice.has("Disorganized")) {
                KinkyDungeonAdvanceTime(1);
                KinkyDungeonSlowMoveTurns = 2;
            }
            else if (!KinkyDungeonStatsChoice.has("QuickDraw"))
                KinkyDungeonAdvanceTime(1);
            KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonEquipWeapon").replace("WEAPONNAME", TextGet("KinkyDungeonInventoryItem" + data.weapon)), "white", 5);
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Equip.ogg");
            break;
        }
        case "unequipWeapon":
            KDDelayedActionPrune(["Action", "SwitchWeapon"]);
            KDGameData.PreviousWeapon = data.weapon;
            KDSetWeapon(null);
            KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
            KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonUnEquipWeapon").replace("WEAPONNAME", TextGet("KinkyDungeonInventoryItem" + data.weapon)), "white", 5);
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Equip.ogg");
            break;
        case "dress":
            KDDelayedActionPrune(["Action", "Dress"]);
            KinkyDungeonSetDress(data.dress, data.outfit);
            KinkyDungeonSlowMoveTurns = 5;
            KinkyDungeonSleepTime = CommonTime() + 200;
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Equip.ogg");
            break;
        case "equip":
            KDDelayedActionPrune(["Action", "Equip"]);
            success = KinkyDungeonAddRestraintIfWeaker(KinkyDungeonRestraintsCache.get(data.name), 0, true, "", KinkyDungeonGetRestraintItem(data.Group) && !KinkyDungeonLinkableAndStricter(KinkyDungeonRestraintsCache.get(data.currentItem), KinkyDungeonRestraintsCache.get(data.name)), false, data.events, data.faction, false, data.curse);
            if (success != undefined) {
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Unlock.ogg");
                KDSendStatus('bound', data.name, "self");
                loose = KinkyDungeonInventoryGetLoose(data.name);
                if (!(loose.quantity > 1)) {
                    KinkyDungeonInventoryRemove(loose);
                }
                else {
                    loose.quantity -= 1;
                }
                KDStunTurns(2);
                msg = "KinkyDungeonSelfBondage";
                if (KDRestraint(loose).Group == "ItemVulvaPiercings" || KDRestraint(loose).Group == "ItemVulva" || KDRestraint(loose).Group == "ItemButt") {
                    if (KinkyDungeonIsChaste(false)) {
                        msg = "KinkyDungeonSelfBondagePlug";
                    }
                }
                else if (KDRestraint(loose).Group == "Item") {
                    if (KinkyDungeonIsChaste(true)) {
                        msg = "KinkyDungeonSelfBondageNipple";
                    }
                }
                else if (KDRestraint(loose).enchanted) {
                    msg = "KinkyDungeonSelfBondageEnchanted";
                }
                KinkyDungeonSendTextMessage(10, TextGet(msg).replace("RestraintName", TextGet("Restraint" + KDRestraint(loose).name)), "yellow", 1);
                return msg;
            }
            else
                return "KDCantEquip";
        case "tryOrgasm":
            KDDelayedActionPrune(["Action", "Sexy"]);
            KinkyDungeonDoTryOrgasm(data.bonus);
            break;
        case "tryPlay":
            KDDelayedActionPrune(["Action", "Sexy"]);
            KinkyDungeonDoPlayWithSelf();
            break;
        case "sleep":
            KDGameData.SleepTurns = KinkyDungeonSleepTurnsMax;
            break;
        case "noise": {
            KDDelayedActionPrune(["Action", "Dialogue"]);
            let gagTotal = KinkyDungeonGagTotal(true);
            KinkyDungeonMakeNoise(Math.ceil(10 - 8 * Math.min(1, gagTotal * gagTotal)), KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
            KinkyDungeonSendTextMessage(10, TextGet("KDShoutHelp" + Math.min(3, Math.floor(gagTotal * 3.3))), "yellow", 1);
            break;
        }
        case "pick":
            KDDelayedActionPrune(["Action", "Struggle"]);
            tile = KinkyDungeonTilesGet(data.targetTile);
            KinkyDungeonTargetTile = tile;
            KinkyDungeonTargetTileLocation = data.targetTile;
            if (KinkyDungeonTargetTile === null || KinkyDungeonTargetTile === void 0 ? void 0 : KinkyDungeonTargetTile.Lock) {
                KinkyDungeonAdvanceTime(1, true);
                if (KinkyDungeonPickAttempt()) {
                    KinkyDungeonTargetTile.Lock = undefined;
                    if (KinkyDungeonTargetTile.Type == "Lock")
                        delete KinkyDungeonTargetTile.Type;
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                }
                KinkyDungeonMultiplayerUpdate(KinkyDungeonNextDataSendTimeDelay);
            }
            break;
        case "unlock":
            KDDelayedActionPrune(["Action", "Struggle"]);
            tile = KinkyDungeonTilesGet(data.targetTile);
            KinkyDungeonTargetTile = tile;
            KinkyDungeonTargetTileLocation = data.targetTile;
            if (KinkyDungeonTargetTile === null || KinkyDungeonTargetTile === void 0 ? void 0 : KinkyDungeonTargetTile.Lock) {
                KDUpdateDoorNavMap();
                KinkyDungeonAdvanceTime(1, true);
                if (KinkyDungeonUnlockAttempt(KinkyDungeonTargetTile.Lock)) {
                    KinkyDungeonTargetTile.Lock = undefined;
                    if (KinkyDungeonTargetTile.Type == "Lock")
                        delete KinkyDungeonTargetTile.Type;
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                }
                KinkyDungeonMultiplayerUpdate(KinkyDungeonNextDataSendTimeDelay);
            }
            break;
        case "commandunlock": {
            KDDelayedActionPrune(["Action", "Cast"]);
            tile = KinkyDungeonTilesGet(data.targetTile);
            KinkyDungeonTargetTile = tile;
            KinkyDungeonTargetTileLocation = data.targetTile;
            if (KinkyDungeonTargetTile === null || KinkyDungeonTargetTile === void 0 ? void 0 : KinkyDungeonTargetTile.Lock) {
                KinkyDungeonAdvanceTime(1, true);
                let spell = KinkyDungeonFindSpell("CommandWord", true);
                let miscast = KinkyDungeonMiscastChance;
                let gagTotal = KinkyDungeonGagTotal();
                if (KinkyDungeoCheckComponents(KinkyDungeonFindSpell("CommandWord"), KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y).length > 0) {
                    miscast = miscast + Math.max(0, 1 - miscast) * Math.min(1, gagTotal);
                }
                if (KDRandom() > miscast) {
                    KinkyDungeonTargetTile.Lock = undefined;
                    if (KinkyDungeonTargetTile.Type == "Lock")
                        delete KinkyDungeonTargetTile.Type;
                    KDUpdateDoorNavMap();
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                    if (gagTotal) {
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonUnlockDoorPurpleUseGagged"), "#aa44ff", 1);
                    }
                    else {
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonUnlockDoorPurpleUse"), "#aa44ff", 1);
                    }
                    KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                }
                else {
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonUnlockDoorPurpleUseGaggedFail"), "#ff0000", 1);
                }
                KinkyDungeonMultiplayerUpdate(KinkyDungeonNextDataSendTimeDelay);
            }
            break;
        }
        case "closeDoor":
            KDDelayedActionPrune(["Action", "World"]);
            KinkyDungeonCloseDoor(data);
            break;
        case "shrineBuy":
            KDDelayedActionPrune(["Action", "World"]);
            KinkyDungeonShopIndex = data.shopIndex;
            KinkyDungeonPayShrine(data.type);
            KinkyDungeonAggroAction('shrine', {});
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
            break;
        case "shrineUse":
            KDDelayedActionPrune(["Action", "World"]);
            tile = KinkyDungeonTilesGet(data.targetTile);
            KinkyDungeonAdvanceTime(1, true);
            if (KinkyDungeonGold >= data.cost) {
                KinkyDungeonPayShrine(data.type);
                KinkyDungeonTilesDelete(KinkyDungeonTargetTileLocation);
                let x = data.targetTile.split(',')[0];
                let y = data.targetTile.split(',')[1];
                KinkyDungeonMapSet(parseInt(x), parseInt(y), "a");
                KinkyDungeonAggroAction('shrine', { x: parseInt(x), y: parseInt(y) });
                KDGameData.AlreadyOpened.push({ x: parseInt(x), y: parseInt(y) });
                KinkyDungeonUpdateStats(0);
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
            }
            else {
                if (KinkyDungeonShrineTypeRemove.includes(type))
                    KinkyDungeonSendActionMessage(9, TextGet("KDNoRestraints"), "#ff5555", 1, true);
                else
                    KinkyDungeonSendActionMessage(9, TextGet("KinkyDungeonPayShrineFail"), "#ff5555", 1, true);
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Damage.ogg");
            }
            KinkyDungeonMultiplayerUpdate(KinkyDungeonNextDataSendTimeDelay);
            break;
        case "shrineDrink": {
            if (!KDCanDrinkShrine(false)) {
                KinkyDungeonSendActionMessage(9, TextGet("KDNoMana"), "#ff5555", 2, true);
                break;
            }
            KDDelayedActionPrune(["Action", "World"]);
            tile = KinkyDungeonTilesGet(data.targetTile);
            if (tile)
                tile.drunk = true;
            KinkyDungeonAdvanceTime(1, true);
            let slimed = 0;
            for (let inv of KinkyDungeonAllRestraint()) {
                if (KDRestraint(inv).slimeLevel) {
                    slimed += 1;
                    KinkyDungeonRemoveRestraint(KDRestraint(inv).Group, false);
                }
            }
            if (slimed) {
                KinkyDungeonSendActionMessage(9, TextGet("KinkyDungeonPoolDrinkSlime"), "#FF00FF", 2);
                KinkyDungeonChangeRep(data.type, -slimed * 2);
            }
            else
                KinkyDungeonSendActionMessage(9, TextGet(KinkyDungeonGagTotal() > 0 ? "KinkyDungeonPoolDrinkFace" : "KinkyDungeonPoolDrink"), "#AAFFFF", 2);
            KinkyDungeonChangeMana(5, false, 0, false, true);
            KDSendStatus('goddess', data.type, 'shrineDrink');
            KinkyDungeonAggroAction('shrine', {});
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
            let x = data.targetTile.split(',')[0];
            let y = data.targetTile.split(',')[1];
            KDSummonRevengeMobs(parseInt(x), parseInt(y), tile.type, slimed ? 1.5 : 1);
            KDGameData.PoolUses += 1;
            break;
        }
        case "shrineBottle": {
            if (!KDCanDrinkShrine(true)) {
                KinkyDungeonSendTextMessage(9, TextGet("KDNoMana"), "#ff5555", 2, true);
                break;
            }
            KDDelayedActionPrune(["Action", "World"]);
            tile = KinkyDungeonTilesGet(data.targetTile);
            if (tile)
                tile.drunk = true;
            KinkyDungeonAdvanceTime(1, true);
            let x = data.targetTile.split(',')[0];
            let y = data.targetTile.split(',')[1];
            KDSummonRevengeMobs(parseInt(x), parseInt(y), tile.type, 1.0);
            KinkyDungeonSendActionMessage(9, TextGet("KinkyDungeonPoolBottle"), "#AAFFFF", 2);
            KinkyDungeonChangeConsumable(KinkyDungeonFindConsumable("PotionMana"), 1);
            KDSendStatus('goddess', data.type, 'shrineBottle');
            KinkyDungeonAggroAction('shrine', {});
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/PotionDrink.ogg");
            KDGameData.PoolUses += 1;
            break;
        }
        case "defeat":
            KDDelayedActionPrune(["Action", "World"]);
            KinkyDungeonDefeat();
            KinkyDungeonChangeRep("Ghost", 4);
            break;
        case "lose":
            KinkyDungeonState = "Menu";
            KDLose = true;
            MiniGameKinkyDungeonLevel = -1;
            break;
        case "orb":
            if (KinkyDungeonMapGet(data.x, data.y) == 'O') {
                KDDelayedActionPrune(["Action", "World"]);
                if (KinkyDungeonGoddessRep[data.shrine] < -45) {
                    KinkyDungeonSummonEnemy(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, "OrbGuardian", 3 + Math.floor(Math.sqrt(1 + MiniGameKinkyDungeonLevel)), 10, false, 30);
                }
                KinkyDungeonChangeRep(data.shrine, data.Amount * -10);
                KDSendStatus('goddess', data.shrine, 'takeOrb');
                if (KinkyDungeonStatsChoice.get("randomMode")) {
                    let spell = null;
                    let spellList = [];
                    let maxSpellLevel = 4;
                    for (let k of Object.keys(KinkyDungeonSpellList)) {
                        for (let sp of KinkyDungeonSpellList[k]) {
                            if (KinkyDungeonCheckSpellPrerequisite(sp) && sp.school == k && !sp.secret) {
                                for (let iii = 0; iii < maxSpellLevel - sp.level; iii++)
                                    spellList.push(sp);
                            }
                        }
                    }
                    for (let sp of KinkyDungeonSpells) {
                        for (let S = 0; S < spellList.length; S++) {
                            if (sp.name == spellList[S].name) {
                                spellList.splice(S, 1);
                                S--;
                            }
                        }
                    }
                    spell = spellList[Math.floor(KDRandom() * spellList.length)];
                    if (spell) {
                        KinkyDungeonSpells.push(spell);
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonOrbSpell").replace("SPELL", TextGet("KinkyDungeonSpell" + spell.name)), "lightblue", 2);
                    }
                }
                else {
                    KinkyDungeonSpellPoints += data.Amount;
                }
                KinkyDungeonMapSet(data.x, data.y, 'o');
                KinkyDungeonAggroAction('orb', {});
            }
            break;
        case "perkorb":
            if (KinkyDungeonMapGet(data.x, data.y) == 'P') {
                KDDelayedActionPrune(["Action", "World"]);
                KDSendStatus('goddess', data.perks, 'takePerkOrb');
                if (data.perks) {
                    for (let p of data.perks) {
                        KinkyDungeonStatsChoice.set(p, true);
                    }
                }
                KinkyDungeonMapSet(data.x, data.y, 'p');
                for (let x = 0; x < KinkyDungeonGridWidth; x++) {
                    if (KinkyDungeonMapGet(x, data.y) == 'P') {
                        KinkyDungeonMapSet(x, data.y, 'p');
                    }
                }
                KinkyDungeonSendEvent("perkOrb", { x: data.x, y: data.y, perks: data.perks });
            }
            break;
        case "heart":
            if (data.type == "AP") {
                if (KinkyDungeonStatDistractionMax < KDMaxStat)
                    KinkyDungeonSpells.push(KinkyDungeonFindSpell("APUp1"));
                KinkyDungeonUpdateStats(0);
            }
            else if (data.type == "SP") {
                if (KinkyDungeonStatStaminaMax < KDMaxStat)
                    KinkyDungeonSpells.push(KinkyDungeonFindSpell("SPUp1"));
                KinkyDungeonUpdateStats(0);
            }
            else if (data.type == "MP") {
                if (KinkyDungeonStatManaMax < KDMaxStat)
                    KinkyDungeonSpells.push(KinkyDungeonFindSpell("MPUp1"));
                KinkyDungeonUpdateStats(0);
            }
            else if (data.type == "WP") {
                if (KinkyDungeonStatWillMax < KDMaxStat)
                    KinkyDungeonSpells.push(KinkyDungeonFindSpell("WPUp1"));
                KinkyDungeonUpdateStats(0);
            }
            KDGameData.CollectedHearts = (KDGameData.CollectedHearts || 0) + 1;
            break;
        case "champion":
            KDGameData.Champion = data.rep;
            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonBecomeChampion").replace("GODDESS", TextGet("KinkyDungeonShrine" + data.rep)), "yellow", 1);
            KDSendStatus('goddess', data.rep, 'helpChampion');
            break;
        case "aid":
            KDDelayedActionPrune(["Action", "World"]);
            KinkyDungeonChangeRep(data.rep, -KinkyDungeonAidManaCost(data.rep, data.value));
            KinkyDungeonChangeMana(KinkyDungeonAidManaAmount(data.rep, data.value));
            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonAidManaMe"), "purple", 2);
            KDSendStatus('goddess', data.rep, 'helpMana');
            break;
        case "rescue":
            KinkyDungeonRescued[data.rep] = true;
            if (KDRandom() < 0.5 + data.value / 100) {
                KDDelayedActionPrune(["Action", "World"]);
                let tiles = KinkyDungeonRescueTiles();
                if (tiles.length > 0) {
                    KDSendStatus('goddess', data.rep, 'helpRescue');
                    KinkyDungeonChangeRep(data.rep, -10);
                    tile = tiles[Math.floor(tiles.length * KDRandom())];
                    if (tile) {
                        KinkyDungeonMapSet(tile.x, tile.y, "$");
                        KinkyDungeonTilesSet(tile.x + "," + tile.y, { Type: "Angel" });
                        KDStartDialog("AngelHelp", "Angel", true, "");
                    }
                    KDGameData.RescueFlag = true;
                }
                return "Rescue";
            }
            else {
                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonNoRescue"), "purple", 10);
                KDSendStatus('goddess', data.rep, 'helpNoRescue');
                return "FailRescue";
            }
        case "penance":
            KDGameData.KinkyDungeonPenance = true;
            KDGameData.KDPenanceMode = "";
            KDGameData.KDPenanceStage = 0;
            KDGameData.KDPenanceStageEnd = 0;
            KDGameData.AngelCurrentRep = data.rep;
            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonPenanceHappen"), "purple", 4);
            KDGameData.KinkyDungeonPenanceCostCurrent = KinkyDungeonPenanceCosts[data.rep] ? KinkyDungeonPenanceCosts[data.rep] : KinkyDungeonPenanceCostDefault;
            if (KinkyDungeonGold >= KDGameData.KinkyDungeonPenanceCostCurrent) {
                if (KinkyDungeonPenanceCosts[data.rep])
                    KinkyDungeonPenanceCosts[data.rep] += KinkyDungeonPenanceCostGrowth;
                else
                    KinkyDungeonPenanceCosts[data.rep] = KinkyDungeonPenanceCostDefault + KinkyDungeonPenanceCostGrowth;
            }
            KDSendStatus('goddess', data.rep, 'helpPenance');
            break;
        case "spellChoice":
            KDDelayedActionPrune(["Action", "SwitchSpell"]);
            KinkyDungeonEvasionPityModifier = 0.0;
            KinkyDungeonSpellChoices[data.I] = data.CurrentSpell;
            KinkyDungeonSpellChoicesToggle[data.I] = !KinkyDungeonSpells[KinkyDungeonSpellChoices[data.I]].defaultOff;
            if (KinkyDungeonSpellChoicesToggle[data.I] && KinkyDungeonSpells[KinkyDungeonSpellChoices[data.I]].costOnToggle) {
                if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(KinkyDungeonSpells[KinkyDungeonSpellChoices[data.I]]))) {
                    KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(KinkyDungeonSpells[KinkyDungeonSpellChoices[data.I]]));
                }
                else
                    KinkyDungeonSpellChoicesToggle[data.I] = false;
            }
            if (KinkyDungeonStatsChoice.has("Disorganized")) {
                KinkyDungeonAdvanceTime(1);
                KinkyDungeonSlowMoveTurns = 2;
            }
            else if (!KinkyDungeonStatsChoice.has("QuickDraw"))
                KinkyDungeonAdvanceTime(1);
            break;
        case "spellRemove":
            KinkyDungeonEvasionPityModifier = 0.0;
            KinkyDungeonSpellChoices[data.I] = -1;
            KinkyDungeonSpellChoicesToggle[data.I] = true;
            break;
        case "spellCastFromBook": {
            KDDelayedActionPrune(["Action", "Cast"]);
            let spell = KinkyDungeonHandleSpellCast(KinkyDungeonSpells[data.CurrentSpell]);
            if (spell && !(KinkyDungeonSpells[data.CurrentSpell].type == "passive") && !KinkyDungeonSpells[data.CurrentSpell].passive && !KinkyDungeonSpells[data.CurrentSpell].upcastFrom) {
                if (KinkyDungeonStatsChoice.has("Disorganized")) {
                    KinkyDungeonAdvanceTime(1);
                    KinkyDungeonSlowMoveTurns = 2;
                }
                else if (!KinkyDungeonStatsChoice.has("QuickDraw"))
                    KinkyDungeonAdvanceTime(1);
                KinkyDungeonSendActionMessage(5, TextGet("KinkyDungeonSpellTarget" + spell.name).replace("SpellArea", "" + Math.floor(spell.aoe)), "white", 0.1, true);
            }
            break;
        }
        case "upcast": {
            KDDelayedActionPrune(["Action", "Cast"]);
            KDEmpower(data, KinkyDungeonPlayerEntity);
            break;
        }
        case "upcastcancel": {
            KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "upcast", 1);
            break;
        }
        case "spellLearn": {
            KDDelayedActionPrune(["Action", "SwitchSpell"]);
            KinkyDungeonEvasionPityModifier = 0.0;
            let spell = KinkyDungeonFindSpell(data.SpellName, true);
            let cost = KinkyDungeonGetCost(spell);
            if (KinkyDungeonCheckSpellPrerequisite(spell)) {
                if (KinkyDungeonSpellPoints >= cost) {
                    if (spell.manacost <= KinkyDungeonStatManaMax) {
                        KinkyDungeonSpellPoints -= cost;
                        KinkyDungeonSpells.push(spell);
                        KDSendStatus('learnspell', spell.name);
                        if (spell.goToPage) {
                            KinkyDungeonCurrentSpellsPage = spell.goToPage;
                        }
                        if (spell.autoLearn) {
                            for (let sp of spell.autoLearn) {
                                if (KinkyDungeonSpellIndex(sp) < 0) {
                                    KinkyDungeonSpells.push(KinkyDungeonFindSpell(sp, true));
                                    KDSendStatus('learnspell', sp);
                                }
                            }
                        }
                        KinkyDungeonSetMaxStats();
                        if (KDToggles.Sound && KinkyDungeonIsPlayer())
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
                        KinkyDungeonCurrentPage = KinkyDungeonSpellIndex(spell.name);
                        if (KinkyDungeonStatsChoice.has("Disorganized")) {
                            KinkyDungeonAdvanceTime(1);
                            KinkyDungeonSlowMoveTurns = 2;
                        }
                        else if (!KinkyDungeonStatsChoice.has("QuickDraw"))
                            KinkyDungeonAdvanceTime(1);
                        if (KinkyDungeonIsPlayer()) {
                            KinkyDungeonPreviewSpell = undefined;
                        }
                    }
                    else if (KinkyDungeonIsPlayer())
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonSpellsNotEnoughMana"), "#b4dbfc", 1);
                }
                else if (KinkyDungeonIsPlayer())
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonSpellsNotEnoughPoints"), "#ffff00", 1);
            }
            else if (KinkyDungeonIsPlayer())
                KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonSpellsNotPrerequisite").replace("REQUIREDSPELL", TextGet("KinkyDungeonSpell" + spell.prerequisite)), "#ff4444", 1);
            break;
        }
        case "tabletInteract": {
            KDDelayedActionPrune(["Action", "World"]);
            if (data.action == "read") {
                tile = KinkyDungeonTilesGet(data.targetTile);
                if (tile && tile.Type == "Tablet") {
                    if (tile.Name == "Will") {
                        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "TabletWill", type: "restore_mp", power: 0.5, duration: 20 });
                        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "TabletWill2", type: "restore_sp", power: 0.5, duration: 20 });
                        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "TabletWill3", type: "restore_wp", power: 0.5, duration: 5 });
                    }
                    else if (tile.Name == "Determination") {
                        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "TabletDetermination", type: "restore_wp", power: 1, duration: 5 });
                    }
                    else {
                        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "Tablet" + tile.Name, aura: KDGoddessColor(tile.Name), type: "event", duration: 9999, power: 2, player: true, enemies: false, maxCount: 3, tags: ["cast_" + tile.Name.toLowerCase()], events: [
                                { trigger: "calcMana", type: "Tablet", requiredTag: tile.Name.toLowerCase(), power: 0.5 },
                            ] });
                    }
                    KinkyDungeonAdvanceTime(1);
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonTabletReadSuccess"), "lightgreen", 1);
                    let x = parseInt(data.targetTile.split(',')[0]);
                    let y = parseInt(data.targetTile.split(',')[1]);
                    if (x && y) {
                        KinkyDungeonMapSet(x, y, 'm');
                        KinkyDungeonTilesDelete(data.targetTile);
                    }
                }
            }
            break;
        }
        case "foodInteract": {
            KDDelayedActionPrune(["Action", "World"]);
            if (data.action == "eat") {
                tile = KinkyDungeonTilesGet(data.targetTile);
                if (tile && tile.Type == "Food") {
                    let gagged = KinkyDungeonGagTotal();
                    if (gagged > 0) {
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonFoodEatenGag"), "#ff8800", 1);
                    }
                    else {
                        let Willmulti = Math.max(KinkyDungeonStatWillMax / KDMaxStatStart);
                        let amount = tile.Amount ? tile.Amount : 1.0;
                        KinkyDungeonChangeWill(amount * Willmulti);
                        KinkyDungeonAdvanceTime(1);
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonFoodEaten"), "lightgreen", 1);
                        tile.Food = "Plate";
                    }
                }
            }
            break;
        }
        case "chargerInteract":
            KDDelayedActionPrune(["Action", "World"]);
            if (data.action == "charge") {
                if (KinkyDungeonInventoryGet("AncientPowerSourceSpent") && KinkyDungeonGold >= KDRechargeCost) {
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, 1);
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSourceSpent, -1);
                    KinkyDungeonAddGold(-KDRechargeCost);
                    KinkyDungeonAdvanceTime(1);
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonChargerChargeSuccess").replace("VALUE", "" + KDRechargeCost), "yellow", 1);
                    let x = parseInt(data.targetTile.split(',')[0]);
                    let y = parseInt(data.targetTile.split(',')[1]);
                    if (x && y) {
                        KinkyDungeonTilesDelete(data.targetTile);
                        KinkyDungeonMapSet(x, y, '-');
                    }
                    return "Pass";
                }
                else {
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonChargerChargeFailure"), "orange", 1);
                    return "Fail";
                }
            }
            else if (data.action == "place") {
                tile = KinkyDungeonTilesGet(data.targetTile);
                if (tile && tile.Type == "Charger" && KinkyDungeonInventoryGet("AncientPowerSource")) {
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, -1);
                    tile.Light = KDChargerLight;
                    KinkyDungeonAdvanceTime(1);
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonChargerPlace"), "yellow", 1);
                    let x = parseInt(data.targetTile.split(',')[0]);
                    let y = parseInt(data.targetTile.split(',')[1]);
                    if (x && y) {
                        KinkyDungeonMapSet(x, y, '=');
                    }
                }
            }
            else if (data.action == "remove") {
                tile = KinkyDungeonTilesGet(data.targetTile);
                if (tile && tile.Type == "Charger" && tile.Light > 0 && !tile.NoRemove) {
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSource, 1);
                    tile.Light = undefined;
                    KinkyDungeonAdvanceTime(1);
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonChargerRemove"), "yellow", 1);
                    let x = parseInt(data.targetTile.split(',')[0]);
                    let y = parseInt(data.targetTile.split(',')[1]);
                    if (x && y) {
                        KinkyDungeonMapSet(x, y, '+');
                    }
                }
                else if (tile && tile.NoRemove) {
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonChargerNoRemove"), "yellow", 1);
                }
            }
            break;
        case "dialogue": {
            KDDoDialogue(data);
            break;
        }
    }
    return "";
}
function KDSendInput(type, data, frame, noUpdate) {
    if (!noUpdate) {
        KDGameData.OrigEnergyLevel = KDGameData.AncientEnergyLevel;
        KDGameData.LastSP = KinkyDungeonStatStamina;
        KDGameData.LastMP = KinkyDungeonStatMana;
        KDGameData.LastAP = KinkyDungeonStatDistraction;
        KDGameData.LastWP = KinkyDungeonStatWill;
    }
    KinkyDungeonInputQueue.push({ type: type, data: data });
    return KDProcessInputs(true);
}
function KDProcessInputs(ReturnResult) {
    for (let i = 0; i < 3; i++) {
        if (KinkyDungeonInputQueue.length > 0) {
            let input = KinkyDungeonInputQueue.splice(0, 1)[0];
            if (input) {
                let res = KDProcessInput(input.type, input.data);
                if (ReturnResult)
                    return res;
            }
        }
    }
    return "";
}
let KinkyDungeonStruggleGroups = [];
let KinkyDungeonStruggleGroupsBase = [
    "ItemH",
    "ItemDevices",
    "ItemM",
    "ItemEars",
    "ItemArms",
    "ItemNeck",
    "ItemHands",
    "ItemNeckRestraints",
    "ItemBreast",
    "ItemNipples",
    "ItemTorso",
    "ItemButt",
    "ItemVulva",
    "ItemVulvaPiercings",
    "ItemPelvis",
    "ItemLegs",
    "ItemFeet",
    "ItemBoots",
];
let KinkyDungeonDrawStruggle = 1;
let KDPlayerSetPose = false;
let KinkyDungeonDrawStruggleHover = false;
let KinkyDungeonDrawState = "Game";
let KinkyDungeonDrawStatesModal = ["Heart", "Orb"];
let KinkyDungeonSpellValid = false;
let KinkyDungeonCamX = 0;
let KinkyDungeonCamY = 0;
let KinkyDungeonTargetX = 0;
let KinkyDungeonTargetY = 0;
let KinkyDungeonLastDraw = 0;
let KinkyDungeonLastDraw2 = 0;
let KinkyDungeonDrawDelta = 0;
const KinkyDungeonLastChatTimeout = 10000;
let KinkyDungeonStatBarHeight = 50;
let KinkyDungeonToggleAutoDoor = false;
let KinkyDungeonToggleAutoPass = false;
let KinkyDungeonToggleAutoSprint = false;
let KinkyDungeonInspect = false;
let KinkyDungeonFastMove = true;
let KinkyDungeonFastMovePath = [];
let KinkyDungeonFastStruggle = false;
let KinkyDungeonFastStruggleType = "";
let KinkyDungeonFastStruggleGroup = "";
function KDDynamicLinkList(item, includeItem) {
    let ret = [];
    if (includeItem)
        ret.push(item);
    if (item && item.dynamicLink) {
        let link = item.dynamicLink;
        while (link) {
            ret.push(link);
            link = link.dynamicLink;
        }
    }
    return ret;
}
function KDDynamicLinkListSurface(item) {
    let stack = [];
    if (item && item.dynamicLink) {
        let last = item;
        let link = item.dynamicLink;
        while (link) {
            stack.push({ item: link, host: last });
            link = link.dynamicLink;
            last = link;
        }
    }
    let ret = [item];
    for (let tuple of stack) {
        let inv = tuple.item;
        let host = tuple.host;
        if ((!KDRestraint(host).inaccessible)
            && ((KDRestraint(host).accessible) || (KDRestraint(inv).renderWhenLinked && KDRestraint(item).shrine && KDRestraint(inv).renderWhenLinked.some((link) => { return KDRestraint(item).shrine.includes(link); })))) {
            ret.push(inv);
        }
    }
    return ret;
}
function KDLinkSize(restraint) {
    return restraint.linkSize ? restraint.linkSize : 1;
}
function KDLinkCategorySize(item, linkCategory, ignoreItem) {
    let total = 0;
    let stack = [item];
    if (item && item.dynamicLink) {
        let link = item.dynamicLink;
        while (link) {
            stack.push(link);
            link = link.dynamicLink;
        }
    }
    for (let inv of stack) {
        if (KDRestraint(inv).linkCategory == linkCategory && (ignoreItem === null || ignoreItem === void 0 ? void 0 : ignoreItem.id) != inv.id) {
            total += KDLinkSize(KDRestraint(inv));
        }
    }
    return total;
}
let KDBuffSprites = {
    "Camo": true,
    "Drenched": true,
    "StoneSkin": true,
    "Conduction": true,
    "Ignite": true,
    "Burning": true,
    "Unsteady": true,
    "Unsteady2": true,
    "Chilled": true,
    "ChillWalk": true,
    "Slimed": true,
    "LightningRod": true,
    "PoisonDagger": true,
    "Cutting": true,
    "Slippery": true,
    "ScrollVerbal": true,
    "ScrollArms": true,
    "ScrollLegs": true,
    "Empower": true,
    "SlimeMimic": true,
    "DisenchantSelf": true,
    "LeatherBurst": true,
    "TabletElements": true,
    "TabletConjure": true,
    "TabletIllusion": true,
    "TabletRope": true,
    "TabletWill": true,
    "TabletMetal": true,
    "TabletLatex": true,
    "TabletLeather": true,
    "AvatarFire": true,
    "AvatarWater": true,
    "AvatarEarth": true,
    "AvatarAir": true,
    "DistractionCast": true,
    "BoundByFate": true,
};
let KDStatsSkipLine = {
    "info": 1,
    "status": 1,
    "dmg": 1,
};
let KDStatsSkipLineBefore = {
    "kinky": 1,
};
let KDStatsOrder = {
    "info": 10000,
    "help": 3500,
    "status": 7000,
    "buffs": 1000,
    "dmg": 2000,
    "kinky": -1000,
};
function KinkyDungeonDrawInputs() {
    let statsDraw = {};
    if (ServerURL == "foobar")
        DrawButtonVis(1880, 82, 100, 50, TextGet("KinkyDungeonRestart"), "#ffffff");
    else
        DrawButtonVis(1750, 20, 100, 50, TextGet("KinkyDungeonRestart"), "#ffffff");
    let i = 0;
    if (KinkyDungeonPlayerDamage) {
        let accuracy = KinkyDungeonGetEvasion();
        let weapon = KinkyDungeonWeapons[KinkyDungeonPlayerWeapon] || KinkyDungeonPlayerDamage;
        statsDraw.accuracy = {
            text: TextGet("KinkyDungeonAccuracy") + Math.round(accuracy * 100) + "%",
            count: Math.round(accuracy * 100) + "%",
            icon: "infoAccuracy",
            countcolor: accuracy > weapon.chance * 1.01 ? "#c4efaa" : (accuracy < weapon.chance * 0.99 ? "#ff5555" : "#ffffff"),
            category: "info", color: "#ffffff", bgcolor: "#000000", priority: 10
        };
    }
    statsDraw.miscast = {
        text: TextGet("StatMiscastChance") + Math.round(KinkyDungeonMiscastChance * 100) + "%",
        count: Math.round(KinkyDungeonMiscastChance * 100) + "%",
        icon: "infoMiscast",
        countcolor: KinkyDungeonMiscastChance > 0 ? "#ff5555" : "#ffffff",
        category: "info", color: "#ffffff", bgcolor: "#000000", priority: 9
    };
    let evasion = KinkyDungeonPlayerEvasion();
    statsDraw.evasion = {
        text: TextGet("StatEvasion")
            .replace("Percent", ("") + Math.round((1 - evasion) * 100))
            .replace("EVASIONSUM", ("") + Math.round((KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Evasion")) * 100))
            .replace("EVASIONPENALTY", ("") + Math.round((KDPlayerEvasionPenalty()) * 100)),
        count: ("") + Math.round((1 - evasion) * 100) + "%",
        icon: "infoEvasion",
        countcolor: evasion < 1 ? "#65d45d" : (evasion == 1 ? "#ffffff" : "#ff5555"),
        category: "info", color: "#ffffff", bgcolor: "#000000", priority: 8
    };
    let jailstatus = "KinkyDungeonPlayerNotJailed";
    if (KDGameData.PrisonerState == 'jail') {
        jailstatus = "KinkyDungeonPlayerJail";
    }
    else if (KDGameData.PrisonerState == 'parole') {
        jailstatus = "KinkyDungeonPlayerParole";
    }
    else if (KDGameData.PrisonerState == 'chase') {
        jailstatus = "KinkyDungeonPlayerChase";
    }
    if (jailstatus == "KinkyDungeonPlayerJail") {
        statsDraw.jail = {
            text: TextGet(jailstatus),
            icon: "infoJailPrisoner",
            category: "help", color: "#ffffff", bgcolor: "#000000", priority: 12
        };
    }
    else if (jailstatus == "KinkyDungeonPlayerParole") {
        statsDraw.jail = {
            text: TextGet(jailstatus),
            icon: "infoJailSubmissive",
            category: "help", color: "#ffffff", bgcolor: "#000000", priority: 12
        };
    }
    else if (jailstatus == "KinkyDungeonPlayerChase") {
        statsDraw.jail = {
            text: TextGet(jailstatus),
            icon: "infoJailPrisoner",
            category: "help", color: "#ffffff", bgcolor: "#000000", priority: 12
        };
    }
    let escape = KDCanEscape();
    statsDraw.key = {
        text: TextGet(escape ? "StatKeyEscapeKey" : "StatKeyEscapeNoKey"),
        icon: escape ? "infoKey" : "infoNoKey",
        category: "info", color: "#ffffff", bgcolor: "#000000", priority: 5
    };
    if (KinkyDungeonIsHandsBound(false, false)) {
        statsDraw.b_hands = { text: TextGet("KDStatHands"), category: "status", icon: "boundHands", color: "#ff5555", bgcolor: "#333333", priority: 10 };
    }
    else {
        if (KDHandBondageTotal() > 0)
            statsDraw.b_hands = { text: TextGet("KDStatHandsPartial"), category: "status", icon: "boundHandsPartial", color: "#ff5555", bgcolor: "#333333", priority: 10 };
        else
            statsDraw.b_hands = { text: TextGet("KDStatFreeHands"), category: "status", icon: "status/freeHands", color: "#55ff55", bgcolor: "#333333", priority: 10 };
    }
    if (KinkyDungeonIsArmsBound(false, false)) {
        statsDraw.b_arms = { text: TextGet("KDStatArms"), category: "status", icon: "boundArms", color: "#ff5555", bgcolor: "#333333", priority: 11 };
    }
    else {
        statsDraw.b_arms = { text: TextGet("KDStatFreeArms"), category: "status", icon: "status/freeArms", color: "#55ff55", bgcolor: "#333333", priority: 11 };
    }
    let gag = KinkyDungeonGagTotal(false);
    if (gag >= 0.99) {
        statsDraw.b_gag = { text: TextGet("KDStatGagFull"), category: "status", icon: "boundGagFull", color: "#ff5555", bgcolor: "#333333", priority: 7 };
    }
    else if (gag > 0) {
        statsDraw.b_gag = { text: TextGet("KDStatGag"), category: "status", icon: "boundGag", color: "#ff5555", bgcolor: "#333333", priority: 7 };
    }
    else {
        statsDraw.b_gag = { text: TextGet("KDStatFreeMouth"), category: "status", icon: "status/freeMouth", color: "#55ff55", bgcolor: "#333333", priority: 7 };
    }
    if (KinkyDungeonBlindLevel > 0 || KinkyDungeonStatBlind > 0) {
        statsDraw.b_blind = { text: TextGet("KDStatBlind"), category: "status", icon: "boundBlind", color: "#ff5555", bgcolor: "#333333", priority: 8 };
    }
    else {
        statsDraw.b_blind = { text: TextGet("KDStatFreeEyes"), category: "status", icon: "status/freeEyes", color: "#55ff55", bgcolor: "#333333", priority: 8 };
    }
    if (KinkyDungeonMovePoints < 0) {
        statsDraw.b_speed = { text: TextGet("KDStatStun"), category: "status", icon: "boundStun", color: "#ff5555", bgcolor: "#333333", priority: 9 };
    }
    else if (KinkyDungeonSlowLevel > 9) {
        statsDraw.b_speed = { text: TextGet("KDStatSpeedImmobile"), category: "status", icon: "boundImmobile", color: "#ff5555", bgcolor: "#333333", priority: 9 };
    }
    else if (KinkyDungeonSlowLevel > 3) {
        statsDraw.b_speed = { text: TextGet("KDStatSpeedNoSprint"), category: "status", icon: "boundSlow4", color: "#ff5555", bgcolor: "#333333", priority: 9 };
    }
    else if (KinkyDungeonSlowLevel > 2) {
        statsDraw.b_speed = { text: TextGet("KDStatSpeedVerySlow"), category: "status", icon: "boundSlow3", color: "#ff5555", bgcolor: "#333333", priority: 9 };
    }
    else if (KinkyDungeonSlowLevel == 2) {
        statsDraw.b_speed = { text: TextGet("KDStatSpeedSlow"), category: "status", icon: "boundSlow2", color: "#ff5555", bgcolor: "#333333", priority: 9 };
    }
    else if (KinkyDungeonSlowLevel > 0) {
        statsDraw.b_speed = { text: TextGet("KDStatSpeedSlightlySlow"), category: "status", icon: "boundSlow1", color: "#ffff00", bgcolor: "#333333", priority: 9 };
    }
    else {
        statsDraw.b_speed = { text: TextGet("KDStatFreeLegs"), category: "status", icon: "status/freeLegs", color: "#55ff55", bgcolor: "#333333", priority: 9 };
    }
    if (KinkyDungeonBrightnessGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y) < 1.5) {
        statsDraw.shadow = { text: TextGet("KinkyDungeonPlayerShadow"), icon: "shadow", category: "status", color: "#a3a7c2", bgcolor: "#5e52ff", priority: 1 };
    }
    let sneak = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak", true);
    if (sneak > 2.5) {
        statsDraw.sneak = { text: TextGet("KinkyDungeonPlayerSneak"), category: "status", icon: "invisible", color: "#ceaaed", bgcolor: "#333333", priority: 2 };
    }
    else {
        let visibility = KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowDetection"));
        if (visibility != 1.0) {
            statsDraw.visibility = {
                text: TextGet("KinkyDungeonPlayerVisibility") + Math.round(visibility * 100) + "%",
                count: Math.round(visibility * 100) + "%",
                icon: "visibility",
                countcolor: visibility < 1 ? "#c4efaa" : "#ff5555",
                category: "status", color: "#ceaaed", bgcolor: KDTextGray0, priority: 2
            };
        }
    }
    let help = KinkyDungeonHasAllyHelp() || KinkyDungeonHasGhostHelp();
    if (help) {
        statsDraw.hashelp = { text: TextGet("KinkyDungeonPlayerHelp"), icon: "Help", category: "help", color: "#ffffff", bgcolor: "#333333", priority: 5 };
    }
    else {
        if (KinkyDungeonGetAffinity(false, "Hook")) {
            statsDraw.helphook = { text: TextGet("KinkyDungeonPlayerHook"), icon: "HelpHook", category: "help", color: "#ffffff", bgcolor: "#333333", priority: 5 };
        }
        if (KinkyDungeonGetAffinity(false, "Sharp") || KinkyDungeonWeaponCanCut(true)) {
            statsDraw.helpsharp = { text: TextGet("KinkyDungeonPlayerSharp"), icon: "HelpSharp", category: "help", color: "#ffffff", bgcolor: "#333333", priority: 5 };
        }
        if (KinkyDungeonGetAffinity(false, "Edge")) {
            statsDraw.helpedge = { text: TextGet("KinkyDungeonPlayerEdge"), icon: "HelpCorner", category: "help", color: "#ffffff", bgcolor: "#333333", priority: 5 };
        }
        if (KinkyDungeonGetAffinity(false, "Sticky")) {
            statsDraw.helpsticky = { text: TextGet("KinkyDungeonPlayerSticky"), icon: "HelpSticky", category: "help", color: "#ffffff", bgcolor: "#333333", priority: 5 };
        }
        if (KinkyDungeonWallCrackAndKnife(false)) {
            statsDraw.helpcrack = { text: TextGet("KinkyDungeonPlayerCrack"), icon: "HelpCrack", category: "help", color: "#ffffff", bgcolor: "#333333", priority: 5 };
        }
    }
    if (KinkyDungeonFlags.has("Quickness")) {
        statsDraw.quickness = { text: TextGet("KinkyDungeonPlayerQuickness"), icon: "quickness", category: "buffs", color: "#ffff00", bgcolor: "#333333", priority: 100 };
    }
    i = 0;
    let armor = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Armor");
    if (armor != 0) {
        statsDraw.armor = { text: TextGet("KinkyDungeonPlayerArmor") + Math.round(armor * 10), count: (armor > 0 ? "+" : "") + Math.round(armor * 10), category: "buffs", icon: "armor", color: "#fca570", bgcolor: "#333333", priority: armor };
    }
    let spellarmor = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SpellResist");
    if (spellarmor != 0) {
        statsDraw.spellarmor = { text: TextGet("KinkyDungeonPlayerSpellResist") + Math.round(spellarmor * 10), count: (spellarmor > 0 ? "+" : "") + Math.round(spellarmor * 10), category: "buffs", icon: "spellarmor", color: "#73efe8", bgcolor: "#333333", priority: spellarmor + 1 };
    }
    let restraintblock = KDRestraintBlockPower(KinkyDungeonGetPlayerStat("RestraintBlock"), 10);
    if (restraintblock < 1)
        statsDraw.restraintblock = {
            text: TextGet("StatRestraintBlock").replace("Percent", ("") + Math.round((1 - restraintblock) * 100)),
            count: ("") + Math.round((1 - restraintblock) * 100) + "%",
            icon: "restraintblock",
            countcolor: "#65d45d",
            category: "buffs", color: "#ffffff", bgcolor: "#000000", priority: 20
        };
    let damageReduction = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "DamageReduction");
    if (damageReduction > 0) {
        statsDraw.damageReduction = {
            text: TextGet("KinkyDungeonPlayerReduction") + Math.round(damageReduction * 10),
            count: "-" + Math.round(damageReduction * 10),
            category: "buffs", color: "#73efe8", bgcolor: "#333333", icon: "damageresist", priority: damageReduction * 3
        };
    }
    if (KinkyDungeonPlayerDamage) {
        let data = {
            buffdmg: 0,
            Damage: KinkyDungeonPlayerDamage,
        };
        KinkyDungeonSendEvent("calcDisplayDamage", data);
        let meleeDamage = (KinkyDungeonPlayerDamage.dmg) + KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackDmg") + data.buffdmg;
        statsDraw.meleeDamage = {
            text: TextGet("KinkyDungeonPlayerDamage")
                .replace("DAMAGEDEALT", "" + Math.round(meleeDamage * 10))
                .replace("DAMAGETYPE", TextGet("KinkyDungeonDamageType" + KinkyDungeonPlayerDamage.type)),
            count: "" + Math.round(meleeDamage * 10),
            category: "info", color: "#ffffff", bgcolor: "#333333", icon: "infoDamageMelee", priority: 10.1
        };
    }
    let bindAmp = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "BindAmp");
    if (bindAmp > 0) {
        statsDraw.bindAmp = {
            text: TextGet("KinkyDungeonPlayerBindBuff").replace("PERCENT", Math.round(bindAmp * 100) + "%"),
            count: "+" + Math.round(bindAmp * 100) + "%",
            countcolor: "#ffffff",
            icon: "dmgPlus/dmgbind",
            category: "dmg", color: "#ffae70", bgcolor: "#333333", priority: 5 + bindAmp * 20
        };
    }
    let magicResist = KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "magicDamageResist"));
    let meleeResist = KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "meleeDamageResist"));
    for (let dt of Object.values(KinkyDungeonDamageTypes)) {
        let color = dt.color;
        let type = dt.name;
        let DR = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, type + "DamageResist");
        let resist = KinkyDungeonMultiplicativeStat(DR);
        let boost = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, type + "DamageBuff");
        let melee = KinkyDungeonMeleeDamageTypes.includes(type);
        switch (type) {
            case "melee":
                boost += KDDamageAmpPerks + KDDamageAmpPerksMelee;
                break;
            case "magic":
                boost += KDDamageAmpPerks + KDDamageAmpPerksMagic;
                break;
            case "spell":
                boost += KDDamageAmpPerksSpell;
                break;
        }
        if (resist != 1.0) {
            statsDraw[type + "_resist"] = {
                text: TextGet("KinkyDungeonPlayerDamageResist")
                    .replace("DAMAGETYPE", TextGet("KinkyDungeonDamageType" + type).toLocaleLowerCase())
                    .replace("DAMAGETYPE", TextGet("KinkyDungeonDamageType" + type).toLocaleLowerCase())
                    .replace("DAMAGECATEGORY", TextGet(melee ? "KinkyDungeonDamageTypemelee" : "KinkyDungeonDamageTypemagic").toLocaleLowerCase())
                    .replace("PERCENT1", Math.round(resist * (melee ? meleeResist : magicResist) * 100) + "%")
                    .replace("PERCENT2", Math.round(DR * 100) + "")
                    .replace("PERCENT3", Math.round((melee ? meleeResist : magicResist) * 100) + "%"),
                count: (resist > 1 ? '+' : "") + Math.round(resist * 100 - 100) + "%",
                countcolor: resist < 1 ? "#c4efaa" : "#ff5555",
                icon: "dmg" + type,
                category: "dmg", color: color, bgcolor: "#333333", priority: resist * 10
            };
        }
        if (boost > 0) {
            statsDraw[type + "_buff"] = {
                text: TextGet("KinkyDungeonPlayerDamageBuff").replace("DAMAGETYPE", TextGet("KinkyDungeonDamageType" + type)).replace("PERCENT", Math.round(boost * 100) + "%"),
                count: "+" + Math.round(boost * 100) + "%",
                countcolor: "#ffffff",
                icon: "dmgPlus/dmg" + type,
                category: "dmg", color: color, bgcolor: "#333333", priority: 5 + boost * 10
            };
        }
    }
    i = 0;
    if (KinkyDungeonPlugCount > 0) {
        statsDraw.plugs = {
            text: TextGet("KinkyDungeonPlayerPlugged"),
            icon: "Plugged",
            category: "kinky", color: "#ff8888", bgcolor: "#333333", priority: 1,
        };
        if (KinkyDungeonPlugCount > 1) {
            statsDraw.plugs = {
                text: TextGet("KinkyDungeonPlayerPluggedExtreme"),
                icon: "PluggedFull",
                category: "kinky", color: "#ff8888", bgcolor: "#333333", priority: 2,
            };
        }
    }
    if (KinkyDungeonVibeLevel > 0) {
        let locations = KDSumVibeLocations();
        let suff = "";
        if (locations.length == 1 && locations[0] == "ItemVulva") {
            suff = "";
        }
        else {
            let sum = "";
            if (locations.length > 3)
                sum = TextGet("KinkyDungeonPlayerVibratedLocationMultiple");
            else
                for (let l of locations) {
                    if (sum)
                        sum = sum + ", ";
                    sum = sum + TextGet("KinkyDungeonPlayerVibratedLocation" + l);
                }
            suff = ` (${sum})`;
        }
        statsDraw.vibe = {
            text: TextGet("KinkyDungeonPlayerVibrated" + Math.max(0, Math.min(Math.floor(KinkyDungeonVibeLevel), 5))) + suff,
            category: "kinky", color: "#ff8888", bgcolor: "#333333", priority: 11,
            icon: "Vibe" + Math.max(0, Math.min(Math.floor(KinkyDungeonVibeLevel), 5)),
        };
    }
    if (KDGameData.OrgasmStamina > 0) {
        statsDraw.sex = {
            text: TextGet("KinkyDungeonPlayerStatisfied"),
            icon: "Satisfied",
            category: "kinky", color: "#ff88aa", bgcolor: "#333333", priority: 7,
        };
    }
    else if (KDGameData.OrgasmTurns > KinkyDungeonOrgasmTurnsCrave) {
        statsDraw.sex = {
            text: TextGet("KinkyDungeonPlayerEdged"),
            icon: "Edged",
            category: "kinky", color: "#ff0000", bgcolor: "#333333", priority: 7,
        };
    }
    if (KDGameData.CurrentVibration && KDGameData.CurrentVibration.denyTimeLeft > 0) {
        statsDraw.deny = {
            text: TextGet("KinkyDungeonPlayerDenied"),
            icon: "Denied",
            category: "kinky", color: "#ff0000", bgcolor: "#333333", priority: 12,
        };
    }
    i = 0;
    for (let b of Object.values(KinkyDungeonPlayerBuffs)) {
        if ((b.aura || b.labelcolor) && b.duration > 0) {
            let count = b.maxCount > 1 ? b.maxCount - (b.currentCount ? b.currentCount : 0) : 0;
            let pri = 0;
            if (b.duration)
                pri += Math.min(90, b.duration);
            if (count)
                pri += Math.min(10, count);
            statsDraw[b.id] = {
                text: TextGet("KinkyDungeonBuff" + b.id) + (count ? ` ${count}/${b.maxCount}` : "") + ((b.duration > 1 && b.duration < 1000) ? ` (${b.duration})` : ""),
                count: (count ? `${count}/${b.maxCount}` : "") + ((b.duration > 1 && b.duration < 1000) ? ((count ? " " : "") + `${b.duration}`) : ""),
                icon: KDBuffSprites[b.id] ? "buff/buff" + b.id : undefined,
                category: "buffs", color: b.aura ? b.aura : b.labelcolor, bgcolor: "#333333", priority: pri,
            };
        }
    }
    i = 0;
    for (let perk of KinkyDungeonStatsChoice.keys()) {
        if (KDPerkIcons[perk] && KDPerkIcons[perk]()) {
            statsDraw["p" + perk] = {
                text: TextGet("KinkyDungeonStatDesc" + KinkyDungeonStatsPresets[perk].id),
                count: KDPerkCount[perk] ? KDPerkCount[perk]() : undefined,
                icon: "perk/perk" + perk,
                category: "perks", color: "#ffffff", bgcolor: "#333333", priority: 0,
            };
        }
    }
    let II = 0;
    let spriteSize = 46;
    let sorted = Object.values(statsDraw).sort((a, b) => {
        return (b.priority + KDStatsOrder[b.category]) - (a.priority + KDStatsOrder[a.category]);
    });
    let minYY = 510;
    let minXX = 1750;
    let maxXX = 2000 - 5 - spriteSize;
    let YY = minYY;
    let textWidth = 44;
    let XX = minXX;
    let XXspacing = spriteSize + 3;
    let YYspacing = spriteSize + 3;
    let currCategory = "";
    for (let stat of sorted) {
        if (XX > minXX && (KDStatsSkipLine[currCategory] || KDStatsSkipLineBefore[stat.category]) && currCategory != stat.category) {
            XX = minXX;
            YY += YYspacing;
        }
        currCategory = stat.category;
        if (stat.count)
            DrawTextFitKD(stat.count, XX + spriteSize / 2, YY + spriteSize / 2 - 10, textWidth, stat.countcolor || "#ffffff", "#000000", 16, undefined, 114, 0.8, 5);
        KDDraw(kdcanvas, kdpixisprites, "stat" + II, KinkyDungeonRootDirectory + "Buffs/" + (stat.icon || "buff/buff") + ".png", XX, YY - Math.ceil(spriteSize / 2), undefined, undefined);
        if (MouseIn(XX, YY - Math.ceil(spriteSize / 2), spriteSize, spriteSize)) {
            DrawTextFitKD(stat.text, XX - 10, YY, 1250, stat.color, "#000000", 22, "right", 160, 1.0, 8);
        }
        XX += XXspacing;
        if (XX > maxXX) {
            XX = minXX;
            YY += YYspacing;
        }
        II++;
    }
    KinkyDungeonDrawStruggleHover = false;
    if (!KDShowQuickInv() && ((KinkyDungeonDrawStruggle > 0 || MouseIn(0, 0, 500, 1000)) && KinkyDungeonStruggleGroups))
        for (let sg of KinkyDungeonStruggleGroups) {
            let ButtonWidth = 60;
            let x = 5 + ((!sg.left) ? (490 - ButtonWidth) : 0);
            let y = 42 + sg.y * (ButtonWidth + 46);
            let item = KinkyDungeonGetRestraintItem(sg.group);
            let drawLayers = 0;
            let MY = 200;
            let surfaceItems = [];
            let dynamicList = [];
            let noRefreshlists = false;
            if (KDStruggleGroupLinkIndex[sg.group] && item && item.dynamicLink) {
                surfaceItems = KDDynamicLinkListSurface(item);
                dynamicList = KDDynamicLinkList(item, true);
                noRefreshlists = true;
                if (!KDStruggleGroupLinkIndex[sg.group] || KDStruggleGroupLinkIndex[sg.group] >= surfaceItems.length) {
                    KDStruggleGroupLinkIndex[sg.group] = 0;
                }
                item = surfaceItems[KDStruggleGroupLinkIndex[sg.group]];
            }
            if (MouseIn(((!sg.left) ? (260) : 0), y - 48, 230, (ButtonWidth + 45)) && sg) {
                if (MouseY < y)
                    KinkyDungeonDrawInventorySelected(KDGetItemPreview(item), false, true, 500);
                let data = {
                    struggleGroup: sg,
                    struggleIndex: KDStruggleGroupLinkIndex ? KDStruggleGroupLinkIndex[sg.group] : 0,
                    surfaceItems: surfaceItems,
                    dynamicList: dynamicList,
                    item: item,
                    group: sg.group,
                    extraLines: [],
                    extraLineColor: [],
                };
                KinkyDungeonSendEvent("drawSGTooltip", data);
                let lastO = 0;
                if (data.extraLines.length > 0) {
                    for (let lineIndex = 0; lineIndex < data.extraLines.length; lineIndex++) {
                        DrawTextKD(data.extraLines[lineIndex], 530, MY + lastO * 45, data.extraLineColor[lineIndex] || "#ffffff", "#333333", undefined, "left");
                        lastO += 1;
                    }
                }
                let OInit = lastO;
                if (dynamicList.length > 0 || (item && item.dynamicLink)) {
                    if (!noRefreshlists) {
                        surfaceItems = KDDynamicLinkListSurface(item);
                        dynamicList = KDDynamicLinkList(item, true);
                    }
                    if (surfaceItems.length <= 1) {
                        delete KDStruggleGroupLinkIndex[sg.group];
                        drawLayers = 1;
                    }
                    else {
                        if (!KDStruggleGroupLinkIndex[sg.group] || KDStruggleGroupLinkIndex[sg.group] >= surfaceItems.length) {
                            KDStruggleGroupLinkIndex[sg.group] = 0;
                        }
                        item = surfaceItems[KDStruggleGroupLinkIndex[sg.group]];
                        drawLayers = 2;
                    }
                    let O = OInit + 1;
                    let drawn = false;
                    for (let d of dynamicList) {
                        if (d != item) {
                            drawn = true;
                            let msg = TextGet("Restraint" + d.name);
                            DrawTextKD(msg, 530, MY + O * 45, "#ffffff", "#333333", undefined, "left");
                            O++;
                        }
                    }
                    lastO = O;
                    O = OInit;
                    if (drawn) {
                        DrawTextKD(TextGet("KinkyDungeonItemsUnderneath"), 530, MY + O * 45, "#ffffff", "#333333", undefined, "left");
                    }
                    O = lastO + 1;
                }
                if (lastO)
                    lastO += 1;
                if (item && KDRestraint(item) && KinkyDungeonStrictness(false, KDRestraint(item).Group, item)) {
                    let strictItems = KinkyDungeonGetStrictnessItems(KDRestraint(item).Group, item);
                    let O = lastO + 1;
                    let drawn = false;
                    for (let s of strictItems) {
                        drawn = true;
                        let msg = TextGet("Restraint" + s);
                        DrawTextKD(msg, 530, MY + O * 45, "#ffffff", "#333333", undefined, "left");
                        O++;
                    }
                    O = lastO;
                    if (drawn) {
                        DrawTextKD(TextGet("KinkyDungeonItemsStrictness"), 530, MY + O * 45, "#ffffff", "#333333", undefined, "left");
                    }
                }
            }
            let color = "#ffffff";
            let locktext = "";
            if (item && item.lock) {
                color = "#ffaadd";
            }
            let GroupText = (sg.name && item) ? ("Restraint" + item.name) : ("KinkyDungeonGroup" + sg.group);
            DrawTextFitKD(TextGet(GroupText) + locktext, x + ((!sg.left) ? ButtonWidth - (drawLayers ? ButtonWidth : 0) : 0), y - 24, 240 - (drawLayers ? ButtonWidth : 0), color, "#333333", undefined, sg.left ? "left" : "right");
            if (drawLayers) {
                DrawButtonKDEx("surfaceItems" + sg.group, (bdata) => {
                    if (surfaceItems.length > 1 && MouseInKD("surfaceItems" + sg.group)) {
                        if (!KDStruggleGroupLinkIndex[sg.group])
                            KDStruggleGroupLinkIndex[sg.group] = 1;
                        else
                            KDStruggleGroupLinkIndex[sg.group] = KDStruggleGroupLinkIndex[sg.group] + 1;
                    }
                    return true;
                }, drawLayers == 2, x + (sg.left ? 240 - ButtonWidth : 12), y - ButtonWidth / 2 - 20, 48, 48, "", drawLayers == 2 ? "#ffffff" : "#888888", KinkyDungeonRootDirectory + "Layers.png", "");
            }
            i = 0;
            if (item && (MouseIn(((!sg.left) ? (260) : 0), y - 48, 230, (ButtonWidth + 45)) || KinkyDungeonDrawStruggle > 1)) {
                let r = KDRestraint(item);
                if (!KinkyDungeonDrawStruggleHover) {
                    KinkyDungeonDrawStruggleHover = true;
                }
                let buttons = ["Struggle", "CurseInfo", "CurseUnlock", "Cut", "Remove", "Pick"];
                if (KinkyDungeonControlsEnabled())
                    for (let button_index = 0; button_index < buttons.length; button_index++) {
                        let btn = buttons[sg.left ? button_index : (buttons.length - 1 - button_index)];
                        if (btn == "Struggle") {
                            DrawButtonVis(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Struggle.png", "", undefined, undefined, KDButtonColorIntense);
                            i++;
                        }
                        else if ((item.curse || r.curse) && btn == "CurseInfo") {
                            DrawButtonVis(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "CurseInfo.png", "", undefined, undefined, KDButtonColorIntense);
                            i++;
                        }
                        else if ((item.curse || r.curse) && btn == "CurseUnlock" && KinkyDungeonCurseAvailable(item, (item.curse || r.curse))) {
                            DrawButtonVis(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "CurseUnlock.png", "", undefined, undefined, KDButtonColorIntense);
                            i++;
                        }
                        else if (!(item.curse || r.curse) && !sg.blocked && btn == "Remove") {
                            let toolSprite = (item.lock) ? KDGetLockVisual(item) : "Buckle.png";
                            DrawButtonVis(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth, "", "#ffffff", KinkyDungeonRootDirectory + toolSprite, "", undefined, undefined, KDButtonColorIntense);
                            i++;
                        }
                        else if (!(item.curse || r.curse) && !sg.blocked && btn == "Cut"
                            && (KinkyDungeonAllWeapon().some((inv) => { return KDWeapon(inv).light && KDWeapon(inv).cutBonus != undefined; }) || KinkyDungeonGetAffinity(false, "Sharp"))
                            && !sg.noCut) {
                            let name = ((KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.name && !KinkyDungeonPlayerDamage.unarmed) ? "Items/" + KinkyDungeonPlayerDamage.name + ".png" : "Cut.png");
                            DrawButtonVis(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth, "", (sg.magic) ? "#8394ff" : "#ffffff", KinkyDungeonRootDirectory + name, "", undefined, undefined, KDButtonColorIntense, undefined, undefined, true);
                            i++;
                        }
                        else if (!(item.curse || r.curse) && !sg.blocked && btn == "Pick" && KinkyDungeonLockpicks > 0 && item.lock) {
                            DrawButtonVis(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "UseTool.png", "", undefined, undefined, KDButtonColorIntense);
                            i++;
                        }
                    }
            }
        }
    DrawButtonKDEx("RestHide", (bdata) => {
        KinkyDungeonDrawStruggle += 1;
        if (KinkyDungeonDrawStruggle > 2)
            KinkyDungeonDrawStruggle = 0;
        return true;
    }, true, 510, 925, 60, 60, "", KinkyDungeonStruggleGroups.length > 0 ? "#ffffff" : "#333333", KinkyDungeonRootDirectory + "Hide" + (KinkyDungeonDrawStruggle > 1 ? "Full" : (KinkyDungeonDrawStruggle > 0 ? "True" : "False")) + ".png", "");
    DrawButtonKDEx("SetPose", (bdata) => {
        KDPlayerSetPose = !KDPlayerSetPose;
        return true;
    }, true, 580, 925, 60, 60, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/SetPose.png", "", false, false, KDPlayerSetPose ? KDTextGray3 : KDButtonColor);
    if (KDPlayerSetPose)
        KDPlayerDrawPoseButtons(KinkyDungeonPlayer);
    DrawButtonVis(510, 825, 60, 90, "", "#ffffff", KinkyDungeonRootDirectory + (KinkyDungeonShowInventory ? "BackpackOpen.png" : "Backpack.png"), "");
    if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.special) {
        if (MouseIn(580, 825, 50, 90))
            DrawTextFitKD(TextGet("KinkyDungeonSpecial" + KinkyDungeonPlayerDamage.name), MouseX, MouseY - 150, 750, "#ffffff", "#333333");
        DrawButtonVis(580, 825, 50, 90, "", "#ffffff", KinkyDungeonRootDirectory + "Ranged.png", "");
    }
    if (KinkyDungeonTargetTile) {
        if (KDObjectDraw[KinkyDungeonTargetTile.Type]) {
            KDObjectDraw[KinkyDungeonTargetTile.Type]();
        }
    }
    let bx = 650 + 15;
    let bwidth = 165;
    let bspacing = 5;
    let bindex = 0;
    DrawButtonKDEx("goInv", (bdata) => {
        KinkyDungeonDrawState = "Inventory";
        return true;
    }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonInventory"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_inventory.png", undefined, undefined, false, "", 24, true);
    bindex++;
    DrawButtonKDEx("goRep", (bdata) => {
        KinkyDungeonDrawState = "Reputation";
        return true;
    }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonReputation"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_reputation.png", undefined, undefined, false, "", 24, true);
    bindex++;
    DrawButtonKDEx("goSpells", (bdata) => {
        KinkyDungeonDrawState = "MagicSpells";
        return true;
    }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonMagic"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_spells.png", undefined, undefined, false, "", 24, true);
    bindex++;
    let logtxt = KinkyDungeonNewLoreList.length > 0 ? TextGet("KinkyDungeonLogbookN").replace("N", KinkyDungeonNewLoreList.length) : TextGet("KinkyDungeonLogbook");
    DrawButtonKDEx("goLog", (bdata) => {
        KinkyDungeonDrawState = "Logbook";
        KinkyDungeonUpdateLore(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
        return true;
    }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, logtxt, "#ffffff", KinkyDungeonRootDirectory + "UI/button_logbook.png", undefined, undefined, false, "", 24, true);
    bindex++;
    bx = 650 + bindex * (bwidth + bspacing) + 45;
    bwidth = 145;
    bspacing = 5;
    bindex = 0;
    if (KinkyDungeonSpellChoices.length > KinkyDungeonSpellChoiceCountPerPage) {
        DrawButtonKDEx("CycleSpellButton", () => {
            KDCycleSpellPage();
            return true;
        }, true, 1650, 95, 90, 35, `pg. ${KDSpellPage}`, "#ffffff");
    }
    for (let ii = KinkyDungeonSpellChoiceCount - 1; ii > 0; ii--) {
        if (!(KinkyDungeonSpellChoices[ii] >= 0))
            KinkyDungeonSpellChoices = KinkyDungeonSpellChoices.slice(0, ii);
        else
            break;
    }
    let KDUpcastLevel = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SpellEmpower");
    if (KinkyDungeonSpellChoices.length > 0) {
        let empowerY = Math.min(7, KinkyDungeonSpellChoices.length);
        let empowerYY = empowerY * KinkyDungeonSpellChoiceOffset + 140;
        let hasUpcast = KDCanUpcast();
        let padY = 90 + (KinkyDungeonSpellChoices.length > KinkyDungeonSpellChoiceCountPerPage ? 0 : 40);
        let pages = Math.floor(KinkyDungeonSpellChoices.length / KinkyDungeonSpellChoiceCountPerPage);
        let pageExtra = 40;
        FillRectKD(kdcanvas, kdpixisprites, "spellbg", {
            Left: 1600 - pages * pageExtra, Top: padY, Width: 145 + pages * pageExtra,
            Height: empowerYY - padY + 80,
            Color: "#000000", alpha: 0.4, zIndex: 70
        });
        DrawButtonKDEx("empowerSpell", (bdata) => {
            KDSendInput("upcast", {});
            return true;
        }, true, 1700 - 80, empowerYY, 76, 76, "", "", KinkyDungeonRootDirectory + "Spells/" + KDEmpowerSprite + (hasUpcast ? "" : "Fail") + ".png", undefined, false, true);
        if (KDUpcastLevel > 0)
            DrawButtonKDEx("empowerSpellCancel", (bdata) => {
                KDSendInput("upcastcancel", {});
                return true;
            }, true, 1700 - 80, empowerYY + KinkyDungeonSpellChoiceOffset, 76, 76, "", "", KinkyDungeonRootDirectory + "Spells/" + KDEmpowerSprite + "Cancel" + ".png", undefined, false, true);
        if (MouseIn(1700 - 80, empowerYY, 76, 76)) {
            DrawTextFitKD(TextGet("KDSpellEmpower" + (hasUpcast ? "" : "Fail")), 1700 - 100, empowerYY + 40, 1000, "#ffffff", undefined, undefined, "right");
        }
        if (MouseIn(1700 - 80, empowerYY + KinkyDungeonSpellChoiceOffset, 76, 76)) {
            DrawTextFitKD(TextGet("KDSpellEmpowerCancel"), 1700 - 100, empowerYY + 40 + KinkyDungeonSpellChoiceOffset, 1000, "#ffffff", undefined, undefined, "right");
        }
    }
    for (i = 0; i < KinkyDungeonSpellChoiceCountPerPage; i++) {
        let index = i + KDSpellPage * KinkyDungeonSpellChoiceCountPerPage;
        let buttonWidth = 40;
        let buttonPad = 80;
        if (KinkyDungeonSpellChoices[i])
            DrawButtonVis(1650 + (90 - buttonWidth), 140 + i * KinkyDungeonSpellChoiceOffset, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "ChangeSpell.png", undefined, undefined, true);
        let tooltip = false;
        let buttonDim = {
            x: 1700 - buttonPad,
            y: 140 + i * KinkyDungeonSpellChoiceOffset,
            w: 76,
            h: 76,
            wsmall: 46,
            hsmall: 46,
        };
        if (KinkyDungeonSpells[KinkyDungeonSpellChoices[index]] && !KinkyDungeonSpells[KinkyDungeonSpellChoices[index]].passive) {
            let spell = KDGetUpcast(KinkyDungeonSpells[KinkyDungeonSpellChoices[index]].name, KDUpcastLevel) || KinkyDungeonSpells[KinkyDungeonSpellChoices[index]];
            let components = KinkyDungeonGetCompList(spell);
            let comp = "";
            if (spell.components && spell.components.length > 0)
                comp = components;
            let cost = Math.round(KinkyDungeonGetManaCost(spell) * 10) + "m";
            DrawTextFitKD(cost, 1650 + (89 - buttonWidth / 2), 140 + i * KinkyDungeonSpellChoiceOffset + buttonWidth * 1.4, buttonWidth * 0.35 * Math.min(3, cost.length), "#ccddFF", "#333333", undefined, "left");
            if (spell.type == "passive" && KinkyDungeonSpellChoicesToggle[index]) {
                FillRectKD(kdcanvas, kdpixisprites, "rectspell" + i, {
                    Left: 1700 - buttonPad - 4,
                    Top: 140 - 4 + i * KinkyDungeonSpellChoiceOffset,
                    Width: 84,
                    Height: 84,
                    Color: "#dbdbdb",
                    zIndex: 70,
                });
                FillRectKD(kdcanvas, kdpixisprites, "rectspell2" + i, {
                    Left: 1700 - buttonPad - 4 + 5,
                    Top: 140 - 4 + i * KinkyDungeonSpellChoiceOffset + 5,
                    Width: 74,
                    Height: 74,
                    Color: "#101010",
                    zIndex: 70,
                });
            }
            DrawButtonKD("SpellCast" + index, true, buttonDim.x, buttonDim.y, buttonDim.w, buttonDim.h, "", "rgba(0, 0, 0, 0)", KinkyDungeonRootDirectory + "Spells/" + spell.name + ".png", "", false, true);
            if ((KinkyDungeoCheckComponents(spell).length > 0 || (spell.components.includes("Verbal") && !KinkyDungeonStatsChoice.get("Incantation") && KinkyDungeonGagTotal() > 0 && !spell.noMiscast))) {
                let sp = "SpellFail";
                if (spell.components.includes("Verbal") && !KinkyDungeonStatsChoice.get("Incantation") && KinkyDungeonGagTotal() < 1) {
                    sp = "SpellFailPartial";
                }
                KDDraw(kdcanvas, kdpixisprites, "spellFail" + "SpellCast" + i, KinkyDungeonRootDirectory + "Spells/" + sp + ".png", buttonDim.x, buttonDim.y, buttonDim.w, buttonDim.h, undefined, {
                    zIndex: 115,
                });
            }
            if (KDHasUpcast(spell.name)) {
                KDDraw(kdcanvas, kdpixisprites, "spellCanUpcast" + i, KinkyDungeonRootDirectory + "Spells/" + "CanUpcast" + ".png", buttonDim.x, buttonDim.y, 72, 72, undefined, {
                    zIndex: 114,
                });
            }
            if (MouseIn(buttonDim.x, buttonDim.y, buttonDim.w, buttonDim.h)) {
                DrawTextFitKD(TextGet("KinkyDungeonSpell" + spell.name), 1700 - buttonPad - 30, 140 + buttonPad / 2 + i * KinkyDungeonSpellChoiceOffset, 300, "#ffffff", "#333333", undefined, "right");
                DrawTextFitKD(comp, 1700 - 2 - buttonPad / 2, 200 + i * KinkyDungeonSpellChoiceOffset, Math.min(10 + comp.length * 8, buttonPad), "#ffffff", KDTextGray0);
                tooltip = true;
            }
            DrawTextFitKD((i + 1) + "", buttonDim.x + 10, buttonDim.y + 13, 10, "#ffffff", KDTextGray0);
        }
        if (!tooltip) {
            let icon = 0;
            for (let page = 1; page <= Math.floor((KinkyDungeonSpellChoices.length - 1) / KinkyDungeonSpellChoiceCountPerPage); page += 1) {
                let pg = KDSpellPage + page;
                if (pg > Math.floor(KinkyDungeonSpellChoices.length / KinkyDungeonSpellChoiceCountPerPage))
                    pg -= 1 + Math.floor((KinkyDungeonSpellChoices.length - 1) / KinkyDungeonSpellChoiceCountPerPage);
                let indexPaged = (i + pg * KinkyDungeonSpellChoiceCountPerPage) % (KinkyDungeonSpellChoiceCount);
                let spellPaged = KinkyDungeonSpells[KinkyDungeonSpellChoices[indexPaged]];
                if (spellPaged) {
                    if (spellPaged.type == "passive" && KinkyDungeonSpellChoicesToggle[indexPaged]) {
                        FillRectKD(kdcanvas, kdpixisprites, page + "pgspell" + i, {
                            Left: 1700 - buttonPad - 4 - buttonDim.wsmall * page,
                            Top: 140 - 4 + i * KinkyDungeonSpellChoiceOffset,
                            Width: 54,
                            Height: 54,
                            Color: "#333333",
                            zIndex: 70,
                        });
                        FillRectKD(kdcanvas, kdpixisprites, page + "pgspell2" + i, {
                            Left: 1700 - buttonPad - 4 - buttonDim.wsmall * page + 5,
                            Top: 140 - 4 + i * KinkyDungeonSpellChoiceOffset + 5,
                            Width: 44,
                            Height: 44,
                            Color: KDTextGray0,
                            zIndex: 70,
                        });
                    }
                    icon += 1;
                    DrawButtonKD("SpellCast" + indexPaged, true, buttonDim.x - buttonDim.wsmall * page, buttonDim.y, buttonDim.wsmall, buttonDim.hsmall, "", "rgba(0, 0, 0, 0)", "", "", false, true);
                    KDDraw(kdcanvas, kdpixisprites, "spellIcon" + icon + "," + indexPaged, KinkyDungeonRootDirectory + "Spells/" + spellPaged.name + ".png", buttonDim.x - buttonDim.wsmall * page, buttonDim.y, buttonDim.wsmall, buttonDim.hsmall, undefined, {
                        zIndex: 114,
                    });
                    if ((KinkyDungeoCheckComponents(spellPaged).length > 0 || (spellPaged.components.includes("Verbal") && !KinkyDungeonStatsChoice.get("Incantation") && KinkyDungeonGagTotal() > 0 && !spellPaged.noMiscast))) {
                        let sp = "SpellFail";
                        if (spellPaged.components.includes("Verbal") && !KinkyDungeonStatsChoice.get("Incantation") && KinkyDungeonGagTotal() < 1) {
                            sp = "SpellFailPartial";
                        }
                        KDDraw(kdcanvas, kdpixisprites, "spellFail" + icon + "," + page + "," + indexPaged, KinkyDungeonRootDirectory + "Spells/" + sp + ".png", buttonDim.x + 2 - buttonDim.wsmall * page, buttonDim.y + 2, buttonDim.wsmall, buttonDim.hsmall, undefined, {
                            zIndex: 115,
                        });
                    }
                }
            }
        }
    }
    KinkyDungeonMultiplayerUpdate(KinkyDungeonNextDataSendTimeDelayPing);
}
function KDCycleSpellPage(reverse) {
    if (reverse) {
        if (KDSpellPage <= 0) {
            KDSpellPage = KinkyDungeonSpellChoices.length - 1;
        }
        else
            KDSpellPage -= 1;
    }
    else if (KDSpellPage * KinkyDungeonSpellChoiceCountPerPage + KinkyDungeonSpellChoiceCountPerPage >= KinkyDungeonSpellChoices.length) {
        KDSpellPage = 0;
    }
    else
        KDSpellPage += 1;
}
function KinkyDungeonCanSleep() {
    if (KDGameData.CurrentVibration)
        return false;
    else
        return true;
}
function KDLinspace(min, max, steps) {
    if (steps == 0 || Number.isNaN(steps))
        return [];
    let spaces = [];
    for (let i = 0; i < steps; i += 1) {
        spaces.push(min + i * (max - min) / steps);
    }
    return spaces;
}
function KDSteps(max, step, maxStep = 20) {
    if (step == 0 || Number.isNaN(step))
        return [];
    let spaces = [];
    for (let i = 0; i < Math.ceil(Math.abs(max / step)) && i < maxStep; i += 1) {
        spaces.push(step > 0 ? step * i : max + step * i);
    }
    return spaces;
}
function KinkyDungeonDrawStats(x, y, width, heightPerBar) {
    let buttonWidth = 48;
    let suff = (!KinkyDungeonCanDrink()) ? "Unavailable" : "";
    if (suff == "Unavailable") {
        let allowPotions = KinkyDungeonPotionCollar();
        if (allowPotions)
            suff = "Inject";
    }
    let buttonOff = 5;
    let offBarHeight = heightPerBar * 0.12;
    let distRate = KDGetDistractionRate(0);
    KinkyDungeonBar(x, y + heightPerBar * 0.45, width, heightPerBar * 0.45, 100 * KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax, "#ff5277", "#692464", KDGameData.LastAP / KinkyDungeonStatDistractionMax * 100, "#ffa1b4", distRate < 0 ? KDSteps(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax, KDGetDistractionRate(0) / KinkyDungeonStatDistractionMax, 3) : undefined, distRate < 0 ? "#692464" : undefined, distRate < 0 ? "#692464" : undefined);
    if (KinkyDungeonStatDistractionLower / KinkyDungeonStatDistractionMax >= 0.05)
        KDDraw(kdcanvas, kdpixisprites, "dist_lower", KinkyDungeonRootDirectory + "UI/Heart.png", x - heightPerBar * 0.32 + width * KinkyDungeonStatDistractionLower / KinkyDungeonStatDistractionMax, y + heightPerBar * 0.53, undefined, undefined, undefined, {
            zIndex: 150,
        });
    DrawTextFitKD(TextGet("StatDistraction").replace("PERCENT", "" + Math.round(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax * 100)), x + width, y + 10, width - 2 * buttonWidth, (KinkyDungeonStatDistraction > 0) ? "#ffffff" : "pink", "#333333", 24, "right");
    DrawButtonVis(x, y - buttonOff, buttonWidth, buttonWidth, "", (KinkyDungeonStatDistraction > 0 && KinkyDungeonItemCount("PotionFrigid")) ? "#333333" : "Pink", KinkyDungeonRootDirectory + "UI/UsePotion" + ((suff == "Unavailable") ? "" : "Frigid") + suff + ".png", "", false, true);
    DrawTextFitKD("x" + KinkyDungeonItemCount("PotionFrigid"), x + buttonWidth, y + 10, buttonWidth, "#ffffff", "#333333", 18);
    let attackCost = Math.min(-0.5, KDAttackCost());
    KinkyDungeonBar(x, y + heightPerBar * 1.45, width, heightPerBar * 0.45, 100 * KinkyDungeonStatStamina / KinkyDungeonStatStaminaMax, "#63ab3f", "#283540", KDGameData.LastSP / KinkyDungeonStatStaminaMax * 100, "#ffee83", KDSteps(KinkyDungeonStatStamina / KinkyDungeonStatStaminaMax, attackCost / KinkyDungeonStatStaminaMax), "#283540", "#63ab3f");
    DrawTextFitKD(TextGet("StatStamina").replace("MAX", KinkyDungeonStatStaminaMax * 10 + "").replace("CURRENT", Math.floor(KinkyDungeonStatStamina * 10) + ""), x + width, y + 10 + heightPerBar, width - 2 * buttonWidth, (KinkyDungeonStatStamina > 0.5) ? "#ffffff" : "pink", "#333333", 24, "right");
    DrawButtonVis(x, y + heightPerBar - buttonOff, buttonWidth, buttonWidth, "", (KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax && KinkyDungeonItemCount("PotionStamina")) ? "#AAFFAA" : "#333333", KinkyDungeonRootDirectory + "UI/UsePotion" + ((suff == "Unavailable") ? "" : "Stamina") + suff + ".png", "", false, true);
    DrawTextFitKD("x" + KinkyDungeonItemCount("PotionStamina"), x + buttonWidth, y + 1 * heightPerBar + 10, buttonWidth, "#ffffff", "#333333", 18);
    KinkyDungeonBar(x, y + heightPerBar * 2.45, width, heightPerBar * 0.45, 100 * KinkyDungeonStatMana / KinkyDungeonStatManaMax, "#4fa4b8", "#4c6885", KDGameData.LastMP / KinkyDungeonStatManaMax * 100, "#92e8c0", KDLinspace(0, 1, Math.ceil(KinkyDungeonStatManaMax / 5)), "#4c6885", "#4fa4b8");
    KinkyDungeonBar(x, y + heightPerBar * 2.9 - offBarHeight, width, offBarHeight, 100 * KinkyDungeonStatManaPool / KinkyDungeonStatManaPoolMax, "#efefff", "none", undefined, undefined, undefined, undefined, undefined, 56);
    DrawTextFitKD(TextGet("StatMana").replace("MAX", KinkyDungeonStatManaMax * 10 + "").replace("CURRENT", Math.floor(KinkyDungeonStatMana * 10) + ""), x + width, y + 10 + heightPerBar * 2, width - 2 * buttonWidth, (KinkyDungeonStatMana > 0.5) ? "#ffffff" : "pink", "#333333", 24, "right");
    DrawButtonVis(x, y + 2 * heightPerBar - buttonOff, buttonWidth, buttonWidth, "", (KinkyDungeonStatMana < KinkyDungeonStatManaMax && KinkyDungeonItemCount("PotionMana")) ? "#AAAAFF" : "#333333", KinkyDungeonRootDirectory + "UI/UsePotion" + ((suff == "Unavailable") ? "" : "Mana") + suff + ".png", "", false, true);
    DrawTextFitKD("x" + KinkyDungeonItemCount("PotionMana"), x + buttonWidth, y + 2 * heightPerBar + 10, buttonWidth, "#ffffff", "#333333", 18, "left");
    KinkyDungeonBar(x, y + heightPerBar * 3.45, width, heightPerBar * 0.45, 100 * KinkyDungeonStatWill / KinkyDungeonStatWillMax, "#ff4444", "#222222", KDGameData.LastWP / KinkyDungeonStatWillMax * 100, "#aa0000", KDLinspace(0, 1, 4), "#222222", "#ff4444");
    DrawTextFitKD(TextGet("StatWill").replace("MAX", KinkyDungeonStatWillMax * 10 + "").replace("CURRENT", Math.floor(KinkyDungeonStatWill * 10) + ""), x + width, y + 10 + heightPerBar * 3, width - 2 * buttonWidth, (KinkyDungeonStatWill > 0.5) ? "#ffffff" : "pink", "#333333", 24, "right");
    DrawButtonVis(x, y + 3 * heightPerBar - buttonOff, buttonWidth, buttonWidth, "", (KinkyDungeonStatWill < KinkyDungeonStatWillMax && KinkyDungeonItemCount("PotionWill")) ? "#ff4444" : "#333333", KinkyDungeonRootDirectory + "UI/UsePotion" + ((suff == "Unavailable") ? "" : "Will") + suff + ".png", "", false, true);
    DrawTextFitKD("x" + KinkyDungeonItemCount("PotionWill"), x + buttonWidth, y + 3 * heightPerBar + 10, buttonWidth, "#ffffff", "#333333", 18, "left");
    if (KDGameData.AncientEnergyLevel > 0 || KinkyDungeonInventoryGet("AncientPowerSource")) {
        KinkyDungeonBar(x, y + heightPerBar * 4.45, width, heightPerBar * 0.45, 100 * KDGameData.AncientEnergyLevel, "#ffee83", "#3b2027", 100 * KDGameData.OrigEnergyLevel, "#ffffff");
        DrawTextFitKD(TextGet("StatAncient").replace("PERCENT", Math.round(KDGameData.AncientEnergyLevel * 1000) + ""), x + width, y + 10 + heightPerBar * 4, width - 2 * buttonWidth, (KDGameData.AncientEnergyLevel > 0.01) ? "#ffffff" : "pink", "#333333", 24, "right");
        DrawButtonKDEx("potionAncient", (bdata) => {
            KDSendInput("consumable", { item: "AncientPowerSource", quantity: 1 });
            return true;
        }, KDGameData.AncientEnergyLevel < 1.0 && KinkyDungeonItemCount("AncientPowerSource"), x, y + 4 * heightPerBar - buttonOff, buttonWidth, buttonWidth, "", (KDGameData.AncientEnergyLevel < 1.0 && KinkyDungeonItemCount("AncientPowerSource")) ? "#ffee83" : "#333333", KinkyDungeonRootDirectory + "UI/UsePotionAncientInject.png", "", false, true);
        DrawTextFitKD("x" + KinkyDungeonItemCount("AncientPowerSource"), x + buttonWidth, y + 4 * heightPerBar + 10, buttonWidth, "#ffffff", "#333333", 18, "left");
    }
    let ttOffset = 250;
    if (MouseIn(x, y + heightPerBar * 0.45, width, heightPerBar * 0.45)) {
        DrawTextFitKD(TextGet("TooltipDistraction"), x - ttOffset, MouseY, 1000, "#ffffff", "#333333", 20, "right");
    }
    if (MouseIn(x, y + heightPerBar * 1.45, width, heightPerBar * 0.45)) {
        DrawTextFitKD(TextGet("TooltipStamina"), x - ttOffset, MouseY, 1000, "#ffffff", "#333333", 20, "right");
    }
    if (MouseIn(x, y + heightPerBar * 2.45, width, heightPerBar * 0.45)) {
        DrawTextFitKD(TextGet("TooltipMana").replace("POOLMANA", "" + KinkyDungeonStatManaPoolMax * 10), x - ttOffset, MouseY, 1000, "#ffffff", "#333333", 20, "right");
    }
    if (MouseIn(x, y + heightPerBar * 3.45, width, heightPerBar * 0.45)) {
        DrawTextFitKD(TextGet("TooltipWill"), x - ttOffset, MouseY, 1000, "#ffffff", "#333333", 20, "right");
    }
    if ((KDGameData.AncientEnergyLevel > 0 || KinkyDungeonInventoryGet("AncientPowerSource")) && MouseIn(x, y + heightPerBar * 4.45, width, heightPerBar * 0.45)) {
        DrawTextFitKD(TextGet("TooltipCharge"), x - ttOffset, MouseY, 1000, "#ffffff", "#333333", 20, "right");
    }
    let i = 4.6;
    let itemsAdj = 20;
    itemsAdj = 25;
    let fs = 18;
    let textheight = 15;
    KDDraw(kdcanvas, kdpixisprites, "pick", KinkyDungeonRootDirectory + "Items/Pick.png", x, y + 40 - 25 + i * heightPerBar + itemsAdj, 50, 50);
    DrawTextFitKD("" + KinkyDungeonLockpicks, x + 25, y + textheight + i * heightPerBar + itemsAdj, 50, "#ffffff", "#333333", fs);
    if (MouseIn(x, y + 40 - 40 + i * heightPerBar + itemsAdj, 50, 50))
        DrawTextKD(TextGet("KinkyDungeonInventoryItemLockpick"), MouseX - 10, MouseY, "#ffffff", "#333333");
    KDDraw(kdcanvas, kdpixisprites, "redkey", KinkyDungeonRootDirectory + "Items/RedKey.png", x + 50, y + 40 - 25 + i * heightPerBar + itemsAdj, 50, 50);
    DrawTextFitKD("" + KinkyDungeonRedKeys, x + 50 + 25, y + textheight + i * heightPerBar + itemsAdj, 50, "#ffffff", "#333333", fs);
    if (MouseIn(x + 50, y + 40 - 40 + i * heightPerBar + itemsAdj, 50, 50))
        DrawTextKD(TextGet("KinkyDungeonInventoryItemRedKey"), MouseX - 10, MouseY, "#ffffff", "#333333");
    if (KinkyDungeonBlueKeys > 0) {
        KDDraw(kdcanvas, kdpixisprites, "bluekey", KinkyDungeonRootDirectory + "Items/BlueKey.png", x + 100, y + 40 - 25 + i * heightPerBar + itemsAdj, 50, 50);
        DrawTextFitKD("" + KinkyDungeonBlueKeys, x + 50 + 50 + 25, y + textheight + i * heightPerBar + itemsAdj, 50, "#ffffff", "#333333", fs);
        if (MouseIn(x + 100, y + 40 - 40 + i * heightPerBar + itemsAdj, 50, 50))
            DrawTextKD(TextGet("KinkyDungeonInventoryItemMagicKey"), MouseX - 10, MouseY, "#ffffff", "#333333");
    }
    KDDraw(kdcanvas, kdpixisprites, "gold", KinkyDungeonRootDirectory + "Items/Gold.png", x + 150, y + 40 - 40 + i * heightPerBar + itemsAdj, 80, 80);
    DrawTextFitKD("" + KinkyDungeonGold, x + 50 + 50 + 50 + 40, y + textheight + i * heightPerBar + itemsAdj, 50, "#ffffff", "#333333", fs);
    if (MouseIn(x + 150, y + 40 - 40 + i * heightPerBar + itemsAdj, 80, 80))
        DrawTextKD(TextGet("KinkyDungeonInventoryItemGold"), MouseX - 10, MouseY, "#ffffff", "#333333");
    let switchAdj = 460;
    let actionButtonAdj = 460;
    let actionBarWidth = 64;
    let actionBarSpacing = actionBarWidth + 5;
    let actionBarII = 0;
    let actionBarXX = 1360;
    let actionBarYY = 925;
    if (KDToggles.TurnCounter)
        DrawTextKD(TextGet("TurnCounter") + KinkyDungeonCurrentTick, 1995, 995, "#ffffff", "#333333", 12, "right");
    DrawButtonKDEx("switchWeapon", (bdata) => {
        if (!KinkyDungeonControlsEnabled())
            return false;
        KDSwitchWeapon();
        return true;
    }, KDGameData.PreviousWeapon != undefined, x, y + i * heightPerBar + switchAdj, width + 5, 60, "", "#ffffff", undefined, undefined, undefined, true);
    if (KDGameData.PreviousWeapon)
        KDDraw(kdcanvas, kdpixisprites, "previousweapon", KinkyDungeonRootDirectory + "Items/" + KDGameData.PreviousWeapon + ".png", x + width - 40 + 10, y + switchAdj + 10 + i * heightPerBar, 40, 40);
    if (KinkyDungeonPlayerWeapon) {
        DrawTextFitKD(TextGet("StatWeapon") + TextGet("KinkyDungeonInventoryItem" + KinkyDungeonPlayerWeapon), x + (width - 80) / 2, y + switchAdj + 30 + i * heightPerBar, width - 80, "#ffffff", "#333333", 24);
        KDDraw(kdcanvas, kdpixisprites, "currentweapon", KinkyDungeonRootDirectory + "Items/" + KinkyDungeonPlayerWeapon + ".png", x + width - 100 + 20, y + switchAdj + i * heightPerBar, 60, 60);
    }
    let playColor = "#283540";
    if (KinkyDungeonCanTryOrgasm()) {
        playColor = "#ff5277";
    }
    else if (KinkyDungeonCanPlayWithSelf()) {
        if (KinkyDungeonStatDistraction < KinkyDungeonStatDistractionMax * KinkyDungeonDistractionSleepDeprivationThreshold)
            playColor = "#4b1d52";
        else if (KinkyDungeonStatDistraction < KinkyDungeonStatDistractionMax * 0.5)
            playColor = "#692464";
        else if (KinkyDungeonStatDistraction < KinkyDungeonStatDistractionMax * 0.75)
            playColor = "#9c2a70";
        else
            playColor = "#cc2f7b";
    }
    else
        playColor = "#283540";
    DrawButtonKDEx("PlayButton", (bdata) => {
        if (!KinkyDungeonControlsEnabled())
            return false;
        if (KinkyDungeonCanTryOrgasm()) {
            KDSendInput("tryOrgasm", {});
        }
        else if (KinkyDungeonCanPlayWithSelf()) {
            KDSendInput("tryPlay", {});
        }
        else {
            KinkyDungeonSendActionMessage(10, TextGet("KDNotFeeling"), "#ff0000", 1, false, true);
        }
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", playColor, KinkyDungeonRootDirectory + (KinkyDungeonCanTryOrgasm() ? "UI/LetGo.png" : (KDGameData.OrgasmTurns > KinkyDungeonOrgasmTurnsCrave ? "UI/Edged.png" : "UI/Play.png")), undefined, undefined, !KinkyDungeonCanTryOrgasm());
    DrawButtonKDEx("WaitButton", (bdata) => {
        if (!KinkyDungeonControlsEnabled())
            return false;
        if (KinkyDungeonAutoWait) {
            KinkyDungeonAutoWait = false;
            KinkyDungeonTempWait = false;
            KinkyDungeonAutoWaitSuppress = false;
        }
        else {
            KinkyDungeonAutoWait = true;
            KinkyDungeonTempWait = true;
            KinkyDungeonAutoWaitSuppress = true;
            KinkyDungeonSleepTime = CommonTime() + 100;
        }
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "", KinkyDungeonRootDirectory + (KDGameData.KinkyDungeonLeashedPlayer ? "UI/WaitJail.png" : "UI/Wait.png"), undefined, undefined, !KinkyDungeonAutoWait);
    DrawButtonKDEx("AutoStruggle", (bdata) => {
        if (!KinkyDungeonControlsEnabled())
            return false;
        KDAutoStruggleClick();
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "", KinkyDungeonRootDirectory + ("UI/AutoStruggle.png"), undefined, undefined, !KinkyDungeonAutoWaitStruggle);
    DrawButtonKDEx("HelpButton", (bdata) => {
        if (!KinkyDungeonControlsEnabled())
            return false;
        KDSendInput("noise", {});
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "#aaaaaa", KinkyDungeonRootDirectory + ("UI/Help.png"), undefined, undefined, true);
    DrawButtonKDEx("togglePass", (bdata) => {
        KinkyDungeonToggleAutoPass = !KinkyDungeonToggleAutoPass;
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "", KinkyDungeonRootDirectory + (KinkyDungeonToggleAutoPass ? "UI/Pass.png" : "UI/NoPass.png"), undefined, undefined, !KinkyDungeonToggleAutoPass);
    DrawButtonKDEx("toggleSprint", () => { KinkyDungeonToggleAutoSprint = !KinkyDungeonToggleAutoSprint; return true; }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "", KinkyDungeonRootDirectory + (KinkyDungeonToggleAutoSprint ? "UI/Sprint.png" : "UI/NoSprint.png"), undefined, undefined, !KinkyDungeonToggleAutoSprint);
    DrawButtonKDEx("toggleDoor", (bdata) => {
        KinkyDungeonToggleAutoDoor = !KinkyDungeonToggleAutoDoor;
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "", KinkyDungeonRootDirectory + (KinkyDungeonToggleAutoDoor ? "UI/DoorClose.png" : "UI/Door.png"), undefined, undefined, !KinkyDungeonToggleAutoDoor);
    DrawButtonKDEx("toggleFastMove", (bdata) => {
        if (!KinkyDungeonFastMoveSuppress)
            KinkyDungeonFastMove = !KinkyDungeonFastMove;
        KinkyDungeonFastMoveSuppress = false;
        KinkyDungeonFastMovePath = [];
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "", KinkyDungeonRootDirectory + (KinkyDungeonFastMove ? "FastMove" : "FastMoveOff") + ".png", undefined, undefined, !KinkyDungeonFastMove);
    DrawButtonKDEx("toggleInspect", (bdata) => {
        KinkyDungeonInspect = !KinkyDungeonInspect;
        return true;
    }, true, actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, actionBarWidth, 60, "", "", KinkyDungeonRootDirectory + (KinkyDungeonInspect ? "UI/Inspect" : "UI/Inspect") + ".png", undefined, undefined, !KinkyDungeonInspect);
    let str = "";
    actionBarII = 0;
    if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = KinkyDungeonCanTryOrgasm() ? "KDLetGo" : "KDPlay";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDWait";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDAutoStruggle";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDHelp";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDPass";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDSprint";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDDoor";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDAutoPath";
    }
    else if (MouseIn(actionBarXX + actionBarSpacing * actionBarII++, actionBarYY, 75, 64)) {
        str = "KDInspect";
    }
    else if (MouseIn(x, y + i * heightPerBar + switchAdj, width + 5, 60)) {
        str = "KDSwitchWeapon";
        if (KinkyDungeonPlayerWeapon) {
            let inv = KinkyDungeonInventoryGet(KinkyDungeonPlayerWeapon);
            if (inv)
                KinkyDungeonDrawInventorySelected(KDGetItemPreview(inv));
        }
    }
    if (str) {
        DrawTextFitKD(TextGet(str), Math.min(1900, MouseX), y + i * heightPerBar + actionButtonAdj - 15, 250, "#ffffff", undefined, 18);
    }
}
function KDAutoStruggleClick() {
    if (KinkyDungeonAutoWaitStruggle) {
        KDDisableAutoWait();
        KinkyDungeonTempWait = false;
        KinkyDungeonAutoWaitSuppress = false;
    }
    else {
        KinkyDungeonAutoWaitStruggle = true;
        KinkyDungeonSleepTime = CommonTime() + 100;
    }
}
function KinkyDungeonActivateWeaponSpell(instant) {
    if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.special) {
        let energyCost = KinkyDungeonPlayerDamage.special.energyCost;
        if (KDGameData.AncientEnergyLevel < energyCost) {
            KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonInsufficientEnergy"), "#ff0000", 1);
            return true;
        }
        if (KinkyDungeonPlayerDamage.special.selfCast) {
            KinkyDungeonTargetingSpellWeapon = KinkyDungeonPlayerDamage;
            KDStartSpellcast(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonFindSpell(KinkyDungeonPlayerDamage.special.spell, true), undefined, KinkyDungeonPlayerEntity, undefined, {
                targetingSpellWeapon: KinkyDungeonTargetingSpellWeapon,
            });
            KinkyDungeonTargetingSpellWeapon = null;
        }
        else if (!instant) {
            KinkyDungeonTargetingSpell = KinkyDungeonFindSpell(KinkyDungeonPlayerDamage.special.spell, true);
            KinkyDungeonTargetingSpellWeapon = KinkyDungeonPlayerDamage;
            KDModalArea = false;
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = null;
        }
        else {
            KinkyDungeonTargetingSpellWeapon = KinkyDungeonPlayerDamage;
            KDStartSpellcast(KinkyDungeonTargetX, KinkyDungeonTargetY, KinkyDungeonFindSpell(KinkyDungeonPlayerDamage.special.spell, true), undefined, KinkyDungeonPlayerEntity, undefined, {
                targetingSpellWeapon: KinkyDungeonTargetingSpellWeapon,
            });
            KinkyDungeonTargetingSpellWeapon = KinkyDungeonPlayerDamage;
        }
        return true;
    }
    return false;
}
function KinkyDungeonRangedAttack() {
    if (!KinkyDungeonPlayerDamage.special)
        return;
    if (KinkyDungeonPlayerDamage.special.type) {
        if (KinkyDungeonPlayerDamage.special.type == "hitorspell") {
            KinkyDungeonTargetingSpell = { name: "WeaponAttack", components: [], level: 1, type: "special", special: "weaponAttackOrSpell", noMiscast: true, manacost: 0,
                onhit: "", time: 25, power: 0, range: KinkyDungeonPlayerDamage.special.range ? KinkyDungeonPlayerDamage.special.range : 1.5, size: 1, damage: "" };
            KinkyDungeonTargetingSpellWeapon = KinkyDungeonPlayerDamage;
            KDModalArea = false;
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = null;
            return true;
        }
        else if (KinkyDungeonPlayerDamage.special.type == "attack") {
            KinkyDungeonTargetingSpell = { name: "WeaponAttack", components: [], level: 1, type: "special", special: "weaponAttack", noMiscast: true, manacost: 0,
                onhit: "", time: 25, power: 0, range: KinkyDungeonPlayerDamage.special.range ? KinkyDungeonPlayerDamage.special.range : 1.5, size: 1, damage: "" };
            KinkyDungeonTargetingSpellWeapon = KinkyDungeonPlayerDamage;
            KDModalArea = false;
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = null;
            return true;
        }
        else if (KinkyDungeonPlayerDamage.special.type == "ignite") {
            KDCreateEffectTile(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, {
                name: "Ignition",
                duration: 1,
            }, 0);
            return true;
        }
        else {
            return KinkyDungeonActivateWeaponSpell();
        }
    }
    return false;
}
let KDModalArea_x = 600;
let KDModalArea_y = 700;
let KDModalArea_width = 800;
let KDModalArea_height = 100;
let KDModalArea = true;
let KDConfirmDeleteSave = false;
function KinkyDungeonHandleHUD() {
    let buttonWidth = 48;
    if (KinkyDungeonDrawState == "Game") {
        if (KinkyDungeonShowInventory) {
            KinkyDungeonhandleQuickInv();
            return true;
        }
        if (KinkyDungeonMessageToggle) {
            if (MouseIn(500, KDLogTopPad, 1250, KDLogHeight + 175)) {
                return true;
            }
        }
        if (KinkyDungeonIsPlayer() && MouseIn(canvasOffsetX, canvasOffsetY, KinkyDungeonCanvas.width, KinkyDungeonCanvas.height))
            KinkyDungeonSetTargetLocation();
        if (MouseIn(510, 825, 60, 90)) {
            KinkyDungeonShowInventory = !KinkyDungeonShowInventory;
            return true;
        }
        else if (KinkyDungeonIsPlayer() && MouseIn(580, 825, 50, 90) && KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.special) {
            return KinkyDungeonRangedAttack();
        }
        if ((ServerURL == "foobar" && MouseIn(1880, 82, 100, 50)) || (ServerURL != "foobar" && MouseIn(1750, 20, 100, 50))) {
            KinkyDungeonDrawState = "Restart";
            KDConfirmDeleteSave = false;
            if (KDDebugMode) {
                ElementCreateTextArea("DebugEnemy");
                ElementValue("DebugEnemy", "Maidforce");
                ElementCreateTextArea("DebugItem");
                ElementValue("DebugItem", "TrapArmbinder");
            }
            return true;
        }
        if (!KinkyDungeonTargetingSpell) {
            KinkyDungeonSpellPress = "";
            if (KinkyDungeonHandleSpell())
                return true;
        }
        else {
            KinkyDungeonSpellPress = "";
        }
        if (KinkyDungeonIsPlayer() && KinkyDungeonTargetTile) {
            if (KinkyDungeonTargetTile.Type &&
                ((KinkyDungeonTargetTile.Type == "Lock" && KinkyDungeonTargetTile.Lock) || (KinkyDungeonTargetTile.Type == "Door" && KinkyDungeonTargetTile.Lock))) {
                if (KinkyDungeonLockpicks > 0 && (KinkyDungeonTargetTile.Lock.includes("Red") || KinkyDungeonTargetTile.Lock.includes("Blue")) && MouseIn(KDModalArea_x + 313, KDModalArea_y + 25, 112, 60)) {
                    KDSendInput("pick", { targetTile: KinkyDungeonTargetTileLocation });
                    return true;
                }
                if (((KinkyDungeonTargetTile.Lock.includes("Red") && KinkyDungeonRedKeys > 0)
                    || (KinkyDungeonTargetTile.Lock.includes("Blue") && KinkyDungeonBlueKeys > 0)) && MouseIn(KDModalArea_x + 175, KDModalArea_y + 25, 112, 60)) {
                    KDSendInput("unlock", { targetTile: KinkyDungeonTargetTileLocation });
                    return true;
                }
                if (((KinkyDungeonTargetTile.Lock.includes("Purple") && KinkyDungeonStatMana > KinkyDungeonGetManaCost(KinkyDungeonFindSpell("CommandWord", true)))) && MouseIn(KDModalArea_x + 175, KDModalArea_y + 25, 112, 60)) {
                    KDSendInput("commandunlock", { targetTile: KinkyDungeonTargetTileLocation });
                    return true;
                }
            }
            else if (KinkyDungeonTargetTile.Type == "Shrine") {
                if (KinkyDungeonHandleShrine()) {
                    return true;
                }
            }
            else if (KDObjectHandle[KinkyDungeonTargetTile.Type]) {
                return KDObjectHandle[KinkyDungeonTargetTile.Type]();
            }
            else if (KinkyDungeonTargetTile.Type == "Door") {
                if (MouseIn(KDModalArea_x + 25, KDModalArea_y + 25, 350, 60)) {
                    KDSendInput("closeDoor", { targetTile: KinkyDungeonTargetTileLocation });
                    return true;
                }
            }
        }
        else {
        }
        if (KinkyDungeonStruggleGroups && KinkyDungeonDrawStruggleHover)
            for (let sg of KinkyDungeonStruggleGroups) {
                let ButtonWidth = 60;
                let x = 5 + ((!sg.left) ? (490 - ButtonWidth) : 0);
                let y = 42 + sg.y * (ButtonWidth + 46);
                let i = 0;
                let buttons = ["Struggle", "CurseInfo", "CurseUnlock", "Cut", "Remove", "Pick"];
                let item = KinkyDungeonGetRestraintItem(sg.group);
                let surfaceItems = KDDynamicLinkListSurface(item);
                if (KDStruggleGroupLinkIndex[sg.group]) {
                    if (!KDStruggleGroupLinkIndex[sg.group] || KDStruggleGroupLinkIndex[sg.group] >= surfaceItems.length) {
                        KDStruggleGroupLinkIndex[sg.group] = 0;
                    }
                    item = surfaceItems[KDStruggleGroupLinkIndex[sg.group]];
                }
                let r = KDRestraint(item);
                if (KinkyDungeonControlsEnabled())
                    for (let button_index = 0; button_index < buttons.length; button_index++) {
                        let btn = buttons[sg.left ? button_index : (buttons.length - 1 - button_index)];
                        if (btn == "Struggle") {
                            if (MouseIn(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth)) {
                                if ((item.curse || r.curse))
                                    KDSendInput("struggleCurse", { group: sg.group, index: KDStruggleGroupLinkIndex[sg.group], curse: (item.curse || r.curse) });
                                else {
                                    if (KinkyDungeonFastStruggle) {
                                        KinkyDungeonFastStruggleGroup = sg.group;
                                        KinkyDungeonFastStruggleType = "Struggle";
                                    }
                                    else
                                        KDSendInput("struggle", { group: sg.group, index: KDStruggleGroupLinkIndex[sg.group], type: "Struggle" });
                                }
                                return true;
                            }
                            i++;
                        }
                        else if ((item.curse || r.curse) && btn == "CurseInfo") {
                            if (MouseIn(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth)) {
                                KinkyDungeonCurseInfo(item, (item.curse || r.curse));
                                return true;
                            }
                            i++;
                        }
                        else if ((item.curse || r.curse) && btn == "CurseUnlock" && KinkyDungeonCurseAvailable(sg, (item.curse || r.curse))) {
                            if (MouseIn(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth) && KinkyDungeonCurseAvailable(item, (item.curse || r.curse))) {
                                KDSendInput("curseUnlock", { group: sg.group, index: KDStruggleGroupLinkIndex[sg.group], curse: (item.curse || r.curse) });
                                return true;
                            }
                            i++;
                        }
                        else if (!(item.curse || r.curse) && !sg.blocked && btn == "Remove") {
                            if (MouseIn(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth) && item.lock != "Jammed") {
                                if (KinkyDungeonFastStruggle) {
                                    KinkyDungeonFastStruggleGroup = sg.group;
                                    KinkyDungeonFastStruggleType = (item.lock) ? "Unlock" : "Remove";
                                }
                                else
                                    KDSendInput("struggle", { group: sg.group, index: KDStruggleGroupLinkIndex[sg.group], type: (item.lock) ? "Unlock" : "Remove" });
                                return true;
                            }
                            i++;
                        }
                        else if (!(item.curse || r.curse) && !sg.blocked && btn == "Cut"
                            && (KinkyDungeonAllWeapon().some((inv) => { return KDWeapon(inv).light && KDWeapon(inv).cutBonus != undefined; }) || KinkyDungeonGetAffinity(false, "Sharp"))
                            && !sg.noCut) {
                            if (MouseIn(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth)) {
                                if (KinkyDungeonFastStruggle) {
                                    KinkyDungeonFastStruggleGroup = sg.group;
                                    KinkyDungeonFastStruggleType = "Cut";
                                }
                                else
                                    KDSendInput("struggle", { group: sg.group, index: KDStruggleGroupLinkIndex[sg.group], type: "Cut" });
                                return true;
                            }
                            i++;
                        }
                        else if (!(item.curse || r.curse) && !sg.blocked && btn == "Pick" && KinkyDungeonLockpicks > 0 && item.lock) {
                            if (KinkyDungeonLockpicks > 0 && item.lock) {
                                if (MouseIn(x + ((!sg.left) ? -(ButtonWidth) * i : (ButtonWidth) * i), y, ButtonWidth, ButtonWidth)) {
                                    if (KinkyDungeonFastStruggle) {
                                        KinkyDungeonFastStruggleGroup = sg.group;
                                        KinkyDungeonFastStruggleType = "Pick";
                                    }
                                    else
                                        KDSendInput("struggle", { group: sg.group, index: KDStruggleGroupLinkIndex[sg.group], type: "Pick" });
                                    return true;
                                }
                                i++;
                            }
                        }
                    }
            }
        let xxx = 1750;
        let yyy = 164;
        if (MouseIn(xxx, yyy + 0 * KinkyDungeonStatBarHeight, buttonWidth, buttonWidth) && KinkyDungeonItemCount("PotionFrigid") && KinkyDungeonStatDistraction > 0) {
            if (KinkyDungeonCanTalk(true) || KinkyDungeonPotionCollar())
                KDSendInput("consumable", { item: "PotionFrigid", quantity: 1 });
            else
                KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonPotionGagged"), "orange", 1);
            return true;
        }
        else if (MouseIn(xxx, yyy + 1 * KinkyDungeonStatBarHeight, buttonWidth, buttonWidth) && KinkyDungeonItemCount("PotionStamina") && KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax) {
            if (KinkyDungeonCanTalk(true) || KinkyDungeonPotionCollar())
                KDSendInput("consumable", { item: "PotionStamina", quantity: 1 });
            else
                KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonPotionGagged"), "orange", 1);
            return true;
        }
        else if (MouseIn(xxx, yyy + 2 * KinkyDungeonStatBarHeight, buttonWidth, buttonWidth) && KinkyDungeonItemCount("PotionMana") && (KinkyDungeonStatMana < KinkyDungeonStatManaMax || KinkyDungeonStatManaPool < KinkyDungeonStatManaPoolMax)) {
            if (KinkyDungeonCanTalk(true) || KinkyDungeonPotionCollar())
                KDSendInput("consumable", { item: "PotionMana", quantity: 1 });
            else
                KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonPotionGagged"), "orange", 1);
            return true;
        }
        if (MouseIn(xxx, yyy + 3 * KinkyDungeonStatBarHeight, buttonWidth, buttonWidth) && KinkyDungeonItemCount("PotionWill") && KinkyDungeonStatWill < KinkyDungeonStatWillMax) {
            if (KinkyDungeonCanTalk(true) || KinkyDungeonPotionCollar())
                KDSendInput("consumable", { item: "PotionWill", quantity: 1 });
            else
                KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonPotionGagged"), "orange", 1);
            return true;
        }
        else if (MouseIn(xxx, yyy + 0 * KinkyDungeonStatBarHeight, buttonWidth, buttonWidth))
            return true;
        else if (MouseIn(xxx, yyy + 1 * KinkyDungeonStatBarHeight, buttonWidth, buttonWidth))
            return true;
        else if (MouseIn(xxx, yyy + 2 * KinkyDungeonStatBarHeight, buttonWidth, buttonWidth))
            return true;
    }
    else if (KinkyDungeonDrawState == "Orb") {
        return KinkyDungeonHandleOrb();
    }
    else if (KinkyDungeonDrawState == "Heart") {
        return KinkyDungeonHandleHeart();
    }
    else if (KinkyDungeonDrawState == "Magic") {
        return KinkyDungeonHandleMagic();
    }
    else if (KinkyDungeonDrawState == "MagicSpells") {
        return KinkyDungeonHandleMagicSpells();
    }
    else if (KinkyDungeonDrawState == "Inventory") {
        return KinkyDungeonHandleInventory();
    }
    else if (KinkyDungeonDrawState == "Logbook") {
        return KinkyDungeonHandleLore();
    }
    else if (KinkyDungeonDrawState == "Reputation") {
        return KinkyDungeonHandleReputation();
    }
    else if (KinkyDungeonDrawState == "Lore") {
        return KinkyDungeonHandleLore();
    }
    else if (KinkyDungeonDrawState == "Perks2") {
        if (MouseIn(1650, 920, 300, 64)) {
            KinkyDungeonDrawState = "Restart";
            KDConfirmDeleteSave = false;
            if (KDDebugMode) {
                ElementCreateTextArea("DebugEnemy");
                ElementValue("DebugEnemy", "Maidforce");
                ElementCreateTextArea("DebugItem");
                ElementValue("DebugItem", "TrapArmbinder");
            }
            return true;
        }
    }
    else if (KinkyDungeonDrawState == "Restart") {
        if (MouseIn(600, 20, 64, 64)) {
            if (TestMode) {
                KDDebugMode = !KDDebugMode;
                ElementCreateTextArea("DebugEnemy");
                ElementValue("DebugEnemy", "Maidforce");
                ElementCreateTextArea("DebugItem");
                ElementValue("DebugItem", "TrapArmbinder");
                return true;
            }
        }
        if (KDDebugMode) {
            if (MouseIn(1100, 20, 64, 64)) {
                KDDebug = !KDDebug;
                return true;
            }
            else if (MouseIn(1100, 100, 64, 64)) {
                KDDebugPerks = !KDDebugPerks;
                return true;
            }
            else if (MouseIn(1100, 180, 64, 64)) {
                if (KDDebugGold) {
                    KDDebugGold = false;
                    KinkyDungeonGold = 0;
                }
                else {
                    KDDebugGold = true;
                    KinkyDungeonGold = 100000;
                }
                return true;
            }
            else if (MouseIn(1500, 100, 100, 64)) {
                let enemy = KinkyDungeonEnemies.find((element) => { return element.name.toLowerCase() == ElementValue("DebugEnemy").toLowerCase(); });
                if (enemy) {
                    KinkyDungeonSummonEnemy(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, enemy.name, 1, 1.5);
                }
                return true;
            }
            else if (MouseIn(1600, 100, 100, 64)) {
                let enemy = KinkyDungeonEnemies.find((element) => { return element.name.toLowerCase() == ElementValue("DebugEnemy").toLowerCase(); });
                if (enemy) {
                    let e = DialogueCreateEnemy(KinkyDungeonPlayerEntity.x - 1, KinkyDungeonPlayerEntity.y, enemy.name);
                    e.allied = 9999;
                }
                return true;
            }
            else if (MouseIn(1700, 100, 100, 64)) {
                let enemy = KinkyDungeonEnemies.find((element) => { return element.name.toLowerCase() == ElementValue("DebugEnemy").toLowerCase(); });
                if (enemy) {
                    let e = DialogueCreateEnemy(KinkyDungeonPlayerEntity.x - 1, KinkyDungeonPlayerEntity.y, enemy.name);
                    e.ceasefire = 1000;
                    let shop = KinkyDungeonGetShopForEnemy(e, true);
                    if (shop) {
                        KinkyDungeonSetEnemyFlag(e, "Shop", -1);
                        KinkyDungeonSetEnemyFlag(e, shop, -1);
                    }
                }
                return true;
            }
            else if (MouseIn(1500, 260, 300, 64)) {
                let item = null;
                if (KinkyDungeonConsumables[ElementValue("DebugItem")])
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables[ElementValue("DebugItem")], 10);
                else if (KinkyDungeonWeapons[ElementValue("DebugItem")])
                    KinkyDungeonInventoryAddWeapon(ElementValue("DebugItem"));
                else if (KinkyDungeonGetRestraintByName(ElementValue("DebugItem"))) {
                    let restraint = KinkyDungeonGetRestraintByName(ElementValue("DebugItem"));
                    KinkyDungeonInventoryAdd({ name: ElementValue("DebugItem"), type: LooseRestraint, events: restraint.events, quantity: 10, id: KinkyDungeonGetItemID() });
                }
                else if (KinkyDungeonOutfitsBase.filter((outfit) => { return outfit.name == ElementValue("DebugItem"); }).length > 0) {
                    KinkyDungeonInventoryAdd({ name: KinkyDungeonOutfitsBase.filter((outfit) => { return outfit.name == ElementValue("DebugItem"); })[0].name, type: Outfit, id: KinkyDungeonGetItemID() });
                }
                if (item)
                    KinkyDungeonInventoryAdd(item);
                return true;
            }
            if (MouseIn(1500, 320, 300, 64)) {
                let saveData = KinkyDungeonSaveGame(true);
                KinkyDungeonState = "Save";
                ElementCreateTextArea("saveDataField");
                ElementValue("saveDataField", saveData);
                return true;
            }
            if (MouseIn(1100, 260, 300, 64)) {
                KDMovePlayer(KinkyDungeonEndPosition.x, KinkyDungeonEndPosition.y, false);
                KDGameData.JailKey = true;
                KinkyDungeonUpdateLightGrid = true;
                return true;
            }
            else if (MouseIn(1100, 320, 300, 64)) {
                KDGameData.PrisonerState = 'parole';
                return true;
            }
        }
        if (MouseIn(1650, 900, 300, 64)) {
            KinkyDungeonDrawState = "Perks2";
            return true;
        }
        if (KinkyDungeonIsPlayer() && MouseIn(975, 800, 550, 64) && KDGameData.PrisonerState != 'jail' && KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y)) {
            if (KDConfirmDeleteSave) {
                KDSendInput("defeat", {});
                KinkyDungeonDrawState = "Game";
            }
            else {
                KDConfirmDeleteSave = true;
            }
            return true;
        }
        if (KinkyDungeonIsPlayer() && MouseIn(975, 900, 550, 64)) {
            if (KDConfirmDeleteSave) {
                KDSendInput("lose", {});
                localStorage.setItem('KinkyDungeonSave', "");
            }
            else {
                KDConfirmDeleteSave = true;
            }
            return true;
        }
        else if (MouseIn(975, 550, 550, 64)) {
            KinkyDungeonDrawState = "Game";
            return true;
        }
        else if (KinkyDungeonIsPlayer() && MouseIn(975, 650, 550, 64)) {
            KinkyDungeonSaveGame();
            KinkyDungeonState = "Menu";
            return true;
        }
        KDConfirmDeleteSave = false;
        return true;
    }
    if (KDModalArea && MouseIn(KDModalArea_x, KDModalArea_y, KDModalArea_width, KDModalArea_height))
        return true;
    if (MouseIn(0, 0, 500, 1000))
        return true;
    if (MouseIn(1650, 0, 350, 1000))
        return true;
    KDModalArea = false;
    return false;
}
let KDStruggleGroupLinkIndex = {};
function KinkyDungeonUpdateStruggleGroups() {
    let struggleGroups = KinkyDungeonStruggleGroupsBase;
    KinkyDungeonStruggleGroups = [];
    KinkyDungeonCheckClothesLoss = true;
    for (let S = 0; S < struggleGroups.length; S++) {
        let sg = struggleGroups[S];
        let Group = sg;
        if (sg == "ItemM") {
            Group = "ItemMouth";
        }
        if (sg == "ItemH") {
            Group = "ItemHead";
        }
        let restraint = KinkyDungeonGetRestraintItem(Group);
        if (restraint) {
            KinkyDungeonStruggleGroups.push({
                group: Group,
                left: S % 2 == 0,
                y: Math.floor(S / 2),
                icon: sg,
                name: (KDRestraint(restraint)) ? KDRestraint(restraint).name : "",
                lock: restraint.lock,
                magic: KDRestraint(restraint) ? KDRestraint(restraint).magic : undefined,
                noCut: KDRestraint(restraint) && KDRestraint(restraint).escapeChance && KDRestraint(restraint).escapeChance.Cut == undefined,
                curse: KDRestraint(restraint) ? (restraint.curse || KDRestraint(restraint).curse) : undefined,
                blocked: !KDRestraint(restraint).alwaysStruggleable && KDGroupBlocked(Group)
            });
        }
    }
}
let KDRecentRepIndex = 0;
let ShowBoringness = false;
let KDWallReplacers = "14,dDzZbgS";
let KinkyDungeonSuppressSprint = true;
let KDReturnButtonXX = 1450;
let KDIntenseFilter = null;
let pixiview = document.getElementById("MainCanvas");
let pixirenderer = null;
let pixirendererKD = null;
let kdgamefog = new PIXI.Graphics();
kdgamefog.zIndex = -49;
let kdgameboard = new PIXI.Container();
kdgameboard.sortableChildren = true;
kdgameboard.zIndex = -50;
let kdui = new PIXI.Graphics();
let kdcanvas = new PIXI.Container();
kdcanvas.sortableChildren = true;
kdcanvas.addChild(kdgamefog);
kdcanvas.addChild(kdgameboard);
let kdparticles = new PIXI.Container();
kdparticles.zIndex = 10;
kdparticles.sortableChildren = true;
kdcanvas.addChild(kdparticles);
let KDTextWhite = "#ffffff";
let KDTextGray3 = "#aaaaaa";
let KDTextTan = "#d6cbc5";
let KDTextGray2 = "#333333";
let KDTextGray1 = "#111111";
let KDTextGray0 = "#000000";
let KDCurseColor = "#ff55aa";
let KDGoodColor = "#77ff99";
let kdSpritesDrawn = new Map();
let kdpixisprites = new Map();
let kdprimitiveparams = new Map();
let kdpixitex = new Map();
function KDWallVert(x, y, noReplace) {
    let tileBelow = KinkyDungeonMapGet(x, y + 1);
    if ((KDWallReplacers.includes(tileBelow)
        && (!noReplace || !noReplace.includes(tileBelow))))
        return true;
    if (!KinkyDungeonVisionGet(x, y + 1) && !(KinkyDungeonFogGet(x, y + 1) > 0))
        return true;
    return false;
}
function KDWallVertAbove(x, y, noReplace) {
    let tileAbove = KinkyDungeonMapGet(x, y - 1);
    if (KDWallReplacers.includes(tileAbove)
        && (!noReplace || !noReplace.includes(tileAbove)))
        return true;
    return false;
}
function KDWallVertBoth(x, y, noReplace) {
    let tileBelow = KinkyDungeonMapGet(x, y + 1);
    let tileAbove = KinkyDungeonMapGet(x, y - 1);
    if (KDWallReplacers.includes(tileBelow)
        && (!noReplace || !noReplace.includes(tileBelow))
        && KDWallReplacers.includes(tileAbove)
        && (!noReplace || !noReplace.includes(tileAbove)))
        return true;
    return false;
}
function KDWallHorizTunnel(x, y) {
    let tileUp = KinkyDungeonMapGet(x, y - 1);
    let tileBelow = KinkyDungeonMapGet(x, y + 1);
    if (KinkyDungeonWallTiles.includes(tileUp)
        && KinkyDungeonWallTiles.includes(tileBelow))
        return true;
    return false;
}
function KDWallVertTunnel(x, y) {
    let tileRight = KinkyDungeonMapGet(x + 1, y);
    let tileLeft = KinkyDungeonMapGet(x - 1, y);
    if (KinkyDungeonWallTiles.includes(tileRight)
        && KinkyDungeonWallTiles.includes(tileLeft))
        return true;
    return false;
}
let KDChainablePillar = 'bdD';
let KDSprites = {
    "5": (x, y, Fog, noReplace) => {
        let tile = KinkyDungeonTilesGet(x + "," + y);
        if (tile === null || tile === void 0 ? void 0 : tile.Sprite)
            return tile.Sprite;
        return "Floor";
    },
    "1": (x, y, Fog, noReplace) => {
        if (KDWallVert(x, y, noReplace))
            return "WallVert";
        return "Wall";
    },
    "2": (x, y, Fog, noReplace) => {
        return "Brickwork";
    },
    "3": (x, y, Fog, noReplace) => {
        return Fog ? "Doodad" : "MimicBlock";
    },
    "b": (x, y, Fog, noReplace) => {
        if (KDWallVertAbove(x, y, noReplace))
            return KDChainablePillar.includes(KinkyDungeonMapGet(x, y - 1)) ? "BarsVertCont" : "BarsVert";
        return "Bars";
    },
    "X": (x, y, Fog, noReplace) => {
        return "Doodad";
    },
    "4": (x, y, Fog, noReplace) => {
        if (KDWallVert(x, y, noReplace))
            return "WallVert";
        return "Wall";
    },
    "L": (x, y, Fog, noReplace) => {
        if (KinkyDungeonTilesGet(x + "," + y)) {
            let furn = KinkyDungeonTilesGet(x + "," + y).Furniture ? KDFurniture[KinkyDungeonTilesGet(x + "," + y).Furniture] : "";
            if (furn) {
                return furn.floor;
            }
        }
        return "Barrel";
    },
    "F": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "?": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "/": (x, y, Fog, noReplace) => {
        return "RubbleLooted";
    },
    ",": (x, y, Fog, noReplace) => {
        if (KDWallVert(x, y, noReplace))
            return "WallVert";
        return "Wall";
    },
    "D": (x, y, Fog, noReplace) => {
        if (Fog) {
            if (KinkyDungeonTilesMemory[x + "," + y])
                return KinkyDungeonTilesMemory[x + "," + y];
        }
        if (KDWallVertBoth(x, y, noReplace))
            KinkyDungeonTilesMemory[x + "," + y] = KDChainablePillar.includes(KinkyDungeonMapGet(x, y - 1)) ? "DoorVertCont" : "DoorVert";
        else
            KinkyDungeonTilesMemory[x + "," + y] = "Door";
        return KinkyDungeonTilesMemory[x + "," + y];
    },
    "d": (x, y, Fog, noReplace) => {
        if (Fog) {
            if (KinkyDungeonTilesMemory[x + "," + y])
                return KinkyDungeonTilesMemory[x + "," + y];
        }
        if (KDWallVertBoth(x, y, noReplace))
            KinkyDungeonTilesMemory[x + "," + y] = KDChainablePillar.includes(KinkyDungeonMapGet(x, y - 1)) ? "DoorVertOpenCont" : "DoorVertOpen";
        else
            KinkyDungeonTilesMemory[x + "," + y] = "DoorOpen";
        return KinkyDungeonTilesMemory[x + "," + y];
    },
    "Z": (x, y, Fog, noReplace) => {
        if (Fog) {
            if (KinkyDungeonTilesMemory[x + "," + y])
                return KinkyDungeonTilesMemory[x + "," + y];
        }
        if (KDWallVertBoth(x, y, noReplace))
            KinkyDungeonTilesMemory[x + "," + y] = KDChainablePillar.includes(KinkyDungeonMapGet(x, y - 1)) ? "DoorVertCont" : "DoorVert";
        else
            KinkyDungeonTilesMemory[x + "," + y] = "Door";
        return KinkyDungeonTilesMemory[x + "," + y];
    },
    "z": (x, y, Fog, noReplace) => {
        if (Fog) {
            if (KinkyDungeonTilesMemory[x + "," + y])
                return KinkyDungeonTilesMemory[x + "," + y];
        }
        if (KDWallVertBoth(x, y, noReplace))
            KinkyDungeonTilesMemory[x + "," + y] = KDChainablePillar.includes(KinkyDungeonMapGet(x, y - 1)) ? "DoorVertOpenCont" : "DoorVertOpen";
        else
            KinkyDungeonTilesMemory[x + "," + y] = "DoorOpen";
        return KinkyDungeonTilesMemory[x + "," + y];
    },
    "a": (x, y, Fog, noReplace) => {
        return "ShrineBroken";
    },
    "A": (x, y, Fog, noReplace) => {
        return (KinkyDungeonTilesGet(x + "," + y) && KinkyDungeonTilesGet(x + "," + y).Type == "Shrine" && KinkyDungeonTilesGet(x + "," + y).Name == "Commerce") ? "ShrineC" : ((KinkyDungeonTilesGet(x + "," + y) && KinkyDungeonTilesGet(x + "," + y).drunk) ? "ShrineEmpty" : "Shrine");
    },
    "H": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "s": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "S": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "g": (x, y, Fog, noReplace) => {
        if (KDWallHorizTunnel(x, y))
            return "GrateHoriz";
        else if (!KDWallVert(x, y)) {
            return "Grate";
        }
        else if (KDWallVertTunnel(x, y)) {
            return "GrateVert";
        }
        return "Grate";
    },
    "r": (x, y, Fog, noReplace) => {
        return "RubbleLooted";
    },
    "T": (x, y, Fog, noReplace) => {
        return (KinkyDungeonBlindLevel > 0) ? "Floor" : "Trap";
    },
    "Y": (x, y, Fog, noReplace) => {
        return "Doodad";
    },
    "R": (x, y, Fog, noReplace) => {
        return "RubbleLooted";
    },
    "m": (x, y, Fog, noReplace) => {
        return "Brickwork";
    },
    "M": (x, y, Fog, noReplace) => {
        return "Brickwork";
    },
    "O": (x, y, Fog, noReplace) => {
        return "OrbEmpty";
    },
    "P": (x, y, Fog, noReplace) => {
        return "OrbEmpty";
    },
    "p": (x, y, Fog, noReplace) => {
        return "OrbEmpty";
    },
    "o": (x, y, Fog, noReplace) => {
        return "OrbEmpty";
    },
    "w": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "]": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "[": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "=": (x, y, Fog, noReplace) => {
        return "Brickwork";
    },
    "+": (x, y, Fog, noReplace) => {
        return "Brickwork";
    },
    "-": (x, y, Fog, noReplace) => {
        return "Brickwork";
    },
    "l": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "V": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "t": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "u": (x, y, Fog, noReplace) => {
        return "Floor";
    },
    "N": (x, y, Fog, noReplace) => {
        return "Floor";
    },
};
let KDOverlays = {
    "5": (x, y, Fog, noReplace) => {
        let tile = KinkyDungeonTilesGet(x + "," + y);
        if (tile === null || tile === void 0 ? void 0 : tile.Overlay)
            return tile.Overlay;
        return "";
    },
    "Z": (x, y, Fog, noReplace) => {
        return "Signal/AutoLock";
    },
    "H": (x, y, Fog, noReplace) => {
        return "StairsDown";
    },
    "s": (x, y, Fog, noReplace) => {
        return "StairsDown";
    },
    "S": (x, y, Fog, noReplace) => {
        return "StairsUp";
    },
    "-": (x, y, Fog, noReplace) => {
        return "ChargerSpent";
    },
    "l": (x, y, Fog, noReplace) => {
        return "Leyline";
    },
    "+": (x, y, Fog, noReplace) => {
        return "Charger";
    },
    "=": (x, y, Fog, noReplace) => {
        return "ChargerCrystal";
    },
    "Y": (x, y, Fog, noReplace) => {
        return "Rubble";
    },
    "/": (x, y, Fog, noReplace) => {
        return "Scrap";
    },
    "R": (x, y, Fog, noReplace) => {
        return "Rubble";
    },
    "$": (x, y, Fog, noReplace) => {
        return "Angel";
    },
    "m": (x, y, Fog, noReplace) => {
        return "TabletSpent";
    },
    "M": (x, y, Fog, noReplace) => {
        if (KinkyDungeonTilesGet(x + "," + y) && !Object.keys(KinkyDungeonGoddessRep).includes(KinkyDungeonTilesGet(x + "," + y).Name))
            return "Tablet" + KinkyDungeonTilesGet(x + "," + y).Name;
        return "Tablet";
    },
    "[": (x, y, Fog, noReplace) => {
        return "Spores";
    },
    "]": (x, y, Fog, noReplace) => {
        return "HappyGas";
    },
    "w": (x, y, Fog, noReplace) => {
        return Fog ? "" : "Water";
    },
    "O": (x, y, Fog, noReplace) => {
        return "Orb";
    },
    "P": (x, y, Fog, noReplace) => {
        return "Perk";
    },
    ",": (x, y, Fog, noReplace) => {
        return "HookLow";
    },
    "?": (x, y, Fog, noReplace) => {
        return "HookHigh";
    },
    "B": (x, y, Fog, noReplace) => {
        return "Bed";
    },
    "@": (x, y, Fog, noReplace) => {
        return "Signal/Button";
    },
    "V": (x, y, Fog, noReplace) => {
        let tile = KinkyDungeonTilesGet(x + "," + y);
        if (tile) {
            let tU = KinkyDungeonTilesGet(x + "," + (y - 1));
            let tD = KinkyDungeonTilesGet(x + "," + (y + 1));
            let tR = KinkyDungeonTilesGet((x + 1) + "," + y);
            let tL = KinkyDungeonTilesGet((x - 1) + "," + y);
            let sprite = "";
            if (tile.DY == -1) {
                if ((tD === null || tD === void 0 ? void 0 : tD.DY) == -1)
                    return "Conveyor/Up";
                if ((tL === null || tL === void 0 ? void 0 : tL.DX) == 1 && (tR === null || tR === void 0 ? void 0 : tR.DX) == -1)
                    sprite = sprite + "LeftRight";
                else if ((tL === null || tL === void 0 ? void 0 : tL.DX) == 1)
                    sprite = sprite + "Right";
                else if ((tR === null || tR === void 0 ? void 0 : tR.DX) == -1)
                    sprite = sprite + "Left";
                sprite = sprite + "Up";
            }
            else if (tile.DY == 1) {
                if ((tU === null || tU === void 0 ? void 0 : tU.DY) == 1)
                    return "Conveyor/Down";
                if ((tL === null || tL === void 0 ? void 0 : tL.DX) == 1 && (tR === null || tR === void 0 ? void 0 : tR.DX) == -1)
                    sprite = sprite + "LeftRight";
                else if ((tL === null || tL === void 0 ? void 0 : tL.DX) == 1 && !((tR === null || tR === void 0 ? void 0 : tR.DX) == -1))
                    sprite = sprite + "Right";
                else if ((tR === null || tR === void 0 ? void 0 : tR.DX) == -1 && !((tL === null || tL === void 0 ? void 0 : tL.DX) == 1))
                    sprite = sprite + "Left";
                sprite = sprite + "Down";
            }
            else if (tile.DX == 1) {
                if ((tU === null || tU === void 0 ? void 0 : tU.DY) == 1 && (tD === null || tD === void 0 ? void 0 : tD.DY) == -1)
                    sprite = sprite + "UpDown";
                else if ((tU === null || tU === void 0 ? void 0 : tU.DY) == 1)
                    sprite = sprite + "Down";
                else if ((tD === null || tD === void 0 ? void 0 : tD.DY) == -1)
                    sprite = sprite + "Up";
                sprite = sprite + "Right";
            }
            else if (tile.DX == -1) {
                if ((tU === null || tU === void 0 ? void 0 : tU.DY) == 1 && (tD === null || tD === void 0 ? void 0 : tD.DY) == -1)
                    sprite = sprite + "UpDown";
                else if ((tU === null || tU === void 0 ? void 0 : tU.DY) == 1)
                    sprite = sprite + "Down";
                else if ((tD === null || tD === void 0 ? void 0 : tD.DY) == -1)
                    sprite = sprite + "Up";
                sprite = sprite + "Left";
            }
            return "Conveyor/" + sprite;
        }
        return "Conveyor/Conveyor";
    },
    "t": (x, y, Fog, noReplace) => {
        return "DollTerminal";
    },
    "u": (x, y, Fog, noReplace) => {
        return "DollSupply";
    },
    "N": (x, y, Fog, noReplace) => {
        var _a, _b;
        let tile = KinkyDungeonTilesGet(x + ',' + y);
        let tileAbove = KinkyDungeonMapGet(x, y - 1);
        let tileBelow = KinkyDungeonMapGet(x, y + 1);
        if (tileAbove == 'V' && ((_a = KinkyDungeonTilesGet(x + "," + (y - 1))) === null || _a === void 0 ? void 0 : _a.DY) == 1) {
            return `BondageMachine/${tile.Binding || "Latex"}Vert`;
        }
        else if (tileBelow == 'V' && ((_b = KinkyDungeonTilesGet(x + "," + (y + 1))) === null || _b === void 0 ? void 0 : _b.DY) == -1) {
            return `BondageMachine/${tile.Binding || "Latex"}Vert`;
        }
        return `BondageMachine/${tile.Binding || "Latex"}Horiz`;
    },
};
let KDOverlays2 = {
    "V": (x, y, Fog, noReplace) => {
        let tile = KinkyDungeonTilesGet(x + "," + y);
        if (tile && tile.SwitchMode != undefined) {
            let sprite = "";
            if (tile.DY == -1) {
                sprite = sprite + "Up";
            }
            else if (tile.DY == 1) {
                sprite = sprite + "Down";
            }
            else if (tile.DX == 1) {
                sprite = sprite + "Right";
            }
            else if (tile.DX == -1) {
                sprite = sprite + "Left";
            }
            if (tile.SwitchMode)
                sprite = sprite + tile.SwitchMode;
            return "Conveyor/" + sprite;
        }
        return "";
    },
};
function KinkyDungeonGetSprite(code, x, y, Fog, noReplace) {
    let sprite = "Floor";
    if (KDSprites[code])
        sprite = KDSprites[code](x, y, Fog, noReplace);
    return sprite;
}
function KinkyDungeonGetSpriteOverlay2(code, x, y, Fog, noReplace) {
    let sprite = "";
    if (KDOverlays2[code])
        sprite = KDOverlays2[code](x, y, Fog, noReplace);
    if (KinkyDungeonTilesGet(x + "," + y) && KinkyDungeonTilesGet(x + "," + y).Skin2) {
        sprite = KinkyDungeonTilesGet(x + "," + y).Skin2;
    }
    return sprite;
}
function KinkyDungeonGetSpriteOverlay(code, x, y, Fog, noReplace) {
    let sprite = "";
    if (KDOverlays[code])
        sprite = KDOverlays[code](x, y, Fog, noReplace);
    if (KinkyDungeonTilesGet(x + "," + y) && KinkyDungeonTilesGet(x + "," + y).Skin) {
        sprite = KinkyDungeonTilesGet(x + "," + y).Skin;
    }
    else if (code == "G") {
        sprite = "Ghost";
        if (KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Msg || KinkyDungeonTilesGet(x + "," + y).Dialogue)) {
            sprite = "GhostImportant";
        }
    }
    else if (code == "L") {
        if (KinkyDungeonTilesGet(x + "," + y)) {
            let furn = KinkyDungeonTilesGet(x + "," + y).Furniture ? KDFurniture[KinkyDungeonTilesGet(x + "," + y).Furniture] : "";
            if (furn) {
                return furn.sprite;
            }
        }
    }
    else if (code == "F") {
        sprite = "Table";
        if (KinkyDungeonTilesGet(x + "," + y)) {
            let table = "Table";
            if (KinkyDungeonTilesGet(x + "," + y).Food) {
                sprite = table + KinkyDungeonTilesGet(x + "," + y).Food;
            }
        }
    }
    else if (code == "4") {
        let left = KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x - 1, y));
        let right = KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x + 1, y));
        let up = KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x, y - 1));
        let down = KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x, y + 1));
        if (down) {
            sprite = "Crack";
        }
        else if (up) {
            sprite = "CrackHoriz";
        }
        else if (left && right) {
            sprite = "CrackVert";
        }
        else if (left) {
            sprite = "CrackLeft";
        }
        else if (right) {
            sprite = "CrackRight";
        }
        else
            sprite = "CrackNone";
    }
    else if (code == "C")
        sprite = (KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "gold" || KinkyDungeonTilesGet(x + "," + y).Loot == "lessergold")) ? "ChestGold" :
            ((KinkyDungeonTilesGet(x + "," + y) && (KDSpecialChests[KinkyDungeonTilesGet(x + "," + y).Loot])) ? KDSpecialChests[KinkyDungeonTilesGet(x + "," + y).Loot] :
                ((KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "blue")) ? "ChestBlue" :
                    ((KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "dark")) ? "ChestDark" :
                        ((KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "pearl" || KinkyDungeonTilesGet(x + "," + y).Loot == "lesserpearl")) ? "ChestPearl" : "Chest"))));
    else if (code == "c")
        sprite = (KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "gold" || KinkyDungeonTilesGet(x + "," + y).Loot == "lessergold")) ? "ChestGoldOpen" :
            ((KinkyDungeonTilesGet(x + "," + y) && (KDSpecialChests[KinkyDungeonTilesGet(x + "," + y).Loot])) ? KDSpecialChests[KinkyDungeonTilesGet(x + "," + y).Loot] + "Open" :
                ((KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "blue")) ? "ChestBlueOpen" :
                    ((KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "dark")) ? "ChestDarkOpen" :
                        ((KinkyDungeonTilesGet(x + "," + y) && (KinkyDungeonTilesGet(x + "," + y).Loot == "pearl" || KinkyDungeonTilesGet(x + "," + y).Loot == "lesserpearl")) ? "ChestPearlOpen" : "ChestOpen"))));
    return sprite;
}
let KDSpecialChests = {
    "silver": "ChestSilver",
    "shadow": "ChestShadow",
};
let KDLastKeyTime = {};
function KinkyDungeonDrawGame() {
    var _a;
    if (KinkyDungeonKeybindingCurrentKey && KinkyDungeonGameKeyDown()) {
        if (KinkyDungeonKeybindingCurrentKey)
            KDLastKeyTime[KinkyDungeonKeybindingCurrentKey] = CommonTime();
        KinkyDungeonKeybindingCurrentKey = '';
    }
    if (KinkyDungeonDrawState == "Game")
        KinkyDungeonListenKeyMove();
    KDProcessInputs();
    if (!KinkyDungeonFlags.get("lastAuto") && KinkyDungeonStatsChoice.get("saveMode")) {
        KinkyDungeonSetFlag("lastAuto", Math.floor(50 + KDRandom() * 50));
        KinkyDungeonSaveGame();
    }
    if (KDRefresh) {
        CharacterRefresh(KinkyDungeonPlayer);
    }
    KDNaked = false;
    KDRefresh = false;
    if (ServerURL == "foobar") {
        DrawTextFitKD(TextGet("KinkyDungeon"), 1865, 50, 200, "#ffffff", KDTextGray2);
    }
    if ((KinkyDungeonGameKey.keyPressed[9]) && !KinkyDungeonDrawStatesModal.includes(KinkyDungeonDrawState)) {
        if (KinkyDungeonDrawState == "Magic") {
            KinkyDungeonDrawState = "MagicSpells";
            KinkyDungeonGameKey.keyPressed[9] = false;
        }
        else {
            KinkyDungeonDrawState = "Game";
            KinkyDungeonMessageToggle = false;
            KinkyDungeonTargetingSpell = null;
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = "";
            KinkyDungeonSpellPress = "";
            KDModalArea = false;
            KDCloseQuickInv();
            KDRepSelectionMode = "";
            KinkyDungeonGameKey.keyPressed[9] = false;
        }
    }
    KinkyDungeonCapStats();
    if (ChatRoomChatLog.length > 0) {
        let LastChatObject = ChatRoomChatLog[ChatRoomChatLog.length - 1];
        let LastChat = LastChatObject.Garbled;
        let LastChatTime = LastChatObject.Time;
        let LastChatSender = (LastChatObject.SenderName) ? LastChatObject.SenderName + ": " : ">";
        let LastChatMaxLength = 60;
        if (LastChat) {
            LastChat = (LastChatSender + LastChat).substr(0, LastChatMaxLength);
            if (LastChat.length == LastChatMaxLength)
                LastChat = LastChat + "...";
            if (LastChatTime && CommonTime() < LastChatTime + KinkyDungeonLastChatTimeout)
                if (!KinkyDungeonSendTextMessage(0, LastChat, "#ffffff", 1) && LastChat != KinkyDungeonActionMessage)
                    if (!KinkyDungeonSendActionMessage(0, LastChat, "#ffffff", 1) && LastChat != KinkyDungeonTextMessage)
                        KinkyDungeonSendTextMessage(1, LastChat, "#ffffff", 1);
        }
    }
    KinkyDungeonDrawDelta = Math.min(CommonTime() - KinkyDungeonLastDraw, KinkyDungeonLastDraw - KinkyDungeonLastDraw2);
    KinkyDungeonLastDraw2 = KinkyDungeonLastDraw;
    KinkyDungeonLastDraw = CommonTime();
    if (!(KinkyDungeonDrawState == "MagicSpells")) {
        KDSwapSpell = -1;
    }
    let bx = 650 + 15;
    let bwidth = 165;
    let bspacing = 5;
    let bindex = 0;
    if (KinkyDungeonDrawState == "Game") {
        let tooltip = "";
        if ((KinkyDungeonIsPlayer() || (KinkyDungeonGameData && CommonTime() < KinkyDungeonNextDataLastTimeReceived + KinkyDungeonNextDataLastTimeReceivedTimeout))) {
            KinkyDungeonUpdateVisualPosition(KinkyDungeonPlayerEntity, KinkyDungeonDrawDelta);
            let CamX = KinkyDungeonPlayerEntity.x - Math.floor(KinkyDungeonGridWidthDisplay / 2);
            let CamY = KinkyDungeonPlayerEntity.y - Math.floor(KinkyDungeonGridHeightDisplay / 2);
            let CamX_offset = KinkyDungeonPlayerEntity.visual_x - Math.floor(KinkyDungeonGridWidthDisplay / 2) - CamX;
            let CamY_offset = KinkyDungeonPlayerEntity.visual_y - Math.floor(KinkyDungeonGridHeightDisplay / 2) - CamY;
            KinkyDungeonCamX = CamX;
            KinkyDungeonCamY = CamY;
            let KinkyDungeonForceRender = "";
            KinkyDungeonSetMoveDirection();
            if (KinkyDungeonCanvas) {
                KinkyDungeonContext.fillStyle = "rgba(0,0,0.0,1.0)";
                KinkyDungeonContext.fillRect(0, 0, KinkyDungeonCanvas.width, KinkyDungeonCanvas.height);
                KinkyDungeonContext.fill();
                let spriteRes = KDDrawMap(CamX, CamY, CamX_offset, CamY_offset);
                if (KinkyDungeonUpdateLightGrid) {
                    KDUpdateFog = true;
                    KDUpdateVision();
                }
                let CamPos = { x: CamX, y: CamY };
                if (CamPos.x != KDLastCamPos.x || CamPos.y != KDLastCamPos.y)
                    KDUpdateFog = true;
                KDLastCamPos = CamPos;
                KDDrawFog(CamX, CamY, CamX_offset, CamY_offset);
                tooltip = spriteRes.tooltip;
                KinkyDungeonForceRender = spriteRes.KinkyDungeonForceRender;
                KDDrawEffectTiles(canvasOffsetX, canvasOffsetY, CamX + CamX_offset, CamY + CamY_offset);
                let aura_scale = 0;
                let aura_scale_max = 0;
                for (let b of Object.values(KinkyDungeonPlayerBuffs)) {
                    if (b && b.aura && b.duration > 0) {
                        aura_scale_max += 1;
                    }
                }
                if (aura_scale_max > 0) {
                    let buffs = Object.values(KinkyDungeonPlayerBuffs);
                    buffs = buffs.sort((a, b) => { return b.duration - a.duration; });
                    for (let b of buffs) {
                        if (b && b.aura && b.duration > 0) {
                            aura_scale += 1 / aura_scale_max;
                            let s = aura_scale;
                            if (b.noAuraColor) {
                                KDDraw(kdgameboard, kdpixisprites, b.id, KinkyDungeonRootDirectory + "Aura/" + (b.aurasprite ? b.aurasprite : "Aura") + ".png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s, KinkyDungeonSpriteSize * (1 + s), KinkyDungeonSpriteSize * (1 + s), undefined, {
                                    zIndex: 2.1,
                                });
                            }
                            else {
                                KDDraw(kdgameboard, kdpixisprites, b.id, KinkyDungeonRootDirectory + "Aura/" + (b.aurasprite ? b.aurasprite : "Aura") + ".png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - 0.5 * KinkyDungeonGridSizeDisplay * s, KinkyDungeonSpriteSize * (1 + s), KinkyDungeonSpriteSize * (1 + s), undefined, {
                                    tint: string2hex(b.aura),
                                    zIndex: 2.1,
                                });
                            }
                        }
                    }
                }
                KinkyDungeonDrawItems(canvasOffsetX, canvasOffsetY, CamX + CamX_offset, CamY + CamY_offset);
                if (!kdpixitex.get("playertex")) {
                    kdpixitex.set("playertex", PIXI.Texture.from(KinkyDungeonCanvasPlayer));
                }
                let playertex = kdpixitex.get("playertex");
                if (playertex) {
                    KDDraw(kdgameboard, kdpixisprites, "player", "playertex", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                        zIndex: 0.01,
                    });
                }
                if ((KinkyDungeonMovePoints < 0 || KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowLevel") > 0) && KinkyDungeonSlowLevel < 10) {
                    KDDraw(kdgameboard, kdpixisprites, "c_slow", KinkyDungeonRootDirectory + "Conditions/Slow.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonStatBlind > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_stun", KinkyDungeonRootDirectory + "Conditions/Stun.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonStatFreeze > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_freeze", KinkyDungeonRootDirectory + "Conditions/Freeze.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonStatBind > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_bind", KinkyDungeonRootDirectory + "Conditions/Bind.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Sneak") > 0 || KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SlowDetection") > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_sneak", KinkyDungeonRootDirectory + "Conditions/Sneak.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - 30, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackDmg") > 0 || KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackAcc") > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_buff", KinkyDungeonRootDirectory + "Conditions/Buff.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackDmg") < 0 || KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackAcc") < 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_dbuff", KinkyDungeonRootDirectory + "Conditions/Debuff.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Armor") > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_arm", KinkyDungeonRootDirectory + "Conditions/ArmorBuff.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                else if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Armor") < 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_armd", KinkyDungeonRootDirectory + "Conditions/ArmorDebuff.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "Evasion") > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_eva", KinkyDungeonRootDirectory + "Conditions/EvasionBuff.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SpellResist") > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_shield", KinkyDungeonRootDirectory + "Conditions/ShieldBuff.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                else if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SpellResist") < 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_shield", KinkyDungeonRootDirectory + "Conditions/ShieldDeuff.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "DamageAmp") > 0) {
                    KDDraw(kdgameboard, kdpixisprites, "c_amp", KinkyDungeonRootDirectory + "Conditions/DamageAmp.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                if (!KDCanAttack()) {
                    KDDraw(kdgameboard, kdpixisprites, "c_cantAttack", KinkyDungeonRootDirectory + "Conditions/Tired.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay * 0.5, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                KinkyDungeonDrawFight(canvasOffsetX, canvasOffsetY, CamX + CamX_offset, CamY + CamY_offset);
                KinkyDungeonDrawEnemiesWarning(canvasOffsetX, canvasOffsetY, CamX + CamX_offset, CamY + CamY_offset);
                KinkyDungeonDrawEnemies(canvasOffsetX, canvasOffsetY, CamX + CamX_offset, CamY + CamY_offset);
                KinkyDungeonDrawEnemiesStatus(canvasOffsetX, canvasOffsetY, CamX + CamX_offset, CamY + CamY_offset);
                KinkyDungeonSendEvent("draw", { update: KDDrawUpdate, CamX: CamX, CamY: CamY, CamX_offset: CamX_offset, CamY_offset: CamY_offset });
                KDDrawUpdate = 0;
                KinkyDungeonSuppressSprint = false;
                if (!KinkyDungeonMessageToggle && !KDIsAutoAction() && !KinkyDungeonShowInventory
                    && MouseIn(canvasOffsetX, canvasOffsetY, KinkyDungeonCanvas.width, KinkyDungeonCanvas.height) && KinkyDungeonIsPlayer()
                    && !MouseIn(0, 0, 500, 1000) && !MouseIn(1750, 0, 250, 1000)
                    && (!KDModalArea || !MouseIn(KDModalArea_x, KDModalArea_y, KDModalArea_width, KDModalArea_height))) {
                    if (KinkyDungeonTargetingSpell) {
                        KinkyDungeonSetTargetLocation();
                        KDDraw(kdgameboard, kdpixisprites, "ui_spellreticule", KinkyDungeonRootDirectory + "TargetSpell.png", (KinkyDungeonTargetX - CamX) * KinkyDungeonGridSizeDisplay, (KinkyDungeonTargetY - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 100,
                        });
                        let spellRange = KinkyDungeonTargetingSpell.range * KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "spellRange"));
                        let free = KinkyDungeonOpenObjects.includes(KinkyDungeonMapGet(KinkyDungeonTargetX, KinkyDungeonTargetY)) || KinkyDungeonVisionGet(KinkyDungeonTargetX, KinkyDungeonTargetY) < 0.1;
                        KinkyDungeonSpellValid = (KinkyDungeonTargetingSpell.projectileTargeting || spellRange >= Math.sqrt((KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x) * (KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x) + (KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y) * (KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y))) &&
                            (KinkyDungeonTargetingSpell.projectileTargeting || KinkyDungeonTargetingSpell.CastInWalls || free) &&
                            (!KinkyDungeonTargetingSpell.WallsOnly || !KinkyDungeonOpenObjects.includes(KinkyDungeonMapGet(KinkyDungeonTargetX, KinkyDungeonTargetY)));
                        if (KinkyDungeonTargetingSpell.noTargetEnemies) {
                            let enemy = KinkyDungeonEnemyAt(KinkyDungeonTargetX, KinkyDungeonTargetY);
                            let faction = KDGetFaction(enemy);
                            if (enemy && (!KinkyDungeonTargetingSpell.exceptionFactions || !KinkyDungeonTargetingSpell.exceptionFactions.includes(faction)))
                                KinkyDungeonSpellValid = false;
                        }
                        if (KinkyDungeonTargetingSpell.noTargetAllies) {
                            let enemy = KinkyDungeonEnemyAt(KinkyDungeonTargetX, KinkyDungeonTargetY);
                            if (enemy && KDAllied(enemy))
                                KinkyDungeonSpellValid = false;
                        }
                        if (KinkyDungeonTargetingSpell.selfTargetOnly && (KinkyDungeonPlayerEntity.x != KinkyDungeonTargetX || KinkyDungeonPlayerEntity.y != KinkyDungeonTargetY))
                            KinkyDungeonSpellValid = false;
                        if (KinkyDungeonTargetingSpell.requireLOS &&
                            !KinkyDungeonCheckPath(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonTargetX, KinkyDungeonTargetY, true, true, 1, true))
                            KinkyDungeonSpellValid = false;
                        if (KinkyDungeonTargetingSpell.noTargetPlayer && KinkyDungeonPlayerEntity.x == KinkyDungeonTargetX && KinkyDungeonPlayerEntity.y == KinkyDungeonTargetY)
                            KinkyDungeonSpellValid = false;
                        if (KinkyDungeonTargetingSpell.mustTarget && KinkyDungeonNoEnemy(KinkyDungeonTargetX, KinkyDungeonTargetY, true))
                            KinkyDungeonSpellValid = false;
                        if (KinkyDungeonTargetingSpell.minRange && KDistEuclidean(KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x, KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y) < KinkyDungeonTargetingSpell.minRange)
                            KinkyDungeonSpellValid = false;
                        if (KinkyDungeonSpellValid)
                            if (KinkyDungeonTargetingSpell.projectileTargeting) {
                                let range = KinkyDungeonTargetingSpell.castRange;
                                if (!range || spellRange > range)
                                    range = spellRange;
                                let dist = Math.sqrt((KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x) * (KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x)
                                    + (KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y) * (KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y));
                                for (let R = 0; R <= Math.max(1, range - 1); R += 0.1) {
                                    let xx = KinkyDungeonMoveDirection.x + Math.round((KinkyDungeonTargetX - KinkyDungeonPlayerEntity.x) * R / dist);
                                    let yy = KinkyDungeonMoveDirection.y + Math.round((KinkyDungeonTargetY - KinkyDungeonPlayerEntity.y) * R / dist);
                                    if (KinkyDungeonVisionGet(xx + KinkyDungeonPlayerEntity.x, yy + KinkyDungeonPlayerEntity.y) > 0 && !KinkyDungeonForceRender)
                                        KDDraw(kdgameboard, kdpixisprites, xx + "," + yy + "_target", KinkyDungeonRootDirectory + "Target.png", (xx + KinkyDungeonPlayerEntity.x - CamX) * KinkyDungeonGridSizeDisplay, (yy + KinkyDungeonPlayerEntity.y - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                                            zIndex: 99,
                                        });
                                }
                            }
                            else if (!KinkyDungeonForceRender) {
                                let rad = KinkyDungeonTargetingSpell.aoe ? KinkyDungeonTargetingSpell.aoe : 0.5;
                                for (let xxx = KinkyDungeonTargetX - Math.ceil(rad); xxx <= KinkyDungeonTargetX + Math.ceil(rad); xxx++)
                                    for (let yyy = KinkyDungeonTargetY - Math.ceil(rad); yyy <= KinkyDungeonTargetY + Math.ceil(rad); yyy++)
                                        if (AOECondition(KinkyDungeonTargetX, KinkyDungeonTargetY, xxx, yyy, rad, KinkyDungeonTargetingSpell.aoetype || ""))
                                            KDDraw(kdgameboard, kdpixisprites, xxx + "," + yyy + "_target", KinkyDungeonRootDirectory + "Target.png", (xxx - CamX) * KinkyDungeonGridSizeDisplay, (yyy - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                                                zIndex: 99,
                                            });
                            }
                    }
                    else if (KinkyDungeonFastMove && !(!KinkyDungeonSuppressSprint && KinkyDungeonToggleAutoSprint && KDCanSprint()) && (KinkyDungeonMoveDirection.x != 0 || KinkyDungeonMoveDirection.y != 0)) {
                        KinkyDungeonSetTargetLocation();
                        let allowFog = KDAllowFog();
                        if (KinkyDungeonVisionGet(KinkyDungeonTargetX, KinkyDungeonTargetY) > 0 || (allowFog && KinkyDungeonFogGet(KinkyDungeonTargetX, KinkyDungeonTargetY) > 0)) {
                            KDDraw(kdgameboard, kdpixisprites, "ui_movereticule", KinkyDungeonRootDirectory + "TargetMove.png", (KinkyDungeonTargetX - CamX) * KinkyDungeonGridSizeDisplay, (KinkyDungeonTargetY - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                                zIndex: 100,
                            });
                            if (KinkyDungeonSlowLevel > 1 && KinkyDungeonSlowLevel < 10) {
                                if (!KinkyDungeonEnemyAt(KinkyDungeonTargetX, KinkyDungeonTargetY) || KDCanPassEnemy(KinkyDungeonPlayerEntity, KinkyDungeonEnemyAt(KinkyDungeonTargetX, KinkyDungeonTargetY))) {
                                    let dist = Math.round(KinkyDungeonSlowLevel);
                                    let path = KinkyDungeonFindPath(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonTargetX, KinkyDungeonTargetY, false, false, true, KinkyDungeonMovableTilesSmartEnemy, false, false, false);
                                    if ((path === null || path === void 0 ? void 0 : path.length) > 1) {
                                        dist *= path.length;
                                    }
                                    DrawTextKD("x" + dist, (KinkyDungeonTargetX - CamX + 0.5) * KinkyDungeonGridSizeDisplay, (KinkyDungeonTargetY - CamY + 0.5) * KinkyDungeonGridSizeDisplay, "#ffaa44");
                                }
                            }
                        }
                    }
                    else if ((KinkyDungeonMoveDirection.x != 0 || KinkyDungeonMoveDirection.y != 0)) {
                        let xx = KinkyDungeonMoveDirection.x + KinkyDungeonPlayerEntity.x;
                        let yy = KinkyDungeonMoveDirection.y + KinkyDungeonPlayerEntity.y;
                        if (KinkyDungeonSlowLevel < 2 && MouseIn(canvasOffsetX + (xx - CamX) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (yy - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay)) {
                            KinkyDungeonSuppressSprint = true;
                        }
                        if (!KinkyDungeonSuppressSprint && KinkyDungeonToggleAutoSprint && (KDCanSprint())) {
                            if (KinkyDungeonMoveDirection.x || KinkyDungeonMoveDirection.y) {
                                let newX = KinkyDungeonMoveDirection.x * (KinkyDungeonSlowLevel < 2 ? 2 : 1) + KinkyDungeonPlayerEntity.x;
                                let newY = KinkyDungeonMoveDirection.y * (KinkyDungeonSlowLevel < 2 ? 2 : 1) + KinkyDungeonPlayerEntity.y;
                                let tile = KinkyDungeonMapGet(newX, newY);
                                if (KinkyDungeonMovableTilesEnemy.includes(tile) && KinkyDungeonNoEnemy(newX, newY)) {
                                    KDDraw(kdgameboard, kdpixisprites, "ui_movesprint", KinkyDungeonRootDirectory + "Sprint.png", (newX - CamX) * KinkyDungeonGridSizeDisplay, (newY - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                                        zIndex: 99,
                                    });
                                    xx = newX;
                                    yy = newY;
                                }
                            }
                        }
                        KDDraw(kdgameboard, kdpixisprites, "ui_movereticule", KinkyDungeonRootDirectory + "TargetMove.png", (xx - CamX) * KinkyDungeonGridSizeDisplay, (yy - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            zIndex: 100,
                        });
                        if (KinkyDungeonSlowLevel > 1 && KinkyDungeonSlowLevel < 10) {
                            if (!KinkyDungeonEnemyAt(xx, yy) || KDCanPassEnemy(KinkyDungeonPlayerEntity, KinkyDungeonEnemyAt(xx, yy))) {
                                let dist = Math.round(KinkyDungeonSlowLevel);
                                DrawTextKD("x" + dist, (xx - CamX + 0.5) * KinkyDungeonGridSizeDisplay, (yy - CamY + 0.5) * KinkyDungeonGridSizeDisplay, "#ffaa44");
                            }
                        }
                    }
                }
                let cursorX = Math.round((MouseX - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetX) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamX;
                let cursorY = Math.round((MouseY - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetY) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamY;
                let tooltips = [];
                if (KinkyDungeonVisionGet(cursorX, cursorY) > 0) {
                    let ambushTile = "";
                    let enemy = KinkyDungeonEnemyAt(cursorX, cursorY);
                    if (enemy && KDCanSeeEnemy(KinkyDungeonEnemyAt(cursorX, cursorY))) {
                        if (!enemy.ambushtrigger && ((_a = KDAIType[KDGetAI(KinkyDungeonEnemyAt(cursorX, cursorY))]) === null || _a === void 0 ? void 0 : _a.ambushtile)) {
                            ambushTile = KDAIType[KDGetAI(enemy)].ambushtile;
                        }
                        else {
                            tooltips.push((offset) => KDDrawEnemyTooltip(enemy, offset));
                        }
                    }
                    let eTiles = KDGetEffectTiles(cursorX, cursorY);
                    for (let etile of Object.values(eTiles)) {
                        if (KDEffectTileTooltips[etile.name] && KDCanSeeEffectTile(etile)) {
                            tooltips.push((offset) => KDDrawEffectTileTooltip(etile, cursorX, cursorY, offset));
                        }
                    }
                    let tile = ambushTile || KinkyDungeonMapGet(cursorX, cursorY);
                    if (KDTileTooltips[tile] && (KinkyDungeonInspect || KDTileTooltips[tile]().noInspect)) {
                        tooltips.push((offset) => KDDrawTileTooltip(tile, cursorX, cursorY, offset));
                    }
                }
                let tooltipOffset = 0;
                for (let t of tooltips) {
                    tooltipOffset = t(tooltipOffset);
                }
                if (KinkyDungeonFastMoveSuppress) {
                    DrawRectKD(kdcanvas, kdpixisprites, "redborder", {
                        Left: canvasOffsetX,
                        Top: canvasOffsetY,
                        Width: KinkyDungeonCanvas.width,
                        Height: KinkyDungeonCanvas.height,
                        Color: "#ff4444",
                        LineWidth: 2,
                        zIndex: 10,
                    });
                }
                if (KinkyDungeonLastTurnAction == "Struggle" && KinkyDungeonCurrentEscapingItem && KinkyDungeonCurrentEscapingItem.lock) {
                    KDDraw(kdgameboard, kdpixisprites, "ui_lock", KinkyDungeonRootDirectory + "Lock.png", (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - 60, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
                }
                for (let sprite of kdpixisprites.entries()) {
                    if (!kdSpritesDrawn.has(sprite[0]) && sprite[1] && sprite[1].parent == kdgameboard) {
                        sprite[1].parent.removeChild(sprite[1]);
                        if (kdprimitiveparams.has(sprite[0]))
                            kdprimitiveparams.delete(sprite[0]);
                        kdpixisprites.delete(sprite[0]);
                        sprite[1].destroy();
                    }
                }
                if (!StandalonePatched) {
                    if (pixirendererKD) {
                        pixirendererKD.render(kdgameboard, {
                            clear: false,
                        });
                    }
                    if (pixirendererKD) {
                        pixirendererKD.render(kdgamefog, {
                            clear: false,
                        });
                    }
                    if (pixirendererKD) {
                        pixirendererKD.render(kdparticles, {
                            clear: false,
                        });
                    }
                    if (!pixirendererKD) {
                        if (!StandalonePatched) {
                            if (KinkyDungeonContext && KinkyDungeonCanvas) {
                                pixirendererKD = new PIXI.Renderer({
                                    width: KinkyDungeonCanvas.width,
                                    height: KinkyDungeonCanvas.height,
                                    view: KinkyDungeonCanvas,
                                    antialias: true,
                                });
                            }
                        }
                    }
                    MainCanvas.drawImage(KinkyDungeonCanvas, canvasOffsetX, canvasOffsetY);
                }
            }
            DrawCharacter(KinkyDungeonPlayer, 0, 0, 1);
            DrawTextFitKD(TextGet("CurrentLevel").replace("FLOORNUMBER", "" + MiniGameKinkyDungeonLevel).replace("DUNGEONNAME", TextGet("DungeonName" + KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]))
                + (KinkyDungeonNewGame ? TextGet("KDNGPlus").replace("XXX", "" + KinkyDungeonNewGame) : ""), KDMsgX + KDMsgWidth / 2, 42, 1000, "#ffffff", "#333333");
            KinkyDungeonDrawStats(1750, 164, 230, KinkyDungeonStatBarHeight);
            if (KinkyDungeonSleepiness) {
                CharacterSetFacialExpression(KinkyDungeonPlayer, "Emoticon", "Sleep");
            }
            else
                CharacterSetFacialExpression(KinkyDungeonPlayer, "Emoticon", null);
            if (!StandalonePatched) {
                KinkyDungeonContextPlayer.clearRect(0, 0, KinkyDungeonCanvasPlayer.width, KinkyDungeonCanvasPlayer.height);
            }
            let PlayerModel = StandalonePatched ? KDCurrentModels.get(KinkyDungeonPlayer) : null;
            let zoom = PlayerModel ? KinkyDungeonGridSizeDisplay / 1200
                : KinkyDungeonGridSizeDisplay / 250;
            let mods = StandalonePatched ? [
                {
                    Layer: "Head",
                    scale_x: 2.5,
                    scale_y: 2.5,
                    rotation_x_anchor: 1190 / MODELWIDTH,
                    rotation_y_anchor: 690 / MODELHEIGHT,
                    offset_x: 1100 / MODELWIDTH,
                    offset_y: 620 / MODELHEIGHT,
                },
            ] : [];
            if (KDDrawPlayer)
                DrawCharacter(KinkyDungeonPlayer, canvasOffsetX + (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay + (StandalonePatched ? KinkyDungeonGridSizeDisplay / 4 : -KinkyDungeonGridSizeDisplay / 2), canvasOffsetY + (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay + (StandalonePatched ? KinkyDungeonGridSizeDisplay / 6 : (KinkyDungeonPlayer.Pose.includes("Hogtied") ? -165 : (KinkyDungeonPlayer.IsKneeling() ? -78 : 0))), zoom, false, undefined, PIXI.SCALE_MODES.NEAREST, mods);
            KinkyDungeonDrawEnemiesHP(canvasOffsetX, canvasOffsetY, CamX + CamX_offset, CamY + CamY_offset);
            KinkyDungeonDrawFloaters(CamX + CamX_offset, CamY + CamY_offset);
            if (KinkyDungeonCanvas) {
                let barInt = 0;
                if (KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax * 0.9) {
                    KinkyDungeonBar(canvasOffsetX + (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - 12 - 13 * barInt, KinkyDungeonGridSizeDisplay, 8, 100 * KinkyDungeonStatStamina / KinkyDungeonStatStaminaMax, !KDCanAttack() ? "#ff5555" : "#44ff44", KDTextGray0);
                    barInt += 1;
                }
                if (KinkyDungeonCurrentEscapingItem && KinkyDungeonFlags.get("escaping")) {
                    let item = KinkyDungeonCurrentEscapingItem;
                    let value = 0;
                    let value2 = 0;
                    let color = "#ecebe7";
                    let color2 = "#ff0000";
                    if (KinkyDungeonCurrentEscapingMethod == "Struggle") {
                        if (item.struggleProgress)
                            value = item.struggleProgress;
                        if (item.cutProgress)
                            value2 = item.cutProgress;
                    }
                    else if (KinkyDungeonCurrentEscapingMethod == "Pick" && item.pickProgress) {
                        value = item.pickProgress;
                        color = "#ceaaed";
                    }
                    else if (KinkyDungeonCurrentEscapingMethod == "Remove") {
                        if (item.struggleProgress)
                            value = item.struggleProgress;
                        if (item.cutProgress)
                            value2 = item.cutProgress;
                    }
                    else if (KinkyDungeonCurrentEscapingMethod == "Cut") {
                        if (item.struggleProgress)
                            value = item.struggleProgress;
                        if (item.cutProgress)
                            value2 = item.cutProgress;
                    }
                    else if (KinkyDungeonCurrentEscapingMethod == "Unlock" && item.unlockProgress) {
                        value = item.unlockProgress;
                        color = "#d0ffea";
                    }
                    let xAdd = 0;
                    let yAdd = 0;
                    if (KinkyDungeonStruggleTime > CommonTime()) {
                        xAdd = Math.round(-1 + 2 * Math.random());
                        yAdd = Math.round(-1 + 2 * Math.random());
                    }
                    if (value <= 1)
                        KinkyDungeonBar(canvasOffsetX + xAdd + (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, canvasOffsetY + yAdd + (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - 24, KinkyDungeonGridSizeDisplay, 12, Math.max(7, Math.min(100, 100 * (value + value2))), color, KDTextGray0);
                    if (value2 && value <= 1) {
                        KinkyDungeonBar(canvasOffsetX + xAdd + (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay, canvasOffsetY + yAdd + (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - 24, KinkyDungeonGridSizeDisplay, 12, Math.max(7, 100 * value2), color2, "none");
                    }
                }
                KinkyDungeonDrawTethers(KinkyDungeonPlayerEntity, CamX + CamX_offset, CamY + CamY_offset);
                if (tooltip) {
                    DrawTextFitKD(tooltip, MouseX, MouseY - KinkyDungeonGridSizeDisplay / 2, 200, "#ffffff", KDTextGray2);
                }
            }
            if (KinkyDungeonPlayerEntity.dialogue) {
                let yboost = 0;
                DrawTextFitKD(KinkyDungeonPlayerEntity.dialogue, canvasOffsetX + (KinkyDungeonPlayerEntity.visual_x - CamX - CamX_offset) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, yboost + canvasOffsetY + (KinkyDungeonPlayerEntity.visual_y - CamY - CamY_offset) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 1.5, 10 + KinkyDungeonPlayerEntity.dialogue.length * 8, KinkyDungeonPlayerEntity.dialogueColor, KDTextGray0);
            }
            KDModalArea_x = 600;
            KDModalArea_y = 700;
            KDModalArea_width = 800;
            KDModalArea_height = 100;
            if (KinkyDungeonIsPlayer()) {
                KinkyDungeonDrawInputs();
            }
            if (KDGameData.CurrentDialog) {
                KDDrawDialogue();
            }
            KinkyDungeonDrawMessages();
            if (KDShowQuickInv()) {
                KinkyDungeonDrawQuickInv();
            }
        }
        else {
            DrawTextKD(TextGet("KinkyDungeonLoading"), 1100, 500, "#ffffff", KDTextGray2);
            if (CommonTime() > KinkyDungeonGameDataNullTimerTime + KinkyDungeonGameDataNullTimer) {
                ServerSend("ChatRoomChat", { Content: "RequestFullKinkyDungeonData", Type: "Hidden", Target: KinkyDungeonPlayerCharacter.MemberNumber });
                KinkyDungeonGameDataNullTimerTime = CommonTime();
            }
        }
    }
    else if (KinkyDungeonDrawState == "Orb") {
        KinkyDungeonDrawOrb();
    }
    else if (KinkyDungeonDrawState == "PerkOrb") {
        KinkyDungeonDrawPerkOrb();
    }
    else if (KinkyDungeonDrawState == "Heart") {
        KinkyDungeonDrawHeart();
    }
    else if (KinkyDungeonDrawState == "Magic") {
        DrawButtonKDEx("goInv", (bdata) => {
            KinkyDungeonDrawState = "Inventory";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonInventory"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_inventory.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("goRep", (bdata) => {
            KinkyDungeonDrawState = "Reputation";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonReputation"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_reputation.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("goSpells", (bdata) => {
            KinkyDungeonDrawState = "MagicSpells";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonMagic"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_spells.png", undefined, undefined, false, "", 24, true);
        bindex++;
        let logtxt = KinkyDungeonNewLoreList.length > 0 ? TextGet("KinkyDungeonLogbookN").replace("N", KinkyDungeonNewLoreList.length) : TextGet("KinkyDungeonLogbook");
        DrawButtonKDEx("goLog", (bdata) => {
            KinkyDungeonDrawState = "Logbook";
            KinkyDungeonUpdateLore(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, logtxt, "#ffffff", KinkyDungeonRootDirectory + "UI/button_logbook.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("return", (bdata) => { KinkyDungeonDrawState = "Game"; return true; }, true, KDReturnButtonXX, 925, bwidth, 60, TextGet("KinkyDungeonGame"), "#ffffff", "", "");
        KinkyDungeonDrawMagic();
    }
    else if (KinkyDungeonDrawState == "MagicSpells") {
        DrawButtonKDEx("goInv", (bdata) => {
            KinkyDungeonDrawState = "Inventory";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonInventory"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_inventory.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("goRep", (bdata) => {
            KinkyDungeonDrawState = "Reputation";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonReputation"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_reputation.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("return", (bdata) => { KinkyDungeonDrawState = "Game"; return true; }, true, KDReturnButtonXX, 925, bwidth, 60, TextGet("KinkyDungeonGame"), "#ffffff", "", "");
        bindex++;
        let logtxt = KinkyDungeonNewLoreList.length > 0 ? TextGet("KinkyDungeonLogbookN").replace("N", KinkyDungeonNewLoreList.length) : TextGet("KinkyDungeonLogbook");
        DrawButtonKDEx("goLog", (bdata) => {
            KinkyDungeonDrawState = "Logbook";
            KinkyDungeonUpdateLore(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, logtxt, "#ffffff", KinkyDungeonRootDirectory + "UI/button_logbook.png", undefined, undefined, false, "", 24, true);
        bindex++;
        KinkyDungeonDrawMagicSpells();
    }
    else if (KinkyDungeonDrawState == "Inventory") {
        DrawButtonKDEx("return", (bdata) => { KinkyDungeonDrawState = "Game"; return true; }, true, KDReturnButtonXX, 925, bwidth, 60, TextGet("KinkyDungeonGame"), "#ffffff", "", "");
        bindex++;
        DrawButtonKDEx("goRep", (bdata) => {
            KinkyDungeonDrawState = "Reputation";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonReputation"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_reputation.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("goSpells", (bdata) => {
            KinkyDungeonDrawState = "MagicSpells";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonMagic"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_spells.png", undefined, undefined, false, "", 24, true);
        bindex++;
        let logtxt = KinkyDungeonNewLoreList.length > 0 ? TextGet("KinkyDungeonLogbookN").replace("N", KinkyDungeonNewLoreList.length) : TextGet("KinkyDungeonLogbook");
        DrawButtonKDEx("goLog", (bdata) => {
            KinkyDungeonDrawState = "Logbook";
            KinkyDungeonUpdateLore(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, logtxt, "#ffffff", KinkyDungeonRootDirectory + "UI/button_logbook.png", undefined, undefined, false, "", 24, true);
        bindex++;
        KinkyDungeonDrawInventory();
    }
    else if (KinkyDungeonDrawState == "Logbook") {
        DrawButtonKDEx("goInv", (bdata) => {
            KinkyDungeonDrawState = "Inventory";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonInventory"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_inventory.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("goRep", (bdata) => {
            KinkyDungeonDrawState = "Reputation";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonReputation"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_reputation.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("goSpells", (bdata) => {
            KinkyDungeonDrawState = "MagicSpells";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonMagic"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_spells.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("return", (bdata) => { KinkyDungeonDrawState = "Game"; return true; }, true, KDReturnButtonXX, 925, bwidth, 60, TextGet("KinkyDungeonGame"), "#ffffff", "", "");
        bindex++;
        KinkyDungeonDrawLore();
    }
    else if (KinkyDungeonDrawState == "Reputation") {
        DrawButtonKDEx("goInv", (bdata) => {
            KinkyDungeonDrawState = "Inventory";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonInventory"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_inventory.png", undefined, undefined, false, "", 24, true);
        bindex++;
        DrawButtonKDEx("return", (bdata) => { KinkyDungeonDrawState = "Game"; return true; }, true, KDReturnButtonXX, 925, 165, 60, TextGet("KinkyDungeonGame"), "#ffffff", "", "");
        bindex++;
        DrawButtonKDEx("goSpells", (bdata) => {
            KinkyDungeonDrawState = "MagicSpells";
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, TextGet("KinkyDungeonMagic"), "#ffffff", KinkyDungeonRootDirectory + "UI/button_spells.png", undefined, undefined, false, "", 24, true);
        bindex++;
        let logtxt = KinkyDungeonNewLoreList.length > 0 ? TextGet("KinkyDungeonLogbookN").replace("N", KinkyDungeonNewLoreList.length) : TextGet("KinkyDungeonLogbook");
        DrawButtonKDEx("goLog", (bdata) => {
            KinkyDungeonDrawState = "Logbook";
            KinkyDungeonUpdateLore(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
            return true;
        }, true, bx + bindex * (bwidth + bspacing), 925, bwidth, 60, logtxt, "#ffffff", KinkyDungeonRootDirectory + "UI/button_logbook.png", undefined, undefined, false, "", 24, true);
        bindex++;
        KinkyDungeonDrawReputation();
    }
    else if (KinkyDungeonDrawState == "Lore") {
        DrawButtonKDEx("return", (bdata) => { KinkyDungeonDrawState = "Game"; return true; }, true, KDReturnButtonXX, 925, 250, 60, TextGet("KinkyDungeonGame"), "#ffffff", "", "");
        KinkyDungeonDrawLore();
    }
    else if (KinkyDungeonDrawState == "Restart") {
        if (TestMode) {
            DrawCheckboxVis(600, 20, 64, 64, "Debug Mode", KDDebugMode, false, "#ffffff");
            if (KDDebugMode) {
                let dd = 30;
                let i = 0;
                for (let r of KinkyDungeonRestraints) {
                    if (i * dd < 1200 && r.name.includes(ElementValue("DebugItem"))) {
                        DrawTextFitKD(r.name, 0, 15 + i * dd, 200, "#ffffff", KDTextGray0, undefined, "left");
                        i++;
                    }
                }
                i = 0;
                for (let r of Object.values(KinkyDungeonConsumables)) {
                    if (i * dd < 1200 && r.name.includes(ElementValue("DebugItem"))) {
                        DrawTextFitKD(r.name, 200, 15 + i * dd, 200, "lightblue", KDTextGray0, undefined, "left");
                        i++;
                    }
                }
                i = 0;
                for (let r of KinkyDungeonEnemies) {
                    if (i * dd < 1200 && r.name.includes(ElementValue("DebugEnemy"))) {
                        DrawTextFitKD(r.name, 400, 15 + i * dd, 200, "#ff0000", KDTextGray0);
                        i++;
                    }
                }
                i = 0;
                for (let r of Object.values(KinkyDungeonWeapons)) {
                    if (i * dd < 1200 && r.name.includes(ElementValue("DebugItem"))) {
                        DrawTextFitKD(r.name, 1800, 15 + i * dd, 200, "orange", KDTextGray0);
                        i++;
                    }
                }
                i = 0;
                for (let r of KinkyDungeonOutfitsBase) {
                    if (i * dd < 1200 && r.name.includes(ElementValue("DebugItem"))) {
                        DrawTextFitKD(r.name, 900, 15 + i * dd, 200, "lightgreen", KDTextGray0);
                        i++;
                    }
                }
                DrawCheckboxVis(1100, 20, 64, 64, "Verbose Console", KDDebug, false, "#ffffff");
                DrawCheckboxVis(1100, 100, 64, 64, "Changeable Perks", KDDebugPerks, false, "#ffffff");
                DrawCheckboxVis(1100, 180, 64, 64, "Unlimited Gold", KDDebugGold, false, "#ffffff");
                ElementPosition("DebugEnemy", 1650, 52, 300, 64);
                DrawButtonVis(1500, 100, 100, 64, "Enemy", "#ffffff", "");
                DrawButtonVis(1600, 100, 100, 64, "Ally", "#ffffff", "");
                DrawButtonVis(1700, 100, 100, 64, "Shop", "#ffffff", "");
                ElementPosition("DebugItem", 1650, 212, 300, 64);
                DrawButtonVis(1500, 260, 300, 64, "Add to inventory", "#ffffff", "");
                DrawButtonVis(1100, 260, 300, 64, "Teleport to stairs", "#ffffff", "");
                DrawButtonVis(1500, 320, 300, 64, "Get save code", "#ffffff", "");
                DrawButtonVis(1100, 320, 300, 64, "Enter parole mode", "#ffffff", "");
                DrawButtonKDEx("debugAddKey", (bdata) => {
                    KinkyDungeonRedKeys += 1;
                    KinkyDungeonBlueKeys += 1;
                    KinkyDungeonLockpicks += 1;
                    return true;
                }, true, 600, 160, 300, 64, "Add keys and lockpicks", "#ffffff", "");
                DrawButtonKDEx("debugAddVision", (bdata) => {
                    KinkyDungeonSeeAll = !KinkyDungeonSeeAll;
                    return true;
                }, true, 600, 240, 300, 64, "Toggle OmniVision™", "#ffffff", "");
                DrawButtonKDEx("debugAddSP", (bdata) => {
                    KinkyDungeonSpellPoints += 1;
                    return true;
                }, true, 600, 320, 300, 64, "Add spell point", "#ffffff", "");
                DrawButtonKDEx("debugClearQuickInv", (bdata) => {
                    KinkyDungeonInventory.get('looserestraint').clear();
                    KinkyDungeonAdvanceTime(0, true);
                    return true;
                }, true, 600, 400, 300, 64, "Clear loose restraints", "#ffffff", "");
                DrawButtonKDEx("debugClearPlayerInv", (bdata) => {
                    KinkyDungeonInventory.get('restraint').clear();
                    KinkyDungeonAdvanceTime(0, true);
                    return true;
                }, true, 600, 480, 300, 64, "Clear worn restraints", "#ffffff", "");
                DrawButtonKDEx("debugIncFloor", (bdata) => {
                    MiniGameKinkyDungeonLevel += 1;
                    return true;
                }, true, 600, 560, 300, 64, "Increment Floor", "#ffffff", "");
            }
        }
        DrawTextFitKD(TextGet("KinkyDungeonRestartConfirm"), 1250, 400, 1000, "#ffffff", "#333333");
        DrawButtonVis(975, 550, 550, 64, TextGet("KinkyDungeonRestartNo"), "#ffffff", "");
        DrawButtonVis(975, 650, 550, 64, TextGet("KinkyDungeonRestartQuitNoErase"), "#ffffff", "");
        DrawButtonVis(975, 800, 550, 64, TextGet("KinkyDungeonRestartCapture" + (KDConfirmDeleteSave ? "Confirm" : "")), (KDGameData.PrisonerState == 'jail' || !KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y)) ? "Pink" : "#ffffff", "");
        DrawButtonVis(975, 900, 550, 64, TextGet("KinkyDungeonRestartYes" + (KDConfirmDeleteSave ? "Confirm" : "")), "#ffffff", "");
        DrawButtonVis(1650, 900, 300, 64, TextGet("KinkyDungeonCheckPerks"), "#ffffff", "");
        DrawButtonKDEx("GameConfigKeys", () => {
            KinkyDungeonState = "Keybindings";
            if (!KinkyDungeonKeybindings)
                KDSetDefaultKeybindings();
            else {
                KinkyDungeonKeybindingsTemp = {};
                Object.assign(KinkyDungeonKeybindingsTemp, KinkyDungeonKeybindings);
            }
            return true;
        }, true, 975, 450, 260, 64, TextGet("GameConfigKeys"), "#ffffff", "");
        DrawButtonKDEx("GameToggles", () => {
            KinkyDungeonState = "Toggles";
            return true;
        }, true, 1265, 450, 260, 64, TextGet("GameToggles"), "#ffffff", "");
    }
    else if (KinkyDungeonDrawState == "Perks2") {
        KinkyDungeonDrawPerks(!KDDebugPerks);
        DrawButtonVis(1650, 920, 300, 64, TextGet("KinkyDungeonLoadBack"), "#ffffff", "");
        DrawButtonKDEx("copyperks", (bdata) => {
            let txt = "";
            for (let k of KinkyDungeonStatsChoice.keys()) {
                if (!k.startsWith("arousal") && !k.endsWith("Mode"))
                    txt += (txt ? "\n" : "") + k;
            }
            navigator.clipboard.writeText(txt);
            return true;
        }, true, 1400, 930, 200, 54, TextGet("KinkyDungeonCopyPerks"), "#ffffff", "");
    }
    if (KinkyDungeonDrawState == "Game") {
        if (KinkyDungeonFlags.get("PlayerOrgasmFilter")) {
            FillRectKD(kdcanvas, kdpixisprites, "screenoverlayor", {
                Left: 0,
                Top: 0,
                Width: 2000,
                Height: 1000,
                Color: "#ff5277",
                LineWidth: 1,
                zIndex: 1,
                alpha: 0.1,
            });
        }
        else if (KinkyDungeonStatFreeze > 0) {
            FillRectKD(kdcanvas, kdpixisprites, "screenoverlayfr", {
                Left: 0,
                Top: 0,
                Width: 2000,
                Height: 1000,
                Color: "#92e8c0",
                LineWidth: 1,
                zIndex: 1,
                alpha: 0.1,
            });
        }
        else if (KDToggles.StunFlash && (KinkyDungeonFlags.get("playerStun") || (KinkyDungeonMovePoints < 0 && KinkyDungeonSlowLevel < 9))) {
            FillRectKD(kdcanvas, kdpixisprites, "screenoverlayst", {
                Left: 0,
                Top: 0,
                Width: 2000,
                Height: 1000,
                Color: "#aaaaaa",
                LineWidth: 1,
                zIndex: 1,
                alpha: 0.07,
            });
        }
        else if (KDToggles.ArousalHearts) {
            KDDrawArousalParticles(KDGameData.OrgasmTurns / KinkyDungeonOrgasmTurnsMax, KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax, (KDGameData.OrgasmStage / KinkyDungeonMaxOrgasmStage));
        }
        else if (KinkyDungeonStatDistraction > 1.0) {
            KDDrawArousalScreenFilter(0, 1000, 2000, KinkyDungeonStatDistraction * 100 / KinkyDungeonStatDistractionMax);
        }
        if (KDToggles.VibeHearts) {
            KDDrawVibeParticles(KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax);
        }
    }
    if (ServerURL != "foobar")
        DrawButtonVis(1885, 25, 90, 90, "", "#ffffff", KinkyDungeonRootDirectory + "UI/Exit.png");
    if ((!KDDebugMode && KinkyDungeonDrawState == "Restart") || (KDDebugMode && KinkyDungeonDrawState != "Restart")) {
        ElementRemove("DebugEnemy");
        ElementRemove("DebugItem");
    }
}
function KDDrawArousalScreenFilter(y1, h, Width, ArousalOverride, Color = '255, 100, 176', AlphaBonus = 0) {
}
function KDCanAttack() {
    let attackCost = KinkyDungeonStatStaminaCostAttack;
    if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.staminacost)
        attackCost = -KinkyDungeonPlayerDamage.staminacost;
    if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackStamina")) {
        attackCost = Math.min(0, attackCost * KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "AttackStamina")));
    }
    return KinkyDungeonHasStamina(Math.abs(attackCost), true);
}
let KinkyDungeonFloaters = [];
let KinkyDungeonLastFloaterTime = 0;
let KDTimescale = 0.004;
let KDBulletSpeed = 40;
let KDEntitiesFloaterRegisty = new Map();
let KDFloaterSpacing = 36 / KinkyDungeonGridSizeDisplay;
function KinkyDungeonSendFloater(Entity, Amount, Color, Time, LocationOverride, suff = "") {
    if (Entity.x && Entity.y) {
        let II = KDEntitiesFloaterRegisty.get(Entity) || 1;
        II += 1;
        KDEntitiesFloaterRegisty.set(Entity, II);
        let floater = {
            x: Entity.x + 0.5,
            y: Entity.y - (II - 1) * KDFloaterSpacing,
            override: LocationOverride,
            speed: 30,
            t: 0,
            color: Color,
            text: "" + ((typeof Amount === "string") ? Amount : Math.round(Amount * 10) / 10) + suff,
            lifetime: Time ? Time : ((typeof Amount === "string") ? 4 : ((Amount < 3) ? 2 : (Amount > 5 ? 3 : 2))),
        };
        KinkyDungeonFloaters.push(floater);
    }
}
function KinkyDungeonDrawFloaters(CamX, CamY) {
    let delta = CommonTime() - KinkyDungeonLastFloaterTime;
    if (delta > 0) {
        for (let floater of KinkyDungeonFloaters) {
            floater.t += delta / 1000;
        }
    }
    let newFloaters = [];
    for (let floater of KinkyDungeonFloaters) {
        let x = floater.override ? floater.x : canvasOffsetX + (floater.x - CamX) * KinkyDungeonGridSizeDisplay;
        let y = floater.override ? floater.y : canvasOffsetY + (floater.y - CamY) * KinkyDungeonGridSizeDisplay;
        DrawTextKD(floater.text, x, y - floater.speed * floater.t, floater.color, KDTextGray1, undefined, undefined, 120, KDEase(floater.t / floater.lifetime));
        if (floater.t < floater.lifetime)
            newFloaters.push(floater);
    }
    KinkyDungeonFloaters = newFloaters;
    KinkyDungeonLastFloaterTime = CommonTime();
}
function KDEase(value) {
    if (value < 0.25)
        return Math.sin(value * Math.PI * 2);
    else if (value > 0.75)
        return Math.sin(-value * Math.PI * 2);
    else
        return 1;
}
let KinkyDungeonMessageToggle = false;
let KinkyDungeonMessageLog = [];
let KDLogDist = 24;
let KDMSGFontSize = 20;
let KDLogHeight = 700;
let KDMaxLog = Math.floor(700 / KDLogDist);
let KDLogTopPad = 100;
let KDLogIndex = 0;
let KDLogIndexInc = 3;
let KDMsgWidth = 1200;
let KDMsgWidthMin = 800;
let KDMsgX = 400;
let KDMsgFadeTime = 10;
let KDMaxConsoleMsg = 6;
function KinkyDungeonDrawMessages(NoLog) {
    if (!NoLog)
        DrawButtonKDEx("logtog", (bdata) => {
            KinkyDungeonMessageToggle = !KinkyDungeonMessageToggle;
            KDLogIndex = 0;
            return true;
        }, true, 1750, 82, 100, 50, TextGet("KinkyDungeonLog"), "#ffffff");
    if (!KinkyDungeonMessageToggle || NoLog) {
        let i = 0;
        if (!MouseIn(KDMsgX + (KDMsgWidth - KDMsgWidthMin) / 2, 62, KDMsgWidthMin, KDLogDist * (2 + KDMaxConsoleMsg)) || KinkyDungeonDrawState != "Game") {
            let msg2nd = [];
            let ignoreMSG = [];
            let spacing = KDLogDist;
            if (KinkyDungeonActionMessageTime > 0 && KinkyDungeonActionMessageNoPush) {
                DrawTextFitKD(KinkyDungeonActionMessage, KDMsgX + KDMsgWidth / 2, 82 + spacing * i, KDMsgWidthMin, KinkyDungeonActionMessageColor, KDTextGray1, KDMSGFontSize);
                ignoreMSG.push(KinkyDungeonActionMessage);
                i++;
            }
            if (KinkyDungeonTextMessageTime > 0 && KinkyDungeonTextMessageNoPush) {
                DrawTextFitKD(KinkyDungeonTextMessage, KDMsgX + KDMsgWidth / 2, 82 + spacing * i, KDMsgWidthMin, KinkyDungeonTextMessageColor, KDTextGray1, KDMSGFontSize);
                ignoreMSG.push(KinkyDungeonTextMessage);
                i++;
            }
            for (let ii = 0; ii < KinkyDungeonMessageLog.length && ii < 100; ii++) {
                let index = KinkyDungeonMessageLog.length - 1 - ii;
                let msg = KinkyDungeonMessageLog[index];
                if (!msg)
                    break;
                if (ignoreMSG.includes(msg.text)) {
                    ignoreMSG.splice(ignoreMSG.indexOf(msg.text), 1);
                    continue;
                }
                if (KinkyDungeonCurrentTick - msg.time < KDMsgFadeTime) {
                    let count = 1;
                    for (let iii = 1; iii < 100; iii++) {
                        if (KinkyDungeonMessageLog[index - iii] && KinkyDungeonMessageLog[index - iii].text == msg.text) {
                            count += 1;
                        }
                        else
                            break;
                    }
                    if (count > 1) {
                        ii += count - 1;
                    }
                    msg2nd.push(count == 1 ? msg : Object.assign({}, { text: msg.text + ` (x${count})`, color: msg.color, time: msg.time }));
                }
            }
            if (msg2nd.length > 0) {
                let alpha = 1;
                let alphamin = 0.4;
                for (let msg of msg2nd) {
                    if (i > KDMaxConsoleMsg || (KinkyDungeonDrawState != "Game" && i > 3))
                        break;
                    if (alpha > 0) {
                        alpha = Math.max(0, Math.min(1, 2.0 - i / KDMaxConsoleMsg)) * (1 - Math.max(0, Math.min(1, Math.max(0, KinkyDungeonCurrentTick - msg.time - 1) / KDMsgFadeTime)));
                        DrawTextFitKD(msg.text, KDMsgX + KDMsgWidth / 2, 82 + spacing * i, KDMsgWidthMin, msg.color, KDTextGray1, KDMSGFontSize, undefined, undefined, alphamin + (1 - alphamin) * alpha);
                        i++;
                    }
                }
            }
        }
        if (i > 0 || KinkyDungeonDrawState == "Game")
            FillRectKD(kdcanvas, kdpixisprites, "msglogbg", {
                Left: KDMsgX + (KDMsgWidth - KDMsgWidthMin) / 2,
                Top: 0,
                Width: KDMsgWidthMin,
                Height: 62 + KDLogDist * (i + 1),
                Color: "#000000",
                LineWidth: 1,
                zIndex: 100,
                alpha: 0.45,
            });
    }
    else {
        FillRectKD(kdcanvas, kdpixisprites, "msglogbg", {
            Left: KDMsgX,
            Top: 0,
            Width: KDMsgWidth,
            Height: KDLogTopPad + KDLogHeight,
            Color: KDTextGray0,
            LineWidth: 1,
            zIndex: 100,
            alpha: 0.6,
        });
        for (let i = 0; i < KinkyDungeonMessageLog.length && i < KDMaxLog; i++) {
            let log = KinkyDungeonMessageLog[Math.max(0, KinkyDungeonMessageLog.length - 1 - (i + KDLogIndex))];
            let col = log.color;
            DrawTextFitKD(log.text, KDMsgX + KDMsgWidth / 2, KDLogTopPad + i * KDLogDist + KDLogDist / 2, KDMsgWidth, col, KDTextGray1, 28, undefined, 101);
        }
        if (KinkyDungeonMessageLog.length > KDMaxLog) {
            DrawButtonKDEx("logscrollup", (bdata) => {
                if (KDLogIndex > 0)
                    KDLogIndex = Math.max(0, KDLogIndex - KDLogIndexInc);
                return true;
            }, true, 1500, 20, 90, 40, "", "#ffffff", KinkyDungeonRootDirectory + "Up.png");
            DrawButtonKDEx("logscrolldown", (bdata) => {
                if (KDLogIndex < KinkyDungeonMessageLog.length - KDMaxLog)
                    KDLogIndex = Math.min(Math.max(0, KinkyDungeonMessageLog.length - KDMaxLog), KDLogIndex + KDLogIndexInc);
                return true;
            }, true, 1500, 60, 90, 40, "", "#ffffff", KinkyDungeonRootDirectory + "Down.png");
            if (KinkyDungeonMessageLog.length > KDMaxLog * 100) {
                KinkyDungeonMessageLog.splice(0, KDMaxLog * 100 - KinkyDungeonMessageLog.length);
            }
        }
    }
}
function KDhexToRGB(h) {
    let r = "", g = "", b = "";
    if (h.length == 4) {
        r = h[1] + h[1];
        g = h[2] + h[2];
        b = h[3] + h[3];
    }
    else if (h.length == 7) {
        r = h[1] + h[2];
        g = h[3] + h[4];
        b = h[5] + h[6];
    }
    return { r: r, g: g, b: b };
}
function KinkyDungeonUpdateVisualPosition(Entity, amount) {
    if (amount < 0 || Entity.visual_x == undefined || Entity.visual_y == undefined) {
        Entity.visual_x = (Entity.xx != undefined) ? Entity.xx : Entity.x;
        Entity.visual_y = (Entity.yy != undefined) ? Entity.yy : Entity.y;
        return -1;
    }
    else {
        let speed = 50 + KDAnimSpeed * 50;
        if (Entity.player && KinkyDungeonSlowLevel > 0 && KDGameData.KinkyDungeonLeashedPlayer < 2 && (KinkyDungeonFastMovePath.length < 1 || KinkyDungeonSlowLevel > 1))
            speed += KDAnimSpeed * 50 * KinkyDungeonSlowLevel;
        if (KDGameData.SleepTurns > 0)
            speed = 100;
        if (speed > 300)
            speed = 250;
        if (Entity.scale)
            speed = KDBulletSpeed;
        let value = amount / speed;
        let tx = (Entity.xx != undefined) ? Entity.xx : Entity.x;
        let ty = (Entity.yy != undefined) ? Entity.yy : Entity.y;
        let offX = 0;
        let offY = 0;
        let offamount = 0.25;
        if (Entity.fx && Entity.fy && (Entity.fx != Entity.x || Entity.fy != Entity.y) && Entity.Enemy && !KDIsImmobile(Entity)) {
            if (Entity.fx != Entity.x) {
                offX = offamount * Math.sign(Entity.fx - Entity.x);
            }
            if (Entity.fy != Entity.y) {
                offY = offamount * Math.sign(Entity.fy - Entity.y);
            }
        }
        tx += offX;
        ty += offY;
        let dist = Math.sqrt((Entity.visual_x - tx) * (Entity.visual_x - tx) + (Entity.visual_y - ty) * (Entity.visual_y - ty));
        if (dist > 5) {
            value = 1;
        }
        if (Entity.scale != undefined) {
            let scalemult = 0.9;
            if (dist > 0 || !Entity.end || !(Entity.vx || Entity.vy)) {
                if (Entity.vx || Entity.vy) {
                    scalemult = KDistEuclidean(Entity.vx, Entity.vy);
                }
                Entity.scale = Math.min(1.0, Entity.scale + KDTimescale * amount * scalemult);
            }
            else {
                Entity.scale = Math.max(0.0, Entity.scale - KDTimescale * amount * scalemult);
            }
        }
        if (Entity.alpha != undefined) {
            let alphamult = 0.28;
            if (dist > 0 || !Entity.end) {
                Entity.alpha = Math.min(1.0, Entity.alpha + KDTimescale * amount * 3.0);
            }
            else {
                if ((Entity.vx || Entity.vy) || Entity.time > 1) {
                    alphamult = 0;
                }
                Entity.alpha = Math.min(1, Math.max(0.0, Entity.alpha - KDTimescale * amount * alphamult));
            }
        }
        if (Entity.spin != undefined && Entity.spinAngle != undefined) {
            Entity.spinAngle += Entity.spin * KDTimescale * amount;
            if (Entity.spinAngle > Math.PI * 2)
                Entity.spinAngle -= Math.PI * 2;
            else if (Entity.spinAngle < 0)
                Entity.spinAngle += Math.PI * 2;
        }
        if (dist == 0)
            return dist;
        let weightx = Math.abs(Entity.visual_x - tx) / (dist);
        let weighty = Math.abs(Entity.visual_y - ty) / (dist);
        if (Entity.visual_x > tx)
            Entity.visual_x = Math.max(Entity.visual_x - value * weightx, tx);
        else
            Entity.visual_x = Math.min(Entity.visual_x + value * weightx, tx);
        if (Entity.visual_y > ty)
            Entity.visual_y = Math.max(Entity.visual_y - value * weighty, ty);
        else
            Entity.visual_y = Math.min(Entity.visual_y + value * weighty, ty);
        return dist;
    }
}
function KinkyDungeonSetTargetLocation() {
    KinkyDungeonTargetX = Math.round((MouseX - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetX) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamX;
    KinkyDungeonTargetY = Math.round((MouseY - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetY) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamY;
}
function KinkyDungeonSetMoveDirection() {
    let tx = Math.round((MouseX - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetX) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamX;
    let ty = Math.round((MouseY - KinkyDungeonGridSizeDisplay / 2 - canvasOffsetY) / KinkyDungeonGridSizeDisplay) + KinkyDungeonCamY;
    KDSendInput("setMoveDirection", { dir: KinkyDungeonGetDirection(tx - KinkyDungeonPlayerEntity.x, ty - KinkyDungeonPlayerEntity.y) }, true, true);
}
let KDBoxThreshold = 60;
let KDButtonColor = "rgba(5, 5, 5, 0.5)";
let KDButtonColorIntense = "rgba(5, 5, 5, 0.8)";
let KDBorderColor = '#f0b541';
function DrawBoxKD(Left, Top, Width, Height, Color, NoBorder, Alpha, zIndex = 90) {
    FillRectKD(kdcanvas, kdpixisprites, "box" + Left + "," + Top + "," + Width + "," + Height + Color + zIndex, {
        Left: Left,
        Top: Top,
        Width: Width,
        Height: Height,
        Color: Color,
        LineWidth: 1,
        zIndex: zIndex,
        alpha: Alpha != undefined ? Alpha : 1,
    });
    if (!NoBorder) {
        DrawRectKD(kdcanvas, kdpixisprites, "boxBorder" + Left + "," + Top + "," + Width + "," + Height + zIndex, {
            Left: Left,
            Top: Top,
            Width: Width,
            Height: Height,
            Color: KDBorderColor,
            LineWidth: 2,
            zIndex: zIndex + 0.001,
        });
    }
}
let KDFont = 'Arial';
function DrawTextFitKD(Text, X, Y, Width, Color, BackColor, FontSize, Align, zIndex = 110, alpha = 1.0, border = undefined) {
    if (!Text)
        return;
    let alignment = Align ? Align : "center";
    DrawTextVisKD(kdcanvas, kdpixisprites, Text + "," + X + "," + Y, {
        Text: Text,
        X: X,
        Y: Y,
        Width: Width,
        Color: Color,
        BackColor: BackColor ? BackColor : (Color == KDTextGray2 ? KDTextGray0 : (Color == KDTextGray0 ? KDTextGray3 : KDTextGray2)),
        FontSize: FontSize ? FontSize : 30,
        align: alignment,
        zIndex: zIndex,
        alpha: alpha,
        border: border,
    });
}
function DrawTextKD(Text, X, Y, Color, BackColor, FontSize, Align, zIndex = 110, alpha = 1.0, border = undefined) {
    if (!Text)
        return;
    let alignment = Align ? Align : "center";
    DrawTextVisKD(kdcanvas, kdpixisprites, Text + "," + X + "," + Y, {
        Text: Text,
        X: X,
        Y: Y,
        Width: undefined,
        Color: Color,
        BackColor: BackColor,
        FontSize: FontSize ? FontSize : 30,
        align: alignment,
        zIndex: zIndex,
        alpha: alpha,
        border: border,
    });
}
let KDFontName = "Roboto";
window.WebFontConfig = {
    google: {
        families: [KDFontName],
    },
    active() {
        KDAllowText = true;
    },
};
let KDAllowText = true;
(function () {
    const wf = document.createElement('script');
    wf.src = `Fonts/webfont.js`;
    wf.type = 'text/javascript';
    wf.async = true;
    const s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
}());
function DrawTextVisKD(Container, Map, id, Params) {
    if (!KDAllowText)
        return;
    let sprite = Map.get(id);
    let same = true;
    let par = kdprimitiveparams.get(id);
    if (sprite && par) {
        for (let p of Object.entries(kdprimitiveparams.get(id))) {
            if (Params[p[0]] != p[1]) {
                same = false;
                break;
            }
        }
        for (let p of Object.entries(Params)) {
            if (par[p[0]] != p[1]) {
                same = false;
                break;
            }
        }
    }
    if (!sprite || !same) {
        if (sprite)
            sprite.destroy();
        sprite = new PIXI.Text(Params.Text, {
            fontFamily: KDFontName,
            fontSize: Params.FontSize ? Params.FontSize : 30,
            fill: string2hex(Params.Color),
            stroke: Params.BackColor != "none" ? (Params.BackColor ? string2hex(Params.BackColor) : "#333333") : 0x000000,
            strokeThickness: Params.border != undefined ? Params.border : (Params.BackColor != "none" ? (Params.FontSize ? Math.ceil(Params.FontSize / 8) : 2) : 0),
            miterLimit: 4,
        });
        if (Params.Width) {
            sprite.scale.x = Math.min(1, Params.Width / Math.max(1, sprite.width));
            sprite.scale.y = sprite.scale.x;
        }
        Map.set(id, sprite);
        Container.addChild(sprite);
        if (!kdprimitiveparams.has(id) || !same)
            kdprimitiveparams.set(id, Params);
    }
    if (sprite) {
        sprite.name = id;
        sprite.position.x = Params.X + (Params.align == 'center' ? -sprite.width / 2 : (Params.align == 'right' ? -sprite.width : 0));
        sprite.position.y = Params.Y - sprite.height / 2 - 2;
        sprite.zIndex = Params.zIndex ? Params.zIndex : 0;
        sprite.alpha = Params.alpha ? Params.alpha : 1;
        kdSpritesDrawn.set(id, true);
        return true;
    }
    return false;
}
function DrawRectKD(Container, Map, id, Params) {
    let sprite = Map.get(id);
    let same = true;
    if (sprite && kdprimitiveparams.has(id)) {
        for (let p of Object.entries(kdprimitiveparams.get(id))) {
            if (Params[p[0]] != p[1]) {
                same = false;
                break;
            }
        }
    }
    if (!sprite || !same) {
        if (sprite)
            sprite.destroy();
        sprite = new PIXI.Graphics();
        sprite.lineStyle(Params.LineWidth ? Params.LineWidth : 1, string2hex(Params.Color), 1);
        sprite.drawRect(0, 0, Params.Width, Params.Height);
        Map.set(id, sprite);
        Container.addChild(sprite);
        if (!kdprimitiveparams.has(id) || !same)
            kdprimitiveparams.set(id, Params);
    }
    if (sprite) {
        sprite.name = id;
        sprite.position.x = Params.Left;
        sprite.position.y = Params.Top;
        sprite.width = Params.Width;
        sprite.height = Params.Height;
        sprite.zIndex = Params.zIndex ? Params.zIndex : 0;
        sprite.alpha = Params.alpha ? Params.alpha : 1;
        kdSpritesDrawn.set(id, true);
        return true;
    }
    return false;
}
function FillRectKD(Container, Map, id, Params) {
    let sprite = Map.get(id);
    let same = true;
    if (sprite && kdprimitiveparams.has(id)) {
        for (let p of Object.entries(kdprimitiveparams.get(id))) {
            if (Params[p[0]] != p[1]) {
                same = false;
                break;
            }
        }
    }
    if (!sprite || !same) {
        if (sprite)
            sprite.destroy();
        sprite = new PIXI.Graphics();
        sprite.beginFill(string2hex(Params.Color));
        sprite.drawRect(0, 0, Params.Width, Params.Height);
        Map.set(id, sprite);
        Container.addChild(sprite);
        if (!kdprimitiveparams.has(id))
            kdprimitiveparams.set(id, Params);
    }
    if (sprite) {
        sprite.name = id;
        sprite.position.x = Params.Left;
        sprite.position.y = Params.Top;
        sprite.width = Params.Width;
        sprite.height = Params.Height;
        sprite.zIndex = Params.zIndex ? Params.zIndex : 0;
        sprite.alpha = Params.alpha ? Params.alpha : 1;
        kdSpritesDrawn.set(id, true);
        return true;
    }
    return false;
}
function DrawButtonVis(Left, Top, Width, Height, Label, Color, Image, HoveringText, Disabled, NoBorder, FillColor, FontSize, ShiftText, Stretch, zIndex = 100, options) {
    let hover = ((MouseX >= Left) && (MouseX <= Left + Width) && (MouseY >= Top) && (MouseY <= Top + Height) && !CommonIsMobile && !Disabled);
    if (!NoBorder || FillColor)
        DrawBoxKD(Left, Top, Width, Height, FillColor ? FillColor : (hover ? (KDTextGray2) : KDButtonColor), NoBorder, (options === null || options === void 0 ? void 0 : options.alpha) || 0.5, zIndex);
    if (hover) {
        let pad = 4;
        DrawRectKD(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height + "out", {
            Left: Left + pad,
            Top: Top + pad,
            Width: Width - 2 * pad + 1,
            Height: Height - 2 * pad + 1,
            Color: "#ffffff",
            LineWidth: 2,
            zIndex: zIndex,
        });
    }
    let textPush = 0;
    if ((Image != null) && (Image != "")) {
        let img = KDTex(Image);
        if (Stretch) {
            KDDraw(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height, Image, Left, Top, Width, Height, undefined, {
                zIndex: zIndex + 0.001,
            });
        }
        else
            KDDraw(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height, Image, Left + 2, Top + Height / 2 - img.orig.height / 2, img.orig.width, img.orig.height, undefined, {
                zIndex: zIndex + 0.001,
            });
        textPush = img.orig.width;
    }
    DrawTextFitKD(Label, Left + Width / 2 + (ShiftText ? textPush * 0.5 : 0), Top + (Height / 2), Width - 4 - Width * 0.04 - (textPush ? (textPush + (ShiftText ? 0 : Width * 0.04)) : Width * 0.04), Color, (options && options.noTextBG) ? "none" : undefined, FontSize, undefined, zIndex + 0.001);
    if ((HoveringText != null) && (MouseX >= Left) && (MouseX <= Left + Width) && (MouseY >= Top) && (MouseY <= Top + Height)) {
        DrawTextFitKD(HoveringText, 1000, MouseY, 1500, "#ffffff");
    }
}
function DrawCheckboxVis(Left, Top, Width, Height, Text, IsChecked, Disabled = false, TextColor = KDTextGray0, CheckImage = "Icons/Checked.png", options) {
    DrawTextFitKD(Text, Left + 100, Top + 33, 1000, TextColor, "#333333", undefined, "left");
    DrawButtonVis(Left, Top, Width, Height, "", Disabled ? "#ebebe4" : "#ffffff", IsChecked ? (KinkyDungeonRootDirectory + "UI/Checked.png") : "", null, Disabled, undefined, undefined, undefined, undefined, undefined, options === null || options === void 0 ? void 0 : options.zIndex, options);
}
function DrawCheckboxKDEx(name, func, enabled, Left, Top, Width, Height, Text, IsChecked, Disabled = false, TextColor = KDTextGray0, CheckImage = "Icons/Checked.png", options) {
    DrawTextFitKD(Text, Left + 100, Top + 33, (options === null || options === void 0 ? void 0 : options.maxWidth) || 1000, TextColor, "#333333", undefined, "left");
    DrawButtonKDEx(name, func, enabled, Left, Top, Width, Height, "", Disabled ? "#ebebe4" : "#ffffff", IsChecked ? (KinkyDungeonRootDirectory + "UI/Checked.png") : "", null, Disabled, undefined, undefined, undefined, undefined, options);
}
function DrawBackNextButtonVis(Left, Top, Width, Height, Label, Color, Image, BackText, NextText, Disabled, ArrowWidth, NoBorder, options) {
    let id = "BackNext" + Left + "," + Top + "," + Width + Color;
    if (ArrowWidth == null || ArrowWidth > Width / 2)
        ArrowWidth = Width / 2;
    const LeftSplit = Left + ArrowWidth;
    const RightSplit = Left + Width - ArrowWidth;
    DrawBoxKD(Left, Top, Width, Height, KDButtonColor, undefined, (options === null || options === void 0 ? void 0 : options.alpha) || 0.5);
    if (MouseIn(Left, Top, Width, Height) && !CommonIsMobile && !Disabled) {
        if (MouseX > RightSplit) {
            DrawRectKD(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height + "a", {
                Left: RightSplit + 4,
                Top: Top + 4,
                Width: ArrowWidth - 8,
                Height: Height - 8,
                Color: "#ffffff",
                LineWidth: 1,
                zIndex: 101,
            });
        }
        else if (MouseX <= LeftSplit) {
            DrawRectKD(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height + "a", {
                Left: Left + 4,
                Top: Top + 4,
                Width: ArrowWidth - 8,
                Height: Height - 8,
                Color: "#ffffff",
                LineWidth: 1,
                zIndex: 101,
            });
        }
        else {
            DrawRectKD(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height + "a", {
                Left: Left + ArrowWidth + 4,
                Top: Top + 4,
                Width: Width - ArrowWidth * 2 - 8,
                Height: Height - 8,
                Color: "#ffffff",
                LineWidth: 1,
                zIndex: 101,
            });
        }
    }
    else if (CommonIsMobile && ArrowWidth < Width / 2 && !Disabled) {
        DrawRectKD(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height + "a1", {
            Left: Left + 4,
            Top: Top + 4,
            Width: ArrowWidth - 8,
            Height: Height - 8,
            Color: "#ffffff",
            LineWidth: 1,
            zIndex: 101,
        });
        DrawRectKD(kdcanvas, kdpixisprites, Left + "," + Top + Image + "w" + Width + "h" + Height + "a2", {
            Left: RightSplit + 4,
            Top: Top + 4,
            Width: ArrowWidth - 8,
            Height: Height - 8,
            Color: "#ffffff",
            LineWidth: 1,
            zIndex: 101,
        });
    }
    DrawTextFitKD(Label, Left + Width / 2, Top + (Height / 2) + 1, (CommonIsMobile) ? Width - 6 : Width - 36, "#ffffff");
}
function KDDrawMap(CamX, CamY, CamX_offset, CamY_offset, Debug) {
    let tooltip = "";
    let KinkyDungeonForceRender = "";
    let KinkyDungeonForceRenderFloor = "";
    for (let b of Object.values(KinkyDungeonPlayerBuffs)) {
        if (b && b.mushroom) {
            KinkyDungeonForceRender = '2';
            KinkyDungeonForceRenderFloor = "cry";
        }
    }
    let altType = KDGetAltType(MiniGameKinkyDungeonLevel);
    let drawFloor = (altType === null || altType === void 0 ? void 0 : altType.skin) ? altType.skin : KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint];
    let noReplace = "";
    let noReplace_skin = {};
    for (let tile of Object.values(KinkyDungeonTilesSkin)) {
        if (tile.skin && noReplace_skin[tile.skin] != undefined) {
            let paramskin = KinkyDungeonMapParams[drawFloor];
            if (paramskin.noReplace)
                noReplace_skin[tile.skin] = paramskin.noReplace;
            else
                noReplace_skin[tile.skin] = "";
        }
    }
    let params = KinkyDungeonMapParams[drawFloor];
    if (params.noReplace)
        noReplace = params.noReplace;
    let rows = KinkyDungeonGrid.split('\n');
    for (let R = -1; R <= KinkyDungeonGridHeightDisplay + 1; R++) {
        for (let X = -1; X <= KinkyDungeonGridWidthDisplay + 1; X++) {
            let RY = R + CamY;
            let RX = X + CamX;
            let allowFog = KDAllowFog();
            if (RY >= 0 && RY < KinkyDungeonGridHeight && RX >= 0 && RX < KinkyDungeonGridWidth && (KinkyDungeonVisionGet(RX, RY) > 0 || (allowFog && KinkyDungeonFogGet(RX, RY) > 0))) {
                if (Debug) {
                    if (KinkyDungeonTilesGet(RX + "," + RY)) {
                        if (KinkyDungeonTilesGet(RX + "," + RY).Lock)
                            DrawTextFitKD(KinkyDungeonTilesGet(RX + "," + RY).Lock, (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, "#aaaaaA");
                        if (KinkyDungeonTilesGet(RX + "," + RY).AI)
                            DrawTextFitKD(KinkyDungeonTilesGet(RX + "," + RY).AI, (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, "#aaaaaA");
                        if (KinkyDungeonTilesGet(RX + "," + RY).Type == "Prisoner")
                            DrawTextFitKD("Prisoner", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, "#aaaaaA");
                        if (KinkyDungeonTilesGet(RX + "," + RY).required && KinkyDungeonTilesGet(RX + "," + RY).required)
                            DrawTextFitKD(KinkyDungeonTilesGet(RX + "," + RY).required[0], (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 3, KinkyDungeonGridSizeDisplay, "#aaaaaA");
                        if (KinkyDungeonTilesGet(RX + "," + RY).Label && KinkyDungeonTilesGet(RX + "," + RY).required)
                            DrawTextFitKD(KinkyDungeonTilesGet(RX + "," + RY).required[0], (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 1.5, KinkyDungeonGridSizeDisplay, "#aaaaaA");
                        if (KinkyDungeonTilesGet(RX + "," + RY).OffLimits)
                            DrawTextFitKD("OffLimits", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 3, KinkyDungeonGridSizeDisplay, "#ff5555");
                        if (KinkyDungeonTilesGet(RX + "," + RY).Priority)
                            DrawTextFitKD("Priority", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay * 0.67, KinkyDungeonGridSizeDisplay, "#55ff55");
                    }
                    for (let p of KinkyDungeonPOI) {
                        if (p.x == RX && p.y == RY) {
                            DrawTextFitKD("POI" + (p.requireTags && p.requireTags.includes("endpoint") ? "Endpoint" : ""), (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay - KinkyDungeonGridSizeDisplay / 3, KinkyDungeonGridSizeDisplay, "#999999");
                            DrawTextFitKD((p.favor && p.favor.length > 0 ? p.favor[0] : ""), (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, "#999999");
                            DrawTextFitKD((p.chance || 1.0) * 100 + "%", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 3, KinkyDungeonGridSizeDisplay, "#999999");
                        }
                    }
                    for (let p of KDGameData.KeyringLocations) {
                        if (p.x == RX && p.y == RY) {
                            DrawTextFitKD("Keyring", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 2, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay + KinkyDungeonGridSizeDisplay / 3, KinkyDungeonGridSizeDisplay, "#999999");
                        }
                    }
                }
                let floor = KinkyDungeonTilesSkin[RX + "," + RY] ?
                    (KinkyDungeonTilesSkin[RX + "," + RY].force ? KinkyDungeonTilesSkin[RX + "," + RY].skin : KinkyDungeonMapIndex[KinkyDungeonTilesSkin[RX + "," + RY].skin])
                    : drawFloor;
                let vision = KinkyDungeonVisionGet(RX, RY);
                let nR = KinkyDungeonTilesSkin[RX + "," + RY] ? noReplace : noReplace_skin[floor];
                let sprite = KinkyDungeonGetSprite(rows[RY][RX], RX, RY, vision == 0, nR);
                let sprite2 = KinkyDungeonGetSpriteOverlay(rows[RY][RX], RX, RY, vision == 0, nR);
                let sprite3 = KinkyDungeonGetSpriteOverlay2(rows[RY][RX], RX, RY, vision == 0, nR);
                if (KinkyDungeonForceRender) {
                    sprite = KinkyDungeonGetSprite(KinkyDungeonForceRender, RX, RY, vision == 0, nR);
                    sprite2 = null;
                    sprite3 = null;
                }
                if (KinkyDungeonForceRenderFloor != "")
                    floor = KinkyDungeonForceRenderFloor;
                let light = KinkyDungeonBrightnessGet(RX, RY);
                let lightColor = KDAvgColor(KinkyDungeonColorGet(RX, RY), KinkyDungeonShadowGet(RX, RY), light, 1);
                lightColor = KDAvgColor(lightColor, 0xffffff, 1, 1);
                KDDraw(kdgameboard, kdpixisprites, RX + "," + RY, KinkyDungeonRootDirectory + "Floors/Floor_" + floor + "/" + sprite + ".png", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                    zIndex: -2,
                    tint: lightColor,
                });
                if (sprite2)
                    KDDraw(kdgameboard, kdpixisprites, RX + "," + RY + "_o", KinkyDungeonRootDirectory + "FloorGeneric/" + sprite2 + ".png", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                        zIndex: -1.1,
                        tint: lightColor,
                    });
                if (sprite3)
                    KDDraw(kdgameboard, kdpixisprites, RX + "," + RY + "_o2", KinkyDungeonRootDirectory + "FloorGeneric/" + sprite3 + ".png", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                        zIndex: -1,
                        tint: lightColor,
                    });
                if (rows[RY][RX] == "A") {
                    let color = "";
                    if (KinkyDungeonTilesGet(RX + "," + RY)) {
                        color = KDGoddessColor(KinkyDungeonTilesGet(RX + "," + RY).Name);
                    }
                    if (color)
                        KDDraw(kdgameboard, kdpixisprites, RX + "," + RY + "_a", KinkyDungeonRootDirectory + "ShrineAura.png", (-CamX_offset + X) * KinkyDungeonGridSizeDisplay, (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, undefined, {
                            tint: string2hex(color),
                        });
                }
                if (KinkyDungeonVisionGet(RX, RY) > 0
                    && (KinkyDungeonTilesGet(RX + "," + RY) && rows[RY][RX] == "A" || KinkyDungeonTilesGet(RX + "," + RY) && rows[RY][RX] == "M")
                    && MouseIn(canvasOffsetX + (-CamX_offset + X) * KinkyDungeonGridSizeDisplay, canvasOffsetY + (-CamY_offset + R) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay)) {
                    tooltip = TextGet("KinkyDungeon" + KinkyDungeonTilesGet(RX + "," + RY).Type + "Tooltip").replace("SHRINETYPE", TextGet("KinkyDungeonShrine" + KinkyDungeonTilesGet(RX + "," + RY).Name));
                }
            }
        }
    }
    return {
        tooltip: tooltip,
        KinkyDungeonForceRender: KinkyDungeonForceRender,
    };
}
function KDDraw(Container, Map, id, Image, Left, Top, Width, Height, Rotation, options, Centered, SpritesDrawn, Scale) {
    let sprite = Map.get(id);
    if (!sprite) {
        let tex = KDTex(Image);
        if (tex) {
            sprite = PIXI.Sprite.from(tex);
            Map.set(id, sprite);
            Container.addChild(sprite);
        }
    }
    if (sprite) {
        sprite.interactive = false;
        let tex = KDTex(Image);
        if (tex)
            sprite.texture = tex;
        sprite.name = id;
        sprite.position.x = Left;
        sprite.position.y = Top;
        if (Width)
            sprite.width = Width;
        if (Height)
            sprite.height = Height;
        if (Scale) {
            sprite.scale.x = Scale;
            sprite.scale.y = Scale;
        }
        if (Centered) {
            sprite.anchor.set(0.5);
        }
        if (Rotation != undefined)
            sprite.rotation = Rotation;
        if (options) {
            if (options.filters && sprite.cacheAsBitmap) {
                sprite.filters = null;
            }
            else {
                for (let o of Object.entries(options)) {
                    sprite[o[0]] = o[1];
                }
            }
            if (options.scalex != undefined) {
                sprite.scale.x = sprite.scale.x * options.scalex;
            }
            if (options.scaley != undefined) {
                sprite.scale.y = sprite.scale.y * options.scaley;
            }
            if (options.anchorx != undefined) {
                sprite.anchor.x = options.anchorx;
            }
            if (options.anchory != undefined) {
                sprite.anchor.y = options.anchory;
            }
        }
        if (SpritesDrawn)
            SpritesDrawn.set(id, true);
        else
            kdSpritesDrawn.set(id, true);
        return true;
    }
    return false;
}
function KDTex(Image) {
    if (kdpixitex.has(Image))
        return kdpixitex.get(Image);
    let tex = PIXI.Texture.from(Image);
    kdpixitex.set(Image, tex);
    return tex;
}
function string2hex(str) {
    return PIXI.utils.string2hex(str);
}
function GetAdjacentList(list, index, width) {
    return {
        left: list.slice(0, index),
        right: list.slice(index + width),
    };
}
function KDUpdateVision() {
    var _a;
    KinkyDungeonUpdateLightGrid = false;
    let viewpoints = [{ x: KinkyDungeonPlayerEntity.x, y: KinkyDungeonPlayerEntity.y, brightness: KinkyDungeonDeaf ? 2 : 4 }];
    let data = {
        lights: [],
        maplights: [],
    };
    let l = null;
    for (let t of Object.keys(KinkyDungeonTiles)) {
        let tile = KinkyDungeonTilesGet(t);
        let x = parseInt(t.split(',')[0]);
        let y = parseInt(t.split(',')[1]);
        if (tile && tile.Light && x && y) {
            l = { x: x, y: y + (tile.Offset ? 1 : 0), y_orig: y, brightness: tile.Light, color: tile.lightColor };
            data.lights.push(l);
            data.maplights.push(l);
        }
    }
    for (let b of KinkyDungeonBullets) {
        if ((_a = b.bullet) === null || _a === void 0 ? void 0 : _a.bulletColor) {
            l = { x: b.x, y: b.y, y_orig: b.y, brightness: b.bullet.bulletLight, color: b.bullet.bulletColor };
            data.lights.push(l);
        }
    }
    KinkyDungeonSendEvent("getLights", data);
    KinkyDungeonMakeBrightnessMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, KinkyDungeonMapBrightness, data.lights, KDVisionUpdate);
    KinkyDungeonMakeVisionMap(KinkyDungeonGridWidth, KinkyDungeonGridHeight, viewpoints, data.lights, KDVisionUpdate, KinkyDungeonMapBrightness);
    KDVisionUpdate = 0;
}
let KDTileTooltips = {
    '1': () => { return { color: "#ffffff", text: "1" }; },
    '0': () => { return { color: "#ffffff", text: "0" }; },
    '2': () => { return { color: "#ffffff", text: "2" }; },
    'R': () => { return { color: "#ffffff", noInspect: true, text: "R" }; },
    'Y': () => { return { color: "#ffffff", noInspect: true, text: "Y" }; },
    'L': () => { return { color: "#ffffff", noInspect: true, text: "L" }; },
    'A': () => { return { color: "#ffffff", noInspect: true, text: "A" }; },
    'a': () => { return { color: "#ffffff", text: "a" }; },
    'O': () => { return { color: "#ffffff", text: "O" }; },
    'o': () => { return { color: "#ffffff", text: "o" }; },
    'C': () => { return { color: "#ffffff", noInspect: true, text: "C" }; },
    'c': () => { return { color: "#ffffff", text: "c" }; },
    'T': () => { return { color: "#ffffff", text: "T" }; },
    '4': () => { return { color: "#ffffff", noInspect: true, text: "4" }; },
    'X': () => { return { color: "#ffffff", text: "X" }; },
    '?': () => { return { color: "#ffffff", noInspect: true, text: "Hook" }; },
    ',': () => { return { color: "#ffffff", noInspect: true, text: "Hook" }; },
    'S': () => { return { color: "#ffffff", noInspect: true, text: "S" }; },
    's': () => { return { color: "#ffffff", noInspect: true, text: "s" }; },
    'H': () => { return { color: "#ffffff", noInspect: true, text: "H" }; },
    'G': () => { return { color: "#ffffff", noInspect: true, text: "G" }; },
    'B': () => { return { color: "#ffffff", noInspect: true, text: "B" }; },
    '@': () => { return { color: "#ffffff", noInspect: true, text: "@" }; },
    'b': () => { return { color: "#ffffff", noInspect: true, text: "b" }; },
    'D': () => { return { color: "#ffffff", noInspect: true, text: "D" }; },
    'd': () => { return { color: "#ffffff", noInspect: true, text: "d" }; },
    'Z': () => { return { color: "#ffffff", noInspect: true, text: "Z" }; },
    'z': () => { return { color: "#ffffff", noInspect: true, text: "z" }; },
    't': () => { return { color: "#aa55ff", noInspect: true, text: "t" }; },
    'u': () => { return { color: "#ffffff", noInspect: true, text: "u" }; },
    'V': () => { return { color: "#ffffff", noInspect: true, text: "V" }; },
    'N': () => { return { color: "#ffffff", noInspect: true, text: "N" }; },
};
function KDDrawTileTooltip(maptile, x, y, offset) {
    let TooltipList = [];
    TooltipList.push({
        str: TextGet("KDTileTooltip" + KDTileTooltips[maptile]().text),
        fg: KDTileTooltips[maptile]().color,
        bg: "#000000",
        size: 24,
        center: true,
    });
    return KDDrawTooltip(TooltipList, offset);
}
let KDEffectTileTooltips = {
    'Runes': (tile, x, y, TooltipList) => {
        TooltipList.push({
            str: TextGet("KDEffectTileTooltip" + tile.name),
            fg: "#ff5555",
            bg: "#000000",
            size: 24,
            center: true,
        });
        TooltipList.push({
            str: TextGet("KDEffectTileTooltip" + tile.name + "Desc"),
            fg: "#ffffff",
            bg: "#000000",
            size: 16,
            center: true,
        });
    },
    'RunesTrap': (tile, x, y, TooltipList) => {
        TooltipList.push({
            str: TextGet("KDEffectTileTooltip" + tile.name),
            fg: "#92e8c0",
            bg: "#000000",
            size: 24,
            center: true,
        });
        TooltipList.push({
            str: TextGet("KDEffectTileTooltip" + tile.name + "Desc"),
            fg: "#ffffff",
            bg: "#000000",
            size: 16,
            center: true,
        });
    },
    'Inferno': (tile, x, y, TooltipList) => {
        TooltipList.push({
            str: TextGet("KDEffectTileTooltip" + tile.name),
            fg: "#ff8855",
            bg: "#000000",
            size: 24,
            center: true,
        });
        TooltipList.push({
            str: TextGet("KDEffectTileTooltip" + tile.name + "Desc").replace("DAMAGEDEALT", "" + Math.round(10 * KDGetEnvironmentalDmg())),
            fg: "#ffaa55",
            bg: "#000000",
            size: 16,
            center: true,
        });
    },
    'Ember': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffaa88"); },
    'Ice': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#88ffff"); },
    'Water': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#8888ff"); },
    'Vines': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#44ff44", "KDEffectTileTooltipCMDBindings"); },
    'Ropes': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffae70", "KDEffectTileTooltipCMDBindings"); },
    'Chains': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#aaaaaa", "KDEffectTileTooltipCMDBindings"); },
    'Belts': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#8f4d57", "KDEffectTileTooltipCMDBindings"); },
    'Fabric': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ff5277", "KDEffectTileTooltipCMDBindings"); },
    'FabricGreen': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#63ab3f", "KDEffectTileTooltipCMDBindings"); },
    'Slime': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#d952ff", "KDEffectTileTooltipCMDSlime"); },
    'Latex': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#d952ff"); },
    'Steam': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'Smoke': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#888888"); },
    'Torch': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'TorchUnlit': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'Lantern': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'LanternUnlit': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'IllusOrb': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'IllusOrbDead': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'TorchOrb': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ffffff"); },
    'Cracked': (tile, x, y, TooltipList) => { KDETileTooltipSimple(tile, TooltipList, "#ff8844"); },
};
function KDETileTooltipSimple(tile, TooltipList, color, extra, descColor = "#ffffff", extraColor = "#ffffff") {
    TooltipList.push({
        str: TextGet("KDEffectTileTooltip" + tile.name),
        fg: color,
        bg: "#000000",
        size: 24,
        center: true,
    });
    TooltipList.push({
        str: TextGet("KDEffectTileTooltip" + tile.name + "Desc"),
        fg: descColor,
        bg: "#000000",
        size: 16,
        center: true,
    });
    if (extra) {
        TooltipList.push({
            str: TextGet(extra),
            fg: extraColor,
            bg: "#000000",
            size: 16,
            center: true,
        });
    }
}
function KDDrawEffectTileTooltip(tile, x, y, offset) {
    let TooltipList = [];
    KDEffectTileTooltips[tile.name](tile, x, y, TooltipList);
    return KDDrawTooltip(TooltipList, offset);
}
function KDDrawTooltip(TooltipList, offset) {
    let TooltipWidth = 300;
    let TooltipHeight = 0;
    let extra = 5;
    for (let listItem of TooltipList) {
        TooltipHeight += listItem.size + extra;
    }
    TooltipHeight = Math.max(20, TooltipHeight);
    let tooltipX = 2000 - 410 - TooltipWidth;
    let tooltipY = 890 - TooltipHeight - offset;
    let YY = 0;
    FillRectKD(kdcanvas, kdpixisprites, "inspectTooltip" + offset, {
        Left: tooltipX,
        Top: tooltipY - 25,
        Width: TooltipWidth,
        Height: TooltipHeight + 20,
        Color: "#000000",
        LineWidth: 1,
        zIndex: 60,
        alpha: 0.4,
    });
    let pad = 10;
    for (let listItem of TooltipList) {
        DrawTextFitKD(listItem.str, tooltipX + (listItem.center ? TooltipWidth / 2 : pad), tooltipY + YY, TooltipWidth - 2 * pad, listItem.fg, listItem.bg, listItem.size, listItem.center ? "center" : "left", 61);
        YY += extra + listItem.size;
    }
    return offset + TooltipHeight + 30;
}
let KDTempElements = new Map();
let KDDrawnElements = new Map();
function KDTextArea(Name, Left, Top, Width, Height) {
    let Element = KDTempElements.get(Name);
    let created = false;
    if (!Element) {
        ElementCreateTextArea(Name);
        Element = document.getElementById(Name);
        KDTempElements.set(Name, Element);
        if (Element)
            created = true;
    }
    KDElementPosition(Name, Left, Top, Width, Height);
    KDDrawnElements.set(Name, Element);
    return { Element: Element, Created: created };
}
function KDTextField(Name, Left, Top, Width, Height, Type = "text", Value = "", MaxLength = "30") {
    let Element = KDTempElements.get(Name);
    let created = false;
    if (!Element) {
        ElementCreateInput(Name, Type, Value, MaxLength);
        Element = document.getElementById(Name);
        KDTempElements.set(Name, Element);
        if (Element)
            created = true;
    }
    KDElementPosition(Name, Left, Top, Width, Height);
    KDDrawnElements.set(Name, Element);
    return { Element: Element, Created: created };
}
function KDCullTempElements() {
    for (let Name of KDTempElements.keys()) {
        if (!KDDrawnElements.get(Name)) {
            ElementRemove(Name);
            KDTempElements.delete(Name);
        }
    }
    KDDrawnElements = new Map();
}
function KDElementPosition(ElementID, X, Y, W, H) {
    let E = document.getElementById(ElementID);
    if (!E) {
        console.warn("A call to ElementPosition was made on non-existent element with ID '" + ElementID + "'");
        return;
    }
    if (E.tagName.toLowerCase() === "input" && E.getAttribute("type") === "range" && E.classList.contains("Vertical")) {
        let tmp = W;
        W = H;
        H = tmp;
    }
    const HRatio = PIXICanvas.clientHeight / 1000;
    const WRatio = PIXICanvas.clientWidth / 2000;
    const Font = PIXICanvas.clientWidth <= PIXICanvas.clientHeight * 2 ? PIXICanvas.clientWidth / 50 : PIXICanvas.clientHeight / 25;
    const Height = H ? H * HRatio : Font * 1.1;
    const Width = W * WRatio;
    const Top = PIXICanvas.offsetTop + Y * HRatio - 4;
    const Left = PIXICanvas.offsetLeft + (X) * WRatio + 4;
    Object.assign(E.style, {
        fontSize: Font + "px",
        fontFamily: CommonGetFontName(),
        position: "fixed",
        left: Left + "px",
        top: Top + "px",
        width: Width + "px",
        height: Height + "px",
        display: "inline"
    });
}
function KDShowQuickInv() {
    return KinkyDungeonShowInventory || (KDGameData.CurrentDialog && KDDialogue[KDGameData.CurrentDialog] && KDDialogue[KDGameData.CurrentDialog].inventory);
}
let KDUpdateFog = false;
let KDLastCamPos = { x: 0, y: 0 };
let KDDrawPlayer = true;
let KDDesiredPlayerPose = {};
function KDPlayerDrawPoseButtons(C) {
    KDModalArea = true;
    KDModalArea_x = 650;
    KDModalArea_y = 630;
    KDModalArea_width = 1000;
    KDModalArea_height = 370;
    KDDrawPoseButtons(C, 700, 680, true);
    KDDesiredPlayerPose = {
        Arms: KDWardrobe_CurrentPoseArms,
        Legs: KDWardrobe_CurrentPoseLegs,
        Eyes: KDWardrobe_CurrentPoseEyes,
        Brows: KDWardrobe_CurrentPoseBrows,
        Blush: KDWardrobe_CurrentPoseBlush,
        Mouth: KDWardrobe_CurrentPoseMouth,
    };
}
let KDFurniture = {
    "Cage": {
        floor: "Floor",
        sprite: "Cage",
        restraintTag: "cage",
        tickFunction: (delta) => {
            if (!KDGameData.PrisonerState) {
                let power = 0;
                if (KDBoundPowerLevel >= 0.35)
                    power = 2;
                else if (KDBoundPowerLevel >= 0.1)
                    power = 1;
                if (power >= 2) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage", type: "SlowDetection", duration: 1, power: 4.0, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["SlowDetection", "move", "cast"] });
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage2", type: "Sneak", duration: 1, power: 9.95, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Sneak", "move", "cast"] });
                }
                else if (power >= 1) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage", type: "SlowDetection", duration: 1, power: 4.0, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["SlowDetection", "move", "cast"] });
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage2", type: "Sneak", duration: 1, power: 2.95, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Sneak", "move", "cast"] });
                }
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonCage" + power), "lightgreen", 1, true);
            }
        }
    },
    "DisplayStand": {
        floor: "Floor",
        sprite: "DisplayStand",
        restraintTag: "displaystand",
        tickFunction: (delta) => {
            if (!KDGameData.PrisonerState) {
                let power = 0;
                if (KDBoundPowerLevel >= 0.35)
                    power = 2;
                else if (KDBoundPowerLevel >= 0.1)
                    power = 1;
                if (power >= 2) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage", type: "SlowDetection", duration: 1, power: 4.0, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["SlowDetection", "move", "cast"] });
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage2", type: "Sneak", duration: 1, power: 9.95, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Sneak", "move", "cast"] });
                }
                else if (power >= 1) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage", type: "SlowDetection", duration: 1, power: 4.0, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["SlowDetection", "move", "cast"] });
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage2", type: "Sneak", duration: 1, power: 2.95, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Sneak", "move", "cast"] });
                }
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonCage" + power), "lightgreen", 1, true);
            }
        }
    },
    "DisplayEgyptian": {
        floor: "Floor",
        sprite: "DisplayEgyptian",
        restraintTag: "displaystand",
        tickFunction: (delta) => {
            if (!KDGameData.PrisonerState) {
                let power = 0;
                if (KDBoundPowerLevel >= 0.35)
                    power = 2;
                else if (KDBoundPowerLevel >= 0.1)
                    power = 1;
                if (power >= 2) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage", type: "SlowDetection", duration: 1, power: 4.0, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["SlowDetection", "move", "cast"] });
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage2", type: "Sneak", duration: 1, power: 9.95, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Sneak", "darkness", "move", "cast"] });
                }
                else if (power >= 1) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage", type: "SlowDetection", duration: 1, power: 4.0, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["SlowDetection", "move", "cast"] });
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "cage2", type: "Sneak", duration: 1, power: 2.95, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Sneak", "darkness", "move", "cast"] });
                }
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonCage" + power), "lightgreen", 1, true);
            }
        }
    },
};
let KinkyDungeonManaCost = 10;
let KDEmpowerSprite = "Empower";
let KDMaxEmpower = 3;
let KinkyDungeonBookScale = 1.3;
let KinkyDungeonMysticSeals = 0;
let KinkyDungeonCurrentBook = "Elements";
let KinkyDungeonCurrentPage = 0;
let KinkyDungeonCurrentSpellsPage = 0;
let KinkyDungeonBooks = ["Elements", "Conjure", "Illusion"];
let KinkyDungeonPreviewSpell = null;
let KinkyDungeonSpellChoices = [0, 1, 2];
let KinkyDungeonSpellChoicesToggle = [true, true];
let KinkyDungeonSpellChoiceCount = 21;
let KinkyDungeonSpellChoiceCountPerPage = 7;
let KDSpellPage = 0;
let KinkyDungeonSpellOffset = 100;
let KinkyDungeonSpellChoiceOffset = 80;
let KDPlayerHitBy = [];
let KinkyDungeonMiscastPityModifier = 0;
let KinkyDungeonMiscastPityModifierIncrementPercentage = 0.5;
function KinkyDungeonSearchSpell(list, name) {
    for (let spell of list) {
        if (spell.name == name)
            return spell;
    }
    return null;
}
function KinkyDungeonFindSpell(name, SearchEnemies) {
    if (SearchEnemies) {
        let spell = KinkyDungeonSearchSpell(KinkyDungeonSpellListEnemies, name);
        if (spell)
            return spell;
    }
    let spell2 = KinkyDungeonSearchSpell(KinkyDungeonSpellsStart, name);
    if (spell2)
        return spell2;
    for (let key in KinkyDungeonSpellList) {
        let list = KinkyDungeonSpellList[key];
        let spell = KinkyDungeonSearchSpell(list, name);
        if (spell)
            return spell;
    }
    return KinkyDungeonSearchSpell(KinkyDungeonSpells, name);
}
function KinkyDungeonDisableSpell(Name) {
    for (let i = 0; i < KinkyDungeonSpellChoices.length; i++) {
        if (KinkyDungeonSpells[KinkyDungeonSpellChoices[i]] && KinkyDungeonSpells[KinkyDungeonSpellChoices[i]].name == Name) {
            KinkyDungeonSpellChoicesToggle[i] = false;
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Click.ogg");
        }
    }
}
let KinkyDungeonSpellPress = "";
function KinkyDungeonResetMagic() {
    KinkyDungeonSpellChoices = [];
    KinkyDungeonSpellChoicesToggle = [];
    KinkyDungeonSpellChoiceCount = 21;
    KinkyDungeonSpells = [];
    Object.assign(KinkyDungeonSpells, KinkyDungeonSpellsStart);
    KinkyDungeonMysticSeals = 1.3;
    KinkyDungeonSpellPress = "";
    KinkyDungeonCurrentPage = 0;
    KinkyDungeonCurrentSpellsPage = 0;
    KinkyDungeonSpellPoints = 3;
    KDSpellPage = 0;
    if (KinkyDungeonStatsChoice.get("randomMode")) {
        KinkyDungeonSpells.push({ name: "ApprenticeFire", hideLearned: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeWater", hideLearned: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeEarth", hideLearned: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeAir", hideLearned: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeIce", hideLearned: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeLightning", hideLearned: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeLeather", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeRope", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeMetal", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeSummon", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeLatex", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticePhysics", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeShadow", hideLearned: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeLight", hideLearned: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeMystery", hideLearned: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeKnowledge", hideLearned: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
        KinkyDungeonSpells.push({ name: "ApprenticeProjection", hideLearned: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" });
    }
}
function KDHasSpell(name) {
    for (let s of KinkyDungeonSpells) {
        if (s.name == name)
            return true;
    }
    return false;
}
function KDGetUpcast(name, Level) {
    if (Level < 0) {
        for (let sp of KinkyDungeonSpells) {
            if (sp.upcastFrom && sp.upcastFrom == name) {
                return sp;
            }
        }
    }
    else {
        for (let i = Level; i > 0; i--) {
            for (let sp of KinkyDungeonSpells) {
                if (i == sp.upcastLevel && sp.upcastFrom && sp.upcastFrom == name) {
                    return sp;
                }
            }
        }
    }
    return null;
}
function KDHasUpcast(name) {
    for (let sp of KinkyDungeonSpells) {
        if (sp.upcastFrom && sp.upcastFrom == name) {
            return true;
        }
    }
    return false;
}
function KDCanUpcast() {
    for (let i of KinkyDungeonSpellChoices) {
        let spell = KinkyDungeonSpells[i];
        if (spell) {
            let upcast = KDGetUpcast(spell.name, -1);
            if (upcast) {
                return true;
            }
        }
    }
    return false;
}
function KDEmpower(data, entity) {
    let Level = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SpellEmpower");
    if (!KDCanUpcast()) {
        KinkyDungeonSendActionMessage(10, TextGet("KDSpellEmpowerFail"), "#ffffff", 1);
    }
    else {
        KinkyDungeonTargetingSpell = null;
        let newLevel = Math.min(KDMaxEmpower, Level + 1);
        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, {
            id: "Empower",
            aura: "#aaaaff",
            type: "SpellEmpower",
            maxCount: 1,
            currentCount: 1,
            power: newLevel,
            duration: 13,
            tags: ["cast", "upcast"],
        });
        KinkyDungeonSendActionMessage(5, TextGet("KDSpellEmpowerMsg").replace("LEVEL", "" + newLevel), "#aaaaff", 2);
        KinkyDungeonAdvanceTime(1, true);
    }
}
function KinkyDungeoCheckComponents(spell, x, y) {
    let failedcomp = [];
    if (spell.components.includes("Verbal") && !KinkyDungeonCanTalk(true) && !(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "NoVerbalComp") > 0))
        failedcomp.push("Verbal");
    if (spell.components.includes("Arms") && KinkyDungeonIsArmsBound() && !(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "NoArmsComp") > 0))
        failedcomp.push("Arms");
    if (spell.components.includes("Legs") && (KinkyDungeonSlowLevel > 1 || KinkyDungeonLegsBlocked()) && !(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "NoLegsComp") > 0))
        failedcomp.push("Legs");
    let data = {
        spell: spell,
        failed: failedcomp,
        x: x || KinkyDungeonPlayerEntity.x,
        y: y || KinkyDungeonPlayerEntity.y
    };
    KinkyDungeonSendEvent("calcComp", data);
    return data.failed;
}
function KinkyDungeonHandleSpellChoice(SpellChoice) {
    let spell = KinkyDungeonHandleSpellCast(KDGetUpcast(KinkyDungeonSpells[SpellChoice].name, KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "SpellEmpower")) || KinkyDungeonSpells[SpellChoice]);
    return spell;
}
function KDSpellIgnoreComp(spell) {
    return (KinkyDungeonStatsChoice.get("Slayer") && spell.school == "Elements")
        || (KinkyDungeonStatsChoice.get("Conjurer") && spell.school == "Conjure")
        || (KinkyDungeonStatsChoice.get("Magician") && spell.school == "Illusion");
}
function KinkyDungeonHandleSpellCast(spell) {
    if (KinkyDungeoCheckComponents(spell).length == 0 || (KDSpellIgnoreComp(spell))) {
        if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell))
            && (!spell.staminacost || KinkyDungeonHasStamina(spell.staminacost)))
            return spell;
        else
            KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonNoMana"), "#ff0000", 1);
    }
    else {
        KinkyDungeonTargetingSpell = null;
        KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonComponentsFail" + KinkyDungeoCheckComponents(spell)[0]), "#ff0000", 1);
    }
    return null;
}
function KinkyDungeonClickSpell(i) {
    let spell = null;
    let clicked = false;
    if (KinkyDungeonSpells[KinkyDungeonSpellChoices[i]]) {
        if (KinkyDungeonSpells[KinkyDungeonSpellChoices[i]] && KinkyDungeonSpells[KinkyDungeonSpellChoices[i]].type == "passive") {
            KDSendInput("toggleSpell", { i: i });
            if (KinkyDungeonSpellChoicesToggle[i] && KinkyDungeonSpells[KinkyDungeonSpellChoices[i]].cancelAutoMove) {
                KinkyDungeonFastMove = false;
                KinkyDungeonFastMoveSuppress = false;
            }
            KinkyDungeonSpellPress = "";
            clicked = true;
        }
        else {
            spell = KinkyDungeonHandleSpellChoice(KinkyDungeonSpellChoices[i]);
            clicked = true;
        }
    }
    return { spell: spell, clicked: clicked };
}
let KDSwapSpell = -1;
function KinkyDungeonHandleSpell() {
    let spell = null;
    let clicked = false;
    for (let i = 0; i < KinkyDungeonSpellChoiceCountPerPage; i++) {
        let index = i + KDSpellPage * KinkyDungeonSpellChoiceCountPerPage;
        let buttonWidth = 40;
        if (MouseIn(1650 + (90 - buttonWidth), 180 + i * KinkyDungeonSpellChoiceOffset - buttonWidth, buttonWidth, buttonWidth) && KinkyDungeonSpellChoices[i]) {
            KinkyDungeonDrawState = "MagicSpells";
            KDSwapSpell = index;
            return true;
        }
        if (KinkyDungeonSpellPress == KinkyDungeonKeySpell[i]) {
            let result = KinkyDungeonClickSpell(index);
            spell = result.spell;
            clicked = result.clicked;
        }
    }
    for (let ii = 0; ii < KinkyDungeonSpellChoiceCount; ii++) {
        if (MouseInKD("SpellCast" + ii)) {
            let result = KinkyDungeonClickSpell(ii);
            spell = result.spell;
            clicked = result.clicked;
        }
    }
    if (spell) {
        KinkyDungeonTargetingSpell = spell;
        KDModalArea = false;
        KinkyDungeonTargetTile = null;
        KinkyDungeonTargetTileLocation = null;
        KinkyDungeonSendActionMessage(5, TextGet("KinkyDungeonSpellTarget" + spell.name).replace("SpellArea", "" + Math.floor(spell.aoe)), "white", 0.1, true);
        return true;
    }
    if (clicked)
        return true;
    return false;
}
function KinkyDungeonGetManaCost(Spell) {
    let data = {
        spell: Spell,
        cost: Spell.manacost,
        costscale: KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "ManaCostMult")),
        lvlcostscale: KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "ManaCostLevelMult"),
    };
    KinkyDungeonSendEvent("calcMana", data);
    if (data.costscale)
        data.cost = Math.floor(data.cost * data.costscale);
    if (data.lvlcostscale && Spell.level && Spell.manacost)
        data.cost += Spell.level * data.lvlcostscale;
    KinkyDungeonSendEvent("beforeMultMana", data);
    KinkyDungeonSendEvent("afterCalcMana", data);
    if (KinkyDungeonStatsChoice.get("Slayer") && Spell.school == "Elements" && KinkyDungeoCheckComponents(Spell).length > 0)
        data.cost *= 2;
    if (KinkyDungeonStatsChoice.get("Conjurer") && Spell.school == "Conjure" && KinkyDungeoCheckComponents(Spell).length > 0)
        data.cost *= 2;
    if (KinkyDungeonStatsChoice.get("Magician") && Spell.school == "Illusion" && KinkyDungeoCheckComponents(Spell).length > 0)
        data.cost *= 2;
    return data.cost;
}
function KinkyDungeonGetCost(Spell) {
    let cost = Spell.level;
    if (Spell.level > 1 && !Spell.passive && KinkyDungeonStatsChoice.get("Novice"))
        cost *= 2;
    if (Spell.spellPointCost)
        return Spell.spellPointCost;
    return cost;
}
function KinkyDungeonMakeNoise(radius, noiseX, noiseY) {
    for (let e of KinkyDungeonEntities) {
        if (!e.aware && !e.Enemy.tags.deaf && !KDAmbushAI(e) && KDistChebyshev(e.x - noiseX, e.y - noiseY) <= radius) {
            e.gx = noiseX;
            e.gy = noiseY;
            KDAddThought(e.id, "Search", 2, 1 + KDistChebyshev(e.x - noiseX, e.y - noiseY));
        }
    }
}
function KinkyDungeonCastSpell(targetX, targetY, spell, enemy, player, bullet, forceFaction, castData) {
    let entity = KinkyDungeonPlayerEntity;
    let moveDirection = KinkyDungeonMoveDirection;
    let flags = {
        miscastChance: KinkyDungeonMiscastChance,
    };
    let faction = spell.allySpell ? "Player" : spell.enemySpell ? "Enemy" : "Player";
    if (forceFaction)
        faction = forceFaction;
    else {
        if (!enemy && !bullet && player)
            faction = "Player";
        else if (enemy) {
            let f = KDGetFaction(enemy);
            if (f)
                faction = f;
        }
        else if (bullet && bullet.bullet) {
            let f = bullet.bullet.faction;
            if (f)
                faction = f;
        }
        if (spell.faction)
            faction = spell.faction;
    }
    let gaggedMiscastFlag = false;
    if (!enemy && !bullet && player && spell.components && spell.components.includes("Verbal") && !KDSpellIgnoreComp(spell) && !(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "NoVerbalComp") > 0)) {
        let gagTotal = (KinkyDungeonStatsChoice.get("Incantation") && KinkyDungeonGagTotal() > 0) ? 1.0 : KinkyDungeonGagTotal();
        flags.miscastChance = flags.miscastChance + Math.max(0, 1 - flags.miscastChance) * Math.min(1, gagTotal);
        if (gagTotal > 0)
            gaggedMiscastFlag = true;
    }
    let data = Object.assign(Object.assign({}, castData), {
        spell: spell,
        bulletfired: null,
        target: null,
        targetX: targetX,
        targetY: targetY,
        originX: KinkyDungeonPlayerEntity.x,
        originY: KinkyDungeonPlayerEntity.y,
        flags: flags,
        enemy: enemy,
        bullet: bullet,
        player: player,
        delta: 1,
    });
    if (!enemy && !bullet && player) {
        KinkyDungeonSendEvent("beforeCast", data);
    }
    let tX = targetX;
    let tY = targetY;
    let miscast = false;
    let selfCast = !enemy && !bullet && player && targetX == KinkyDungeonPlayerEntity.x && targetY == KinkyDungeonPlayerEntity.y;
    if (!enemy && !player && !bullet) {
        moveDirection = { x: 0, y: 0, delta: 1 };
    }
    let noiseX = targetX;
    let noiseY = targetY;
    if (enemy && player) {
        entity = enemy;
        moveDirection = KinkyDungeonGetDirection(player.x - entity.x, player.y - entity.y);
        flags.miscastChance = 0;
    }
    if (bullet) {
        entity = bullet;
        if (bullet.bullet.cast) {
            moveDirection = { x: bullet.bullet.cast.mx, y: bullet.bullet.cast.my, delta: 1 };
        }
        else {
            moveDirection = { x: 0, y: 0, delta: 0 };
        }
        flags.miscastChance = 0;
    }
    if (!spell.noMiscast && !enemy && !bullet && player && Math.min(1, KDRandom() + KinkyDungeonMiscastPityModifier) < flags.miscastChance) {
        KinkyDungeonMiscastPityModifier += KinkyDungeonMiscastPityModifierIncrementPercentage * Math.max(1 - flags.miscastChance, 0);
        if (gaggedMiscastFlag)
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonSpellMiscastGagged"), "#FF8800", 2);
        else
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonSpellMiscast"), "#FF8800", 2);
        moveDirection = { x: 0, y: 0, delta: 1 };
        tX = entity.x;
        tY = entity.y;
        miscast = true;
        return { result: "Miscast", data: data };
    }
    let spellRange = spell.range * KinkyDungeonMultiplicativeStat(-KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "spellRange"));
    if (spell.type != "bolt" && spell.effectTilePre) {
        KDCreateAoEEffectTiles(tX, tY, spell.effectTilePre, spell.effectTileDurationModPre, (spell.aoe) ? spell.aoe : 0.5);
    }
    let originaltX = tX;
    let originaltY = tY;
    let originalSpeed = spell.speed;
    let castCount = spell.shotgunCount ? spell.shotgunCount : 1;
    for (let castI = 0; castI < castCount; castI++) {
        tX = originaltX;
        tY = originaltY;
        if (spell.shotgunDistance) {
            let dx = tX - entity.x;
            let dy = tY - entity.y;
            let dmult = KDistEuclidean(dx, dy);
            if (dmult != 0)
                dmult = 1 / dmult;
            tX = entity.x + dx * dmult * spell.shotgunDistance;
            tY = entity.y + dy * dmult * spell.shotgunDistance;
        }
        if (spell.shotgunSpread) {
            let ang = KDRandom() * 2 * Math.PI;
            tX += spell.shotgunSpread * ((castI + 1) / castCount) * Math.cos(ang);
            tY += spell.shotgunSpread * ((castI + 1) / castCount) * Math.sin(ang);
        }
        let speed = originalSpeed;
        if (spell.shotgunSpeedBonus && castCount > 1) {
            speed += spell.shotgunSpeedBonus * (castI / (castCount - 1));
        }
        let cast = spell.spellcast ? Object.assign({}, spell.spellcast) : undefined;
        if (cast) {
            if (cast.target == "target") {
                if (tX == entity.x + moveDirection.x && tY == entity.y + moveDirection.y && !cast.noTargetMoveDir) {
                    cast.tx = tX + moveDirection.x;
                    cast.ty = tY + moveDirection.y;
                }
                else {
                    cast.tx = tX;
                    cast.ty = tY;
                }
            }
            else if (cast.target == "origin") {
                cast.tx = entity.x;
                cast.ty = entity.y;
            }
            if (cast.directional) {
                if (cast.randomDirection) {
                    let slots = [];
                    for (let XX = -1; XX <= 1; XX++) {
                        for (let YY = -1; YY <= 1; YY++) {
                            if ((XX != 0 || YY != 0) && KinkyDungeonNoEnemy(entity.x + XX, entity.y + YY, true) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(entity.x + XX, entity.y + YY)))
                                slots.push({ x: XX, y: YY });
                        }
                    }
                    if (slots.length > 0) {
                        let slot = slots[Math.floor(KDRandom() * slots.length)];
                        cast.mx = slot.x;
                        cast.my = slot.y;
                        moveDirection.x = slot.x;
                        moveDirection.y = slot.y;
                    }
                    else {
                        cast.mx = moveDirection.x;
                        cast.my = moveDirection.y;
                    }
                }
                else if (cast.randomDirectionPartial || cast.randomDirectionFallback) {
                    if (cast.randomDirectionFallback && (!cast.alwaysRandomBuff || !KDEntityHasBuff(entity, cast.alwaysRandomBuff))
                        && KinkyDungeonNoEnemy(entity.x + moveDirection.x, entity.y + moveDirection.y, true)
                        && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(entity.x + moveDirection.x, entity.y + moveDirection.y))) {
                        cast.mx = moveDirection.x;
                        cast.my = moveDirection.y;
                    }
                    else {
                        let slots = [];
                        let dist = KDistEuclidean(entity.x - tX, entity.y - tY);
                        for (let XX = -1; XX <= 1; XX++) {
                            for (let YY = -1; YY <= 1; YY++) {
                                if ((XX != 0 || YY != 0) && KinkyDungeonNoEnemy(entity.x + XX, entity.y + YY, true) && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(entity.x + XX, entity.y + YY))
                                    && (entity.x + XX != tX || entity.y + YY != tY)
                                    && KDistEuclidean(entity.x + XX - tX, entity.y + YY - tY) <= dist + 0.1)
                                    slots.push({ x: XX, y: YY });
                            }
                        }
                        if (slots.length > 0) {
                            let slot = slots[Math.floor(KDRandom() * slots.length)];
                            cast.mx = slot.x;
                            cast.my = slot.y;
                            moveDirection.x = slot.x;
                            moveDirection.y = slot.y;
                        }
                        else {
                            cast.mx = moveDirection.x;
                            cast.my = moveDirection.y;
                            if (entity.x + cast.mx == tX && entity.y + cast.my == tY) {
                                cast.tx += moveDirection.x;
                                cast.ty += moveDirection.y;
                            }
                        }
                    }
                }
                else {
                    cast.mx = moveDirection.x;
                    cast.my = moveDirection.y;
                }
            }
            if (cast.aimAtTarget && KinkyDungeonEnemyAt(targetX, targetY) && KDCanSeeEnemy(KinkyDungeonEnemyAt(targetX, targetY), KDistEuclidean(entity.x - targetX, entity.y - targetY))) {
                cast.targetID = KinkyDungeonEnemyAt(targetX, targetY).id;
            }
        }
        if (spell.type == "bolt") {
            let size = (spell.size) ? spell.size : 1;
            let xx = entity.x;
            let yy = entity.y;
            noiseX = entity.x;
            noiseY = entity.y;
            if (!bullet || (bullet.spell && bullet.spell.cast && bullet.spell.cast.offset)) {
                xx += moveDirection.x;
                yy += moveDirection.y;
            }
            if (spell.effectTilePre) {
                KDCreateAoEEffectTiles(tX - entity.x, tY - entity.y, spell.effectTilePre, spell.effectTileDurationModPre, (spell.aoe) ? spell.aoe : 0.5);
            }
            let b = KinkyDungeonLaunchBullet(xx, yy, tX - entity.x, tY - entity.y, speed, { noSprite: spell.noSprite, faction: faction, name: spell.name, block: spell.block, width: size, height: size, summon: spell.summon,
                targetX: tX, targetY: tY,
                source: (entity === null || entity === void 0 ? void 0 : entity.player) ? -1 : entity === null || entity === void 0 ? void 0 : entity.id, cast: cast, dot: spell.dot,
                bulletColor: spell.bulletColor, bulletLight: spell.bulletLight,
                bulletSpin: spell.bulletSpin,
                effectTile: spell.effectTile, effectTileDurationMod: spell.effectTileDurationMod,
                effectTileTrail: spell.effectTileTrail, effectTileDurationModTrail: spell.effectTileDurationModTrail, effectTileTrailAoE: spell.effectTileTrailAoE,
                passthrough: spell.noTerrainHit, noEnemyCollision: spell.noEnemyCollision, alwaysCollideTags: spell.alwaysCollideTags, nonVolatile: spell.nonVolatile, noDoubleHit: spell.noDoubleHit,
                pierceEnemies: spell.pierceEnemies, piercing: spell.piercing, events: spell.events,
                lifetime: miscast || selfCast ? 1 : (spell.bulletLifetime ? spell.bulletLifetime : 1000), origin: { x: entity.x, y: entity.y }, range: spellRange, hit: spell.onhit,
                damage: { evadeable: spell.evadeable, damage: spell.power, type: spell.damage, distract: spell.distract, distractEff: spell.distractEff, bindEff: spell.bindEff, bind: spell.bind, bindType: spell.bindType, boundBonus: spell.boundBonus, time: spell.time, flags: spell.damageFlags }, spell: spell }, miscast);
            b.visual_x = entity.x;
            b.visual_y = entity.y;
            data.bulletfired = b;
        }
        else if (spell.type == "inert" || spell.type == "dot") {
            let sz = spell.size;
            if (!sz)
                sz = 1;
            if (spell.meleeOrigin) {
                tX = entity.x + moveDirection.x;
                tY = entity.y + moveDirection.y;
            }
            let b = KinkyDungeonLaunchBullet(tX, tY, moveDirection.x, moveDirection.y, 0, {
                noSprite: spell.noSprite, faction: faction, name: spell.name, block: spell.block, width: sz, height: sz, summon: spell.summon,
                targetX: tX, targetY: tY,
                source: (entity === null || entity === void 0 ? void 0 : entity.player) ? -1 : entity === null || entity === void 0 ? void 0 : entity.id, lifetime: spell.delay +
                    (spell.delayRandom ? Math.floor(KDRandom() * spell.delayRandom) : 0), cast: cast, dot: spell.dot, events: spell.events, alwaysCollideTags: spell.alwaysCollideTags,
                bulletColor: spell.bulletColor, bulletLight: spell.bulletLight,
                bulletSpin: spell.bulletSpin,
                passthrough: (spell.CastInWalls || spell.WallsOnly || spell.noTerrainHit), hit: spell.onhit, noDoubleHit: spell.noDoubleHit, effectTile: spell.effectTile, effectTileDurationMod: spell.effectTileDurationMod,
                damage: spell.type == "inert" ? null : { evadeable: spell.evadeable, damage: spell.power, type: spell.damage, distract: spell.distract, distractEff: spell.distractEff, bindEff: spell.bindEff, bind: spell.bind, bindType: spell.bindType, boundBonus: spell.boundBonus, time: spell.time, flags: spell.damageFlags }, spell: spell
            }, miscast);
            data.bulletfired = b;
        }
        else if (spell.type == "hit") {
            let sz = spell.size;
            if (!sz)
                sz = 1;
            if (spell.meleeOrigin) {
                tX = entity.x + moveDirection.x;
                tY = entity.y + moveDirection.y;
            }
            let b = { x: tX, y: tY,
                vx: moveDirection.x, vy: moveDirection.y, born: 1,
                bullet: { noSprite: spell.noSprite, faction: faction, name: spell.name, block: spell.block, width: sz, height: sz, summon: spell.summon,
                    targetX: tX, targetY: tY,
                    source: (entity === null || entity === void 0 ? void 0 : entity.player) ? -1 : entity === null || entity === void 0 ? void 0 : entity.id, lifetime: spell.lifetime, cast: cast, dot: spell.dot, events: spell.events, aoe: spell.aoe,
                    passthrough: (spell.CastInWalls || spell.WallsOnly || spell.noTerrainHit), hit: spell.onhit, noDoubleHit: spell.noDoubleHit, effectTile: spell.effectTile, effectTileDurationMod: spell.effectTileDurationMod,
                    damage: { evadeable: spell.evadeable, damage: spell.power, type: spell.damage, distract: spell.distract, distractEff: spell.distractEff, bindEff: spell.bindEff, bind: spell.bind, bindType: spell.bindType, boundBonus: spell.boundBonus, time: spell.time, flags: spell.damageFlags }, spell: spell } };
            KinkyDungeonBulletHit(b, 1);
            data.bulletfired = b;
        }
        else if (spell.type == "buff") {
            let aoe = spell.aoe;
            let casted = false;
            if (!aoe)
                aoe = 0.1;
            if (Math.sqrt((KinkyDungeonPlayerEntity.x - targetX) * (KinkyDungeonPlayerEntity.x - targetX) + (KinkyDungeonPlayerEntity.y - targetY) * (KinkyDungeonPlayerEntity.y - targetY)) <= aoe) {
                for (let buff of spell.buffs) {
                    if (buff.player) {
                        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff);
                        if (KinkyDungeonPlayerEntity.x == targetX && KinkyDungeonPlayerEntity.y == targetY)
                            data.target = KinkyDungeonPlayerEntity;
                        casted = true;
                    }
                }
            }
            for (let e of KinkyDungeonEntities) {
                if (Math.sqrt((e.x - targetX) * (e.x - targetX) + (e.y - targetY) * (e.y - targetY)) <= aoe) {
                    for (let buff of spell.buffs) {
                        if (!spell.filterTags || KDMatchTags(spell.filterTags, e)) {
                            if (!e.buffs)
                                e.buffs = {};
                            KinkyDungeonApplyBuff(e.buffs, buff);
                            if (e.x == targetX && e.y == targetY)
                                data.target = e;
                            casted = true;
                        }
                    }
                }
            }
            if (!casted)
                return { result: "Fail", data: data };
        }
        else if (spell.type == "special") {
            let ret = KinkyDungeonSpellSpecials[spell.special](spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast);
            if (ret) {
                if (!enemy && !bullet && player) {
                    KinkyDungeonSendEvent("playerCast", data);
                }
                return { result: ret, data: data };
            }
        }
    }
    tX = originaltX;
    tY = originaltY;
    if (spell.extraCast) {
        for (let extraCast of spell.extraCast)
            KinkyDungeonCastSpell(targetX, targetY, KinkyDungeonFindSpell(extraCast.spell, true), undefined, undefined, undefined);
    }
    if (spell.noise) {
        KinkyDungeonMakeNoise(spell.noise, noiseX, noiseY);
    }
    if (!enemy && !bullet && player) {
        KinkyDungeonSetFlag("PlayerCombat", 8);
        if (data.targetingSpellItem) {
            KinkyDungeonChangeConsumable(KinkyDungeonTargetingSpellItem, -(KinkyDungeonTargetingSpellItem.useQuantity ? KinkyDungeonTargetingSpellItem.useQuantity : 1));
            KinkyDungeonTargetingSpellItem = null;
            if (!spell.noAggro)
                KinkyDungeonAggroAction('item', {});
        }
        else if (data.targetingSpellWeapon) {
            let special = KinkyDungeonPlayerDamage ? KinkyDungeonPlayerDamage.special : null;
            if (special) {
                let energyCost = KinkyDungeonPlayerDamage.special.energyCost;
                if (KDGameData.AncientEnergyLevel < energyCost)
                    return;
                if (energyCost)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - energyCost);
            }
            KinkyDungeonTargetingSpellItem = null;
            if (!spell.noAggro)
                KinkyDungeonAggroAction('item', {});
        }
        else {
            if (!spell.noAggro)
                KinkyDungeonAggroAction('magic', {});
            if (spell.school)
                KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "cast_" + spell.school.toLowerCase(), 1);
        }
        KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
        KDSendSpellCast(spell.name);
        KinkyDungeonSendEvent("playerCast", data);
        KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "cast", 1);
        if (spell.tags) {
            for (let t of spell.tags) {
                KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "cast_" + t, 1);
            }
        }
        KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
        if (spell.staminacost)
            KinkyDungeonChangeStamina(-spell.staminacost);
        if (spell.channel) {
            KinkyDungeonSetFlag("channeling", spell.channel);
            KinkyDungeonSlowMoveTurns = Math.max(KinkyDungeonSlowMoveTurns, spell.channel);
            KinkyDungeonSleepTime = CommonTime() + 200;
        }
        if (spell.noise) {
            if (spell.components && spell.components.includes("Verbal"))
                KinkyDungeonAlert = 3;
        }
        KinkyDungeonLastAction = "Spell";
        KinkyDungeonMiscastPityModifier = 0;
    }
    else {
        KinkyDungeonSendEvent("spellCast", data);
    }
    return { result: "Cast", data: data };
}
function KinkyDungeonClickSpellChoice(I, CurrentSpell) {
    KDSendInput("spellChoice", { I: I, CurrentSpell: CurrentSpell });
    if (KinkyDungeonSpellChoicesToggle[I] && KinkyDungeonSpells[KinkyDungeonSpellChoices[I]].cancelAutoMove) {
        KinkyDungeonFastMove = false;
        KinkyDungeonFastMoveSuppress = false;
    }
}
function KinkyDungeonHandleMagic() {
    if (KinkyDungeonCurrentPage > 0 && MouseIn(canvasOffsetX_ui + 100, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60)) {
        if (KinkyDungeonPreviewSpell)
            KinkyDungeonPreviewSpell = undefined;
        else {
            KinkyDungeonCurrentPage -= 1;
            for (let i = 0; i < 30; i++)
                if (KinkyDungeonCurrentPage > 0 && KinkyDungeonSpells[KinkyDungeonCurrentPage] && (KinkyDungeonSpells[KinkyDungeonCurrentPage].hide))
                    KinkyDungeonCurrentPage -= 1;
        }
        return true;
    }
    if (KinkyDungeonCurrentPage < KinkyDungeonSpells.length - 1 && MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale - 325, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60)) {
        if (KinkyDungeonPreviewSpell)
            KinkyDungeonPreviewSpell = undefined;
        else {
            KinkyDungeonCurrentPage += 1;
            for (let i = 0; i < 30; i++)
                if (KinkyDungeonSpells[KinkyDungeonCurrentPage] && KinkyDungeonSpells[KinkyDungeonCurrentPage].hide)
                    KinkyDungeonCurrentPage += 1;
        }
        return true;
    }
    if (KinkyDungeonSpells[KinkyDungeonCurrentPage] && !KinkyDungeonPreviewSpell) {
        if (MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale * 0.5 - 200, canvasOffsetY_ui - 70 + 483 * KinkyDungeonBookScale, 400, 60)) {
            KDSendInput("spellCastFromBook", { CurrentSpell: KinkyDungeonCurrentPage });
            KinkyDungeonTargetingSpell = KinkyDungeonHandleSpellCast(KinkyDungeonSpells[KinkyDungeonCurrentPage]);
            KDModalArea = false;
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = null;
            KinkyDungeonDrawState = "Game";
        }
    }
    else if (KinkyDungeonPreviewSpell && MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 40, canvasOffsetY_ui + 125, 225, 60)) {
        if (KinkyDungeonPreviewSpell.hideLearned)
            KinkyDungeonDrawState = "MagicSpells";
        KDSendInput("spellLearn", { SpellName: KinkyDungeonPreviewSpell.name });
        return true;
    }
    return true;
}
function KDGetPrerequisite(spell) {
    if (!spell.prerequisite)
        return "";
    if (typeof spell.prerequisite === "string") {
        return TextGet("KinkyDungeonSpell" + spell.prerequisite);
    }
    let str = "";
    for (let pr of spell.prerequisite) {
        if (!str) {
            str = TextGet("KinkyDungeonSpell" + pr);
        }
        else {
            str = str + "/" + TextGet("KinkyDungeonSpell" + pr);
        }
    }
    return str;
}
function KinkyDungeonCheckSpellPrerequisite(spell) {
    if (!spell || !spell.prerequisite)
        return true;
    if (spell.upcastFrom && !KDHasSpell(spell.upcastFrom))
        return false;
    if (typeof spell.prerequisite === "string") {
        let spell_prereq = KinkyDungeonSearchSpell(KinkyDungeonSpells, spell.prerequisite);
        if (spell_prereq)
            return true;
        return false;
    }
    else {
        for (let pr of spell.prerequisite) {
            let spell_prereq = KinkyDungeonSearchSpell(KinkyDungeonSpells, pr);
            if (spell_prereq)
                return true;
        }
        return false;
    }
}
function KinkyDungeonDetectLanguageForMaxWidth(str, maxWidthTranslate, maxWidthEnglish) {
    try {
        if (KDBigLanguages.includes(TranslationLanguage) && guessLanguage) {
            let languageName = guessLanguage.name(str);
            if (languageName === "unknown") {
                return maxWidthTranslate;
            }
            else if (KDBigLanguages2.includes(languageName)) {
                return maxWidthTranslate;
            }
            else if (languageName === "English") {
                return maxWidthEnglish;
            }
            else {
                return maxWidthEnglish;
            }
        }
        else {
            return maxWidthEnglish;
        }
    }
    catch (e) {
        return maxWidthEnglish;
    }
}
function KinkyDungeonWordWrap(str, maxWidthTranslate, maxWidthEnglish) {
    let newLineStr = "\n";
    let res = '';
    let maxWidth = KinkyDungeonDetectLanguageForMaxWidth(str, maxWidthTranslate, maxWidthEnglish);
    if (maxWidth == maxWidthTranslate) {
        while (str.length > maxWidth) {
            let found = false;
            let maxCJKWidth = maxWidth;
            for (let i = 0; i <= maxCJKWidth + 1; i++) {
                if (KinkyDungeonTestWhite(str.charAt(i), "Num")) {
                    maxCJKWidth += 0.5;
                }
                if (KinkyDungeonTestWhite(str.charAt(i), "English")) {
                    maxCJKWidth += 1;
                }
                if (KinkyDungeonTestWhite(str.charAt(i), "CJKP") && (maxCJKWidth - i) <= 2) {
                    res = res + [str.slice(0, i + 1), newLineStr].join('');
                    str = str.slice(i + 1);
                    found = true;
                    break;
                }
            }
            maxCJKWidth = Math.ceil(maxCJKWidth);
            if (!found) {
                if ((str.length - maxCJKWidth) <= 2) {
                    res += [str.slice(0, maxCJKWidth + 3), newLineStr].join('');
                    str = str.slice(maxCJKWidth + 3);
                }
                else if ((str.length - maxCJKWidth) <= 5) {
                    res += [str.slice(0, maxCJKWidth - 1), newLineStr].join('');
                    str = str.slice(maxCJKWidth - 1);
                }
                else {
                    res += [str.slice(0, maxCJKWidth), newLineStr].join('');
                    str = str.slice(maxCJKWidth);
                }
            }
        }
    }
    else {
        while (str.length > maxWidth) {
            let found = false;
            for (let i = maxWidth - 1; i >= 0; i--) {
                if (KinkyDungeonTestWhite(str.charAt(i), "English")) {
                    res = res + [str.slice(0, i), newLineStr].join('');
                    str = str.slice(i + 1);
                    found = true;
                    break;
                }
            }
            if (!found) {
                res += [str.slice(0, maxWidth), newLineStr].join('');
                str = str.slice(maxWidth);
            }
        }
    }
    return res + str;
}
function KinkyDungeonTestWhite(x, language) {
    if (language == "English") {
        let white = new RegExp(/^\s$/);
        return white.test(x.charAt(0));
    }
    if (language == "CJKP") {
        return CJKcheck(x.charAt(0), 3, "test");
    }
    if (language == "Num") {
        let white = new RegExp(/^[0-9.]$/);
        return white.test(x.charAt(0));
    }
}
function KDSchoolColor(school) {
    switch (school) {
        case "Elements": return "#ff4444";
        case "Conjure": return "#77cc99";
        case "Illusion": return "#8877ff";
    }
    return KDTextTan;
}
function KinkyDungeonDrawMagic() {
    KinkyDungeonDrawMessages(true);
    KDDraw(kdcanvas, kdpixisprites, "magicbook", KinkyDungeonRootDirectory + "MagicBook.png", canvasOffsetX_ui, canvasOffsetY_ui, 640 * KinkyDungeonBookScale, 483 * KinkyDungeonBookScale);
    if (KinkyDungeonSpells[KinkyDungeonCurrentPage] || KinkyDungeonPreviewSpell) {
        let spell = KinkyDungeonPreviewSpell ? KinkyDungeonPreviewSpell : KinkyDungeonSpells[KinkyDungeonCurrentPage];
        let SchoolColor = KDTextTan;
        if (spell.school)
            SchoolColor = KDSchoolColor(spell.school);
        DrawTextKD(TextGet("KinkyDungeonSpell" + spell.name), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5, "#000000", SchoolColor);
        DrawTextKD(TextGet("KinkyDungeonSpellsSchool" + spell.school), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 40, "#000000", SchoolColor);
        if (spell.prerequisite) {
            DrawTextKD(TextGet("KDPrerequisite"), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale * 0.6, KDTextGray0, KDTextTan);
            DrawTextFitKD(KDGetPrerequisite(spell), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale * 0.6 + 40, 640 * KinkyDungeonBookScale * 0.35, KDTextGray0, KDTextTan);
        }
        if (spell.upcastFrom) {
            DrawTextFitKD(TextGet("KDUpcastFrom").replace("SPELL", TextGet("KinkyDungeonSpell" + spell.upcastFrom)), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale * 0.4 + 40, 640 * KinkyDungeonBookScale * 0.35, KDTextGray0, KDTextTan);
            DrawTextFitKD(TextGet("KDUpcastLevel").replace("LEVEL", "" + spell.upcastLevel), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale * 0.4, 640 * KinkyDungeonBookScale * 0.35, KDTextGray0, KDTextTan);
        }
        if (KinkyDungeonPreviewSpell)
            DrawTextKD(TextGet("KinkyDungeonMagicCost") + KinkyDungeonGetCost(spell), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 2 + 150, KDTextGray0, KDTextTan);
        DrawTextKD(TextGet("KinkyDungeonMagicManaCost") + (spell.manacost * 10), canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 2 + 195, KDTextGray0, KDTextTan);
        let textSplit = KinkyDungeonWordWrap(TextGet("KinkyDungeonSpellDescription" + spell.name).replace("DamageDealt", "" + (spell.power * 10)).replace("Duration", spell.time).replace("LifeTime", spell.lifetime).replace("DelayTime", spell.delay).replace("BlockAmount", "" + (10 * spell.block)), 14, 32).split('\n');
        let i = 0;
        for (let N = 0; N < textSplit.length; N++) {
            DrawTextKD(textSplit[N], canvasOffsetX_ui + 640 * KinkyDungeonBookScale * (1 - 1 / 3), canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + i * 36, KDTextGray0, KDTextTan, 24);
            i++;
        }
        i = 0;
        if (spell.components.length > 0) {
            if (spell.components.includes("Verbal")) {
                DrawTextKD(TextGet("KinkyDungeonComponentsVerbal"), canvasOffsetX_ui + 640 * KinkyDungeonBookScale * (1 - 1 / 3), canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 2 + 215 - 40 * i, KDTextGray0, KDTextTan);
                i++;
            }
            if (spell.components.includes("Arms")) {
                DrawTextKD(TextGet("KinkyDungeonComponentsArms"), canvasOffsetX_ui + 640 * KinkyDungeonBookScale * (1 - 1 / 3), canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 2 + 215 - 40 * i, KDTextGray0, KDTextTan);
                i++;
            }
            if (spell.components.includes("Legs")) {
                DrawTextKD(TextGet("KinkyDungeonComponentsLegs"), canvasOffsetX_ui + 640 * KinkyDungeonBookScale * (1 - 1 / 3), canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 2 + 215 - 40 * i, KDTextGray0, KDTextTan);
                i++;
            }
            DrawTextKD(TextGet("KinkyDungeonComponents"), canvasOffsetX_ui + 640 * KinkyDungeonBookScale * (1 - 1 / 3), canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 2 + 215 - 40 * i, "#000000", KDTextTan);
            i = 1;
        }
        if (!KinkyDungeonPreviewSpell) {
            if (!spell.passive && !spell.upcastFrom) {
                let w = 225;
                let h = 50;
                let x_start = canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 40;
                let y_start = canvasOffsetY_ui + 150;
                for (let I = 0; I < KinkyDungeonSpellChoiceCount; I++) {
                    let x = x_start + w * Math.floor(I / KinkyDungeonSpellChoiceCountPerPage);
                    let y = y_start + h * (I % KinkyDungeonSpellChoiceCountPerPage);
                    if (KinkyDungeonSpells[KinkyDungeonSpellChoices[I]])
                        KDDraw(kdcanvas, kdpixisprites, "kdspellPreview" + KinkyDungeonSpells[KinkyDungeonSpellChoices[I]].name, KinkyDungeonRootDirectory + "Spells/" + KinkyDungeonSpells[KinkyDungeonSpellChoices[I]].name + ".png", x - h, y, h, h);
                    DrawTextFitKD(`${1 + (I % KinkyDungeonSpellChoiceCountPerPage)}`, x - h, y + h * 0.5, h * 0.25, "#efefef", "#888888");
                    DrawButtonKDEx("SpellSlotBook" + I, (bdata) => {
                        if (KinkyDungeonSpells[KinkyDungeonSpellChoices[I]] == spell) {
                            KDSendInput("spellRemove", { I: I });
                        }
                        else {
                            if (KinkyDungeonSpellChoices.includes(KinkyDungeonCurrentPage)) {
                                KDSendInput("spellRemove", { I: KinkyDungeonSpellChoices.indexOf(KinkyDungeonCurrentPage) });
                            }
                            KinkyDungeonClickSpellChoice(I, KinkyDungeonCurrentPage);
                        }
                        return true;
                    }, true, x, y, w - 25 - h, h - 5, (KinkyDungeonSpells[KinkyDungeonSpellChoices[I]] ? (TextGet("KinkyDungeonSpell" + KinkyDungeonSpells[KinkyDungeonSpellChoices[I]].name)) : ""), KinkyDungeonSpells[KinkyDungeonSpellChoices[I]] && KinkyDungeonSpells[KinkyDungeonSpellChoices[I]].name == spell.name ? "White" : KDTextGray3, "", "");
                }
            }
            if (!spell.passive && !(spell.type == "passive") && !spell.upcastFrom)
                DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale * 0.5 - 200, canvasOffsetY_ui - 70 + 483 * KinkyDungeonBookScale, 400, 60, TextGet("KinkyDungeonSpellCastFromBook")
                    .replace("XXX", KinkyDungeonStatsChoice.has("Disorganized") ? "3" : (KinkyDungeonStatsChoice.has("QuickDraw") ? "No" : "1")), "White", "", "", false, true, KDButtonColor);
        }
        else {
            let cost = KinkyDungeonGetCost(spell);
            DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 40, canvasOffsetY_ui + 125, 225, 60, TextGet("KinkyDungeonSpellsBuy"), (KinkyDungeonSpellPoints >= cost && KinkyDungeonCheckSpellPrerequisite(spell)) ? "White" : "Pink", "", "");
        }
    }
    if (KinkyDungeonCurrentPage > 0) {
        DrawButtonVis(canvasOffsetX_ui + 100, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60, TextGet("KinkyDungeonBookLastPage"), "White", "", "", false, true, KDButtonColor);
    }
    if (KinkyDungeonCurrentPage < KinkyDungeonSpells.length - 1) {
        DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale - 325, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60, TextGet("KinkyDungeonBookNextPage"), "White", "", "", false, true, KDButtonColor);
    }
    if (KDSwapSpell != -1) {
        DrawTextKD(TextGet("KinkyDungeonMagicSpellsQuick").replace("SPELLNAME", TextGet("KinkyDungeonSpell" + KinkyDungeonSpells[KinkyDungeonSpellChoices[KDSwapSpell]].name)), canvasOffsetX_ui + 600, 900, "white", KDTextGray0);
    }
    else {
        DrawTextKD(TextGet("KinkyDungeonSpellsLevels")
            .replace("SPELLPOINTS", "" + KinkyDungeonSpellPoints), canvasOffsetX_ui + 600, 890, "white", KDTextGray0);
    }
}
let selectedFilters = ["learnable"];
let genericfilters = ['learnable', 'unlearned', 'noupgrade', 'yesupgrade', "upcast"];
let KDSpellListIndex = 0;
let KDSpellListIndexVis = 0;
let KDMaxSpellPerColumn = 8;
let KDMaxSpellYY = 480;
function KDFilterSpellPages() {
    if (!KDGameData.HiddenSpellPages)
        return KinkyDungeonLearnableSpells;
    let pages = [];
    for (let i = 0; i < KinkyDungeonLearnableSpells.length; i++) {
        if (!KDGameData.HiddenSpellPages[KinkyDungeonSpellPages[i]]) {
            pages.push(KinkyDungeonLearnableSpells[i]);
        }
    }
    return pages;
}
function KDFilterSpellPageNames() {
    if (!KDGameData.HiddenSpellPages)
        return KinkyDungeonSpellPages;
    let pages = [];
    for (let i = 0; i < KinkyDungeonLearnableSpells.length; i++) {
        if (!KDGameData.HiddenSpellPages[KinkyDungeonSpellPages[i]]) {
            pages.push(KinkyDungeonSpellPages[i]);
        }
    }
    return pages;
}
function KDCorrectCurrentSpellPage(pages) {
    let ret = 0;
    for (let i = 0; i < KinkyDungeonCurrentSpellsPage; i++) {
        if (!KDGameData.HiddenSpellPages[KinkyDungeonSpellPages[i]]) {
            ret += 1;
        }
    }
    return ret;
}
function KinkyDungeonListSpells(Mode) {
    let i = 0;
    let XX = 0;
    let spacing = 60;
    let subspell_reduction = 20;
    let ypadding = 10;
    let yPad = 120 + MagicSpellsUIShift;
    let buttonwidth = 280;
    let xpadding = 20;
    let col = 0;
    let ypadding_min = -2;
    let weight = 5;
    KDSpellListIndexVis = (KDSpellListIndex + KDSpellListIndexVis * (weight - 1)) / weight;
    let pages = KDFilterSpellPages();
    let currentPage = KinkyDungeonCurrentSpellsPage;
    let spellPages = pages[currentPage];
    let pageNames = KDFilterSpellPageNames();
    let columnLabels = KDColumnLabels[currentPage];
    let extraFilters = filtersExtra[currentPage];
    if (Mode == "Draw") {
        let x = 4 * (buttonwidth + xpadding);
        let y = 25 + canvasOffsetY_ui;
        let filterlist = Object.assign([], filters);
        if (extraFilters) {
            for (let ff of extraFilters) {
                filterlist.push(ff);
            }
        }
        for (let f of filterlist) {
            let ticked = selectedFilters.includes(f);
            DrawButtonKDEx("filter" + f, (bdata) => {
                if (selectedFilters.includes(f))
                    selectedFilters.splice(selectedFilters.indexOf(f), 1);
                else
                    selectedFilters.push(f);
                return true;
            }, true, canvasOffsetX_ui + x, y, buttonwidth, 36, TextGet("KinkyDungeonFilter" + f), selectedFilters.includes(f) ? "#ffffff" : "#999999", ticked ? (KinkyDungeonRootDirectory + "UI/Tick.png") : "", "", false, true);
            y += 42;
        }
    }
    if (columnLabels) {
        for (let column = 0; column < columnLabels.length; column++) {
            let x = canvasOffsetX_ui + column * (buttonwidth + xpadding);
            let y = yPad - 40 + canvasOffsetY_ui;
            DrawTextKD(TextGet("KinkyDungeonColumn" + columnLabels[column]), x + buttonwidth / 2, y + 20, "#ffffff", KDTextGray0);
        }
    }
    let longestList = 0;
    for (let pg of spellPages) {
        longestList = Math.max(longestList, pg.length);
    }
    if (KDSpellListIndex > longestList)
        KDSpellListIndex = 0;
    DrawButtonKDEx("spellsUp", (bdata) => {
        KDSpellListIndex = Math.max(0, KDSpellListIndex - 3);
        return true;
    }, KDSpellListIndex > 0, 910, 800, 90, 40, "", KDSpellListIndex > 0 ? "white" : "#888888", KinkyDungeonRootDirectory + "Up.png");
    DrawButtonKDEx("spellsDown", (bdata) => {
        KDSpellListIndex = Math.max(0, Math.min(longestList - KDMaxSpellPerColumn + 1, KDSpellListIndex + 3));
        return true;
    }, KDSpellListIndex < longestList - KDMaxSpellPerColumn + 1, 1160, 800, 90, 40, "", KDSpellListIndex < longestList - KDMaxSpellPerColumn + 1 ? "white" : "#888888", KinkyDungeonRootDirectory + "Down.png");
    for (let pg of spellPages) {
        let column = col;
        i = 0;
        let iii = 0;
        let YY = 0;
        for (let sp of pg) {
            let spell = KinkyDungeonFindSpell(sp, false);
            let prereq = spell ? KinkyDungeonCheckSpellPrerequisite(spell) : false;
            let prereqHost = spell ? (spell.upcastFrom && KinkyDungeonCheckSpellPrerequisite(KinkyDungeonFindSpell(spell.upcastFrom))) : false;
            let learned = spell ? KinkyDungeonSpellIndex(spell.name) >= 0 : false;
            let upgrade = spell ? spell.passive : false;
            let passive = spell ? spell.type == "passive" : false;
            let upcast = spell ? spell.upcastFrom : false;
            if (spell
                && (KDSwapSpell == -1 || KinkyDungeonSpellIndex(spell.name) >= 0)
                && YY < KDMaxSpellYY + spacing
                && (!spell.hideLearned || !learned)
                && (!spell.hideUnlearnable || prereq || learned)
                && (selectedFilters.length == 0 || (selectedFilters.every((element) => { return genericfilters.includes(element) || (spell.tags && spell.tags.includes(element)); })))
                && (!selectedFilters.includes("learnable") || (prereq || learned || prereqHost))
                && (!selectedFilters.includes("unlearned") || (!learned))
                && (!selectedFilters.includes("noupgrade") || (!upgrade && !upcast))
                && (!selectedFilters.includes("yesupgrade") || (upgrade || passive))
                && (!selectedFilters.includes("upcast") || (upcast))) {
                if (iii < Math.round(KDSpellListIndexVis)) {
                    iii += 1;
                    continue;
                }
                XX = column * (buttonwidth + xpadding);
                if (!spell.upcastFrom && i > 0) {
                    YY += ypadding;
                }
                let cost = KinkyDungeonGetCost(spell);
                let suff = `${cost}`;
                let yy = yPad + canvasOffsetY_ui + YY + (spell.upcastFrom ? 2 : 0);
                let h = spacing - ypadding + (spell.upcastFrom ? -subspell_reduction : 0);
                let w = buttonwidth + (spell.upcastFrom ? -30 : 0);
                let xx = canvasOffsetX_ui + XX + (spell.upcastFrom ? 30 : 0);
                if (Mode == "Draw") {
                    let color = KDSwapSpell == -1 ? "#bcbcbc" : "#777777";
                    let index = KinkyDungeonSpellIndex(spell.name);
                    if (index >= 0 && (KDSwapSpell == -1 || !KinkyDungeonSpellChoices.includes(index))) {
                        color = "#ffffff";
                        suff = "";
                    }
                    else if (!KinkyDungeonCheckSpellPrerequisite(spell)) {
                        color = "#555555";
                    }
                    if (!spell.passive)
                        KDDraw(kdcanvas, kdpixisprites, "spIcon" + spell.name, KinkyDungeonRootDirectory + "Spells/" + spell.name + ".png", xx, yy, h, h, undefined, {
                            zIndex: 110,
                            alpha: index >= 0 ? 1.0 : 0.5
                        });
                    if (index >= 0)
                        KDDraw(kdcanvas, kdpixisprites, "spIconTick" + spell.name, KinkyDungeonRootDirectory + "UI/" + "CheckSmall" + ".png", xx + w - 30, yy + h / 2 - 15, 30, 30, undefined, {
                            zIndex: 110,
                        });
                    DrawButtonVis(xx, yy, w, h, "", color, "", "", false, true, (index >= 0) ? "#070707" : "#040404", (spell.upcastFrom ? 20 : 24), false, false, 20, {
                        alpha: index >= 0 ? 0.9 : 0.9
                    });
                    DrawTextFitKD(TextGet("KinkyDungeonSpell" + spell.name), xx + h + 2 + (spell.upcastFrom ? 0 : 8), yy + h / 2, w - h * 1.75, color, undefined, (spell.upcastFrom ? 18 : 22), "left", undefined, undefined, false);
                    DrawTextFitKD(suff, xx + w - 8, yy + h / 2, h, KinkyDungeonSpellPoints >= cost ? color : "#ff5555", undefined, 20, "right", undefined, undefined, false);
                }
                else if (Mode == "Click") {
                    if (MouseIn(canvasOffsetX_ui + XX, yPad + canvasOffsetY_ui + YY, buttonwidth, spacing - ypadding))
                        return spell;
                }
                i++;
                YY += h + ypadding_min;
            }
        }
        col++;
    }
    let procList = pageNames;
    let adjLists = GetAdjacentList(procList, currentPage, 1);
    let left = adjLists.left;
    let right = adjLists.right;
    drawVertList(left.reverse(), canvasOffsetX_ui + 200 / 2 + 100, 100, 200, 25, 5, 18, (data) => {
        return (bdata) => {
            KinkyDungeonCurrentSpellsPage = procList.indexOf(data.name);
            return true;
        };
    }, "KinkyDungeonSpellsPage");
    drawVertList(right, canvasOffsetX_ui - 200 / 2 + 1050, 100, 200, 25, 5, 18, (data) => {
        return (bdata) => {
            KinkyDungeonCurrentSpellsPage = procList.indexOf(data.name);
            return true;
        };
    }, "KinkyDungeonSpellsPage");
    return undefined;
}
let MagicSpellsUIShift = -80;
function KinkyDungeonDrawMagicSpells() {
    KinkyDungeonListSpells("Draw");
    let pages = KDFilterSpellPages();
    let currentPage = KinkyDungeonCurrentSpellsPage;
    let pageNames = KDFilterSpellPageNames();
    DrawTextKD(TextGet("KinkyDungeonSpellsPage").replace("NUM", "" + (currentPage + 1)).replace("TOTAL", "" + (pages.length)) + ": " + TextGet("KinkyDungeonSpellsPage" + pageNames[currentPage]), canvasOffsetX_ui + 575, canvasOffsetY_ui + 25 + MagicSpellsUIShift, "white", KDTextGray0);
    if (KDSwapSpell != -1) {
        DrawTextKD(TextGet("KinkyDungeonMagicSpellsQuick").replace("SPELLNAME", (KinkyDungeonSpells[KinkyDungeonSpellChoices[KDSwapSpell]]) ?
            TextGet("KinkyDungeonSpell" + KinkyDungeonSpells[KinkyDungeonSpellChoices[KDSwapSpell]].name)
            : TextGet("KinkyDungeonSpellNone")), canvasOffsetX_ui + 600, 900, "white", KDTextGray0);
    }
    else {
        DrawTextKD(TextGet("KinkyDungeonSpellsLevels")
            .replace("SPELLPOINTS", "" + KinkyDungeonSpellPoints), canvasOffsetX_ui + 600, 890, "white", KDTextGray0);
    }
    DrawButtonVis(canvasOffsetX_ui + 0, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50, TextGet("KinkyDungeonSpellsPageBackFast"), "White", "", "", false, false, KDButtonColor);
    DrawButtonVis(canvasOffsetX_ui + 1100, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50, TextGet("KinkyDungeonSpellsPageNextFast"), "White", "", "", false, false, KDButtonColor);
    DrawButtonVis(canvasOffsetX_ui + 55, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50, TextGet("KinkyDungeonSpellsPageBack"), "White", "", "", false, false, KDButtonColor);
    DrawButtonVis(canvasOffsetX_ui + 1045, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50, TextGet("KinkyDungeonSpellsPageNext"), "White", "", "", false, false, KDButtonColor);
}
function KinkyDungeonHandleMagicSpells() {
    let pages = KDFilterSpellPages();
    if (MouseIn(canvasOffsetX_ui + 50, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50)) {
        if (KinkyDungeonCurrentSpellsPage > 0)
            KinkyDungeonCurrentSpellsPage -= 1;
        else
            KinkyDungeonCurrentSpellsPage = pages.length - 1;
        KDSpellListIndex = 0;
        selectedFilters = selectedFilters.filter((filter) => {
            return filters.includes(filter);
        });
        return true;
    }
    else if (MouseIn(canvasOffsetX_ui + 1045, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50)) {
        if (KinkyDungeonCurrentSpellsPage < pages.length - 1)
            KinkyDungeonCurrentSpellsPage += 1;
        else
            KinkyDungeonCurrentSpellsPage = 0;
        KDSpellListIndex = 0;
        selectedFilters = selectedFilters.filter((filter) => {
            return filters.includes(filter);
        });
        return true;
    }
    else if (MouseIn(canvasOffsetX_ui + 0, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50)) {
        if (KinkyDungeonCurrentSpellsPage > 0) {
            if (KinkyDungeonCurrentSpellsPage > 2)
                KinkyDungeonCurrentSpellsPage -= 3;
            else
                KinkyDungeonCurrentSpellsPage = 0;
        }
        else
            KinkyDungeonCurrentSpellsPage = pages.length - 1;
        KDSpellListIndex = 0;
        selectedFilters = selectedFilters.filter((filter) => {
            return filters.includes(filter);
        });
        return true;
    }
    else if (MouseIn(canvasOffsetX_ui + 1100, canvasOffsetY_ui + MagicSpellsUIShift, 50, 50)) {
        if (KinkyDungeonCurrentSpellsPage < pages.length - 1) {
            if (KinkyDungeonCurrentSpellsPage < pages.length - 3)
                KinkyDungeonCurrentSpellsPage += 3;
            else
                KinkyDungeonCurrentSpellsPage = pages.length - 1;
        }
        else
            KinkyDungeonCurrentSpellsPage = 0;
        selectedFilters = selectedFilters.filter((filter) => {
            return filters.includes(filter);
        });
        KDSpellListIndex = 0;
        return true;
    }
    let spell = KinkyDungeonListSpells("Click");
    if (spell) {
        if (KDSwapSpell == -1) {
            KinkyDungeonSetPreviewSpell(spell);
        }
        else if (!spell.upcastFrom) {
            let index = KinkyDungeonSpellIndex(spell.name);
            if (!KinkyDungeonSpellChoices.includes(index)) {
                KinkyDungeonClickSpellChoice(KDSwapSpell, index);
                KinkyDungeonDrawState = "Game";
            }
        }
        return true;
    }
    return true;
}
function KinkyDungeonSpellIndex(Name) {
    for (let i = 0; i < KinkyDungeonSpells.length; i++) {
        if (KinkyDungeonSpells[i].name == Name)
            return i;
    }
    return -1;
}
function KinkyDungeonSetPreviewSpell(spell) {
    let index = KinkyDungeonSpellIndex(spell.name);
    KinkyDungeonPreviewSpell = index >= 0 ? null : spell;
    if (!KinkyDungeonPreviewSpell)
        KinkyDungeonCurrentPage = index;
    KinkyDungeonDrawState = "Magic";
}
function KinkyDungeonGetCompList(spell) {
    let ret = "";
    if (spell.components)
        for (let c of spell.components) {
            if (ret)
                ret = ret + "/";
            if (c == "Verbal")
                ret = ret + (ret ? "V" : "Verbal");
            else if (c == "Arms")
                ret = ret + (ret ? "A" : "Arms");
            else if (c == "Legs")
                ret = ret + (ret ? "L" : "Legs");
        }
    return ret;
}
function KinkyDungeonSendMagicEvent(Event, data, forceSpell) {
    if (!KDMapHasEvent(KDEventMapSpell, Event))
        return;
    for (let i = 0; i < KinkyDungeonSpellChoices.length; i++) {
        let spell = KinkyDungeonSpells[KinkyDungeonSpellChoices[i]];
        if (spell && spell.events) {
            for (let e of spell.events) {
                if (e.trigger == Event && (KinkyDungeonSpellChoicesToggle[i] || e.always || spell.name == (forceSpell === null || forceSpell === void 0 ? void 0 : forceSpell.name))) {
                    KinkyDungeonHandleMagicEvent(Event, e, spell, data);
                }
            }
        }
    }
    for (let i = 0; i < KinkyDungeonSpells.length; i++) {
        let spell = KinkyDungeonSpells[i];
        if (spell && spell.passive && spell.events) {
            for (let e of spell.events) {
                if (e.trigger == Event) {
                    KinkyDungeonHandleMagicEvent(Event, e, spell, data);
                }
            }
        }
    }
}
function KDCastSpellToEnemies(fn, tX, tY, spell) {
    let enList = KDNearbyEnemies(tX, tY, spell.aoe);
    let cast = false;
    if (enList.length > 0) {
        for (let en of enList) {
            if (fn(en))
                cast = true;
        }
    }
    return cast;
}
function KDMatchTags(tags, entity) {
    var _a;
    if (tags) {
        for (let tag of tags) {
            if ((_a = entity === null || entity === void 0 ? void 0 : entity.Enemy) === null || _a === void 0 ? void 0 : _a.tags[tag])
                return true;
        }
    }
    return false;
}
let KinkyDungeonSpellSpecials = {
    "analyze": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en) {
            if (!en.buffs || !en.buffs.Analyze) {
                if (!en.buffs)
                    en.buffs = {};
                KinkyDungeonApplyBuff(en.buffs, { id: "Analyze", aura: "#ffffff", type: "DamageAmp", duration: 99999, power: 0.3, player: false, enemies: true, maxCount: 3, tags: ["defense", "damageTaken"] });
                KinkyDungeonApplyBuff(en.buffs, { id: "Analyze2", type: "Info", duration: 99999, power: 1.0, player: false, enemies: true, tags: ["info"] });
            }
            else
                return "Fail";
        }
        else {
            let tile = KinkyDungeonTilesGet(targetX + "," + targetY);
            if (tile) {
                if (tile.Loot && tile.Roll) {
                    let event = KinkyDungeonLoot(MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], tile.Loot, tile.Roll, tile, true);
                    if (event.trap || tile.lootTrap)
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonShrineTooltipTrap"), "#ff0000", 2);
                    else
                        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonShrineTooltipNoTrap"), "lightgreen", 2);
                }
                else
                    return "Fail";
            }
            else
                return "Fail";
        }
    },
    "BoulderKick": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en) {
            if (en.Enemy.tags.summonedRock) {
                en.hp = 0;
                en.faction = "Player";
                en.rage = 0;
                en.hostile = 0;
                let spell2 = KinkyDungeonFindSpell("BoulderKicked", true);
                let size = (spell2.size) ? spell2.size : 1;
                let xx = entity.x;
                let yy = entity.y;
                if (!bullet || (bullet.spell && bullet.spell.cast && bullet.spell.cast.offset)) {
                    xx += moveDirection.x;
                    yy += moveDirection.y;
                }
                let b = KinkyDungeonLaunchBullet(xx, yy, tX - entity.x, tY - entity.y, spell2.speed, { noSprite: spell2.noSprite, faction: faction, name: spell2.name, block: spell2.block, width: size, height: size, summon: spell2.summon, cast: cast, dot: spell2.dot,
                    bulletColor: spell.bulletColor, bulletLight: spell.bulletLight,
                    effectTile: spell2.effectTile, effectTileDurationMod: spell2.effectTileDurationMod,
                    effectTileTrail: spell2.effectTileTrail, effectTileDurationModTrail: spell2.effectTileDurationModTrail, effectTileTrailAoE: spell2.effectTileTrailAoE,
                    passthrough: spell2.noTerrainHit, noEnemyCollision: spell2.noEnemyCollision, alwaysCollideTags: spell2.alwaysCollideTags, nonVolatile: spell2.nonVolatile, noDoubleHit: spell2.noDoubleHit,
                    pierceEnemies: spell2.pierceEnemies, piercing: spell2.piercing, events: spell2.events,
                    lifetime: miscast || selfCast ? 1 : (spell2.bulletLifetime ? spell2.bulletLifetime : 1000), origin: { x: entity.x, y: entity.y }, range: spell2.range, hit: spell2.onhit,
                    damage: { evadeable: spell2.evadeable, damage: spell2.power, type: spell2.damage, bind: spell2.bind, bindEff: spell2.bindEff, distract: spell2.distract, distractEff: spell2.distractEff, boundBonus: spell2.boundBonus, time: spell2.time, flags: spell2.damageFlags }, spell: spell2 }, miscast);
                b.visual_x = entity.x;
                b.visual_y = entity.y;
            }
            else
                return "Fail";
        }
        else
            return "Fail";
    },
    "Volcanism": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let rocks = [];
        for (let e of KinkyDungeonEntities) {
            if (spell.filterTags.some((tag) => { return e.Enemy.tags[tag]; }) && KDistEuclidean(targetX - e.x, targetY - e.y) <= spell.aoe
                && (!e.buffs || !KinkyDungeonHasBuff(e.buffs, KDVolcanism.id))) {
                rocks.push(e);
            }
        }
        if (rocks.length == 0)
            return "Fail";
        for (let rock of rocks) {
            KinkyDungeonApplyBuffToEntity(rock, KDVolcanism);
            rock.hostile = 9999;
        }
    },
    "dress": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        KinkyDungeonSetDress(spell.outfit);
    },
    "CommandWord": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en) {
            if (en.boundLevel > 0) {
                if (KDHostile(en) && en.hp <= en.Enemy.maxhp * 0.1) {
                    en.ceasefire = 50;
                }
                else if (!KDHostile(en) && en.hp <= en.Enemy.maxhp * 0.1) {
                    en.allied = 100;
                    let ff = KDGetFactionOriginal(en);
                    if (!KinkyDungeonHiddenFactions.includes(ff)) {
                        KinkyDungeonChangeFactionRep(ff, 0.005);
                    }
                }
                if (en.buffs)
                    for (let b of Object.values(en.buffs)) {
                        if (b.tags && b.tags.includes("commandword")) {
                            b.duration = 0;
                        }
                    }
                en.boundLevel = Math.max(0, en.boundLevel);
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
                return "Cast";
            }
            KinkyDungeonSendTextMessage(8, TextGet("KDCommandWordFail_NoEnemy"), "#ff5555", 1, true);
            return "Fail";
        }
        else if (targetX == KinkyDungeonPlayerEntity.x && targetY == KinkyDungeonPlayerEntity.y) {
            if (KinkyDungeonPlayerGetRestraintsWithLocks(KDMagicLocks).length > 0) {
                for (let r of KinkyDungeonPlayerGetRestraintsWithLocks(KDMagicLocks, true)) {
                    KinkyDungeonLock(r, "");
                }
                KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonPurpleLockRemove"), "#ffff00", 2);
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                if (KDToggles.Sound)
                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
                return "Cast";
            }
            KinkyDungeonSendTextMessage(8, TextGet("KDCommandWordFail_NoLocks"), "#ff5555", 1, true);
            return "Fail";
        }
        else if (KinkyDungeonTilesGet(targetX + "," + targetY) && KinkyDungeonTilesGet(targetX + "," + targetY).Type == "Charger" && KinkyDungeonTilesGet(targetX + "," + targetY).NoRemove) {
            KinkyDungeonTilesGet(targetX + "," + targetY).NoRemove = false;
            KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonPurpleLockRemoveCharger"), "#ffff00", 2);
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
            return "Cast";
        }
        KinkyDungeonSendTextMessage(8, TextGet("KDCommandWordFail_NoTarget"), "#ff5555", 1, true);
        return "Fail";
    },
    "Lockdown": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en && en.boundLevel > 0) {
            KinkyDungeonApplyBuffToEntity(en, {
                id: "Lockdown", aura: "#a96ef5", type: "MinBoundLevel", duration: 9000, power: Math.min(en.Enemy.maxhp, en.boundLevel), maxCount: 1, tags: ["lock", "debuff", "commandword", "CM1"]
            });
            KinkyDungeonCastSpell(targetX, targetY, KinkyDungeonFindSpell("EffectEnemyLock1", true), undefined, undefined, undefined);
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
            return "Cast";
        }
        else
            return "Fail";
    },
    "Enemy_CM1": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        var _a;
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en) {
            KinkyDungeonTickBuffTag(en.buffs, "CM1", 1);
            KinkyDungeonCastSpell(targetX, targetY, KinkyDungeonFindSpell("EffectEnemyCM" + (((_a = entity === null || entity === void 0 ? void 0 : entity.Enemy) === null || _a === void 0 ? void 0 : _a.unlockCommandLevel) || 1), true), undefined, undefined, undefined);
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
            if (entity === null || entity === void 0 ? void 0 : entity.Enemy) {
                KinkyDungeonSetEnemyFlag(entity, "commandword", entity.Enemy.unlockCommandCD || 90);
                KinkyDungeonSendActionMessage(7, TextGet("KDCastCM1").replace("EnemyName", TextGet("Name" + entity.Enemy.name)).replace("TargetName", TextGet("Name" + en.Enemy.name)), "#ff5555", 4);
            }
            return "Cast";
        }
        return "Fail";
    },
    "Chastity": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en && en.Enemy.bound && KinkyDungeonIsDisabled(en)) {
            KDTieUpEnemy(en, spell.power, "Metal");
            KinkyDungeonApplyBuffToEntity(en, KDChastity);
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else {
            if (KinkyDungeonPlayerEntity.x == tX && KinkyDungeonPlayerEntity.y == tY) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["magicBeltForced"] }, MiniGameKinkyDungeonLevel + 10, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd) {
                    KinkyDungeonSendActionMessage(3, TextGet("KDZoneOfPuritySelf"), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
                    KinkyDungeonAddRestraintIfWeaker(restraintAdd, 0, false, undefined, false, false, undefined, faction);
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    return "Cast";
                }
            }
            return "Fail";
        }
    },
    "DisplayStand": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEntityAt(targetX, targetY);
        if (en && en.player) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["displaySpell"] }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCastSelf" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, 0, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                return "Cast";
            }
        }
        else if (en && KDCanBind(en) && KDHelpless(en)) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            let Enemy = KinkyDungeonGetEnemyByName("PetDisplay");
            if (Enemy) {
                KinkyDungeonDamageEnemy(en, {
                    type: "chain",
                    damage: 0,
                    time: 0,
                    bind: 0,
                }, false, true, undefined, undefined, entity);
                en.hp = 0;
                let doll = {
                    summoned: true,
                    rage: Enemy.summonRage ? 9999 : undefined,
                    Enemy: Enemy,
                    id: KinkyDungeonGetEnemyID(),
                    x: en.x,
                    y: en.y,
                    hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp,
                    movePoints: 0,
                    attackPoints: 0
                };
                KDAddEntity(doll);
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                KinkyDungeonChangeCharge(0.05);
                return "Cast";
            }
            return "Fail";
        }
        else
            return "Fail";
    },
    "Petsuit": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEntityAt(targetX, targetY);
        if (en && en.player) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["petsuitSpell"] }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCastSelf" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, 0, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                return "Cast";
            }
        }
        else if (en && KDCanBind(en) && KDHelpless(en)) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            let Enemy = KinkyDungeonGetEnemyByName("Pet");
            if (Enemy) {
                KinkyDungeonDamageEnemy(en, {
                    type: "chain",
                    damage: 0,
                    time: 0,
                    bind: 0,
                }, false, true, undefined, undefined, entity);
                en.hp = 0;
                let doll = {
                    summoned: true,
                    rage: Enemy.summonRage ? 9999 : undefined,
                    Enemy: Enemy,
                    id: KinkyDungeonGetEnemyID(),
                    x: en.x,
                    y: en.y,
                    hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp,
                    movePoints: 0,
                    attackPoints: 0
                };
                KDAddEntity(doll);
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                return "Cast";
            }
            return "Fail";
        }
        else
            return "Fail";
    },
    "CommandCapture": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEntityAt(targetX, targetY);
        if (en && (en.player || en.Enemy.bound)) {
            let bindTypes = [];
            let bindCounts = {};
            for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
                for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                    if (KDistEuclidean(X, Y) <= spell.aoe) {
                        let loc = (tX + X) + "," + (tY + Y);
                        if (KinkyDungeonEffectTilesGet(loc)) {
                            for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                                if (tile.tags && tile.tags.includes("bind")) {
                                    for (let t of tile.tags) {
                                        if (KDCommandCaptureBindings[t]) {
                                            bindTypes.push(t);
                                            if (!bindCounts[t])
                                                bindCounts[t] = 0;
                                            bindCounts[t] += 1;
                                            KDCommandCaptureBindings[t](spell, en, faction, bullet, miscast, entity, bindCounts[t]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            if (bindTypes.length > 0) {
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                if (!en.player)
                    KinkyDungeonDamageEnemy(en, {
                        type: "chain",
                        damage: spell.power,
                        time: spell.time,
                        bind: spell.bind,
                    }, false, false, undefined, undefined, entity);
                return "Cast";
            }
            else
                return "Fail";
        }
        else
            return "Fail";
    },
    "AnimatePuppet": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let maxCount = 3;
        let enemies = [];
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let en = KinkyDungeonEntityAt(tX + X, tY + Y);
                    if (en && !en.player && en.Enemy && KDHelpless(en) && KDEntityBuffedStat(en, "SlimeProgress") >= 1.99) {
                        if (KDRandom() < 0.5)
                            enemies.push(en);
                        else
                            enemies.unshift(en);
                    }
                }
            }
        if (enemies.length > 0) {
            let n = 0;
            let cost = KinkyDungeonGetManaCost(spell) / 3;
            for (let s of enemies) {
                if (n < maxCount) {
                    KinkyDungeonChangeMana(-cost);
                    s.hp = 0;
                    let Enemy = KinkyDungeonGetEnemyByName("AllyDoll");
                    let doll = {
                        summoned: true,
                        rage: Enemy.summonRage ? 9999 : undefined,
                        Enemy: Enemy,
                        id: KinkyDungeonGetEnemyID(),
                        x: s.x,
                        y: s.y,
                        hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp,
                        movePoints: 0,
                        attackPoints: 0
                    };
                    KDAddEntity(doll);
                    n += 1;
                }
            }
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            return "Cast";
        }
        else
            return "Fail";
    },
    "Animate": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let maxCount = 3;
        let slots = [];
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let loc = (tX + X) + "," + (tY + Y);
                    if (KinkyDungeonEffectTilesGet(loc)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                            if (tile.tags && tile.tags.includes("slime") && !KinkyDungeonEntityAt(tX + X, tY + Y)) {
                                if (KDRandom() < 0.5)
                                    slots.push({ x: tX + X, y: tY + Y });
                                else
                                    slots.unshift({ x: tX + X, y: tY + Y });
                            }
                        }
                    }
                }
            }
        if (slots.length > 0) {
            let n = 0;
            let cost = KinkyDungeonGetManaCost(spell) / 3;
            for (let s of slots) {
                if (n < maxCount) {
                    KinkyDungeonChangeMana(-cost);
                    KinkyDungeonSummonEnemy(s.x, s.y, "SmallSlime", 1, 0.5, undefined, 50, undefined, undefined, "Player");
                    n += 1;
                }
            }
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            return "Cast";
        }
        else
            return "Fail";
    },
    "AnimateLarge": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let slimeCount = 0;
        let slots = [];
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let loc = (tX + X) + "," + (tY + Y);
                    if (KinkyDungeonEffectTilesGet(loc)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                            if (tile.tags && tile.tags.includes("slime")) {
                                if (!KinkyDungeonEntityAt(tX + X, tY + Y)) {
                                    if (KDRandom() < 0.5)
                                        slots.push({ x: tX + X, y: tY + Y });
                                    else
                                        slots.unshift({ x: tX + X, y: tY + Y });
                                }
                                slimeCount += 1;
                            }
                        }
                    }
                }
            }
        if (slimeCount > 0 && slots.length > 0) {
            let cost = KinkyDungeonGetManaCost(spell) / 3;
            let s = slots[Math.floor(KDRandom() * slots.length)];
            KinkyDungeonChangeMana(-cost);
            KinkyDungeonSummonEnemy(s.x, s.y, "BigSlime", 1, 0.5, undefined, 90, undefined, undefined, "Player");
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            return "Cast";
        }
        else
            return "Fail";
    },
    "ElasticGrip": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        if (!KinkyDungeonCheckPath(entity.x, entity.y, tX, tY, true, false)) {
            KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonSpellCastFail" + spell.name), "#ff5555", 1);
            return "Fail";
        }
        let en = KinkyDungeonEntityAt(targetX, targetY);
        if (en && !en.player) {
            if (!KDIsImmobile(en)) {
                if (!en.player)
                    KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
                let dist = Math.min(KDistEuclidean(en.x - entity.x, en.y - entity.y), Math.max(1, KDPushModifier(4, en))) + 0.01;
                let pullToX = entity.x;
                let pullToY = entity.y;
                KDCreateParticle(tX, tY, "ElasticGripHit");
                let lastx = en.x;
                let lasty = en.y;
                for (let i = dist; i > 0; i -= 0.2499) {
                    if (KDistChebyshev(pullToX - en.x, pullToY - en.y) > 1.5) {
                        let newX = pullToX + Math.round((en.x - pullToX) * i / dist);
                        let newY = pullToY + Math.round((en.y - pullToY) * i / dist);
                        if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(newX, newY)) && KinkyDungeonNoEnemy(newX, newY, true)
                            && (KinkyDungeonCheckProjectileClearance(en.x, en.y, newX, newY))) {
                            KDMoveEntity(en, newX, newY, false, true, KDHostile(en));
                            if (en.x != lastx || en.y != lasty) {
                                lastx = en.x;
                                lasty = en.y;
                                KDCreateParticle(en.x, en.y, "ElasticGripHit");
                            }
                        }
                    }
                    else
                        break;
                }
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                KDCreateParticle(en.x, en.y, "ElasticGripHit");
                if (!en.player)
                    KinkyDungeonDamageEnemy(en, {
                        type: "glue",
                        damage: spell.power,
                        time: spell.time,
                        bind: spell.bind,
                    }, false, true, undefined, undefined, entity);
                return "Cast";
            }
            else
                return "Fail";
        }
        else
            return "Fail";
    },
    "Awaken": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let count = 0;
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let loc = (tX + X) + "," + (tY + Y);
                    if (KinkyDungeonEffectTilesGet(loc)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                            if (tile.tags && (tile.tags.includes("slime") || tile.tags.includes("latex"))) {
                                count += 1;
                                KinkyDungeonCastSpell(tX + X, tY + Y, KinkyDungeonFindSpell("AwakenStrike", true), undefined, undefined, undefined, "Player");
                            }
                        }
                    }
                }
            }
        if (count > 0) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else
            return "Fail";
    },
    "Spread": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let slots = [];
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let loc = (tX + X) + "," + (tY + Y);
                    if (KinkyDungeonEffectTilesGet(loc)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                            if (tile.tags && (tile.tags.includes("slime"))) {
                                slots.push({ x: tX + X, y: tY + Y, duration: tile.duration });
                            }
                        }
                    }
                }
            }
        if (slots.length > 0) {
            for (let s of slots) {
                for (let xx = -1; xx <= 1; xx++)
                    for (let yy = -1; yy <= 1; yy++) {
                        if ((xx == 0 || yy == 0) && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(s.x + xx, s.y + yy)))
                            KDCreateEffectTile(s.x + xx, s.y + yy, {
                                name: "Slime",
                                duration: Math.max(s.duration, 12),
                            }, 8);
                    }
            }
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else
            return "Fail";
    },
    "CommandBind": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let count = 0;
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let loc = (tX + X) + "," + (tY + Y);
                    if (KinkyDungeonEffectTilesGet(loc)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                            if (tile.tags && tile.tags.includes("bind")) {
                                for (let t of tile.tags) {
                                    if (KDCommandCaptureBindings[t]) {
                                        count += 1;
                                        KDCommandBindBindings[t](spell, tX + X, tY + Y, faction, bullet, miscast, entity);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        if (count > 0) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else
            return "Fail";
    },
    "Coalesce": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let count = 0;
        let finalTile = "Slime";
        let finalTilePri = -1;
        let finalTileDuration = 0;
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let loc = (tX + X) + "," + (tY + Y);
                    if (KinkyDungeonEffectTilesGet(loc)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                            if (tile.tags && tile.tags.includes("slime")) {
                                count += 1;
                                if (tile.duration > finalTileDuration)
                                    finalTileDuration = tile.duration;
                                if (tile.priority > finalTilePri) {
                                    finalTile = tile.name;
                                    finalTilePri = tile.priority;
                                }
                                tile.duration = 0;
                                tile.pauseDuration = 0;
                            }
                        }
                    }
                }
            }
        if (count == 0)
            return "Fail";
        KDCreateEffectTile(tX, tY, {
            name: finalTile,
            duration: finalTileDuration,
        }, 10);
        let enList = KDNearbyEnemies(tX, tY, spell.aoe);
        if (enList.length > 0) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            for (let en of enList) {
                if (en.buffs && KinkyDungeonGetBuffedStat(en.buffs, "SlimeProgress")) {
                    KinkyDungeonApplyBuffToEntity(en, KDEncased);
                    KinkyDungeonDamageEnemy(en, {
                        type: spell.damage,
                        damage: spell.power * count,
                        time: spell.time,
                        bind: spell.bind,
                    }, false, true, undefined, undefined, entity);
                    let point = KinkyDungeonEntityAt(tX, tY) ? KinkyDungeonGetNearbyPoint(tX, tY, true, undefined, true) : { x: tX, y: tY };
                    if (point)
                        KDMoveEntity(en, point.x, point.y, false, true);
                }
            }
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell) / 2);
        }
        KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell) / 2);
        return "Cast";
    },
    "SlimeToLatex": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let count = 0;
        for (let X = -Math.ceil(spell.aoe); X <= Math.ceil(spell.aoe); X++)
            for (let Y = -Math.ceil(spell.aoe); Y <= Math.ceil(spell.aoe); Y++) {
                if (KDistEuclidean(X, Y) <= spell.aoe) {
                    let loc = (tX + X) + "," + (tY + Y);
                    if (KinkyDungeonEffectTilesGet(loc)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(loc))) {
                            if (tile.tags && tile.tags.includes("slime")) {
                                count += 1;
                                tile.duration = 0;
                                tile.pauseDuration = 0;
                                KDCreateEffectTile(tX + X, tY + Y, {
                                    name: "Latex"
                                }, 20);
                            }
                        }
                    }
                }
            }
        if (count == 0)
            return "Fail";
        KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
        KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
        return "Cast";
    },
    "CommandDisenchant": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let enList = KDNearbyEnemies(tX, tY, spell.aoe);
        if (enList.length > 0) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            for (let en of enList) {
                if (en.Enemy.tags.construct && (!en.buffs || !en.buffs.Disenchant1)) {
                    KinkyDungeonApplyBuffToEntity(en, KDDisenchant1);
                    KinkyDungeonApplyBuffToEntity(en, KDDisenchant2);
                    KinkyDungeonDamageEnemy(en, {
                        type: "cold",
                        damage: spell.power,
                        time: 0,
                        bind: 0,
                    }, false, true, undefined, undefined, entity);
                }
            }
            cast = true;
        }
        if (AOECondition(tX, tY, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, spell.aoe, KinkyDungeonTargetingSpell.aoetype || "")) {
            KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, KDDisenchantSelf);
            cast = true;
        }
        if (cast) {
            KinkyDungeonChangeMana(-(1 - 0.5 * Math.min(1, (enList.length - 1) / 2)) * (KinkyDungeonGetManaCost(spell)));
            return "Cast";
        }
        else
            return "Fail";
    },
    "DollConvert": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        var _a, _b;
        let enList = KDNearbyEnemies(tX, tY, spell.aoe);
        if (enList.length > 0) {
            let count = 0;
            let seen = 0;
            for (let en of enList) {
                if (!KDHelpless(en) && ((_a = en.Enemy.tags) === null || _a === void 0 ? void 0 : _a.dollmakerconvert)) {
                    en.hp = 0;
                    let e = DialogueCreateEnemy(en.x, en.y, "DollsmithDoll");
                    if (entity)
                        e.faction = KDGetFaction(entity);
                    count += 1;
                    KDCreateEffectTile(en.x, en.y, {
                        name: "Latex",
                        duration: 4,
                    }, 0);
                    if (KinkyDungeonVisionGet(en.x, en.y) > 0)
                        seen += 1;
                }
                if (count >= 3)
                    break;
            }
            if (count > 0) {
                if (KinkyDungeonVisionGet((entity === null || entity === void 0 ? void 0 : entity.x) || 0, (entity === null || entity === void 0 ? void 0 : entity.y) || 0) > 0 || seen > 0)
                    KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonSpellCast" + spell.name).replace("ENEMYNAME", TextGet("Name" + ((_b = entity === null || entity === void 0 ? void 0 : entity.Enemy) === null || _b === void 0 ? void 0 : _b.name))), "#ff4488", 2);
                return "Cast";
            }
        }
        return "Fail";
    },
    "CommandVibrate": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        if (!KDGameData.CurrentVibration && AOECondition(tX, tY, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, spell.aoe, KinkyDungeonTargetingSpell.aoetype || "")
            && (KinkyDungeonPlayerTags.get("ItemVulvaFull") || KinkyDungeonPlayerTags.get("ItemButtFull") || KinkyDungeonPlayerTags.get("ItemVulvaPiercingsFull"))) {
            let vibes = [];
            if (KinkyDungeonPlayerTags.get("ItemVulvaFull"))
                vibes.push("ItemVulva");
            if (KinkyDungeonPlayerTags.get("ItemButtFull"))
                vibes.push("ItemButt");
            if (KinkyDungeonPlayerTags.get("ItemVulvaPiercingsFull"))
                vibes.push("ItemVulvaPiercings");
            KinkyDungeonStartVibration(KinkyDungeonGetRestraintItem(vibes[Math.floor(KDRandom() * vibes.length)]).name, "tease", vibes, 0.5, 30, undefined, undefined, undefined, undefined, true);
            cast = true;
        }
        cast = cast || KDCastSpellToEnemies((en) => {
            if (en.Enemy.bound && KDEntityBuffedStat(en, "Plug") > 0) {
                KDApplyGenBuffs(en, "Vibrate1", spell.time);
                return true;
            }
        }, tX, tY, spell);
        if (cast) {
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else
            return "Fail";
    },
    "CommandOrgasm": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        if (!KDGameData.CurrentVibration && AOECondition(tX, tY, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, spell.aoe, KinkyDungeonTargetingSpell.aoetype || "")
            && (KinkyDungeonPlayerTags.get("ItemVulvaFull") || KinkyDungeonPlayerTags.get("ItemButtFull") || KinkyDungeonPlayerTags.get("ItemVulvaPiercingsFull"))) {
            let vibes = [];
            if (KinkyDungeonPlayerTags.get("ItemVulvaFull"))
                vibes.push("ItemVulva");
            if (KinkyDungeonPlayerTags.get("ItemButtFull"))
                vibes.push("ItemButt");
            if (KinkyDungeonPlayerTags.get("ItemVulvaPiercingsFull"))
                vibes.push("ItemVulvaPiercings");
            KinkyDungeonStartVibration(KinkyDungeonGetRestraintItem(vibes[Math.floor(KDRandom() * vibes.length)]).name, "tease", vibes, 3.0, 10, undefined, undefined, undefined, undefined, true);
            KinkyDungeonCastSpell(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonFindSpell("OrgasmStrike", true), undefined, undefined, undefined, "Player");
            cast = true;
        }
        cast = cast || KDCastSpellToEnemies((en) => {
            if (en.Enemy.bound && en.distraction > 0) {
                let dist = en.distraction / en.Enemy.maxhp;
                if (dist < 0.9)
                    dist *= 2;
                KinkyDungeonDamageEnemy(en, {
                    type: "charm",
                    damage: spell.power * Math.max(0.1, dist),
                }, true, false, spell);
                KinkyDungeonCastSpell(en.x, en.y, KinkyDungeonFindSpell("OrgasmStrike", true), undefined, undefined, undefined, "Player");
                en.distraction = 0;
                return true;
            }
        }, tX, tY, spell);
        if (cast) {
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else
            return "Fail";
    },
    "CommandSlime": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let enList = KDNearbyEnemies(tX, tY, spell.aoe);
        let count = 0;
        if (enList.length > 0) {
            count += enList.length;
            for (let en of enList) {
                if (en.boundLevel) {
                    en.boundLevel = Math.max(0, en.boundLevel - 5);
                }
                KinkyDungeonRemoveBuffsWithTag(en, ["encased", "slimed"]);
                KinkyDungeonApplyBuffToEntity(en, KDGlueResist, { duration: 10 });
            }
        }
        let tried = false;
        let playerInRange = KDistEuclidean(KinkyDungeonPlayerEntity.x - tX, KinkyDungeonPlayerEntity.y - tY) <= spell.aoe;
        if (playerInRange) {
            let active = false;
            let restraints = KinkyDungeonAllRestraint();
            for (let r of restraints) {
                if (KDRestraint(r).shrine && KDRestraint(r).shrine.includes("Slime")) {
                    KinkyDungeonRemoveRestraint(KDRestraint(r).Group);
                    active = true;
                    tried = true;
                }
                else if (!tried && KDRestraint(r).shrine && KDRestraint(r).shrine.includes("SlimeHard")) {
                    tried = true;
                }
            }
            if (active)
                count += 1;
        }
        if (count > 0) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else {
            if (tried && playerInRange) {
                KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCastFail" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            }
            return "Fail";
        }
    },
    "CommandRelease": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let enList = KDNearbyEnemies(tX, tY, spell.aoe);
        let count = 0;
        if (enList.length > 0) {
            count += enList.length;
            for (let en of enList) {
                if (en.boundLevel) {
                    en.boundLevel = Math.max(0, en.boundLevel - spell.power);
                }
            }
        }
        let tried = false;
        let playerInRange = KDistEuclidean(KinkyDungeonPlayerEntity.x - tX, KinkyDungeonPlayerEntity.y - tY) <= spell.aoe;
        if (playerInRange) {
            let active = false;
            let restraints = KinkyDungeonAllRestraint();
            if (restraints.length > 0)
                tried = true;
            for (let r of restraints) {
                if (!r.lock && KDGetEscapeChance(KDRestraint(r), "Remove", undefined, undefined, false, false).escapeChance > 0 && !KDGroupBlocked(KDRestraint(r).Group)) {
                    KinkyDungeonRemoveRestraint(KDRestraint(r).Group);
                    active = true;
                }
            }
            if (active)
                count += 1;
        }
        if (count > 0) {
            KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCast" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            return "Cast";
        }
        else {
            if (tried && playerInRange) {
                KinkyDungeonSendActionMessage(3, TextGet("KinkyDungeonSpellCastFail" + spell.name), "#88AAFF", 2 + (spell.channel ? spell.channel - 1 : 0));
            }
            return "Fail";
        }
    },
    "Disarm": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en) {
            let time = Math.max(1, spell.time
                - (en.Enemy.disarm ? en.Enemy.disarm : 0)
                - (en.Enemy.tags.elite ? 1 : 0)
                - (en.Enemy.tags.miniboss ? 2 : 0)
                - (en.Enemy.tags.boss ? 4 : 0));
            en.disarm = Math.max(0, time);
            return "Cast";
        }
        else
            return "Fail";
    },
    "weaponAttack": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        KinkyDungeonTargetingSpellWeapon = null;
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en) {
            KinkyDungeonLaunchAttack(en, true);
            return "Cast";
        }
        else
            return "Fail";
    },
    "weaponAttackOrSpell": (spell, data, targetX, targetY, tX, tY, entity, enemy, moveDirection, bullet, miscast, faction, cast, selfCast) => {
        KinkyDungeonTargetingSpellWeapon = null;
        let en = KinkyDungeonEnemyAt(targetX, targetY);
        if (en) {
            KinkyDungeonLaunchAttack(en, true);
            return "Cast";
        }
        else {
            return KinkyDungeonActivateWeaponSpell(true) ? "Cast" : "Fail";
        }
    }
};
let KDCommandCaptureBindings = {
    "vine": (spell, entity, faction, bullet, miscast, attacker, counter) => {
        if (entity.player) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["vineRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleVine"), "#ff0000", spell.time);
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", spell.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
        }
        else {
            if (!(entity.slow))
                entity.slow = spell.level * 5;
        }
    },
    "rope": (spell, entity, faction, bullet, miscast, attacker, counter) => {
        if (entity.player) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ropeRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleRope"), "#ff0000", spell.time);
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", spell.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
        }
        else {
            if (!(entity.slow))
                entity.bind = counter * spell.level * 3;
            else
                entity.bind = Math.max(entity.bind, counter * spell.level * 3);
            KinkyDungeonDamageEnemy(entity, {
                type: "chain",
                damage: 0,
                time: 0,
                bind: 0,
            }, false, false, undefined, undefined, attacker);
        }
    },
    "fabric": (spell, entity, faction, bullet, miscast, attacker, counter) => {
        if (entity.player) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ribbonRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleFabric"), "#ff0055", spell.time);
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", spell.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
        }
        else {
            if (!(entity.slow))
                entity.bind = counter * spell.level * 3;
            else
                entity.bind = Math.max(entity.bind, counter * spell.level * 3);
            KinkyDungeonDamageEnemy(entity, {
                type: "glue",
                damage: 0,
                time: 0,
                bind: 0,
            }, false, false, undefined, undefined, attacker);
        }
    },
    "belt": (spell, entity, faction, bullet, miscast, attacker, counter) => {
        if (entity.player) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["leatherRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleBelt"), "#ff0000", spell.time);
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", spell.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
        }
        else {
            KinkyDungeonDamageEnemy(entity, {
                type: "chain",
                damage: 0,
                time: 0,
                bind: spell.level * 2.0,
            }, false, true, undefined, undefined, attacker);
        }
    },
    "chain": (spell, entity, faction, bullet, miscast, attacker, counter) => {
        if (entity.player) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["chainRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleChain"), "#ff0000", spell.time);
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", spell.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
        }
        else {
            KinkyDungeonDamageEnemy(entity, {
                type: "crush",
                damage: spell.level * 1.5,
                time: 0,
                bind: 0,
            }, false, true, undefined, undefined, attacker);
        }
    },
};
let KDCommandBindBindings = {
    "vine": (spell, x, y, faction, bullet, miscast, attacker, counter) => {
        KinkyDungeonCastSpell(x, y, KinkyDungeonFindSpell("BindVine", true), undefined, undefined, undefined, "Player");
    },
    "rope": (spell, x, y, faction, bullet, miscast, attacker, counter) => {
        KinkyDungeonCastSpell(x, y, KinkyDungeonFindSpell("BindRope", true), undefined, undefined, undefined, "Player");
    },
    "rofabricpe": (spell, x, y, faction, bullet, miscast, attacker, counter) => {
        KinkyDungeonCastSpell(x, y, KinkyDungeonFindSpell("BindRope", true), undefined, undefined, undefined, "Player");
    },
    "chain": (spell, x, y, faction, bullet, miscast, attacker, counter) => {
        KinkyDungeonCastSpell(x, y, KinkyDungeonFindSpell("BindChain", true), undefined, undefined, undefined, "Player");
    },
    "belt": (spell, x, y, faction, bullet, miscast, attacker, counter) => {
        KinkyDungeonCastSpell(x, y, KinkyDungeonFindSpell("BindBelt", true), undefined, undefined, undefined, "Player");
    },
};
let KDCommandWord = { name: "CommandWord", tags: ["command", "binding", "utility", "defense"], sfx: "Magic", school: "Conjure", manacost: 9, components: ["Verbal"], level: 1, type: "special", special: "CommandWord", noMiscast: true,
    onhit: "", time: 25, power: 0, range: 2.8, size: 1, damage: "" };
let KinkyDungeonSpellsStart = [];
let filters = genericfilters.concat(...["buff", "bolt", "aoe", "dot", "offense", "defense", "utility"]);
let filtersExtra = [
    ["upgrade", "magic"],
    ["fire", "ice", "earth", "electric", "air", "water"],
    ["binding", "slime", "summon", "physics", "metal", "leather", "rope"],
    ["stealth", "light", "shadow", "knowledge"],
    ["will", "stamina", "mana", "damage"],
];
let KDColumnLabels = [
    ["Elements", "Conjure", "Illusion", "Other"],
    ["Verbal", "Arms", "Legs", "Passive"],
    ["Verbal", "Arms", "Legs", "Passive"],
    ["Verbal", "Arms", "Legs", "Passive"],
    ["Strength", "Dexterity", "Intelligence", "Misc"],
];
let KinkyDungeonSpellPages = [
    "Upgrade",
    "Elements",
    "Conjure",
    "Illusion",
    "Upgrades",
];
let KinkyDungeonLearnableSpells = [
    [
        ["ApprenticeFire", "ApprenticeLightning", "ApprenticeAir", "ApprenticeIce", "ApprenticeWater", "ApprenticeEarth"],
        ["ApprenticeRope", "ApprenticeLeather", "ApprenticeMetal", "ApprenticeLatex", "ApprenticePhysics", "ApprenticeSummon"],
        ["ApprenticeLight", "ApprenticeShadow", "ApprenticeMystery", "ApprenticeProjection", "ApprenticeKnowledge"],
        ["DistractionCast"],
    ],
    [
        ["Firecracker", "Incinerate", "Gust", "Freeze", "FlashFreeze", "Hailstorm", "IceBreath", "Tremor", "Earthquake", "Shield", "GreaterShield", "IronBlood", "Electrify", "Thunderstorm", "StaticSphere", "Rainstorm"],
        ["Firebolt", "Fireball", "WindBlast", "Icebolt", "Snowball", "IceOrb", "Icicles", "IceLance", "StoneSkin", "Shock", "Crackle", "LightningBolt", "WaterBall", "TidalBall"],
        ["Ignite", "Fissure", "Sleet", "BoulderLaunch", "BigBoulderLaunch", "Earthform", "EarthformRing", "EarthformMound", "EarthformLine", "BoulderKick", "Volcanism", "FlameRune", "FreezeRune", "LightningRune",],
        ["FlameBlade", "Burning", "TemperaturePlay", "Strength", "Shatter", "IcePrison", "LightningRod"],
    ],
    [
        ["CommandWord", "CommandDisenchant", "CommandRelease", "CommandCapture", "CommandBind", "CommandVibrate", "CommandOrgasm", "ZoneOfExcitement", "Lockdown", "Chastity", "ZoneOfPurity", "Heal", "Heal2", "Bomb", "RopeBoltLaunch", "RopeStrike", "Leap", "Blink", "CommandSlime", "Spread", "Awaken", "Animate", "AnimateLarge", "AnimatePuppet", "Coalesce", "FireElemental", "AirMote"],
        ["TickleCloud", "FeatherCloud", "ChainBolt", "SteelRainPlug", "SteelRainBurst", "DisplayStand", "SummonGag", "SummonBlindfold", "SummonCuffs", "SummonLeatherCuffs", "SummonArmbinder", "SummonStraitjacket", "SummonLegbinder", "SummonHarness", "Petsuit", "SlimeBall", "ElasticGrip", "WaterMote"],
        ["Snare", "Wall", "SlimeSplash", "Slime", "SlimeEruption", "SlimeWall", "SlimeWallVert", "LatexWallVert", "SlimeWallHoriz", "LatexWallHoriz", "LatexWall", "SlimeToLatex", "StormCrystal", "Ally", "EarthMote", "Golem"],
        ["Frustration", "LeatherBurst", "OneWithSlime", "SlimeWalk", "SlimeMimic", "Engulf", "FloatingWeapon"],
    ],
    [
        ["Flash", "GreaterFlash", "FocusedFlash", "ShadowWarrior", "Shroud", "Invisibility"],
        ["ShadowBlade", "ShadowSlash", "Dagger", "TrueSteel", "Ring", "Light", "Corona"],
        ["Evasion", "Camo", "Decoy"],
        ["Analyze", "TrueSight", "EnemySense"],
    ],
    [
        ["IronWill", "SteadfastGuard", "WillStruggle"],
        ["Athlete", "Vault", "Sneaky", "Evasive1", "Evasive2", "Evasive3"],
        ["SummonUp1", "SummonUp2", "StaffUser1", "StaffUser2", "StaffUser3"],
        ["CriticalStrike"],
    ],
];
let KinkyDungeonSpellList = {
    "Elements": [
        { goToPage: 1, name: "ApprenticeFire", tags: ["magic"], autoLearn: ["Firebolt"], hideLearned: true, hideUnlearnable: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 1, name: "ApprenticeWater", tags: ["magic"], autoLearn: ["WaterBall"], hideLearned: true, hideUnlearnable: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 1, name: "ApprenticeEarth", tags: ["magic"], autoLearn: ["StoneSkin"], hideLearned: true, hideUnlearnable: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 1, name: "ApprenticeAir", tags: ["magic"], autoLearn: ["WindBlast"], hideLearned: true, hideUnlearnable: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 1, name: "ApprenticeLightning", tags: ["magic"], autoLearn: ["Electrify"], hideLearned: true, hideUnlearnable: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 1, name: "ApprenticeIce", tags: ["magic"], autoLearn: ["Freeze"], hideLearned: true, hideUnlearnable: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "Earthform", tags: ["earth", "utility", "summon"], hide: true, autoLearn: ["EarthformRing", "EarthformMound", "EarthformLine"], prerequisite: "ApprenticeEarth", hideLearned: true, school: "Elements", manacost: 0, spellPointCost: 1, components: [], level: 1, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "BoulderKick", tags: ["earth", "offense", "utility"], sfx: "HeavySwing", school: "Elements", prerequisite: "Earthform", manacost: 1, components: [], level: 1, type: "special", special: "BoulderKick", noMiscast: true,
            onhit: "", power: 4.0, range: 1.5, size: 1, damage: "" },
        { name: "Volcanism", tags: ["earth", "fire", "offense"], sfx: "FireSpell", school: "Elements", prerequisite: "Earthform", manacost: 6, components: [], level: 1, type: "special", special: "Volcanism", noMiscast: true,
            filterTags: ["summonedRock"], onhit: "", power: 6.0, range: 5.99, aoe: 2.5, size: 1, damage: "" },
        { name: "EarthformRing", secret: true, tags: ["earth", "utility", "summon"], noSprite: true, noise: 6, minRange: 0, landsfx: "Bones", school: "Elements", hideUnlearnable: true, manacost: 4, components: ["Legs"], prerequisite: ["Earthform"],
            level: 1, type: "hit", onhit: "summon", summon: [{ name: "EarthenMonolith", faction: "Rock", count: 30, minRange: 2.5, time: 9999, bound: true }], power: 0, time: 9999, delay: 1, range: 2.5, size: 1, aoe: 3.99, lifetime: 1, damage: "inert",
            effectTileDurationMod: 40, effectTile: {
                name: "Cracked",
                duration: 100,
            }, effectTileDensity: 0.3 },
        { name: "EarthformMound", secret: true, tags: ["earth", "utility", "summon"], noSprite: true, noise: 6, minRange: 0, landsfx: "Bones", school: "Elements", hideUnlearnable: true, manacost: 3, components: ["Legs"], prerequisite: ["Earthform"],
            level: 1, type: "hit", onhit: "summon", summon: [{ name: "EarthenMonolith", count: 9, faction: "Rock", time: 9999, bound: true }], power: 0, time: 9999, delay: 1, range: 4, size: 1, aoe: 1.5, lifetime: 1, damage: "inert",
            effectTileDurationMod: 40, effectTile: {
                name: "Cracked",
                duration: 100,
            } },
        { name: "EarthformLine", secret: true, tags: ["earth", "utility", "summon"], noSprite: true, noise: 6, sfx: "Bones", school: "Elements", hideUnlearnable: true, manacost: 2, components: ["Legs"], level: 1, type: "bolt", prerequisite: ["Earthform"],
            piercing: true, projectileTargeting: true, castRange: 3, nonVolatile: true, onhit: "", power: 3, delay: 0, range: 4.99, speed: 7, size: 1, damage: "inert",
            trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "cast", trailChance: 1.0, trailOnSelf: true,
            trailcast: { spell: "EarthformSingle", target: "onhit", directional: true, offset: false },
            effectTileDurationModTrail: 40, effectTileTrail: {
                name: "Cracked",
                duration: 100,
            },
        },
        { name: "DistractionCast", tags: ["will", "defense"], school: "Elements", manacost: 0, components: [], prerequisite: "Null", hideUnlearnable: true, level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "DistractionCast", trigger: "calcMiscast" },
                { type: "DistractionCast", trigger: "tick" },
                { type: "DistractionCast", trigger: "playerCast" },
            ] },
        { name: "SPUp1", school: "Any", hide: true, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "WPUp1", school: "Any", hide: true, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "TemperaturePlay", tags: ["fire", "ice", "offense"], prerequisite: ["ApprenticeIce", "ApprenticeFire"], school: "Elements", spellPointCost: 1, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "TemperaturePlay", trigger: "beforeDamageEnemy", power: 0.3 },
            ] },
        { name: "IronWill", tags: ["will", "defense"], school: "Elements", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "IronWill", trigger: "calcMaxStats", power: 0.4 },
            ] },
        { name: "SteadfastGuard", tags: ["will", "defense"], school: "Elements", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "SteadfastGuard", trigger: "calcMaxStats", mult: 0.5, power: 5, },
            ] },
        { name: "WillStruggle", tags: ["will", "utility"], school: "Elements", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "WillStruggle", mult: 0.01, power: 5, StruggleType: "Struggle", trigger: "beforeStruggleCalc", msg: "KinkyDungeonSpellWillStruggleMsg" },
            ] },
        { name: "StaffUser1", tags: ["utility"], school: "Elements", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "StaffUser1", trigger: "afterCalcMana", power: 0.8 },
            ] },
        { name: "StaffUser2", tags: ["utility"], prerequisite: "StaffUser1", school: "Elements", manacost: 0, components: [], level: 2, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0.5, damage: "inert", events: [
                { type: "IncreaseManaPool", trigger: "calcMaxStats", power: 10 },
            ] },
        { name: "ManaPoolUp", tags: ["utility"], hideUnlearnable: true, school: "Elements", manacost: 0, components: [], level: 2, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0.5, damage: "inert", events: [
                { type: "IncreaseManaPool", trigger: "calcMaxStats", power: 10 },
            ] },
        { name: "StaffUser3", tags: ["utility"], prerequisite: "StaffUser2", school: "Elements", manacost: 0, components: [], level: 3, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "StaffUser3", trigger: "beforeMultMana", power: 0.75 },
            ] },
        { name: "Burning", tags: ["fire", "offense"], prerequisite: "ApprenticeFire", school: "Elements", spellPointCost: 2, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "Burning", trigger: "beforeDamageEnemy", damage: "fire" },
            ] },
        { name: "IcePrison", tags: ["ice", "offense"], prerequisite: "ApprenticeIce", school: "Elements", spellPointCost: 1, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "IcePrison", trigger: "afterDamageEnemy" },
            ] },
        { name: "LightningRod", tags: ["electric", "air", "defense", "utility"], prerequisite: "ApprenticeLightning", school: "Elements", spellPointCost: 1, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "LightningRod", trigger: "playerCast", power: 3.0 },
            ] },
        { name: "Incinerate", prerequisite: "Firecracker", tags: ["fire", "aoe", "dot", "offense", "denial"], noUniqueHits: true, noise: 3, landsfx: "FireSpell", school: "Elements", manacost: 8,
            upcastFrom: "Firecracker", upcastLevel: 1, hitSpin: 1,
            components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", delay: 1, power: 2.5, range: 2.5, size: 3, aoe: 1.5, lifetime: 6, damage: "fire", playerEffect: { name: "Damage" },
            effectTileDurationMod: 12, effectTile: {
                name: "Ember",
                duration: -6,
            }
        },
        { name: "Tremor", prerequisite: "ApprenticeEarth", tags: ["earth", "offense", "utility"], sfx: "Telekinesis", school: "Elements", manacost: 2, components: ["Verbal"], level: 1,
            type: "hit", onhit: "instant", evadeable: true, time: 8, power: 2, range: 3.99, size: 3, lifetime: 1, aoe: 1.5, damage: "crush",
            events: [{ trigger: "beforeDamageEnemy", type: "MakeVulnerable", time: 8 }],
            effectTileDurationMod: 40, effectTile: {
                name: "Cracked",
                duration: 100,
            }, effectTileDensity: 0.5,
        },
        { name: "Earthquake", prerequisite: "Tremor", landsfx: "Telekinesis", school: "Elements", manacost: 9, components: ["Verbal"], level: 1, type: "inert", onhit: "cast",
            upcastFrom: "Tremor", upcastLevel: 2,
            dot: true, time: 4, delay: 6, range: 2.99, size: 5, aoe: 1.5, lifetime: 1, power: 1, damage: "inert", noEnemyCollision: true, noTerrainHit: true,
            spellcasthit: { spell: "Tremor", target: "onhit", chance: 1.0, countPerCast: 2, directional: false, offset: false }, channel: 7 },
        { name: "Firecracker", prerequisite: "ApprenticeFire", landsfx: "Lightning", tags: ["fire", "aoe", "offense"], noUniqueHits: true, noise: 7, sfx: "FireSpell", school: "Elements", manacost: 4,
            components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", delay: 1, power: 3.5, range: 3.99, size: 3, aoe: 1, lifetime: 1, damage: "fire", playerEffect: { name: "Damage" },
            effectTileDurationMod: 8, effectTile: {
                name: "Ember",
                duration: -4,
            }
        },
        { name: "Hailstorm", color: "#92e8c0", prerequisite: "ApprenticeIce", tags: ["ice", "aoe", "dot", "offense", "utility", "denial"], noUniqueHits: true, noise: 3, sfx: "FireSpell", school: "Elements", manacost: 7,
            components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", delay: 1, power: 1.0, time: 2, range: 2.5, size: 3, aoe: 1.5, lifetime: 8, damage: "frost", playerEffect: { name: "Damage" },
            effectTileDurationMod: 12, effectTile: {
                name: "Ice",
                duration: -6,
            }
        },
        { name: "Rainstorm", prerequisite: "ApprenticeWater", tags: ["water", "aoe", "dot", "offense", "utility", "denial"], noUniqueHits: true, noise: 3, sfx: "FireSpell", school: "Elements", manacost: 4.5,
            components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", delay: 3, power: 3.5, time: 2, range: 2.5, size: 3, aoe: 1.5, lifetime: 1, damage: "acid",
            effectTileDurationMod: 8, effectTile: {
                name: "Water",
                duration: 14,
            }
        },
        { name: "Freeze", color: "#92e8c0", tags: ["ice", "utility", "offense"], prerequisite: "ApprenticeIce", sfx: "Freeze", school: "Elements", manacost: 3, components: ["Verbal"], noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, time: 6, power: 0, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "ice" },
        { name: "FlashFreeze", color: "#92e8c0", tags: ["ice", "utility", "offense", "aoe"], prerequisite: "Freeze", sfx: "Freeze", school: "Elements", manacost: 5, components: ["Verbal"],
            level: 2, type: "hit", onhit: "instant", evadeable: false, power: 2.0, range: 2.99, size: 3, lifetime: 1, aoe: 1.5, damage: "ice",
            events: [{ type: "ElementalOnDrench", trigger: "bulletHitEnemy", damage: "ice", time: 8, power: 0.0 },] },
        { name: "Sleet", color: "#92e8c0", tags: ["ice", "aoe", "dot", "offense", "denial"], prerequisite: "ApprenticeIce", effectTileDurationMod: 10, effectTile: {
                name: "Ice",
                duration: 20,
            }, hitSpin: 0.5, bulletSpin: 0.25, noUniqueHits: true, noise: 8, sfx: "FireSpell", school: "Elements", manacost: 10, components: ["Legs"], level: 1, type: "inert", onhit: "aoe", delay: 1, power: 1, range: 4.5, size: 5, aoe: 2.9, lifetime: 15, time: 2, damage: "frost" },
        { name: "WindBlast", tags: ["air", "bolt", "offense", "utility"],
            prerequisite: "ApprenticeAir", sfx: "FireSpell", school: "Elements", manacost: 2.5, components: ["Arms"], level: 1, type: "bolt",
            projectileTargeting: true, onhit: "", power: 1.0, time: 2, delay: 0, range: 2.99, damage: "stun", speed: 3, hitSpin: 1, bulletSpin: 1,
            pierceEnemies: true,
            shotgunCount: 3, shotgunDistance: 4, shotgunSpread: 3, shotgunSpeedBonus: 1,
            events: [{ type: "Knockback", trigger: "bulletHitEnemy", power: 1.0, dist: 1.0 },] },
        { name: "Gust", tags: ["air", "bolt", "offense", "utility"],
            prerequisite: "ApprenticeAir", sfx: "FireSpell", school: "Elements", manacost: 4.5, components: ["Verbal"], level: 1, type: "bolt",
            projectileTargeting: true, onhit: "", power: 1.5, delay: 0, range: 7.99, damage: "stun", speed: 1, hitSpin: 1, bulletSpin: 1,
            pierceEnemies: true,
            shotgunCount: 3, shotgunDistance: 8, shotgunSpread: .25, shotgunSpeedBonus: 2,
            events: [{ type: "Knockback", trigger: "bulletHitEnemy", power: 0.8, dist: 1.0 },] },
        { name: "Firebolt", tags: ["fire", "bolt", "offense"], prerequisite: "ApprenticeFire", sfx: "FireSpell", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt",
            bulletColor: 0xb83716, bulletLight: 4,
            hitColor: 0xe64539, hitLight: 6,
            projectileTargeting: true, onhit: "", power: 4.0, delay: 0, range: 50, damage: "fire", speed: 3, playerEffect: { name: "Damage" },
            effectTileDurationMod: 3, effectTile: {
                name: "Ember",
                duration: 3,
            } },
        { name: "Fireball", prerequisite: "Firebolt", tags: ["fire", "bolt", "aoe", "offense"], noise: 3, sfx: "FireSpell", school: "Elements", manacost: 7, components: ["Arms"], level: 1,
            upcastFrom: "Firebolt", upcastLevel: 2,
            bulletColor: 0xb83716, bulletLight: 5.5,
            hitColor: 0xe64539, hitLight: 8,
            landsfx: "Lightning",
            type: "bolt", projectileTargeting: true, onhit: "aoe", power: 6, delay: 0, range: 50, aoe: 1.5, size: 3, lifetime: 1, damage: "fire", speed: 2, playerEffect: { name: "Damage" },
            effectTileDurationModTrail: 8, effectTileTrail: {
                name: "Smoke",
                duration: 2,
            },
            effectTileDurationMod: 6, effectTile: {
                name: "Ember",
                duration: 4,
            } },
        { name: "Icebolt", tags: ["ice", "bolt", "offense"], prerequisite: "ApprenticeIce", sfx: "MagicSlash", hitsfx: "Freeze", school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt",
            bulletColor: 0x92e4e8, bulletLight: 3,
            hitColor: 0x92e4e8, hitLight: 5,
            effectTileDurationMod: 10, effectTile: {
                name: "Ice",
                duration: 20,
            },
            projectileTargeting: true, onhit: "", time: 4, power: 3.5, delay: 0, range: 50, damage: "frost", speed: 3, playerEffect: { name: "Chill", damage: "ice", power: 3, time: 3 },
            events: [{ type: "ElementalOnSlowOrBindOrDrench", trigger: "bulletHitEnemy", damage: "ice", time: 4, power: 0 },] },
        { name: "Snowball", color: "#92e8c0", tags: ["ice", "bolt", "offense"], prerequisite: "ApprenticeIce", sfx: "Freeze", hitsfx: "LesserFreeze", school: "Elements", manacost: 5, components: ["Arms"], level: 1, type: "bolt",
            bulletColor: 0x92e4e8, bulletLight: 6,
            projectileTargeting: true, onhit: "lingering", time: 3, power: 2.0, delay: 0, lifetime: 6, lifetimeHitBonus: 2, range: 50, aoe: 2.5, damage: "frost", speed: 3, playerEffect: { name: "Damage" },
            effectTileDurationMod: 2, effectTile: {
                name: "Ice",
                duration: 6,
            }, effectTileDensity: 0.5 },
        { name: "IceLance", color: "#92e8c0", tags: ["ice", "bolt", "offense", "aoe"], prerequisite: "Icicles", sfx: "Lightning", hitsfx: "Freeze", school: "Elements", pierceEnemies: true,
            upcastFrom: "Icicles", upcastLevel: 2,
            manacost: 7, components: ["Arms"], level: 1, type: "bolt",
            bulletColor: 0x92e4e8, bulletLight: 4,
            hitColor: 0x92e4e8, hitLight: 7,
            effectTileDurationModTrail: 10, effectTileTrail: {
                name: "Ice",
                duration: 20,
            },
            projectileTargeting: true, onhit: "", time: 3, power: 10, delay: 0, range: 50, damage: "frost", speed: 6, playerEffect: { name: "Damage" },
            events: [{ type: "ElementalOnSlowOrBindOrDrench", trigger: "bulletHitEnemy", damage: "ice", time: 3, power: 0 },] },
        { name: "IceOrb", color: "#92e8c0", tags: ["ice", "bolt", "offense", "utility", "aoe"], prerequisite: "Snowball", sfx: "LesserFreeze", hitsfx: "LesserFreeze", school: "Elements",
            upcastFrom: "Snowball", upcastLevel: 1,
            manacost: 4, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 2, pierceEnemies: true, delay: 0, range: 50, damage: "frost", speed: 2,
            bulletColor: 0x92e4e8, bulletLight: 5,
            effectTileDurationModTrail: 4, effectTileTrailAoE: 1.5, noTrailOnPlayer: true, effectTileTrail: {
                name: "Ice",
                duration: 10,
            } },
        { name: "Icicles", tags: ["ice", "bolt", "offense"], prerequisite: "Icebolt", noise: 3, sfx: "MagicSlash", school: "Elements", manacost: 6, components: ["Arms"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 3, power: 3, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false, castDuringDelay: true, noCastOnHit: true,
            spellcast: { spell: "Icicle", target: "target", directional: true, offset: false }, channel: 3 },
        { name: "BoulderLaunch", tags: ["earth", "bolt", "offense"], prerequisite: "ApprenticeEarth", sfx: "Telekinesis", school: "Elements", manacost: 2, components: ["Legs"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 4, delay: 1, power: 4, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "Boulder", target: "target", directional: true, offset: false }, channel: 1 },
        { name: "BigBoulderLaunch", tags: ["earth", "bolt", "offense", "aoe"], prerequisite: "BoulderLaunch", sfx: "Telekinesis", school: "Elements",
            upcastFrom: "BoulderLaunch", upcastLevel: 2,
            manacost: 6, components: ["Legs"], projectileTargeting: true, noTargetPlayer: true, noEnemyCollision: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 8, delay: 1, power: 12, range: 50, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "BigBoulder", target: "target", directional: true, offset: false }, channel: 1 },
        { name: "Electrify", tags: ["electric", "offense"], prerequisite: "ApprenticeLightning", noise: 6,
            effectTileDurationMod: 2, effectTile: {
                name: "Sparks",
                duration: 3,
            },
            sfx: "FireSpell", landsfx: "Shock", school: "Elements", manacost: 5, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", power: 9, time: 4, delay: 1, range: 4, size: 1, aoe: 0.75, lifetime: 1, damage: "electric", playerEffect: { name: "Shock", time: 1 } },
        { name: "Shock", tags: ["electric", "bolt", "offense", "dot"], prerequisite: "ApprenticeLightning", sfx: "FireSpell",
            effectTileDurationMod: 2, effectTile: {
                name: "Sparks",
                duration: 3,
            },
            school: "Elements", manacost: 5, components: ["Arms"], noEnemyCollision: true, level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 2.5, delay: 0, range: 50, damage: "inert", speed: 1,
            events: [{ type: "CastSpellNearbyEnemy", trigger: "bulletTick", spell: "ShockStrike", aoe: 1.5 },] },
        { name: "Crackle", tags: ["electric", "offense", "aoe"], prerequisite: "Shock", noise: 6, sfx: "Shock",
            effectTileDurationModTrail: 2, effectTileTrail: {
                name: "Sparks",
                duration: 3,
            },
            school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, nonVolatile: true, onhit: "", power: 4.0, delay: 0, time: 1, range: 4, speed: 4, size: 1, damage: "electric",
            trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1.0, playerEffect: { name: "Shock", time: 1 } },
        { name: "Fissure", tags: ["fire", "denial", "dot", "aoe", "offense"], noUniqueHits: true, prerequisite: "Ignite", noise: 7, sfx: "FireSpell", school: "Elements", manacost: 8, components: ["Legs"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, nonVolatile: true, onhit: "", power: 5.5, delay: 0, range: 4, speed: 4, size: 1, damage: "fire",
            trailPower: 1.5, trailLifetime: 6, piercingTrail: true, trailDamage: "fire", trail: "lingering", trailChance: 1, playerEffect: { name: "DamageNoMsg", hitTag: "Fissure", time: 1, damage: "fire", power: 3 } },
        { name: "Shield", tags: ["shield", "defense"], prerequisite: "ApprenticeEarth", sfx: "MagicSlash", school: "Elements", manacost: 4, components: ["Verbal"], mustTarget: true, level: 1, type: "buff",
            buffs: [
                { id: "Shield", type: "SpellResist", aura: "#73efe8", duration: 50, power: 3.0, player: true, enemies: true, tags: ["defense", "damageTaken"] },
            ], onhit: "", time: 50, power: 0, range: 2, size: 1, damage: "" },
        { name: "GreaterShield", tags: ["shield", "defense", "utility"], prerequisite: "Shield", spellPointCost: 1, sfx: "MagicSlash", school: "Elements", manacost: 1, components: ["Verbal"], noTargetEnemies: true, noTargetPlayer: true, level: 1, type: "inert", block: 20, onhit: "", power: 0, delay: 5, range: 2.99, size: 1, damage: "" },
        { name: "IceBreath", tags: ["ice", "denial", "offense", "utility", "aoe"], prerequisite: "Hailstorm", sfx: "MagicSlash", hitsfx: "Freeze", school: "Elements", manacost: 8,
            upcastFrom: "Hailstorm", upcastLevel: 1,
            components: ["Verbal"], level: 1, type: "inert", onhit: "lingering", time: 1, delay: 1, range: 3, size: 3, aoe: 1.5, lifetime: 10, power: 5, lifetimeHitBonus: 5, damage: "ice" },
        { name: "LightningBolt", tags: ["electric", "aoe", "offense"], prerequisite: "Crackle", noise: 11, sfx: "Lightning",
            school: "Elements", spellPointCost: 1, manacost: 8, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, nonVolatile: true, onhit: "", power: 8.5, delay: 0, time: 2, range: 50, speed: 50, size: 1, damage: "electric",
            upcastFrom: "Crackle", upcastLevel: 2,
            trailHit: "", trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1, playerEffect: { name: "Shock", time: 3 },
            effectTileDurationModTrail: 4, effectTileDensityTrail: 0.6, effectTileTrail: {
                name: "Sparks",
                duration: 2,
            }
        },
        { name: "StoneSkin", tags: ["earth", "buff", "defense"], prerequisite: "ApprenticeEarth", sfx: "Bones", school: "Elements", manacost: 6, components: ["Arms"], mustTarget: true, level: 1, type: "buff", buffs: [{ id: "StoneSkin", aura: "#FF6A00", type: "Armor", duration: 50, power: 2.0, player: true, enemies: true, tags: ["defense", "armor"] }], onhit: "", time: 50, power: 0, range: 2, size: 1, damage: "" },
        { name: "IronBlood", tags: ["earth", "buff", "offense"], prerequisite: "ApprenticeEarth", sfx: "FireSpell", school: "Elements", manacost: 0, components: ["Verbal"], mustTarget: true, selfTargetOnly: true, level: 1, type: "buff", channel: 4,
            buffs: [
                { id: "IronBlood", aura: "#ff0000", type: "AttackStamina", duration: 99999, cancelOnReapply: true, endSleep: true, power: 1, player: true, enemies: false, tags: ["attack", "stamina"] },
                { id: "IronBlood2", type: "ManaCostMult", duration: 99999, cancelOnReapply: true, endSleep: true, power: 0.25, player: true, enemies: false, tags: ["manacost"] },
            ], onhit: "", time: 30, power: 0, range: 2, size: 1, damage: "" },
        { name: "FlameBlade", tags: ["fire", "aoe", "offense", "buff"], prerequisite: "ApprenticeFire", sfx: "FireSpell", school: "Elements", manacost: 3, components: [], level: 1, type: "passive", events: [{ type: "FlameBlade", trigger: "playerAttack" }] },
        { name: "Strength", tags: ["earth", "struggle", "buff", "utility", "offense"], prerequisite: "ApprenticeEarth", sfx: "FireSpell", school: "Elements", manacost: 1, components: [], level: 1, type: "passive", events: [
                { trigger: "beforePlayerAttack", type: "BoostDamage", prereq: "damageType", kind: "melee", power: 2 },
                { trigger: "calcDisplayDamage", type: "BoostDamage", prereq: "damageType", kind: "melee", power: 2 },
                { type: "ModifyStruggle", mult: 1.5, power: 0.2, StruggleType: "Struggle", trigger: "beforeStruggleCalc", msg: "KinkyDungeonSpellStrengthStruggle" },
            ] },
        { name: "Ignite", tags: ["fire", "aoe", "dot", "buff"], prerequisite: "ApprenticeFire", sfx: "FireSpell", school: "Elements",
            manacost: 2, spellPointCost: 1, components: ["Legs"], mustTarget: true, noTargetEnemies: true, exceptionFactions: ["Player", "Rock"], level: 1, type: "buff",
            buffs: [
                { id: "Ignite", aura: "#ff8400", type: "SpellCastConstant", duration: 6, power: 10.0, player: true, enemies: true, spell: "Ignition", tags: ["offense"] },
            ],
            onhit: "", time: 6, power: 1.5, range: 2.9, size: 1, damage: "" },
        { name: "Thunderstorm", tags: ["aoe", "utility", "offense", "electric"], prerequisite: "ApprenticeLightning", spellPointCost: 1, sfx: "Fwoosh", school: "Elements", manacost: 4, components: ["Verbal"], level: 1, type: "inert", buffs: [
                Object.assign({}, KDConduction),
            ], bulletSpin: 0.1, onhit: "", time: 8, aoe: 1.5, power: 0, delay: 8, range: 4, size: 3, damage: "" },
        { name: "StaticSphere", tags: ["electric", "metal", "summon", "aoe", "offense"], prerequisite: "Thunderstorm", sfx: "MagicSlash", school: "Elements", manacost: 8,
            upcastFrom: "Thunderstorm", upcastLevel: 2,
            components: ["Verbal"], noTargetEnemies: true, noTargetPlayer: true, level: 1, type: "hit", noSprite: true, onhit: "summon",
            summon: [{ name: "StaticSphere", count: 1, time: 12, bound: true }], power: 1.5, time: 12, delay: -1, range: 6, size: 1, aoe: 0, lifetime: 1, damage: "inert" },
        { name: "LightningRune", tags: ["electric", "offense", "defense", "utility"], prerequisite: "ApprenticeLightning", noise: 0, sfx: "Fwoosh", school: "Elements", spellPointCost: 1, manacost: 2,
            components: ["Legs"], noTargetPlayer: true, CastInWalls: false, level: 1, type: "inert",
            onhit: "aoe", time: 5, delay: 3, power: 4.5, range: 2.99, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "LightningRuneStrike", target: "onhit", directional: false, offset: false }, channel: 5 },
        { name: "FlameRune", tags: ["fire", "offense", "defense"], prerequisite: "ApprenticeFire", noise: 0, sfx: "Fwoosh", school: "Elements", spellPointCost: 1, manacost: 2,
            components: ["Legs"], noTargetPlayer: true, CastInWalls: false, level: 1, type: "inert",
            onhit: "aoe", delay: 3, power: 5.5, range: 2.99, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "FlameRuneStrike", target: "onhit", directional: false, offset: false }, channel: 5 },
        { name: "FreezeRune", tags: ["ice", "offense", "defense", "utility"], prerequisite: "ApprenticeIce", noise: 0, sfx: "Fwoosh", school: "Elements", spellPointCost: 1, manacost: 5,
            components: ["Legs"], noTargetPlayer: true, CastInWalls: false, level: 1, type: "inert",
            onhit: "aoe", time: 30, delay: 3, power: 3, range: 2.99, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "FreezeRuneStrike", target: "onhit", directional: false, offset: false }, channel: 5 },
        { name: "WaterBall", color: "#4f7db8", tags: ["water", "bolt", "offense", "utility"], prerequisite: "ApprenticeWater", sfx: "FireSpell", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "buff",
            power: 3.5, delay: 0, range: 50, damage: "acid", speed: 3, playerEffect: { name: "Drench" },
            buffs: [
                Object.assign({}, KDDrenched),
                Object.assign({}, KDDrenched2),
                Object.assign({}, KDDrenched3),
            ],
            effectTileDurationMod: 40, effectTile: {
                name: "Water",
                duration: 40,
            },
        },
        { name: "TidalBall", color: "#4f7db8", tags: ["water", "bolt", "offense", "utility"], prerequisite: "WaterBall", sfx: "FireSpell", school: "Elements", manacost: 6, components: ["Arms"], level: 1, type: "bolt", size: 3, aoe: 1.5, projectileTargeting: true, onhit: "", power: 3.5, pierceEnemies: true, delay: 0, range: 50, damage: "acid", speed: 1,
            upcastFrom: "WaterBall", upcastLevel: 1,
            effectTileDurationModTrail: 100, effectTileTrailAoE: 1.5, noTrailOnPlayer: true, effectTileTrail: {
                name: "Water",
                duration: 40,
            } },
        { name: "Shatter", tags: ["ice", "aoe", "offense"], prerequisite: "ApprenticeIce", school: "Elements", manacost: 1, components: [], power: 1.5, time: 4, level: 1, type: "passive", events: [
                { type: "Shatter", trigger: "enemyStatusEnd" },
                { type: "Shatter", trigger: "beforePlayerAttack" },
                { type: "Shatter", trigger: "kill" },
            ] },
    ],
    "Conjure": [
        { goToPage: 2, name: "ApprenticeRope", tags: ["magic"], autoLearn: ["RopeBoltLaunch"], hideLearned: true, hideUnlearnable: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 2, name: "ApprenticeMetal", tags: ["magic"], autoLearn: ["SummonCuffs"], hideLearned: true, hideUnlearnable: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 2, name: "ApprenticeLeather", tags: ["magic"], autoLearn: ["SummonGag"], hideLearned: true, hideUnlearnable: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 2, name: "ApprenticeSummon", tags: ["magic"], autoLearn: ["Ally"], hideLearned: true, hideUnlearnable: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 2, name: "ApprenticeLatex", tags: ["magic"], autoLearn: ["SlimeBall"], hideLearned: true, hideUnlearnable: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 2, name: "ApprenticePhysics", tags: ["magic"], autoLearn: ["Wall"], hideLearned: true, hideUnlearnable: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "MPUp1", hide: true, school: "Any", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "MPUp2", hide: true, school: "Any", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "MPUp3", hide: true, school: "Any", manacost: 0, components: [], level: 4, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "SummonUp1", hide: true, tags: ["upgrade"], hideLearned: true, hideUnlearnable: true, school: "Any", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "SummonUp2", hide: true, tags: ["upgrade"], hideLearned: false, hideUnlearnable: true, prerequisite: "SummonUp1", school: "Any", manacost: 0, components: [], level: 2, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "Bomb", color: "#ff0000", prerequisite: "ApprenticeSummon", tags: ["aoe", "offense"], noise: 5, sfx: "FireSpell", school: "Conjure", manacost: 5, components: ["Verbal"], level: 1,
            effectTileDurationMod: 7, hitSpin: 0.2, effectTile: {
                name: "Smoke",
                duration: -1,
            }, type: "inert", onhit: "aoe", time: 3, delay: 5, power: 10, range: 3, size: 3, aoe: 1.5, lifetime: 1, damage: "fire", playerEffect: { name: "Damage" }, channel: 1 },
        { name: "FeatherCloud", color: "#ffffff", prerequisite: "TickleCloud", tags: ["tickle", "aoe", "dot", "offense", "utility", "denial"], noUniqueHits: true, noise: 1, landsfx: "Tickle", hitsfx: "Tickle", school: "Elements", manacost: 4,
            components: ["Arms"], hitSpin: 0.7, bulletSpin: 0.4, level: 1, type: "inert", onhit: "aoe", delay: 1, power: 2.0, distract: 6.0, range: 2.5, size: 3, aoe: 1, lifetime: 3, damage: "tickle", playerEffect: { name: "Damage" },
        },
        { name: "TickleCloud", color: "#ffffff", prerequisite: "ApprenticeSummon", tags: ["tickle", "aoe", "dot", "offense", "utility", "denial"], piercing: true, noUniqueHits: true, noise: 1, landsfx: "Tickle", hitsfx: "Tickle", school: "Elements", manacost: 2,
            components: ["Arms"], hitSpin: 1, bulletSpin: 0.4, level: 1, type: "dot", onhit: "aoe", delay: 9, power: 0.5, range: 3.99, size: 1, aoe: 0.5, lifetime: 1, damage: "tickle", playerEffect: { name: "Damage" },
        },
        { name: "Snare", color: "#ff8899", prerequisite: "ApprenticeRope", tags: ["rope", "binding", "denial", "utility", "offense"], sfx: "FireSpell",
            school: "Conjure", manacost: 2, components: ["Legs"], noTargetEnemies: true, level: 1, type: "inert", onhit: "lingering", lifetime: 90, bindType: "Rope",
            time: 8, bind: 15, delay: 5, range: 1, damage: "stun", playerEffect: { name: "MagicRope", time: 3 } },
        { name: "LeatherBurst", prerequisite: "ApprenticeLeather", tags: ["buff", "offense", "binding"], sfx: "MagicSlash", school: "Conjure", manacost: 0, components: [], level: 1, passive: true, type: "",
            events: [{ type: "LeatherBurst", trigger: "playerCast", power: 3 }] },
        { name: "SummonGag", prerequisite: "ApprenticeLeather", tags: ["leather", "bolt", "binding", "burst", "gag", "utility", "offense"], components: ["Arms"], noise: 1,
            sfx: "MagicSlash", school: "Conjure", manacost: 1.5, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 2, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "GagBolt", target: "target", directional: true, randomDirectionFallback: true, alwaysRandomBuff: "LeatherBurst", aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "SummonBlindfold", prerequisite: "ApprenticeLeather", tags: ["leather", "bolt", "binding", "burst", "blindfold", "utility", "offense"], components: ["Arms"], noise: 1,
            sfx: "MagicSlash", school: "Conjure", manacost: 1.5, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 2, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "BlindfoldBolt", target: "target", directional: true, randomDirectionFallback: true, alwaysRandomBuff: "LeatherBurst", aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "SummonArmbinder", prerequisite: "SummonLeatherCuffs", tags: ["leather", "bolt", "binding", "burst", "armbinder", "utility", "offense"], components: ["Arms"], noise: 1,
            upcastFrom: "SummonLeatherCuffs", upcastLevel: 1,
            sfx: "MagicSlash", school: "Conjure", manacost: 4, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 5, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "ArmbinderBolt", target: "target", directional: true, randomDirectionFallback: true, alwaysRandomBuff: "LeatherBurst", aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "SummonLeatherCuffs", prerequisite: "ApprenticeLeather", tags: ["leather", "bolt", "binding", "burst", "cuffs", "utility", "offense"], components: ["Arms"], noise: 1,
            sfx: "MagicSlash", school: "Conjure", manacost: 2.5, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 1, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "LeatherCuffsBolt", target: "target", directional: true, randomDirectionFallback: true, alwaysRandomBuff: "LeatherBurst", aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "SummonCuffs", prerequisite: "ApprenticeMetal", tags: ["metal", "bolt", "binding", "burst", "cuffs", "utility", "offense"], components: ["Arms"], noise: 1,
            sfx: "MagicSlash", school: "Conjure", manacost: 2, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 3, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "CuffsBolt", target: "target", directional: true, randomDirectionFallback: true, alwaysRandomBuff: "LeatherBurst", aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "SummonLegbinder", prerequisite: "SummonLeatherCuffs", tags: ["leather", "bolt", "binding", "burst", "legbinder", "utility", "offense"], components: ["Arms"], noise: 1,
            sfx: "MagicSlash", school: "Conjure", manacost: 4, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 4, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "LegbinderBolt", target: "target", directional: true, randomDirectionFallback: true, alwaysRandomBuff: "LeatherBurst", aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "SummonHarness", prerequisite: "ApprenticeLeather", tags: ["leather", "bolt", "binding", "burst", "harness", "utility", "offense"], components: ["Arms"], noise: 1,
            sfx: "MagicSlash", school: "Conjure", manacost: 3, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 5, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "HarnessBolt", target: "target", directional: true, randomDirectionFallback: true, alwaysRandomBuff: "LeatherBurst", aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "SummonStraitjacket", prerequisite: "SummonLeatherCuffs", tags: ["leather", "bolt", "binding", "burst", "straitjacket", "utility", "offense"], components: ["Arms"], noise: 1,
            upcastFrom: "SummonLeatherCuffs", upcastLevel: 2,
            sfx: "MagicSlash", school: "Conjure", manacost: 7, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 12, range: 6, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "StraitjacketBolt", target: "target", directional: true, randomDirectionFallback: true, aimAtTarget: true, noTargetMoveDir: true, offset: false } },
        { name: "Petsuit", prerequisite: "SummonHarness", tags: ["leather", "summon", "utility", "petsuit"], sfx: "Magic", school: "Conjure", manacost: 1, components: [], level: 1,
            type: "special", special: "Petsuit",
            onhit: "", time: 0, power: 0.0, range: 2.99, size: 1, aoe: 0.5, damage: "glue" },
        { name: "DisplayStand", prerequisite: "ApprenticeMetal", tags: ["metal", "summon", "utility", "petsuit"], sfx: "Magic", school: "Conjure", manacost: 1, components: [], level: 1,
            type: "special", special: "DisplayStand",
            onhit: "", time: 0, power: 0.0, range: 2.99, size: 1, aoe: 0.5, damage: "glue" },
        { name: "RopeBoltLaunch", tags: ["rope", "bolt", "binding", "offense"], prerequisite: "ApprenticeRope", sfx: "MagicSlash", school: "Conjure",
            manacost: 3, components: ["Verbal"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 3, power: 1, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false, castDuringDelay: true, noCastOnHit: true,
            spellcast: { spell: "RopeBolt", target: "target", directional: true, offset: false } },
        { name: "RopeStrike", prerequisite: "RopeBoltLaunch", tags: ["rope", "binding", "aoe", "offense"], sfx: "MagicSlash", effectTileDurationMod: 10, effectTile: {
                name: "Ropes",
                duration: 20,
            }, bulletSpin: 1, school: "Conjure", manacost: 3.5, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", delay: 1, power: 3, bind: 4, time: 6, range: 3.5, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", bindType: "Rope", playerEffect: { name: "MagicRope", time: 4 } },
        { name: "Slime", color: "#ff00ff", prerequisite: "SlimeSplash", tags: ["latex", "slime", "aoe", "offense"], landsfx: "MagicSlash", school: "Conjure", manacost: 4, components: ["Legs"], level: 1, type: "inert",
            upcastFrom: "SlimeSplash", upcastLevel: 1,
            effectTileDurationMod: 12, effectTile: {
                name: "Slime",
                duration: 8,
            },
            onhit: "lingering", time: 4, delay: 1, range: 3.5, size: 3, aoe: 1.5, lifetime: 3, power: 4, damage: "glue", playerEffect: { name: "SlimeTrap", time: 3 } },
        { name: "SlimeSplash", color: "#ff00ff", prerequisite: "ApprenticeLatex", tags: ["latex", "slime", "aoe", "offense"], landsfx: "MagicSlash", school: "Conjure", manacost: 1.4, components: ["Legs"], level: 1, type: "inert",
            effectTileDurationMod: 4, effectTile: {
                name: "Slime",
                duration: 6,
            },
            onhit: "lingering", time: 0, delay: 1, range: 2.5, size: 1, aoe: 1.01, lifetime: 1, power: 1, damage: "glue", playerEffect: { name: "SlimeTrap", time: 3 } },
        { name: "SlimeEruption", color: "#ff00ff", prerequisite: "Slime", tags: ["latex", "slime", "aoe", "denial", "offense"], landsfx: "MagicSlash", school: "Conjure", manacost: 7, components: ["Legs"], level: 1, type: "inert",
            upcastFrom: "SlimeSplash", upcastLevel: 2,
            effectTileDurationMod: 16, effectTile: {
                name: "Slime",
                duration: 8,
            },
            onhit: "lingering", time: 4, delay: 1, range: 4, size: 3, aoe: 2.99, lifetime: 8, power: 5, lifetimeHitBonus: 4, damage: "glue", playerEffect: { name: "SlimeTrap", time: 3 } },
        { name: "ChainBolt", color: "#ffffff", prerequisite: "ApprenticeMetal", tags: ["metal", "binding", "bolt", "offense"], noise: 5,
            sfx: "FireSpell", school: "Conjure", manacost: 2, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", time: 0, power: 2.5, delay: 0, range: 50, damage: "chain", speed: 3, bindType: "Metal",
            playerEffect: { name: "SingleChain", time: 1 }, effectTileDurationMod: 10, effectTile: {
                name: "Chains",
                duration: 20,
            },
            events: [
                { type: "ElementalIfHalfBound", trigger: "bulletHitEnemy", damage: "crush", power: 5.0, time: 4 },
            ]
        },
        { name: "SlimeBall", color: "#ff00ff", prerequisite: "ApprenticeLatex", tags: ["latex", "slime", "denial", "bolt", "offense"], noise: 1, sfx: "FireSpell", school: "Conjure", manacost: 4, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", time: 3, power: 4, delay: 0, range: 50, damage: "glue", speed: 2,
            trailPower: 4, trailLifetime: 10, trailTime: 3, trailDamage: "glue", trail: "lingering", trailChance: 1.0,
            effectTileDurationModTrail: 4, effectTileTrail: {
                name: "Slime",
                duration: 4,
            } },
        { name: "Leap", prerequisite: "ApprenticePhysics", tags: ["physics", "utility", "defense"], sfx: "Teleport", school: "Conjure", spellPointCost: 2,
            manacost: 3, components: ["Verbal"], requireLOS: true, noTargetEnemies: true, level: 1, type: "hit", onhit: "teleport", delay: 1, lifetime: 1, range: 3, damage: "" },
        { name: "Blink", prerequisite: "Leap", tags: ["physics", "utility", "defense"], sfx: "Teleport", school: "Conjure", upcastFrom: "Leap", upcastLevel: 2,
            manacost: 6, components: ["Verbal"], noTargetEnemies: true, level: 1, type: "hit", onhit: "teleport", delay: 1, lifetime: 1, range: 5.99, damage: "" },
        { name: "Wall", prerequisite: "ApprenticePhysics", tags: ["summon", "utility", "defense", "physics"], sfx: "MagicSlash", school: "Conjure", manacost: 3, components: ["Legs"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "Wall", count: 1, time: 10, bound: true }], power: 0, time: 10, delay: -1, range: 6, size: 1, aoe: 0.5, lifetime: 1, damage: "fire" },
        { name: "Ally", prerequisite: "ApprenticeSummon", tags: ["summon", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 8, components: ["Legs"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 1, type: "hit", onhit: "summon", noSprite: true, summon: [{ name: "Ally", count: 1, time: 9999, bound: true }], power: 0, time: 9999, delay: -1, range: 2.9, size: 1, aoe: 0.5, lifetime: 1, damage: "fire" },
        { name: "FireElemental", prerequisite: "ApprenticeSummon", tags: ["fire", "summon", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 15, components: ["Verbal"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "FireElemental", count: 1, time: 9999, bound: true }], power: 0, time: 9999, delay: -1, range: 3.5, size: 1, aoe: 0.5, lifetime: 1, damage: "inert" },
        { name: "WaterMote", prerequisite: "ApprenticeSummon", tags: ["water", "summon", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 15, components: ["Arms"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "WaterMote", count: 1, time: 9999, bound: true }], power: 0, time: 9999, delay: -1, range: 3.5, size: 1, aoe: 0.5, lifetime: 1, damage: "inert" },
        { name: "AirMote", prerequisite: "ApprenticeSummon", tags: ["air", "summon", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 15, components: ["Verbal"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "AirMote", count: 1, time: 9999, bound: true }], power: 0, time: 9999, delay: -1, range: 3.5, size: 1, aoe: 0.5, lifetime: 1, damage: "inert" },
        { name: "EarthMote", prerequisite: "ApprenticeSummon", tags: ["earth", "summon", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 15, components: ["Legs"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "EarthMote", count: 1, time: 9999, bound: true }], power: 0, time: 9999, delay: -1, range: 3.5, size: 1, aoe: 0.5, lifetime: 1, damage: "inert" },
        { name: "Golem", prerequisite: "Ally", tags: ["summon", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 20, components: ["Legs"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 3, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "Golem", count: 1, time: 9999, bound: true }], power: 0, time: 9999, delay: -1, range: 2.5, size: 1, aoe: 0.5, lifetime: 1, damage: "fire" },
        { name: "StormCrystal", prerequisite: "ApprenticeSummon", tags: ["summon", "denial", "offense"], noise: 7, sfx: "MagicSlash", school: "Conjure", manacost: 10, components: ["Legs"], noTargetEnemies: true, noTargetPlayer: true, piercing: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "StormCrystal", count: 1, time: 9999, bound: true }], power: 0, time: 30, delay: -1, range: 2.5, size: 1, aoe: 0.5, lifetime: 1, damage: "fire" },
        { noAggro: true, name: "Heal", prerequisite: "ApprenticeSummon", bulletSpin: 0.1, hitSpin: 0.4, noise: 3, sfx: "FireSpell", school: "Conjure", manacost: 4, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", delay: 1, power: 1.5, range: 4.5, size: 5, aoe: 2.9, lifetime: 4, time: 2, damage: "heal", channel: 4 },
        { noAggro: true, buff: true, heal: true, name: "Heal2", prerequisite: "ApprenticeSummon", sfx: "MagicSlash", school: "Conjure", manacost: 3, components: ["Verbal"], noTargetPlayer: true, mustTarget: true, level: 1, type: "hit",
            onhit: "heal", time: 2, lifetime: 1, delay: 1, power: 4.5, aoe: 0.9, range: 7, size: 1, damage: "inert" },
        { name: "FloatingWeapon", prerequisite: "ApprenticePhysics", tags: ["buff", "offense", "physics"], sfx: "MagicSlash", school: "Conjure", manacost: 2, components: [], level: 3, type: "passive",
            events: [{ type: "FloatingWeapon", trigger: "playerAttack" }, { type: "HandsFree", trigger: "getWeapon" }, { type: "HandsFree", trigger: "calcDamage" }] },
        { name: "Lockdown", prerequisite: "ApprenticeMetal", tags: ["metal", "lock", "binding", "utility", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 4.5, components: ["Verbal"], mustTarget: true, level: 1,
            type: "special", special: "Lockdown",
            onhit: "", time: 8, power: 0, range: 1.5, size: 1, damage: "" },
        { name: "Chastity", prerequisite: "Lockdown", tags: ["metal", "binding", "utility"], sfx: "MagicSlash", school: "Conjure", manacost: 3.5, components: ["Verbal"], mustTarget: true, level: 1,
            type: "special", special: "Chastity",
            onhit: "", time: 8, power: 3.5, range: 1.5, size: 1, damage: "" },
        { name: "ZoneOfPurity", color: "#ffff00", prerequisite: "Chastity", tags: ["metal", "binding", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 7, components: ["Verbal"], level: 1, type: "inert",
            onhit: "aoe", power: 0, delay: 40, range: 4.5, size: 3, lifetime: 1, aoe: 2.5, damage: "charm",
            events: [{ trigger: "bulletTick", type: "ZoneOfPurity", aoe: 2.5, power: 0.5 }]
        },
        { name: "ZoneOfExcitement", color: "#ff8888", prerequisite: "CommandVibrate", tags: ["binding", "utility"], sfx: "MagicSlash", school: "Conjure", manacost: 3.5, components: ["Verbal"], level: 1, type: "inert",
            onhit: "aoe", power: 0, delay: 30, range: 4.5, size: 3, lifetime: 1, aoe: 1.99, damage: "charm",
            events: [{ trigger: "bulletTick", type: "ZoneOfExcitement", aoe: 1.99, power: 0.5 }]
        },
        { name: "Frustration", tags: ["metal", "offense", "utility"], prerequisite: "Chastity", sfx: "FireSpell", school: "Conjure", manacost: 0, components: [], level: 1, type: "passive", events: [
                { type: "Frustration", trigger: "tickAfter" }
            ] },
        { name: "CommandCapture", prerequisite: "CommandDisenchant", tags: ["command", "binding", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 4.5, components: ["Verbal"], mustTarget: true, level: 1,
            type: "special", special: "CommandCapture",
            onhit: "", time: 0, power: 2.5, range: 3.5, bind: 5, size: 1, aoe: 1.5, damage: "chain" },
        { name: "CommandBind", prerequisite: "CommandDisenchant", tags: ["command", "binding", "offense", "aoe"], sfx: "MagicSlash", school: "Conjure", manacost: 4.5, components: ["Verbal"], level: 1,
            type: "special", special: "CommandBind",
            onhit: "", time: 0, power: 0, range: 2.5, size: 1, aoe: 2.5, damage: "inert" },
        { name: "CommandDisenchant", prerequisite: "CommandWord", tags: ["command", "offense", "aoe"], sfx: "MagicSlash", school: "Conjure", manacost: 9, components: ["Verbal"], level: 1,
            type: "special", special: "CommandDisenchant",
            onhit: "", time: 0, power: 3.0, range: 3.5, size: 1, aoe: 3.5, damage: "inert" },
        { name: "CommandVibrate", prerequisite: "CommandWord", tags: ["command", "offense", "aoe", "sexy"], sfx: "MagicSlash", school: "Conjure", manacost: 4.5, components: ["Verbal"], level: 1,
            type: "special", special: "CommandVibrate",
            onhit: "", time: 30, power: 5, range: 3.5, size: 1, aoe: 3.5, damage: "charm" },
        { name: "CommandOrgasm", prerequisite: "CommandVibrate", tags: ["command", "offense", "aoe", "sexy"], sfx: "MagicSlash", school: "Conjure", manacost: 4.5, components: ["Verbal"], level: 1,
            type: "special", special: "CommandOrgasm",
            onhit: "", time: 0, power: 5, range: 7, size: 1, aoe: 4.99, damage: "charm" },
        { name: "CommandRelease", prerequisite: "CommandDisenchant", tags: ["command", "binding", "defense"], sfx: "MagicSlash", school: "Conjure", manacost: 9, components: ["Verbal"], level: 1,
            type: "special", special: "CommandRelease",
            onhit: "", time: 0, power: 10.0, range: 2.5, size: 1, aoe: 1.5, damage: "inert" },
        KDCommandWord,
        { name: "CommandSlime", prerequisite: "ApprenticeLatex", tags: ["command", "slime", "defense"], sfx: "MagicSlash", school: "Conjure", manacost: 9, components: ["Verbal"], level: 1,
            type: "special", special: "CommandSlime",
            onhit: "", time: 0, power: 9.9, range: 2.5, size: 1, aoe: 1.5, damage: "inert" },
        { name: "SlimeWalk", tags: ["slime", "latex", "defense"], prerequisite: "ApprenticeLatex", school: "Conjure", spellPointCost: 2, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "Buff", trigger: "tick", power: 0.5, buffType: "glueDamageResist" },
            ] },
        { name: "SlimeWall", tags: ["latex", "utility", "slime", "wall"], hide: true, autoLearn: ["SlimeWallHoriz", "SlimeWallVert"], prerequisite: "ApprenticeLatex", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "SlimeWallVert", secret: true, color: "#ff00ff", hideUnlearnable: true, prerequisite: "SlimeWall", tags: ["latex", "slime", "defense", "aoe", "denial", "utility", "wall"], landsfx: "MagicSlash", school: "Conjure", manacost: 4, components: ["Legs"], level: 1, type: "inert",
            onhit: "lingering", aoetype: "vert", pierceEnemies: true, time: 2, delay: 2, range: 4, size: 3, aoe: 2.5, lifetime: 20, power: 0, lifetimeHitBonus: 4, damage: "glue", secondaryhit: "buffnoAoE",
            hitColor: 0xff00ff, hitLight: 2.5, bulletColor: 0xff00ff, bulletLight: 3.5,
            buffs: [KDSlimed] },
        { name: "SlimeWallHoriz", secret: true, color: "#ff00ff", hideUnlearnable: true, prerequisite: "SlimeWall", tags: ["latex", "slime", "defense", "aoe", "denial", "utility", "wall"], landsfx: "MagicSlash", school: "Conjure", manacost: 4, components: ["Legs"], level: 1, type: "inert",
            onhit: "lingering", aoetype: "horiz", pierceEnemies: true, time: 2, delay: 2, range: 4, size: 3, aoe: 2.5, lifetime: 20, power: 0, lifetimeHitBonus: 4, damage: "glue", secondaryhit: "buffnoAoE",
            hitColor: 0xff00ff, hitLight: 2.5, bulletColor: 0xff00ff, bulletLight: 3.5,
            buffs: [KDSlimed] },
        { name: "LatexWall", tags: ["latex", "utility", "slime", "wall"], hide: true, autoLearn: ["LatexWallVert", "LatexWallHoriz"],
            prerequisite: "SlimeWall", hideLearned: true, school: "Conjure", manacost: 0, spellPointCost: 1, components: [], level: 1, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "LatexWallVert", secret: true, color: "#aa00ff", hideUnlearnable: true, prerequisite: "LatexWall", tags: ["latex", "slime", "defense", "aoe", "denial", "utility", "wall"], landsfx: "MagicSlash", school: "Conjure", manacost: 9, components: ["Legs"], level: 1, type: "inert",
            upcastFrom: "SlimeWallVert", upcastLevel: 1,
            hitColor: 0xff00ff, hitLight: 2.5, bulletColor: 0xff00ff, bulletLight: 3.5,
            onhit: "lingering", aoetype: "vert", pierceEnemies: true, time: 0, delay: 2, range: 4, size: 3, aoe: 2.5, lifetime: 20, power: 0, lifetimeHitBonus: 4, damage: "glue", secondaryhit: "buffnoAoE",
            hitevents: [
                { trigger: "bulletHitEnemy", type: "LatexWall", power: 5, damage: "glue", time: 6 },
            ],
            buffs: [KDEncased] },
        { name: "LatexWallHoriz", secret: true, color: "#aa00ff", hideUnlearnable: true, prerequisite: "LatexWall", tags: ["latex", "slime", "defense", "aoe", "denial", "utility", "wall"], landsfx: "MagicSlash", school: "Conjure", manacost: 9, components: ["Legs"], level: 1, type: "inert",
            upcastFrom: "SlimeWallHoriz", upcastLevel: 1,
            hitColor: 0xff00ff, hitLight: 2.5, bulletColor: 0xff00ff, bulletLight: 3.5,
            onhit: "lingering", aoetype: "horiz", pierceEnemies: true, time: 0, delay: 2, range: 4, size: 3, aoe: 2.5, lifetime: 20, power: 0, lifetimeHitBonus: 4, damage: "glue", secondaryhit: "buffnoAoE",
            hitevents: [
                { trigger: "bulletHitEnemy", type: "LatexWall", power: 5, damage: "glue", time: 6 },
            ],
            buffs: [KDEncased] },
        { name: "Coalesce", prerequisite: "Spread", tags: ["latex", "slime", "aoe", "utility", "offense"], sfx: "MagicSlash", school: "Conjure", manacost: 4, components: ["Verbal"], level: 1,
            type: "special", special: "Coalesce",
            onhit: "", time: 0, power: 0.5, range: 3.5, size: 1, aoe: 2.5, damage: "glue" },
        { name: "ElasticGrip", prerequisite: "ApprenticeLatex", tags: ["latex", "utility"], sfx: "FireSpell", school: "Conjure", manacost: 2, components: ["Arms"], level: 1,
            type: "special", special: "ElasticGrip",
            onhit: "", time: 0, power: 1.0, range: 7.99, size: 1, damage: "glue" },
        { name: "SlimeToLatex", prerequisite: "ApprenticeLatex", tags: ["latex", "aoe", "utility", "denial"], sfx: "MagicSlash", school: "Conjure", manacost: 9, components: ["Legs"], level: 1,
            type: "special", special: "SlimeToLatex",
            onhit: "", time: 0, power: 2, range: 3.0, size: 1, aoe: 1.5, damage: "glue" },
        { name: "Engulf", tags: ["latex", "slime", "buff", "offense"], prerequisite: "ApprenticeLatex", sfx: "MagicSlash", school: "Conjure", manacost: 1.5, components: [], level: 1, type: "passive", events: [
                { type: "ElementalEffect", power: 2, damage: "glue", trigger: "playerAttack", cost: 1.0 },
                { type: "EffectTile", kind: "Slime", duration: 8, trigger: "playerAttack", cost: 0.5 },
            ] },
        { name: "Awaken", prerequisite: "Spread", tags: ["slime", "latex", "binding", "offense", "aoe"], sfx: "MagicSlash", school: "Conjure", manacost: 2.0, components: ["Verbal"], level: 1,
            type: "special", special: "Awaken",
            onhit: "", time: 0, power: 0, range: 3.99, size: 1, aoe: 2.5, damage: "inert" },
        { name: "Spread", prerequisite: "ApprenticeLatex", tags: ["slime", "latex", "utility",], sfx: "MagicSlash", school: "Conjure", manacost: 1.0, components: ["Verbal"], level: 1,
            type: "special", special: "Spread",
            onhit: "", time: 0, power: 0, range: 3.99, size: 1, aoe: 2, damage: "inert" },
        { name: "Animate", prerequisite: "Awaken", tags: ["slime", "latex", "summon"], sfx: "MagicSlash", school: "Conjure", manacost: 6, components: ["Verbal"], level: 1,
            type: "special", special: "Animate", upcastFrom: "Awaken", upcastLevel: 1,
            onhit: "", time: 0, power: 0, range: 3.99, size: 1, aoe: 1.5, damage: "inert" },
        { name: "AnimateLarge", prerequisite: "Animate", tags: ["slime", "latex", "summon"], sfx: "MagicSlash", school: "Conjure", manacost: 10, components: ["Verbal"], level: 1,
            type: "special", special: "AnimateLarge", upcastFrom: "Awaken", upcastLevel: 2,
            onhit: "", time: 0, power: 0, range: 3.99, size: 1, aoe: 1.1, damage: "inert" },
        { name: "AnimatePuppet", prerequisite: "Awaken", tags: ["slime", "latex", "summon"], sfx: "MagicSlash", school: "Conjure", manacost: 6, components: ["Verbal"], level: 2,
            type: "special", special: "AnimatePuppet",
            onhit: "", time: 0, power: 0, range: 3.99, size: 1, aoe: 2.5, damage: "inert" },
        { name: "OneWithSlime", tags: ["slime", "latex", "utility"], prerequisite: "ApprenticeLatex", school: "Elements", spellPointCost: 3, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "OneWithSlime", trigger: "calcComp", requiredTag: "slime" },
            ] },
        { name: "SlimeMimic", tags: ["slime", "latex", "utility"], prerequisite: "ApprenticeLatex", school: "Elements", spellPointCost: 1, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "SlimeMimic", trigger: "tick" },
            ] },
        { name: "SteelRainPlug", color: "#ffffff", tags: ["binding", "metal", "bolt", "offense"], prerequisite: "ApprenticeMetal", sfx: "MagicSlash", hitsfx: "HeavySwing", school: "Conjure", manacost: 2, components: ["Arms"], level: 1, type: "bolt",
            projectileTargeting: true, onhit: "", time: 0, power: 2.0, delay: 0, range: 15, damage: "pierce", speed: 3, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "pierce", power: 2, tag: "plugSpell" },
            bulletColor: 0xffffff, bulletLight: 1,
            events: [
                { type: "PlugEnemy", trigger: "bulletHitEnemy" },
            ]
        },
        { name: "SteelRainBurst", tags: ["binding", "metal", "bolt", "offense"], prerequisite: "SteelRainPlug", sfx: "MagicSlash", hitsfx: "HeavySwing", school: "Conjure", manacost: 5, components: ["Arms"], level: 1,
            upcastFrom: "SteelRainPlug", upcastLevel: 1,
            projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, type: "inert", onhit: "aoe",
            time: 0, delay: 1, power: 5, range: 12, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            shotgunCount: 4, shotgunDistance: 4, shotgunSpread: 1, shotgunSpeedBonus: 1,
            spellcast: { spell: "SteelRainPlug", target: "target", directional: true, randomDirectionPartial: true, aimAtTarget: true, noTargetMoveDir: true, offset: false } },
    ],
    "Illusion": [
        { goToPage: 3, name: "ApprenticeShadow", tags: ["magic"], autoLearn: ["Dagger"], hideLearned: true, hideUnlearnable: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 3, name: "ApprenticeLight", tags: ["magic"], autoLearn: ["Flash"], hideLearned: true, hideUnlearnable: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 3, name: "ApprenticeMystery", tags: ["magic"], autoLearn: ["Camo"], hideLearned: true, hideUnlearnable: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 3, name: "ApprenticeProjection", tags: ["magic"], autoLearn: ["Decoy"], hideLearned: true, hideUnlearnable: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { goToPage: 3, name: "ApprenticeKnowledge", tags: ["magic"], autoLearn: ["TrueSteel"], hideLearned: true, hideUnlearnable: true, school: "Illusion", manacost: 0, spellPointCost: 1, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "Athlete", tags: ["stamina", "utility"], school: "Illusion", spellPointCost: 1, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "Buff", trigger: "tick", power: 0.67, buffType: "SprintEfficiency" },
            ] },
        { name: "Sneaky", tags: ["buff", "utility"], school: "Illusion", spellPointCost: 1, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "Buff", trigger: "tick", power: 0.5, prereq: "Waiting", buffType: "Sneak", mult: 1, tags: ["SlowDetection", "move", "cast"] },
            ] },
        { name: "Evasive1", tags: ["buff", "defense"], school: "Illusion", spellPointCost: 1, hideLearned: true, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "Buff", trigger: "tick", power: 0.1, buffType: "Evasion" },
            ] },
        { name: "Evasive2", tags: ["buff", "defense"], school: "Illusion", spellPointCost: 1, hideLearned: true, prerequisite: "Evasive1", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "Buff", trigger: "tick", power: 0.15, buffType: "Evasion" },
            ] },
        { name: "Evasive3", tags: ["buff", "defense"], school: "Illusion", spellPointCost: 1, prerequisite: "Evasive2", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { type: "Buff", trigger: "tick", power: 0.25, buffType: "Evasion" },
            ] },
        { name: "CriticalStrike", tags: ["damage", "offense", "buff"], school: "Illusion", spellPointCost: 2, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { trigger: "beforePlayerAttack", type: "CritBoost", prereq: "damageType", kind: "melee", power: 0.5 },
                { trigger: "calcDisplayDamage", type: "CritBoost", prereq: "damageType", kind: "melee", power: 0.5 },
            ] },
        { name: "Vault", tags: ["damage", "utility", "buff"], school: "Illusion", spellPointCost: 1, manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert", events: [
                { trigger: "canSprint", type: "Vault" },
            ] },
        { name: "Analyze", prerequisite: "ApprenticeKnowledge", tags: ["buff", "utility", "knowledge"], school: "Illusion", manacost: 2.5, defaultOff: true, cancelAutoMove: true, costOnToggle: true, components: [], level: 1, type: "passive",
            events: [{ type: "Analyze", trigger: "toggleSpell", power: 5, time: 20 }, { type: "Analyze", trigger: "tick", power: 5, time: 20 }] },
        { name: "APUp1", hide: true, school: "Any", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "APUp2", hide: true, school: "Any", manacost: 0, components: [], level: 1, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "APUp3", hide: true, school: "Any", manacost: 0, components: [], level: 4, passive: true, type: "", onhit: "", time: 0, delay: 0, range: 0, lifetime: 0, power: 0, damage: "inert" },
        { name: "Dagger", prerequisite: "ApprenticeShadow", tags: ["bolt", "shadow", "offense"], sfx: "MagicSlash", school: "Illusion", manacost: 2, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, noDoubleHit: true, piercing: true, onhit: "", power: 2.5, time: 0, delay: 0, range: 6, damage: "cold", speed: 4, playerEffect: { name: "Damage" } },
        { name: "Flash", color: "#ffffff", prerequisite: "ApprenticeLight", tags: ["light", "utility", "aoe", "offense"], noise: 8, sfx: "FireSpell",
            hitColor: 0xffffff, hitLight: 6,
            school: "Illusion", manacost: 4, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 4, delay: 1, power: 1, range: 2.5, size: 3, aoe: 1.5, lifetime: 1, damage: "stun", playerEffect: { name: "Blind", time: 4 } },
        { name: "Ring", prerequisite: "ApprenticeLight", tags: ["aoe", "utility", "stealth"], noise: 10, sfx: "MagicSlash", school: "Illusion", manacost: 1, components: ["Arms"], level: 1, type: "inert", onhit: "aoe", time: 2, delay: 1, power: 1, range: 7, size: 3, aoe: 1.5, lifetime: 1, damage: "stun" },
        { name: "GreaterFlash", color: "#ffffff", tags: ["light", "utility", "aoe", "offense"], prerequisite: "Flash", spellPointCost: 1,
            upcastFrom: "Flash", upcastLevel: 1,
            hitColor: 0xffffff, hitLight: 8,
            noise: 10, sfx: "FireSpell", school: "Illusion", manacost: 5, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 8, delay: 1, power: 1, range: 2.5, size: 3, aoe: 1.5, lifetime: 1, damage: "stun", playerEffect: { name: "Blind", time: 6 } },
        { name: "FocusedFlash", color: "#ffffff", tags: ["light", "utility", "aoe", "offense"], prerequisite: "GreaterFlash", spellPointCost: 1,
            upcastFrom: "Flash", upcastLevel: 2,
            hitColor: 0xffffff, hitLight: 11,
            noise: 10, sfx: "FireSpell", school: "Illusion", manacost: 7, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 12, delay: 2, power: 1, range: 2.5, size: 5, aoe: 2.5, lifetime: 1, damage: "stun", playerEffect: { name: "Blind", time: 10 } },
        { name: "Shroud", prerequisite: "ApprenticeShadow", tags: ["aoe", "buff", "utility", "stealth", "defense"], sfx: "Fwoosh", school: "Illusion", manacost: 5, components: ["Verbal"], level: 1, type: "inert", buffs: [
                { id: "Shroud", type: "Evasion", power: 7.0, player: true, enemies: true, tags: ["darkness"], range: 1.5 },
                { id: "Shroud2", aura: "#444488", type: "Sneak", power: 4.0, player: true, duration: 8, enemies: false, tags: ["darkness"], range: 1.5 }
            ], onhit: "", time: 8, aoe: 1.5, power: 0, delay: 8, range: 4, size: 3, damage: "",
            effectTileDurationModPre: 3, effectTilePre: {
                name: "Smoke",
                duration: 8,
            } },
        { name: "Invisibility", prerequisite: "ApprenticeMystery", tags: ["buff", "utility", "stealth", "defense"], sfx: "Invis", school: "Illusion", manacost: 8, components: ["Verbal"], mustTarget: true, level: 1, type: "buff",
            buffs: [
                { id: "Invisibility", aura: "#888888", type: "Sneak", duration: 10, power: 10.0, player: true, enemies: true, tags: ["invisibility"] },
                { id: "Invisibility2", type: "SlowDetection", duration: 14, power: 0.5, player: true, enemies: false, tags: ["invisibility"] },
            ], onhit: "", time: 14, power: 0, range: 2, size: 1, damage: "" },
        { name: "TrueSteel", prerequisite: "ApprenticeKnowledge", tags: ["offense", "stealth", "knowledge"], sfx: "MagicSlash", school: "Illusion", manacost: 2, components: ["Arms"], noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, time: 1, power: 4, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "slash",
            events: [{ trigger: "beforeDamageEnemy", type: "MultiplyDamageStealth", power: 2.5, humanOnly: true }]
        },
        { name: "Camo", prerequisite: "ApprenticeMystery", tags: ["buff", "utility", "stealth", "defense"], sfx: "MagicSlash", school: "Illusion", manacost: 3, components: ["Legs"], mustTarget: true, noTargetEnemies: true, level: 1, type: "buff",
            buffs: [
                { id: "Camo", aura: "#3b7d4f", type: "SlowDetection", duration: 50, power: 49.0, player: true, enemies: true, endSleep: true, currentCount: -1, maxCount: 1, tags: ["SlowDetection", "move", "cast"] }
            ], onhit: "", time: 50, power: 0, range: 2, size: 1, damage: "" },
        { name: "ShadowBlade", prerequisite: "ApprenticeShadow", tags: ["buff", "offense", "shadow"], sfx: "MagicSlash", school: "Illusion", manacost: 6, components: ["Arms"], mustTarget: true, level: 1, type: "buff",
            buffs: [{ id: "ShadowBlade", aura: "#7022a0", type: "AttackDmg", duration: 50, power: 2.0, player: true, enemies: true, maxCount: 5, tags: ["attack", "damage"] }], onhit: "", time: 50, power: 0, range: 2, size: 1, damage: "" },
        { name: "ShadowSlash", tags: ["aoe", "offense", "shadow"], prerequisite: "ShadowBlade", sfx: "MagicSlash", school: "Illusion", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, piercing: true, noTerrainHit: true, noEnemyCollision: true, onhit: "aoe", power: 4.5, delay: 0, range: 1.5, aoe: 1.5, size: 3, lifetime: 1, damage: "cold", speed: 1, time: 2,
            trailspawnaoe: 1.5, trailPower: 0, trailLifetime: 1.1, trailHit: "", trailDamage: "inert", trail: "lingering", trailChance: 0.4 },
        { name: "Decoy", tags: ["summon", "utility", "stealth", "defense"], prerequisite: "ApprenticeProjection", sfx: "MagicSlash", school: "Illusion", manacost: 6, components: ["Legs"], noTargetEnemies: true, noTargetPlayer: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "Decoy", count: 1, time: 20 }], power: 0, time: 20, delay: -1, range: 4, size: 1, aoe: 0, lifetime: 1, damage: "fire" },
        { name: "ShadowWarrior", prerequisite: "ApprenticeShadow", tags: ["summon", "offense", "shadow", "dot"], sfx: "MagicSlash", school: "Illusion", manacost: 10, components: ["Verbal"], noTargetEnemies: true, noTargetPlayer: true, level: 1, type: "hit", noSprite: true, onhit: "summon", summon: [{ name: "ShadowWarrior", count: 1, time: 12 }], power: 6, time: 12, delay: -1, range: 3.5, size: 1, aoe: 0, lifetime: 1, damage: "inert" },
        { name: "Corona", color: "#ffffff",
            bulletColor: 0xffff77, bulletLight: 5,
            tags: ["light", "offense"], prerequisite: "Light", noise: 4, sfx: "MagicSlash", school: "Illusion", spellPointCost: 1, manacost: 7, components: ["Arms"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 12, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
            spellcast: { spell: "CoronaBeam", target: "target", directional: true, offset: false }, channel: 2 },
        { name: "TrueSight", prerequisite: "ApprenticeKnowledge", tags: ["buff", "utility", "knowledge"], school: "Illusion", manacost: 1, defaultOff: true, cancelAutoMove: true, components: [], level: 1, type: "passive", events: [
                { type: "TrueSight", trigger: "vision" },
                { type: "Blindness", trigger: "calcStats", power: -1 },
                { type: "AccuracyBuff", trigger: "tick", power: 0.4 },
            ] },
        { name: "EnemySense", prerequisite: "ApprenticeKnowledge", tags: ["buff", "utility", "knowledge"], school: "Illusion", manacost: 2, defaultOff: true, cancelAutoMove: true, costOnToggle: true, components: [], level: 1, type: "passive",
            events: [{ type: "EnemySense", trigger: "draw", dist: 12, distStealth: 6 }] },
        { name: "Light", prerequisite: "ApprenticeLight", tags: ["buff", "utility", "light"], school: "Illusion", manacost: 2, spellPointCost: 1, defaultOff: true, cancelAutoMove: true, costOnToggle: true, time: 12, components: [], level: 1, type: "passive",
            events: [{ type: "Light", trigger: "getLights", power: 12, time: 12 }, { type: "Light", trigger: "toggleSpell", power: 12, time: 12 }] },
        { name: "Evasion", prerequisite: "ApprenticeMystery", tags: ["buff", "utility", "defense"], sfx: "Fwoosh", school: "Illusion", manacost: 5, components: ["Legs"], mustTarget: true, level: 1, type: "buff",
            buffs: [
                { id: "Evasion", type: "Evasion", labelcolor: "#a288b6", duration: 25, power: 3.0, player: true, enemies: true, maxCount: 5, tags: ["defense", "incomingHit"] },
            ], onhit: "", time: 25, power: 0, range: 2, size: 1, damage: "" },
    ],
};
let KinkyDungeonSpellListEnemies = [
    { name: "AwakenStrike", tags: ["offense", "latex", "slime", "binding"], sfx: "MagicSlash", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 2.5, time: 5, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "glue",
        playerEffect: { name: "Bind", damage: "glue", power: 3, tag: "slimeRestraints" },
        events: [
            { trigger: "bulletHitEnemy", type: "EncaseBound" },
        ],
    },
    { name: "OrgasmStrike", tags: ["offense", "nature", "binding"], sfx: "FireSpell", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 0, time: 10, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "inert",
    },
    { name: "EffectEnemyCM1", tags: [], sfx: "FireSpell", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 0, time: 10, range: 1.5, size: 3, lifetime: 1, aoe: 0.5, damage: "inert",
    },
    { name: "EffectEnemyCM2", tags: [], sfx: "FireSpell", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 0, time: 10, range: 1.5, size: 3, lifetime: 1, aoe: 0.5, damage: "inert",
    },
    { name: "EffectEnemyCM3", tags: [], sfx: "FireSpell", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 0, time: 10, range: 1.5, size: 3, lifetime: 1, aoe: 0.5, damage: "inert",
    },
    { name: "EffectEnemyLock1", tags: [], sfx: "FireSpell", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 0, time: 10, range: 1.5, size: 3, lifetime: 1, aoe: 0.5, damage: "inert",
    },
    { name: "EnemyMiscast", tags: [], sfx: "FireSpell", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 0, time: 10, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "inert",
    },
    { name: "Summon", faction: "Enemy", school: "Conjure", manacost: 0, components: ["Verbal"], level: 1, type: "hit", onhit: "instant", time: 0, power: 0, delay: 0, range: 4, size: 1, lifetime: 1, damage: "inert" },
    { name: "BindRope", tags: ["offense", "rope", "binding"], sfx: "MagicSlash", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 3.0, time: 5, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "chain",
        playerEffect: { name: "Bind", damage: "chain", power: 2, tag: "ropeRestraints" },
    },
    { name: "BindFabric", tags: ["offense", "fabric", "binding"], sfx: "MagicSlash", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 3.0, time: 5, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "glue",
        playerEffect: { name: "Bind", damage: "chain", power: 2, tag: "ribbonRestraints" },
    },
    { name: "BindVine", tags: ["offense", "nature", "binding"], sfx: "MagicSlash", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 3.0, time: 10, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "crush",
        playerEffect: { name: "Bind", damage: "crush", power: 2, tag: "vineRestraints" },
    },
    { name: "BindChain", tags: ["offense", "metal", "binding"], sfx: "MagicSlash", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 3.0, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "crush",
        events: [{ trigger: "bulletHitEnemy", type: "DisarmHumanoid", time: 8 }],
        playerEffect: { name: "Bind", damage: "crush", power: 2, tag: "chainRestraints" },
    },
    { name: "BindBelt", tags: ["offense", "leather", "binding"], sfx: "MagicSlash", school: "Conjure", manacost: 0.5, components: ["Verbal"],
        noTargetPlayer: true, mustTarget: true, level: 1, type: "hit", onhit: "instant", evadeable: false, power: 0, bind: 4.0, range: 1.5, size: 1, lifetime: 1, aoe: 0.5, damage: "chain",
        events: [{ type: "MakeVulnerable", trigger: "beforeDamageEnemy", time: 3, },],
        playerEffect: { name: "Bind", damage: "chain", power: 2, tag: "leatherRestraints" },
    },
    { name: "GagBolt", tags: ["binding", "leather", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "LightSwing", school: "Conjure", manacost: 3, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", time: 0, power: 2.0, delay: 0, range: 15, damage: "chain", speed: 5, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 2, tag: "gagSpell" },
        events: [
            { type: "SilenceHumanoid", trigger: "bulletHitEnemy", time: 15 },
            { type: "ElementalIfNotSilenced", trigger: "bulletHitEnemy", damage: "chain", power: 0, bind: 4 },
        ], effectTileDurationMod: 10, effectTileAoE: 0.5, effectTile: {
            name: "Belts",
            duration: 20,
        },
    },
    { name: "ArmbinderBolt", tags: ["binding", "leather", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "HeavySwing", school: "Conjure", manacost: 3, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", time: 0, power: 5.0, delay: 0, range: 15, damage: "chain", speed: 2, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 2, tag: "armbinderSpell" },
        events: [
            { type: "DisarmHumanoid", trigger: "bulletHitEnemy", time: 14 },
            { type: "SilenceHumanoid", trigger: "bulletHitEnemy", time: 14, prereq: "silenced" },
            { type: "BlindHumanoid", trigger: "bulletHitEnemy", time: 14, prereq: "blinded" },
        ], effectTileDurationMod: 10, effectTileAoE: 1.5, effectTileDensity: 0.5, effectTile: {
            name: "Belts",
            duration: 20,
        },
    },
    { name: "LeatherCuffsBolt", tags: ["binding", "leather", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "HeavySwing", school: "Conjure", manacost: 3, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", time: 0, power: 1.0, bind: 4, delay: 0, range: 15, damage: "chain", speed: 2, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 2, tag: "leathercuffsSpell" },
        events: [
            { type: "ApplyGenBuff", trigger: "bulletHitEnemy", buff: "RestraintDisarmLight", time: 9999 },
        ], effectTileDurationMod: 10, effectTileAoE: 1.5, effectTileDensity: 0.5, effectTile: {
            name: "Belts",
            duration: 20,
        },
    },
    { name: "BlindfoldBolt", tags: ["binding", "leather", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "LightSwing", school: "Conjure", manacost: 3, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", time: 0, power: 2.0, delay: 0, range: 15, damage: "chain", speed: 5, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 2, tag: "blindfoldSpell" },
        events: [
            { type: "BlindHumanoid", trigger: "bulletHitEnemy", time: 20 },
            { type: "ElementalIfNotBlinded", trigger: "bulletHitEnemy", damage: "chain", power: 0, bind: 4 },
        ], effectTileDurationMod: 10, effectTileAoE: 0.5, effectTile: {
            name: "Belts",
            duration: 20,
        },
    },
    { name: "CuffsBolt", tags: ["binding", "metal", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "LightSwing", school: "Conjure", manacost: 4, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", time: 0, power: 3.0, delay: 0, range: 15, damage: "chain", speed: 5, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 3, tag: "cuffsSpell" },
        events: [
            { type: "DisarmHumanoid", trigger: "bulletHitEnemy", time: 6 },
            { type: "ElementalIfNotDisarmed", trigger: "bulletHitEnemy", damage: "chain", power: 0, bind: 4 },
        ], effectTileDurationMod: 10, effectTileAoE: 0.5, effectTile: {
            name: "Chains",
            duration: 20,
        },
    },
    { name: "LegbinderBolt", tags: ["binding", "leather", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "LightSwing", school: "Conjure", manacost: 6, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", time: 11, power: 4.0, delay: 0, range: 15, damage: "chain", speed: 3, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 4, tag: "legbinderSpell" },
        events: [
            { type: "ElementalIfNotSnared", trigger: "bulletHitEnemy", damage: "chain", power: 0, bind: 5 },
        ], effectTileDurationMod: 10, effectTileAoE: 1.5, effectTileDensity: 0.5, effectTile: {
            name: "Belts",
            duration: 20,
        },
    },
    { name: "HarnessBolt", tags: ["binding", "leather", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "LightSwing", school: "Conjure", manacost: 6, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", time: 0, power: 5.0, delay: 0, range: 15, damage: "crush", speed: 3, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 5, tag: "harnessSpell" },
        events: [
            { type: "BoundBonus", trigger: "bulletHitEnemy", damage: "chain", power: 0, bind: 5 },
        ], effectTileDurationMod: 10, effectTileAoE: 1.5, effectTileDensity: 0.5, effectTile: {
            name: "Belts",
            duration: 20,
        },
    },
    { name: "StraitjacketBolt", tags: ["binding", "leather", "bolt", "offense"], minRange: 1.5, sfx: "MagicSlash", hitsfx: "LightSwing", school: "Conjure", manacost: 6, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "buff", time: 0, bind: 12, power: 1.0, delay: 0, range: 6, damage: "crush", speed: 2, bulletLifetime: 5, playerEffect: { name: "Bind", damage: "chain", power: 5, tag: "jacketSpell" },
        buffs: [
            { id: "StraitjacketBolt", aura: "#ff4400", type: "Locked", duration: 14, power: 2.0, player: true, enemies: true, tags: ["lock", "debuff"] },
        ],
        events: [
            { type: "DisarmHumanoid", trigger: "bulletHitEnemy", time: 10 },
        ], effectTileDurationMod: 10, effectTileAoE: 1.5, effectTileDensity: 0.75, effectTile: {
            name: "Belts",
            duration: 20,
        },
    },
    { name: "SmokePuff", school: "Illusion", manacost: 1, components: ["Verbal"], level: 1, type: "inert", buffs: [
            { id: "SmokePuff", type: "Evasion", power: 3.0, player: true, enemies: true, tags: ["darkness"], range: 0.5 },
            { id: "SmokePuff2", type: "Sneak", power: 3.0, player: true, duration: 1, enemies: true, tags: ["darkness"], range: 0.5 }
        ], onhit: "", time: 5, aoe: 0.5, power: 0, delay: 2, delayRandom: 5, range: 4, size: 1, damage: "" },
    { name: "SteamPuff", school: "Illusion", manacost: 1, components: ["Verbal"], level: 1, type: "inert", buffs: [
            { id: "SmokePuff", type: "Evasion", power: 5.0, player: true, enemies: true, tags: ["darkness"], range: 0.5 },
            { id: "SmokePuff2", type: "Sneak", power: 3.0, player: true, duration: 1, enemies: true, tags: ["darkness"], range: 0.5 }
        ], onhit: "", time: 5, aoe: 0.5, power: 0, delay: 2, delayRandom: 5, range: 4, size: 1, damage: "" },
    { name: "LesserInvisibility", sfx: "MagicSlash", school: "Illusion", manacost: 0, components: ["Verbal"], mustTarget: true, level: 1, type: "buff", buffs: [{ id: "LesserInvisibility", aura: "#888888", type: "Sneak", duration: 10, power: 3, player: true, enemies: true, tags: ["invisibility"] }], onhit: "", time: 10, power: 0, range: 1.5, size: 1, damage: "" },
    { name: "Disarm", tags: ["weapon"], sfx: "Chain", school: "Illusion", manacost: 0, components: [], level: 1, type: "special", special: "Disarm", noMiscast: true,
        onhit: "", time: 5, power: 0, range: 3.99, size: 1, damage: "" },
    { name: "Freedom", sfx: "Magic", hitsfx: "Struggle", school: "Conjure", manacost: 15, components: [], mustTarget: true, selfTargetOnly: true, level: 5, type: "hit",
        onhit: "instant", time: 4, lifetime: 1, bind: 8, delay: 1, power: 4, aoe: 2.99, range: 1.5, size: 5, damage: "chain", playerEffect: { name: "RemoveLowLevelRope" } },
    { allySpell: true, name: "BeltStrike", noise: 2, sfx: "Struggle", school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, castRange: 3, nonVolatile: true, onhit: "", power: 4, delay: 0, range: 4, speed: 4, size: 1, damage: "inert",
        trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "cast", trailChance: 1.0,
        trailcast: { spell: "SingleBelt", target: "onhit", directional: true, offset: false } },
    { allySpell: true, name: "SingleBelt", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 4, bind: 4, range: 2, size: 1, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsLeatherWeak", tags: ["leatherRestraints", "leatherRestraintsHeavy"], power: 3, damage: "chain", count: 2, noGuard: true } },
    { allySpell: true, name: "Slimethrower", landsfx: "FireSpell", manacost: 0, components: ["Legs"], level: 1, type: "hit", onhit: "lingering", time: 3, range: 3.9, power: 3.5, size: 1, aoe: 1, lifetime: 1, lifetimeHitBonus: 9, damage: "glue", playerEffect: { name: "SlimeTrap", time: 3 } },
    { allySpell: true, name: "Slimethrower2", landsfx: "FireSpell", manacost: 0, components: [], level: 1, type: "hit", onhit: "lingering", time: 3, range: 3.9, power: 2.5, size: 1, aoe: 1, lifetime: 1, lifetimeHitBonus: 9, damage: "glue" },
    { name: "SlimeSuit", sfx: "MagicSlash", school: "Illusion", manacost: 5, components: [], level: 1, type: "special", special: "dress", outfit: "SlimeSuit", noMiscast: true,
        onhit: "", time: 25, power: 0, range: 1.5, size: 1, damage: "" },
    { name: "SlimeForm", sfx: "MagicSlash", school: "Illusion", manacost: 8, components: ["Verbal"], mustTarget: true, level: 1, type: "buff", noMiscast: true,
        buffs: [
            { id: "SlimeForm", type: "glueDamageResist", aura: "#ff00ff", duration: 25, power: 0.5, player: true, enemies: false, tags: ["defense"] },
            { id: "SlimeForm2", type: "Squeeze", duration: 25, power: 0.5, player: true, enemies: false, tags: ["mobility"] },
            { id: "SlimeForm3", type: "Evasion", duration: 25, power: 0.5, player: true, enemies: false, tags: ["defense"] },
            { id: "SlimeForm4", type: "Counterattack", duration: 25, power: 2.5, player: true, enemies: false, tags: ["counter"], events: [
                    { trigger: "beforeAttack", type: "CounterattackDamage", power: 2.5, damage: "glue" },
                ] },
        ], onhit: "", time: 10, power: 0, range: 2, size: 1, damage: "",
        extraCast: [{ spell: "Slimethrower2" }, { spell: "SlimeSuit" }] },
    { name: "AvatarForm", sfx: "PowerMagic", school: "Elements", manacost: 8, components: ["Verbal"], mustTarget: true, level: 1, type: "buff", noMiscast: true,
        buffs: [
            { id: "AvatarFire", aura: "#f1641f", type: "event", duration: 9999, power: 5, player: true, enemies: false, maxCount: 1, tags: ["cast_fire"], events: [
                    { trigger: "calcMana", type: "AvatarFire", power: 5.0 },
                ] },
            { id: "AvatarWater", aura: "#2789cd", type: "event", duration: 9999, power: 5, player: true, enemies: false, maxCount: 1, tags: ["cast_water"], events: [
                    { trigger: "calcMana", type: "AvatarWater", power: 5.0 },
                ] },
            { id: "AvatarAir", aura: "#c9d4fd", type: "event", duration: 9999, power: 5, player: true, enemies: false, maxCount: 1, tags: ["cast_air"], events: [
                    { trigger: "calcMana", type: "AvatarAir", power: 5.0 },
                ] },
            { id: "AvatarEarth", aura: "#61a53f", type: "event", duration: 9999, power: 5, player: true, enemies: false, maxCount: 1, tags: ["cast_earth"], events: [
                    { trigger: "calcMana", type: "AvatarEarth", power: 5.0 },
                ] },
        ], onhit: "", time: 10, power: 0, range: 2, size: 1, damage: "" },
    { name: "ShockStrike", sfx: "Shock", manacost: 1, bulletColor: 0x8888ff, bulletLight: 2,
        hitColor: 0x8888ff, hitLight: 6, components: ["Arms"], level: 1, type: "hit", noTerrainHit: true, onhit: "aoe", time: 1, delay: 1, power: 2.5, range: 2, size: 1, aoe: 0.5, lifetime: 1, damage: "electric" },
    { name: "StaticSphereStrike", sfx: "Shock", manacost: 2, bulletColor: 0x8888ff, bulletLight: 2,
        hitColor: 0x8888ff, hitLight: 6, components: ["Verbal"], level: 1, type: "hit", noTerrainHit: true, onhit: "aoe", time: 1, delay: 1, power: 1.5, range: 2, size: 1, aoe: 0.5, lifetime: 1, damage: "electric" },
    { name: "LightningRuneStrike", bulletColor: 0x8888ff, bulletLight: 2,
        effectTileDurationMod: 2, effectTile: {
            name: "Sparks",
            duration: 3,
        },
        hitColor: 0x8888ff, hitLight: 6, hitsfx: "Shock", manacost: 2, components: ["Legs"], level: 1, type: "dot", noTerrainHit: true, onhit: "", time: 4, delay: 300, power: 4.5, range: 2, size: 1, aoe: 0.5, lifetime: 1, damage: "electric" },
    { name: "FlameRuneStrike", bulletColor: 0xb83716, bulletLight: 2,
        hitColor: 0xe64539, hitLight: 6, hitsfx: "Lightning", manacost: 2, components: ["Legs"], level: 1, type: "dot", noTerrainHit: true, onhit: "", delay: 300, power: 5.5, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "fire" },
    { name: "FreezeRuneStrike", hitsfx: "Freeze", manacost: 2, bulletColor: 0x8888ff, bulletLight: 2,
        hitColor: 0x8888ff, hitLight: 6, components: ["Legs"], level: 1, type: "dot", noTerrainHit: true, onhit: "", time: 30, delay: 300, power: 3.0, range: 2, size: 3, aoe: 0.5, lifetime: 1, damage: "ice" },
    { name: "EarthformSingle", tags: ["earth", "utility", "summon"], noSprite: true, minRange: 0, landsfx: "Bones", hideUnlearnable: true, manacost: 4, components: ["Legs"], prerequisite: ["Earthform"],
        level: 1, type: "hit", onhit: "summon", summon: [{ name: "EarthenMonolith", faction: "Rock", count: 1, time: 9999, bound: true }], power: 0, time: 9999, delay: 1, range: 4, size: 1, aoe: 0.5, lifetime: 1, damage: "inert" },
    { name: "DarkShroud", sfx: "FireSpell", school: "Illusion", manacost: 5, components: ["Verbal"], level: 1, type: "inert", buffs: [{ id: "DarkShroud", type: "Evasion", power: 1.5, player: false, enemies: true, tags: ["heavydarkness"], range: 1.5 },],
        onhit: "", time: 8, aoe: 1.5, power: 0, delay: 8, range: 4, size: 3, damage: "",
        effectTileDurationModPre: 3, effectTilePre: {
            name: "Smoke",
            duration: 8,
        } },
    { name: "Slippery", sfx: "FireSpell", school: "Elements", manacost: 0, components: ["Verbal"], mustTarget: true, selfTargetOnly: true, level: 1, type: "buff", channel: 4,
        buffs: [
            { id: "Slippery", aura: "#00ff00", type: "BoostStruggle", duration: 10, power: 0.1, player: true, enemies: false, tags: ["struggle"] },
        ], onhit: "", time: 10, power: 0, range: 2, size: 1, damage: "" },
    { name: "Cutting", sfx: "FireSpell", school: "Elements", manacost: 0, components: ["Verbal"], mustTarget: true, selfTargetOnly: true, level: 1, type: "buff", channel: 4,
        buffs: [
            { id: "Cutting", aura: "#ffff00", type: "BoostCutting", duration: 10, power: 0.3, player: true, enemies: false, tags: ["struggle"] },
            { id: "Cutting2", type: "BoostCuttingMinimum", duration: 10, power: 0.8, player: true, enemies: false, tags: ["struggle", "allowCut"] },
        ], onhit: "", time: 10, power: 0, range: 2, size: 1, damage: "" },
    { enemySpell: true, name: "EnemyCorona",
        bulletColor: 0xffff77, bulletLight: 5,
        minRange: 0, noise: 4, sfx: "MagicSlash", school: "Illusion", manacost: 7, components: ["Arms"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 12, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false,
        spellcast: { spell: "EnemyCoronaBeam", target: "target", directional: true, offset: false }, channel: 2 },
    { enemySpell: true, name: "EnemyCoronaBeam",
        trailColor: 0xffff77, trailLight: 3,
        sfx: "FireSpell", school: "Elements", manacost: 0, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, nonVolatile: true, onhit: "", power: 4, delay: 0, range: 8, speed: 50, size: 1, damage: "fire",
        trailHit: "", trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1, playerEffect: { name: "CoronaShock", time: 3 } },
    { enemySpell: true, name: "MonolithBeam",
        bulletColor: 0xff5555, bulletLight: 5,
        minRange: 0, noise: 4, sfx: "MagicSlash", school: "Illusion", manacost: 7, components: ["Arms"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 12, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false,
        spellcast: { spell: "MonolithBeamBeam", target: "target", directional: true, offset: false }, channel: 2 },
    { enemySpell: true, name: "MonolithBeamBeam",
        trailColor: 0xff5555, trailLight: 3,
        sfx: "MagicSlash", school: "Elements", manacost: 0, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, nonVolatile: true, onhit: "", power: 6, delay: 0, range: 8, speed: 50, size: 1, damage: "chain",
        trailHit: "", trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1, playerEffect: { name: "CrystalBind", time: 3 } },
    { enemySpell: true, name: "ClericBeam",
        bulletColor: 0x88ff88, bulletLight: 5,
        color: "#88ff88", minRange: 0, noise: 4, sfx: "MagicSlash", school: "Illusion", manacost: 7, components: ["Arms"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 12, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false,
        spellcast: { spell: "ClericBeamBeam", target: "target", directional: true, offset: false }, channel: 2 },
    { enemySpell: true, name: "ClericBeamBeam",
        trailColor: 0x88ff88, trailLight: 3,
        sfx: "MagicSlash", school: "Elements", manacost: 0, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, nonVolatile: true, onhit: "", power: 6, delay: 0, range: 8, speed: 50, size: 1, damage: "fire",
        trailHit: "", trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1, playerEffect: { name: "MysticShock", time: 3 } },
    { name: "BlasterBlast", hitsfx: "Shock", sfx: "Laser", school: "Elements", manacost: 0, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, nonVolatile: true, onhit: "", power: 2.5, time: 1, delay: 0,
        bulletColor: 0xffff00, bulletLight: 5, noMiscast: true,
        range: 8, speed: 3, size: 1, damage: "electric", playerEffect: { name: "Shock", time: 3 } },
    { enemySpell: true, name: "EnemyBlast", noFirstChoice: true, hitsfx: "Shock", sfx: "Laser", school: "Elements", manacost: 6, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, nonVolatile: true, onhit: "", power: 2.5, time: 1, delay: 0,
        bulletColor: 0x00ffff, bulletLight: 5,
        range: 8, speed: 3, size: 1, damage: "electric", playerEffect: { name: "Shock", time: 1 } },
    { name: "BondageBust", noise: 7, sfx: "Laser", school: "Illusion", manacost: 0, components: [], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 3, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
        bulletColor: 0xffff00, bulletLight: 5,
        spellcast: { spell: "BondageBustBeam", target: "target", directional: true, offset: false }, noMiscast: true, channel: 1 },
    { name: "BondageBustBeam", hitsfx: "Shock", school: "Elements", manacost: 0, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, nonVolatile: true, onhit: "", power: 3, time: 3, delay: 0, range: 8, speed: 50, size: 1, damage: "electric",
        trailColor: 0xffff00, trailLight: 3,
        trailHit: "", trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1, playerEffect: { name: "Shock", time: 3 } },
    { name: "HeartArrow", sfx: "MagicSlash", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "soul", speed: 2,
        events: [
            { type: "GreaterRage", trigger: "bulletHitEnemy" },
        ],
    },
    { enemySpell: true, name: "BearTrap", tags: ["fire", "offense", "defense"], noise: 0, sfx: "Miss", school: "Elements", spellPointCost: 1, manacost: 4,
        components: ["Legs"], level: 1, type: "inert",
        selfcast: true,
        onhit: "aoe", delay: 2, power: 2, range: 2.99, size: 1, lifetime: 1, damage: "inert",
        spellcast: { spell: "BearTrapStrike", target: "onhit", directional: false, offset: false } },
    { enemySpell: true, name: "BearTrapStrike", bulletColor: 0xaaaaaa, hideWarnings: true,
        hitsfx: "Clang", manacost: 2, components: ["Legs"], level: 1, type: "dot", noTerrainHit: true, onhit: "", delay: 20, power: 1, range: 2, bind: 4, size: 3, aoe: 1.5, lifetime: 1, damage: "chain",
        playerEffect: { name: "BearTrapStun", count: 1, power: 2.0, damage: "chain", time: 3 } },
    { name: "CoronaBeam", sfx: "FireSpell",
        trailColor: 0xffff77, trailLight: 3,
        school: "Elements", manacost: 0, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, nonVolatile: true, onhit: "", power: 12, delay: 0, range: 8, speed: 50, size: 1, damage: "fire",
        trailHit: "", trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1 },
    { name: "AllyCrackle", sfx: "Shock", school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, nonVolatile: true, onhit: "", power: 4, delay: 0, time: 1, range: 4, speed: 4, size: 1, damage: "electric",
        trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1.0 },
    { allySpell: true, name: "AllyFirebolt", sfx: "FireSpell", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4.5, delay: 0, range: 50, damage: "fire", speed: 3 },
    { allySpell: true, name: "AllyWindBlast", sfx: "FireSpell", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", power: 2.0, time: 2, delay: 0, range: 50, damage: "stun", speed: 1, hitSpin: 1, bulletSpin: 1,
        events: [{ type: "Knockback", trigger: "bulletHitEnemy", power: 1.0, dist: 1.0 },] },
    { allySpell: true, name: "AllyShadowStrike", minRange: 0, sfx: "MagicSlash", school: "Illusion", manacost: 3, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", power: 6, time: 2, delay: 1, range: 1.5, size: 1, aoe: 0.75, lifetime: 1, damage: "cold" },
    { allySpell: true, name: "HeelShadowStrike", sfx: "MagicSlash", school: "Illusion", manacost: 3, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", power: 2.5, time: 4, delay: 1, range: 1.5, size: 1, aoe: 0.75, lifetime: 1, damage: "cold" },
    { allySpell: true, name: "FlameStrike", sfx: "FireSpell", school: "Element", manacost: 6, components: [], level: 1, type: "inert", onhit: "aoe", noTerrainHit: true, power: 3, delay: 1, range: 1.5, size: 3, aoe: 1.5, lifetime: 1, damage: "fire" },
    { allySpell: true, name: "ShatterStrike", sfx: "MagicSlash", school: "Element", manacost: 0, components: [], level: 1, type: "hit", onhit: "instant", noTerrainHit: true, power: 1.5, delay: 1, range: 1.5, time: 4, size: 3, aoe: 1.5, lifetime: 1, damage: "frost" },
    { name: "Ignition", faction: "Rage", school: "Element", manacost: 0, components: [], level: 1, type: "hit", onhit: "instant", noTerrainHit: true, power: 1.5, delay: 1, range: 1.5, size: 3, aoe: 1.5, lifetime: 1, damage: "fire", playerEffect: { name: "Ignition", power: 1, damage: "fire" } },
    { name: "VolcanicStrike", school: "Element", manacost: 0, components: [], level: 1, hitsfx: "Lightning", type: "hit", onhit: "instant", noTerrainHit: true, power: 6.0, delay: 1, range: 1.5, size: 5, aoe: 2.99, damageFlags: ["VolcanicDamage"], lifetime: 1, damage: "fire", playerEffect: { name: "Damage" } },
    { allySpell: true, name: "ArcaneStrike", school: "Element", manacost: 0, components: [], level: 1, type: "hit", onhit: "instant", noTerrainHit: true, power: 2.5, delay: 1, range: 1.5, size: 3, aoe: 1.5, lifetime: 1, damage: "soul" },
    { enemySpell: true, name: "ShadowStrike", sfx: "MagicSlash", school: "Illusion", manacost: 3, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", power: 6, time: 2, delay: 1, range: 1.5, size: 1, aoe: 0.75, lifetime: 1, damage: "cold", playerEffect: { name: "ShadowStrike", damage: "cold", power: 4, count: 1 } },
    { name: "RopeBolt", color: "#ffff00", sfx: "Miss", school: "Conjure", manacost: 1, tags: ["rope"], components: ["Verbal"], level: 1, type: "bolt",
        projectileTargeting: true, onhit: "", power: 2.0, bind: 2.2, delay: 0, range: 50, damage: "chain", bindType: "Rope", speed: 3, playerEffect: { name: "SingleRope" },
        effectTileDurationMod: 10, effectTileAoE: 0.5, effectTile: {
            name: "Ropes",
            duration: 20,
        }, },
    { name: "Icicle", sfx: "MagicSlash", hitsfx: "Freeze", school: "Elements", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", time: 4,
        power: 3, delay: 0, range: 50, damage: "frost", speed: 2, playerEffect: { name: "Damage" },
        bulletColor: 0x92e4e8, bulletLight: 3,
        events: [{ type: "ElementalOnSlowOrBindOrDrench", trigger: "bulletHitEnemy", damage: "ice", time: 3, power: 0 },] },
    { name: "Boulder", sfx: "Bones", hitsfx: "HeavySwing", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", block: 8, time: 4, power: 4, delay: 0, range: 50, damage: "crush", speed: 2, playerEffect: { name: "Damage" } },
    { allySpell: true, name: "BoulderKicked", sfx: "Bones", hitsfx: "HeavySwing", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", time: 4, power: 4, delay: 0, range: 50, damage: "crush", speed: 2, playerEffect: { name: "Damage" } },
    { name: "BigBoulder", sfx: "Bones", hitsfx: "HeavySwing", school: "Elements", manacost: 7, components: ["Arms"], level: 1, type: "bolt", noDirectDamage: true,
        projectileTargeting: true, alwaysCollideTags: ["summonedRock"], onhit: "aoe", block: 20, time: 8, power: 12, aoe: 1.5, size: 3, delay: 0, lifetime: 1, range: 50, damage: "crush", speed: 1, playerEffect: { name: "Damage" } },
    { enemySpell: true, name: "Ribbons", color: "#6700ff", noise: 6, sfx: "Struggle", school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, castRange: 3, nonVolatile: true, onhit: "", power: 3, delay: 0, range: 4, speed: 4, size: 1, damage: "inert",
        trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "cast", trailChance: 1.0,
        trailcast: { spell: "SingleRibbon", target: "onhit", directional: true, offset: false } },
    { enemySpell: true, name: "SingleRibbon", color: "#6700ff", sfx: "Struggle", manacost: 4, components: [], level: 1,
        effectTileDurationMod: 10, effectTileAoE: 0.5, effectTile: {
            name: "Fabric",
            duration: 20,
        },
        type: "inert", onhit: "aoe", time: 5, delay: 1, power: 4, range: 2, size: 1, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsRibbons", tags: ["magicRibbons"], power: 3, damage: "chain", count: 1, noGuard: true } },
    { enemySpell: true, msg: true, name: "AreaElectrify", minRange: 0, landsfx: "Shock", school: "Conjure", specialCD: 10, manacost: 10, components: ["Legs"], level: 1, type: "inert", onhit: "cast",
        dot: true, time: 4, delay: 3, range: 2.5, size: 3, aoe: 2.5, lifetime: 1, power: 1, damage: "inert",
        spellcasthit: { spell: "WitchElectrify", target: "onhit", chance: 0.22, directional: false, offset: false }, channel: 2 },
    { enemySpell: true, name: "IceDragonBreath", color: "#00ffff", sfx: "Freeze", school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, nonVolatile: true, onhit: "", time: 1, power: 4, delay: 0, range: 4, speed: 50, size: 1, damage: "inert",
        trailPower: 4, trailLifetime: 1, trailLifetimeBonus: 4, trailTime: 3, trailspawnaoe: 1.5, trailDamage: "ice", trail: "lingering", trailChance: 0.3, trailPlayerEffect: { name: "Freeze", time: 3 } },
    { enemySpell: true, name: "IceDragonBreathPrepare", color: "#00ffff", minRange: 0, sfx: "MagicSlash", school: "Illusion", manacost: 8, components: ["Arms"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 12, range: 5, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
        spellcast: { spell: "IceDragonBreath", target: "target", directional: true, offset: false }, channel: 2 },
    { enemySpell: true, name: "IceSlow", color: "#00ffff", sfx: "Freeze", school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, nonVolatile: true, onhit: "", power: 1, delay: 0, time: 2, range: 4, speed: 50, size: 1, damage: "inert",
        trailPower: 4, trailLifetime: 2, trailLifetimeBonus: 8, trailTime: 3, trailspawnaoe: 1.5, trailDamage: "ice", trail: "lingering", trailChance: 0.5, trailPlayerEffect: { name: "Chill", time: 3, damage: "ice", power: 1 } },
    { enemySpell: true, name: "IceSlowPrepare", color: "#00ffff", minRange: 0, sfx: "MagicSlash", school: "Illusion", manacost: 8, components: ["Arms"], projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 12, range: 5, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert",
        spellcast: { spell: "IceSlow", target: "target", directional: true, offset: false }, channel: 1 },
    { enemySpell: true, name: "FlashBomb", color: "#ff2200", minRange: 0, sfx: "Miss", school: "Illusion", manacost: 3, specialCD: 12, components: ["Verbal"],
        hitColor: 0xffffff, hitLight: 7,
        level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 1, range: 4, size: 3, aoe: 1.5, lifetime: 1, damage: "stun", playerEffect: { name: "Blind", time: 3 } },
    { enemySpell: true, name: "EnemyFlash", color: "#ffffff", minRange: 0, noise: 8, sfx: "FireSpell", school: "Illusion", manacost: 4, components: ["Verbal"], level: 1,
        hitColor: 0xffffff, hitLight: 7,
        type: "inert", onhit: "aoe", time: 3, delay: 1, power: 1, range: 2.5, size: 3, aoe: 1.5, lifetime: 1, damage: "stun", playerEffect: { name: "Blind", time: 4 } },
    { enemySpell: true, name: "SleepGas", color: "#00ff00", sfx: "Miss", school: "Illusion", manacost: 4, specialCD: 24, components: ["Verbal"], level: 1, type: "inert", passthrough: true, noTerrainHit: true, buffs: [
            { id: "SleepGas", type: "Sleepiness", power: 1, player: true, enemies: false, tags: ["sleep"], range: 1.5 }
        ], onhit: "", time: 6, aoe: 1.5, power: 1, delay: 8, range: 4, size: 3, damage: "poison", playerEffect: { name: "DamageNoMsg", damage: "poison", power: 1 } },
    { enemySpell: true, name: "Glue", color: "#ffff00", landsfx: "Freeze", school: "Conjure", manacost: 9, components: ["Legs"], level: 1, type: "inert", onhit: "lingering", time: 4, delay: 1, range: 4, size: 3, aoe: 1.5, lifetime: 24, power: 4, lifetimeHitBonus: 76, damage: "glue", playerEffect: { name: "Glue", count: 1, damage: "glue", power: 4, time: 1 } },
    { enemySpell: true, name: "RedSlime", sfx: "Miss", manacost: 4, specialCD: 15, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "glue", speed: 1.5, playerEffect: { name: "DamageNoMsg", power: 4, damage: "glue" },
        spellcast: { spell: "SummonSingleRedSlime", target: "onhit", directional: false, offset: false, strict: true } },
    { enemySpell: true, name: "AmpuleBlue", sfx: "Miss", manacost: 5, specialCD: 15, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "glue", speed: 1, playerEffect: { name: "AmpuleBlue", damage: "glue", power: 4, count: 1 } },
    { enemySpell: true, name: "AmpuleGreen", sfx: "Miss", manacost: 4, specialCD: 15, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 1, delay: 0, range: 50, damage: "crush", speed: 1, playerEffect: { name: "Ampule", damage: "inert" },
        spellcast: { spell: "SleepGas", target: "onhit", directional: false, offset: false } },
    { enemySpell: true, name: "AmpuleYellow", sfx: "Miss", manacost: 7, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 1, delay: 0, range: 50, damage: "crush", speed: 1, playerEffect: { name: "Ampule", damage: "inert" },
        spellcast: { spell: "Glue", target: "onhit", directional: false, offset: false } },
    { enemySpell: true, name: "AmpuleRed", sfx: "Miss", manacost: 7, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 1, delay: 0, range: 50, damage: "crush", speed: 1, playerEffect: { name: "Ampule", damage: "inert" },
        spellcast: { spell: "SummonRedSlime", target: "onhit", directional: true, offset: false } },
    { name: "ManyOrbs", sfx: "MagicSlash", minRange: 0, manacost: 4, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 3, power: 3, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false, castDuringDelay: true, noCastOnHit: true,
        spellcast: { spell: "ZombieOrbMini", target: "target", directional: true, randomDirection: true, noTargetMoveDir: true, spread: 2.5, offset: false }, channel: 3 },
    { enemySpell: true, name: "ZombieOrbMini", sfx: "MagicSlash", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 1.5, delay: 0, range: 50, damage: "chain", speed: 1,
        playerEffect: { name: "MysticShock", time: 3 } },
    { enemySpell: true, name: "ZombieOrb", sfx: "MagicSlash", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 2, delay: 0, range: 50, damage: "chain", speed: 1,
        playerEffect: { name: "CharmWraps", power: 2, damage: "ice", time: 1 } },
    { enemySpell: true, name: "ZombieOrbIce", color: "#00ffff", specialCD: 12, sfx: "MagicSlash", hitsfx: "Freeze", manacost: 2, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, time: 3, onhit: "", power: 3, delay: 0, range: 50, damage: "ice", speed: 1,
        playerEffect: { name: "Freeze", power: 4, damage: "ice", time: 4 } },
    { enemySpell: true, name: "SarcoEngulf", castCondition: "sarcoEngulf", color: "#ff2200", sfx: "Fwoosh", effectTileDurationMod: 10, effectTileDensity: 0.33, effectTile: {
            name: "FabricGreen",
            duration: 20,
        }, manacost: 3, minRange: 0, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 3, range: 2.5, size: 3, aoe: 1, lifetime: 1, damage: "chain", playerEffect: { name: "SarcoEngulf", power: 2 } },
    { enemySpell: true, name: "SarcoHex", castCondition: "sarcoHex", color: "#ff2200", sfx: "Fwoosh", manacost: 3, minRange: 0, components: ["Verbal"],
        level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 4, range: 2.5, size: 3, aoe: 1, lifetime: 1, damage: "charm", playerEffect: { name: "SarcoHex", power: 2 } },
    { enemySpell: true, name: "RopeEngulf", color: "#ff2200", sfx: "Struggle", effectTileDurationMod: 10, effectTileDensity: 0.33, effectTile: {
            name: "Ropes",
            duration: 20,
        }, manacost: 3, minRange: 0, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 4.5, range: 2, size: 3, aoe: 1, lifetime: 1, damage: "chain", playerEffect: { name: "RopeEngulf", power: 2 } },
    { enemySpell: true, name: "RopeEngulfWeak", color: "#ff2200", sfx: "Struggle", effectTileDurationMod: 10, effectTile: {
            name: "Ropes",
            duration: 20,
        }, manacost: 4, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 3, range: 3.5, size: 3, aoe: 1, lifetime: 1, damage: "chain", playerEffect: { name: "RopeEngulfWeak", power: 1, damage: "chain" } },
    { enemySpell: true, name: "Entangle", color: "#88ff88", minRange: 0, sfx: "Struggle", effectTileDurationMod: 10, effectTileAoE: 1.5, effectTileDensity: 0.5, effectTile: {
            name: "Vines",
            duration: 20,
        }, manacost: 4, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 4, range: 6, size: 3, aoe: 1, lifetime: 1, damage: "chain", playerEffect: { name: "VineEngulf", power: 2 } },
    { enemySpell: true, name: "CrushingFate", color: "#dddddd", minRange: 0, sfx: "MagicSlash", bulletSpin: 0.25,
        manacost: 7, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 4, delay: 6, power: 5, range: 7, size: 5, aoe: 2.5, lifetime: 1, damage: "crush", playerEffect: { name: "MoonBondage", count: 2, kind: "mithrilRestraints" } },
    { enemySpell: true, name: "BoundByFate", color: "#dddddd", minRange: 0, sfx: "MagicSlash", bulletSpin: -0.25,
        manacost: 7, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 4, range: 7, size: 3, aoe: 1.5, lifetime: 1, damage: "soul", playerEffect: { name: "BoundByFate", time: 6 } },
    { enemySpell: true, name: "Feathers", color: "#ffffff", sfx: "Tickle", manacost: 4, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 5, range: 6, size: 3, aoe: 1.5, lifetime: 1, damage: "tickle", playerEffect: { name: "Damage" } },
    { enemySpell: true, name: "NurseBola", color: "#ff2200", sfx: "Miss", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 3, delay: 0, range: 50, damage: "chain", speed: 2, playerEffect: { name: "NurseBola" } },
    { enemySpell: true, name: "NurseSyringe", color: "#ff00ff", minRange: 1.5, sfx: "Miss", manacost: 2, castRange: 6, components: ["Arms"], level: 1, speed: 1,
        type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "pain", playerEffect: { name: "NurseSyringe", power: 4, type: "chain", time: 8 }, },
    { enemySpell: true, name: "RibbonBurst", color: "#ff00ff", sfx: "MagicSlash", manacost: 5, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 4, range: 6, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsRibbons", tags: ["magicRibbons"], power: 3, damage: "chain", count: 2, noGuard: true } },
    { enemySpell: true, name: "Spores", color: "#6733aa", sfx: "MagicSlash", manacost: 4, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 3, range: 6, size: 3, aoe: 1.5, lifetime: 1, damage: "poison", playerEffect: { name: "Spores", power: 2, damage: "poison" } },
    { enemySpell: true, name: "SporesHappy", color: "#ff00ff", sfx: "FireSpell", noCastMsg: true, selfcast: true, manacost: 3, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 1, power: 0.5, range: 3, size: 3, aoe: 1.5, lifetime: 1, damage: "poison", playerEffect: { name: "SporesHappy", power: 2, damage: "poison", distraction: 10 } },
    { enemySpell: true, name: "SporesSick", color: "#55ff55", noCastMsg: true, hitsfx: "DamageWeak", selfcast: true, manacost: 0, components: ["Verbal"], level: 1, type: "hit", onhit: "aoe", time: 5, delay: 0, power: 0.5, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "poison", playerEffect: { name: "SporesSick", power: 2, damage: "poison" } },
    { enemySpell: true, name: "SoulCrystalBind", color: "#ff5277", minRange: 0, sfx: "Evil", manacost: 7, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 2, power: 6, range: 6, size: 3, aoe: 1.5, lifetime: 1, damage: "drain", playerEffect: { name: "ObsidianEngulf", count: 1, power: 6, damage: "drain" } },
    { enemySpell: true, name: "MinerBomb", color: "#ff2200", selfcast: true, noise: 5, sfx: "FireSpell", hitsfx: "FireSpell", school: "Conjure", manacost: 5, components: ["Verbal"], level: 1,
        effectTileDurationMod: 7, effectTile: {
            name: "Smoke",
            duration: -1,
        }, type: "inert", onhit: "aoe", delay: 5, power: 6, range: 3, size: 3, aoe: 1.5, lifetime: 1, damage: "fire", playerEffect: { name: "HeatBlast", time: 3, damage: "pain", power: 6 } },
    { name: "ManyChains", sfx: "MagicSlash", minRange: 0, manacost: 3, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 3, power: 3, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false, castDuringDelay: true, noCastOnHit: true,
        spellcast: { spell: "WitchChainBolt", target: "target", directional: true, randomDirection: true, noTargetMoveDir: true, spread: 1, offset: false }, channel: 3 },
    { enemySpell: true, name: "WitchChainBolt", color: "#ffffff", sfx: "FireSpell", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", bind: 12, time: 6, power: 6, delay: 0, range: 50, damage: "chain", speed: 2, playerEffect: { name: "SingleChain", time: 1 }, effectTileDurationMod: 10, effectTile: {
            name: "Chains",
            duration: 20,
        }, },
    { enemySpell: true, name: "MagicChain", color: "#ff00ff", sfx: "FireSpell", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", time: 6, power: 6, delay: 0, range: 50, damage: "chain", speed: 2, playerEffect: { name: "SingleMagicChain", time: 1 }, effectTileDurationMod: 10, effectTile: {
            name: "Chains",
            duration: 20,
        }, },
    { enemySpell: true, name: "BanditBola", bindType: "Rope", color: "#ff2200", sfx: "Miss", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 1.5, delay: 0, range: 50, damage: "chain", speed: 2, playerEffect: { name: "BanditBola" } },
    { enemySpell: true, name: "WitchRope", bindType: "Rope", color: "#ff2200", sfx: "Miss", effectTileDurationMod: 10, effectTile: {
            name: "Ropes",
            duration: 20,
        }, manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 2, delay: 0, range: 50, damage: "chain", speed: 3, playerEffect: { name: "SingleRope" } },
    { allySpell: true, name: "PlayerBola", bindType: "Rope", fastStart: true, color: "#ff2200", noMiscast: true, sfx: "Miss", manacost: 0, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", time: 4, power: 3, bind: 9, delay: 0, range: 50, damage: "chain", speed: 2, playerEffect: { name: "BanditBola", time: 1 } },
    { enemySpell: true, name: "RestrainingDevice", bindType: "Metal", color: "#19fac1", sfx: "Miss", manacost: 6, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "",
        effectTileDurationMod: 8, effectTile: {
            name: "Chains",
            duration: 10,
        },
        power: 6, delay: 0, range: 4.99, damage: "chain", speed: 1, playerEffect: { name: "RestrainingDevice", count: 3, time: 3, power: 5, damage: "crush" } },
    { enemySpell: true, name: "MiniCable", bindType: "Metal", color: "#19fac1", sfx: "MechLaunch", manacost: 6, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "",
        effectTileDurationMod: 8, effectTile: {
            name: "Chains",
            duration: 10,
        },
        power: 6, delay: 0, range: 4.99, damage: "chain", speed: 1, playerEffect: { name: "RestrainingDevice", count: 1, time: 3, power: 5, damage: "crush" } },
    { enemySpell: true, name: "ManyCables", sfx: "MechEngage", minRange: 0, manacost: 12, color: "#19fac1", projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe",
        time: 5, delay: 3, power: 3, range: 6.99, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false, castDuringDelay: true, noCastOnHit: true,
        spellcast: { spell: "MiniCable", sfx: "MechLaunch", target: "target", directional: true, randomDirection: true, noTargetMoveDir: true, spread: 1, offset: false }, channel: 3 },
    { enemySpell: true, name: "ShadowBolt", bindType: "Slime", color: "#6a15fa", sfx: "Evil", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 3, delay: 0, range: 50, damage: "cold", speed: 2, playerEffect: { name: "ShadowBolt", count: 1, time: 3, power: 3, damage: "cold" } },
    { enemySpell: true, name: "ObsidianBolt", bindType: "Metal", color: "#ff5277", sfx: "Evil", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 3, delay: 0, range: 50, damage: "cold", speed: 2, playerEffect: { name: "ObsidianBolt", count: 1, time: 3, power: 3, damage: "cold" } },
    { enemySpell: true, name: "RubberBolt", bindType: "Slime", color: "#ff3388", sfx: "RubberBolt", manacost: 4, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "glue", speed: 2, playerEffect: { name: "RubberBolt", count: 1, time: 4, power: 4, damage: "glue" } },
    { enemySpell: true, name: "EncaseBolt", bindType: "Slime", color: "#a04abd", sfx: "RubberBolt", manacost: 4, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 2, delay: 0, range: 50, damage: "glue", speed: 2, playerEffect: { name: "EncaseBolt", count: 1, time: 4, power: 2, damage: "glue" } },
    { enemySpell: true, name: "EncaseBoltDrone", bindType: "Slime", color: "#a04abd", sfx: "RubberBolt", manacost: 4, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 1, delay: 0, range: 50, damage: "glue", speed: 2, playerEffect: { name: "EncaseBoltDrone", count: 1, time: 4, power: 1, damage: "glue" } },
    { enemySpell: true, name: "RubberNuke", bindType: "Slime", color: "#ff3388", sfx: "Missile", manacost: 8, components: ["Arms"],
        spellcast: { spell: "RubberNukeExplosion", target: "onhit", directional: true, offset: false },
        events: [{ type: "RubberMissileHoming", trigger: "bulletAfterTick", power: 1.0, dist: 5.5, count: 0.25, limit: 0.7 },],
        level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 12, delay: 0, range: 50, damage: "crush", speed: 0.5, playerEffect: { name: "RubberMissile", count: 4, time: 4, power: 8, damage: "glue" } },
    { enemySpell: true, name: "RubberNukeExplosion", landsfx: "Lightning", bindType: "Slime", school: "Element", manacost: 0, components: [],
        effectTileDurationMod: 3, effectTile: {
            name: "Slime",
            duration: 12,
        },
        level: 1, type: "hit", onhit: "instant", noTerrainHit: true, power: 20, delay: 1, range: 2.5, size: 5, aoe: 2.5, lifetime: 1, damage: "glue" },
    { enemySpell: true, name: "RubberMissile", bindType: "Slime", color: "#ff3388", sfx: "Missile", manacost: 8, components: ["Arms"],
        spellcast: { spell: "RubberMissileExplosion", target: "onhit", directional: true, offset: false },
        events: [{ type: "RubberMissileHoming", trigger: "bulletAfterTick", power: 1.0, dist: 5.5, count: 0.5, limit: 0.7 },],
        level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "crush", speed: 0.5, playerEffect: { name: "RubberMissile", count: 2, time: 4, power: 4, damage: "glue" } },
    { enemySpell: true, name: "RubberMissileExplosion", landsfx: "Lightning", bindType: "Slime", school: "Element", manacost: 0, components: [],
        effectTileDurationMod: 3, effectTile: {
            name: "Slime",
            duration: 12,
        },
        level: 1, type: "hit", onhit: "instant", noTerrainHit: true, power: 1.5, bind: 7, delay: 1, range: 1.5, size: 3, aoe: 1.5, lifetime: 1, damage: "glue" },
    { enemySpell: true, name: "CelestialBolt", bindType: "Rope", color: "#ffff44", sfx: "MagicSlash", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 3, delay: 0, range: 50, damage: "cold", bind: 6, speed: 4, playerEffect: { name: "CelestialBolt", count: 2, time: 3, power: 3, damage: "cold" } },
    { enemySpell: true, name: "WolfCrackle", color: "#8789fd", tags: ["electric", "offense", "aoe"], prerequisite: "Shock", noise: 6, sfx: "Shock", slowStart: true,
        effectTileDurationModTrail: 2, effectTileTrail: {
            name: "Sparks",
            duration: 3,
        },
        school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt", piercing: true, projectileTargeting: true, nonVolatile: true, onhit: "", power: 2.0, delay: 0, time: 1, range: 4, speed: 4, size: 1, damage: "electric",
        trailPower: 0, trailLifetime: 1.1, trailTime: 4, trailDamage: "inert", trail: "lingering", trailChance: 1.0, playerEffect: { name: "Shock", time: 1 } },
    { enemySpell: true, name: "MummyBolt", color: "#88ff88", sfx: "FireSpell", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "fire", speed: 3, playerEffect: { name: "MysticShock", time: 3 } },
    { enemySpell: true, name: "RobotBolt", color: "#ff5277", sfx: "Laser", manacost: 2, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "electric", speed: 2, playerEffect: { name: "RobotShock", time: 2 } },
    { enemySpell: true, name: "RubberBullets", bindType: "Slime", color: "#ffff00", minRange: 2.9, sfx: "Gunfire", manacost: 2, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, time: 0, delay: 0, range: 50, damage: "glue", speed: 3, playerEffect: { name: "RubberBullets", power: 4, count: 1, damage: "glue" } },
    { enemySpell: true, name: "HeatBolt", color: "#ffff00", sfx: "FireSpell", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "fire", speed: 2, playerEffect: { name: "HeatBlast", time: 1, damage: "pain", power: 5 } },
    { enemySpell: true, noFirstChoice: true, name: "Hairpin", color: "#ffffff", minRange: 2.9, sfx: "Miss", manacost: 2, castRange: 6, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "pain", speed: 2, playerEffect: { name: "Hairpin", power: 2, damage: "pain", time: 1 } },
    { enemySpell: true, name: "PoisonDragonBlast", bindType: "Vine", color: "#88ff88", sfx: "FireSpell", hitsfx: "Bones", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "grope", speed: 3, effectTileDurationMod: 10, effectTileAoE: 1.5, effectTileDensity: 0.5, effectTile: {
            name: "Vines",
            duration: 20,
        }, playerEffect: { name: "VineEngulf", power: 2 } },
    { enemySpell: true, name: "ElfArrow", bindType: "Vine", color: "#88ff88", sfx: "Miss", hitsfx: "FireSpell", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 2, delay: 0, range: 50, damage: "fire", speed: 1, playerEffect: { name: "EnchantedArrow", power: 2, count: 1 } },
    { enemySpell: true, name: "ShadowOrb", color: "#8833ff", minRange: 2.9, sfx: "MagicSlash", manacost: 5, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 5, damage: "inert", speed: 2, playerEffect: { name: "" },
        spellcast: { spell: "ShadowScythe", target: "onhit", directional: true, offset: false } },
    { enemySpell: true, name: "ShadowScythe", color: "#0000ff", sfx: "MagicSlash", manacost: 4, components: ["Verbal"], level: 1, type: "inert", noTerrainHit: true, onhit: "aoe", time: 5, delay: 1, power: 6, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "ShadowBind", time: 4 } },
    { enemySpell: true, name: "WitchSlime", bindType: "Slime", color: "#ff00ff", minRange: 0, landsfx: "MagicSlash", manacost: 7, components: ["Legs"], level: 1, type: "inert", onhit: "lingering",
        time: 2, delay: 1, range: 4, power: 2, size: 3, aoe: 1, lifetime: 1, lifetimeHitBonus: 9, damage: "glue", playerEffect: { name: "SlimeTrap", time: 3 },
        effectTileDurationModLinger: 8, effectTileLinger: {
            name: "Slime",
            duration: 10,
        }, },
    { enemySpell: true, name: "RubberSlime", bindType: "Slime", color: "#ff00ff", minRange: 0, landsfx: "MagicSlash", manacost: 7, components: ["Legs"], level: 1, type: "inert", onhit: "lingering",
        time: 2, delay: 1, range: 4, power: 2, size: 3, aoe: 1, lifetime: 1, lifetimeHitBonus: 9, damage: "glue", playerEffect: { name: "EncaseBolt", count: 1, time: 4, power: 5, damage: "glue" },
        effectTileDurationModLinger: 8, effectTileLinger: {
            name: "Slime",
            duration: 10,
        }, },
    { enemySpell: true, name: "WitchSlimeBall", bindType: "Slime", color: "#ff00ff", sfx: "FireSpell", manacost: 6, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "",
        time: 2, power: 2, delay: 0, range: 50, damage: "glue", speed: 1, trailLifetime: 10, trailDamage: "glue", trail: "lingering", trailPower: 2, trailChance: 1.0, playerEffect: { name: "Slime", time: 3 },
        effectTileDurationModTrail: 4, effectTileTrail: {
            name: "Slime",
            duration: 4,
        }
    },
    { enemySpell: true, name: "SlimePuddle", bindType: "Slime", color: "#ff00ff", sfx: "FireSpell", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "lingering",
        time: 2, power: 2, lifetime: 5, lifetimeHitBonus: 5, aoe: 1.5, delay: 0, range: 50, damage: "glue", speed: 1, playerEffect: { name: "SlimeTrap", time: 3 },
        effectTileDurationModLinger: 8, effectTileLinger: {
            name: "Slime",
            duration: 10,
        },
    },
    { enemySpell: true, name: "MiniSlime", color: "#ff00ff", sfx: "MagicSlash", landsfx: "MagicSlash", manacost: 1, level: 1, type: "bolt", projectileTargeting: true, onhit: "",
        time: 2, power: 2, delay: 0, range: 50, damage: "glue", speed: 1, playerEffect: { name: "MiniSlime", time: 2 },
        effectTileDurationMod: 8, effectTile: {
            name: "Slime",
            duration: 10,
        }, },
    { enemySpell: true, name: "ManySlimes", sfx: "MagicSlash", minRange: 0, manacost: 4, projectileTargeting: true, noTargetPlayer: true, CastInWalls: true, level: 1, type: "inert", onhit: "aoe", time: 5, delay: 3, power: 3, range: 8, meleeOrigin: true, size: 1, lifetime: 1, damage: "inert", noMiscast: false, castDuringDelay: true, noCastOnHit: true,
        spellcast: { spell: "MiniSlime", target: "target", directional: true, randomDirection: true, noTargetMoveDir: true, spread: 1, offset: false }, channel: 3 },
    { enemySpell: true, name: "PoisonDagger", color: "#ff00ff", minRange: 1.5, sfx: "Miss", manacost: 2, castRange: 6, components: ["Arms"], level: 1, speed: 1,
        type: "bolt", projectileTargeting: true, onhit: "", power: 4, delay: 0, range: 50, damage: "poison", playerEffect: { name: "PoisonDagger", power: 4, type: "poison", time: 8 }, },
    { enemySpell: true, name: "LustBomb", color: "#ff5277", minRange: 0, sfx: "Miss", school: "Illusion", manacost: 2, specialCD: 12, components: ["Verbal"], level: 1, type: "inert", onhit: "aoe", time: 5, delay: 3, power: 2.5, range: 4, size: 3, aoe: 1.5, lifetime: 1, damage: "charm", playerEffect: { name: "LustBomb", damage: "charm", power: 3.5 } },
    { enemySpell: true, name: "CrystalPuff", color: "#b37bdc", minRange: 0, landsfx: "MagicSlash", manacost: 4, components: ["Arms"], level: 1, type: "inert", onhit: "aoe", power: 3.5, time: 1, delay: 1, range: 4, size: 1, aoe: 0.75, lifetime: 1, damage: "souldrain", playerEffect: { name: "CrystalBind", time: 1 } },
    { enemySpell: true, name: "HighBolt", color: "#8888ff", sfx: "MagicSlash", manacost: 3, specialCD: 7, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "",
        power: 6, delay: 0, range: 50, damage: "poison", speed: 1, playerEffect: { name: "Flummox", time: 1, damage: "poison", power: 6 } },
    { enemySpell: true, name: "WitchElectrify", color: "#8888ff", minRange: 0, landsfx: "Shock", manacost: 5,
        effectTileDurationMod: 2, effectTile: {
            name: "Sparks",
            duration: 3,
        },
        components: ["Arms"], level: 1, type: "inert", onhit: "aoe", power: 3.5, time: 1, delay: 1, range: 4, size: 1, aoe: 0.75, lifetime: 1, damage: "electric", playerEffect: { name: "Shock", time: 1 } },
    { enemySpell: true, name: "WitchElectricOrb", color: "#8888ff", sfx: "MagicSlash", manacost: 4, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 0, delay: 0, range: 5, damage: "electric", speed: 1, playerEffect: { name: "" },
        spellcast: { spell: "WitchElectricBurst", target: "onhit", directional: true, offset: false } },
    { enemySpell: true, name: "WitchElectricBurst", sfx: "Shock", manacost: 4, components: ["Verbal"], level: 1, type: "hit",
        effectTileDurationMod: 2, effectTile: {
            name: "Sparks",
            duration: 3,
        },
        noTerrainHit: true, onhit: "aoe", time: 5, delay: 1, power: 4, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "electric", playerEffect: { name: "Shock", time: 1 } },
    { enemySpell: true, name: "WitchWaterBall", color: "#4f7db8", tags: ["water", "bolt", "offense", "utility"], sfx: "FireSpell", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "buff",
        power: 3.0, delay: 0, range: 50, damage: "acid", speed: 3, playerEffect: { name: "Drench" },
        buffs: [
            Object.assign({}, KDDrenched),
            Object.assign({}, KDDrenched2),
            Object.assign({}, KDDrenched3),
        ],
        effectTileDurationMod: 40, effectTile: {
            name: "Water",
            duration: 40,
        },
    },
    { enemySpell: true, name: "WitchIcebolt", color: "#92e8c0", tags: ["ice", "bolt", "offense"], sfx: "MagicSlash", hitsfx: "Freeze", school: "Elements", manacost: 4, components: ["Arms"], level: 1, type: "bolt",
        effectTileDurationMod: 10, effectTile: {
            name: "Ice",
            duration: 20,
        },
        projectileTargeting: true, onhit: "", time: 4, power: 3.5, delay: 0, range: 50, damage: "frost", speed: 2, playerEffect: { name: "Chill", damage: "ice", power: 3, time: 3 },
        events: [{ type: "ElementalOnSlowOrBindOrDrench", trigger: "bulletHitEnemy", damage: "ice", time: 4, power: 0 },] },
    { enemySpell: true, name: "WitchBoulder", sfx: "Bones", hitsfx: "HeavySwing", school: "Elements", manacost: 3, components: ["Arms"], level: 1, type: "bolt", projectileTargeting: true, onhit: "", block: 8, time: 4, power: 4, delay: 0, range: 50, damage: "crush", speed: 2, playerEffect: { name: "WitchBoulder", time: 2 } },
    { enemySpell: true, name: "SummonSlimeMold", noSprite: true, minRange: 0, sfx: "Bones", manacost: 8, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "SlimeMold", count: 1, strict: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 1, aoe: 1.5, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonSkeleton", landsfx: "Bones", minRange: 0, manacost: 8, components: ["Verbal"], level: 3, type: "inert", onhit: "summon", summon: [{ name: "SummonedSkeleton", count: 1, time: 12, strict: true, bound: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 4, size: 3, aoe: 2.1, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "SummonSkeletons", landsfx: "Bones", minRange: 0, manacost: 18, components: ["Verbal"], level: 4, type: "inert", onhit: "summon", summon: [{ name: "SummonedSkeleton", count: 4, time: 16, strict: true, bound: true, weakBinding: true }], power: 0, time: 16, delay: 1, range: 4, size: 3, aoe: 2.6, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "SummonZombies", landsfx: "Bones", specialCD: 16, minRange: 0, manacost: 4, components: ["Verbal"], level: 4, type: "inert", onhit: "summon", summon: [{ name: "SummonedZombie", count: 4, strict: true, minRange: 1.5, bound: true, weakBinding: true }], power: 0, time: 16, delay: 1, range: 4, size: 3, aoe: 4.6, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "SummonDrones", landsfx: "Teleport", specialCD: 12, selfcast: true, minRange: 0, manacost: 4, components: ["Verbal"], level: 4, type: "inert", onhit: "summon",
        summon: [{ name: "SummonedDrone", count: 2, strict: true, bound: true, time: 16, faction: "Ambush" }], power: 0, time: 15, delay: 3, range: 8, size: 3, aoe: 4.6, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "SummonCaptureDrones", landsfx: "Teleport", specialCD: 7, minRange: 0, manacost: 4, components: ["Verbal"], level: 4, type: "inert", onhit: "summon",
        summon: [{ name: "SummonedCaptureDrone", count: 2, strict: true, bound: true, time: 17, faction: "Ambush" }], power: 0, time: 15, delay: 3, range: 14, size: 3, aoe: 4.6, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "RopeAttack", hitsfx: "Struggle", manacost: 6, components: ["Verbal"], level: 4, type: "hit", onhit: "null", noSprite: true, noSumMsg: true, summon: [
            { name: "LearnedRope", count: 1, chance: 0.5, time: 20, strict: true, bound: true },
            { name: "UnforseenRope", count: 1, chance: 0.5, time: 20, strict: true, bound: true }
        ], power: 0, time: 12, delay: 1, range: 8, size: 3, aoe: 10, lifetime: 1, damage: "fire" },
    { enemySpell: true, name: "SummonCrystals", noSprite: true, minRange: 0, landsfx: "Freeze", manacost: 12, components: ["Verbal"], level: 4, type: "inert", onhit: "summon", summon: [{ name: "ChaoticCrystal", count: 3, time: 10, bound: true, weakBinding: true }], power: 0, time: 10, delay: 1, range: 40, size: 1, aoe: 2.01, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "SummonChainWalls", noSprite: true, minRange: 0, landsfx: "MagicSlash", manacost: 2, specialCD: 12, components: ["Verbal"], level: 4, type: "inert", onhit: "summon", summon: [{ name: "ChainWall", count: 3, time: 0, bound: true, weakBinding: true }], power: 0, time: 10, delay: 1, range: 40, size: 1, aoe: 3.5, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "SummonForceFields", noSprite: true, minRange: 0, landsfx: "MagicSlash", manacost: 2, specialCD: 12, components: ["Verbal"], level: 4, type: "inert", onhit: "summon", summon: [{ name: "ForceField", count: 3, time: 0, bound: true, weakBinding: true }], power: 0, time: 10, delay: 1, range: 40, size: 1, aoe: 3.5, lifetime: 1, damage: "inert" },
    { enemySpell: true, name: "SummonTickleHand", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 12, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "TickleHand", count: 3, time: 12, bound: true, weakBinding: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 3, aoe: 2.6, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonShadowHand", noSprite: true, minRange: 0, sfx: "Evil", castCondition: "shadowHand3count", manacost: 8, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "ShadowHand", count: 1, time: 40, bound: true, weakBinding: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 3, aoe: 2.6, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonMikoGhosts", noSprite: true, minRange: 0, specialCD: 20, sfx: "MagicSlash", manacost: 4, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "MikoGhost", count: 8, minRange: 8, bound: true, weakBinding: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 3, aoe: 12.9, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonSingleTickleHand", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 6, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "TickleHand", count: 1, time: 12, bound: true, weakBinding: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 3, aoe: 2.6, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonEnemyGag", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 6, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "Gag", count: 1, time: 12, bound: true, weakBinding: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 3, aoe: 2.6, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonCuff", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 6, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "Cuffs", count: 1, time: 12, bound: true, weakBinding: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 3, aoe: 2.6, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonLock", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 6, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "Lock", count: 1, time: 12, bound: true, weakBinding: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 3, aoe: 2.6, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonRedSlime", noSprite: true, minRange: 0, sfx: "Freeze", manacost: 8, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "RedSlime", count: 1, time: 12, strict: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 1, aoe: 2.01, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonSingleRedSlime", noSprite: true, minRange: 0, sfx: "Freeze", manacost: 12, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "RedSlime", count: 1, time: 12, strict: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 1, aoe: 1.5, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonLatexElemental", noSprite: true, sfx: "MagicSlash", manacost: 6, specialCD: 40, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "ElementalLatex", count: 1, time: 40, bound: true }], power: 0, damage: "inert", time: 12, delay: 1, range: 0.5, size: 1, aoe: 1.5, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonWolfDrone", noSprite: true, sfx: "MagicSlash", castCondition: "wolfDrone", manacost: 3, specialCD: 10, components: ["Verbal"], level: 1, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "WolfDrone", count: 1, time: 40, bound: true }], power: 0, damage: "inert", time: 34, delay: 1, range: 0.5, size: 1, aoe: 1.5, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "SummonRopeTentacle", noSprite: true, sfx: "MagicSlash", castCondition: "ropeKraken", manacost: 2, specialCD: 4, components: ["Verbal"], level: 1,
        projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "RopeMinion", count: 1, bound: true }],
        power: 0, damage: "inert", time: 34, delay: 1, range: 0.5, size: 1, aoe: 1.5, lifetime: 1, speed: 1, playerEffect: {},
    },
    { enemySpell: true, name: "SummonSarcoTentacle", noSprite: true, sfx: "Evil", castCondition: "sarcoKraken", manacost: 2, specialCD: 4, components: ["Verbal"], level: 1,
        projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "SarcoMinion", count: 1, bound: true }],
        power: 0, damage: "inert", time: 34, delay: 1, range: 0.5, size: 1, aoe: 1.5, lifetime: 1, speed: 1, playerEffect: {},
    },
    { enemySpell: true, name: "SummonTapeDrone", noSprite: true, sfx: "MagicSlash", castCondition: "wolfTapeDrone", manacost: 3, specialCD: 10, components: ["Verbal"], level: 1, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "WolfDrone", count: 1, time: 40, bound: true }], power: 0, damage: "inert", time: 34, delay: 1, range: 0.5, size: 1, aoe: 1.5, lifetime: 1, speed: 1, playerEffect: {} },
    { enemySpell: true, name: "MirrorImage", noSprite: true, minRange: 0, selfcast: true, sfx: "FireSpell", manacost: 12, components: ["Verbal"], level: 4, castRange: 50, type: "inert", onhit: "summon", summon: [{ name: "MaidforceStalkerImage", count: 1, time: 12 }], power: 0, time: 12, delay: 1, range: 2.5, size: 3, aoe: 1.5, lifetime: 1, damage: "inert",
        spellcast: { spell: "DarkShroud", target: "origin", directional: false, offset: false } },
    { enemySpell: true, name: "SummonBookChain", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 12, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookChain", bound: true, count: 3, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, name: "SummonBookNature", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 8, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookNature", bound: true, count: 2, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, name: "SummonBookElectric", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 8, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookElectric", bound: true, count: 1, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, name: "SummonBookIce", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 12, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookIce", bound: true, count: 3, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, name: "SummonBookCelestial", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 12, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookCelestial", bound: true, count: 3, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, name: "SummonBookArcane", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 12, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookArcane", bound: true, count: 3, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, name: "SummonBookForbidden", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 12, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookForbidden", bound: true, count: 3, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, name: "SummonBookSlime", noSprite: true, minRange: 0, sfx: "MagicSlash", manacost: 8, components: ["Verbal"], level: 4, projectileTargeting: true, castRange: 50, type: "bolt", onhit: "summon", summon: [{ name: "BookSlime", bound: true, count: 2, time: 12, strict: true, weakBinding: true }], power: 0, time: 12, delay: 1, range: 0.5, size: 3, aoe: 3, lifetime: 1, speed: 1 },
    { enemySpell: true, selfcast: true, buff: true, minRange: 0, name: "ArmorUp", sfx: "Bones", school: "Elements", manacost: 8, components: ["Arms"], mustTarget: true, level: 1, type: "buff", buffs: [{ id: "ArmorUp", type: "Armor", duration: 6, power: 1.0, player: true, enemies: true, tags: ["defense", "armor"] }], onhit: "", time: 6, power: 0, range: 2, size: 1, damage: "" },
    { enemySpell: true, selfcast: true, buff: true, minRange: 0, name: "ArmorUpArea", sfx: "MagicSlash", school: "Elements", manacost: 8, components: ["Arms"], mustTarget: true, level: 1,
        type: "buff", buffs: [{ id: "ArmorUpArea", type: "Armor", duration: 6, power: 2.0, player: false, enemies: true, tags: ["defense", "armor"] }], onhit: "", time: 6, power: 0, range: 2.9, aoe: 2.9, size: 1, damage: "" },
    { enemySpell: true, selfcast: true, buff: true, minRange: 0, name: "SpellArmorUpAreaNevermere", sfx: "MagicSlash", school: "Elements", manacost: 8, components: ["Arms"], mustTarget: true, level: 1, filterTags: ["wolfPet", "robot"],
        type: "buff", buffs: [
            { id: "SpellArmorUpAreaNevermere", type: "SpellResist", duration: 6, power: 2.0, player: false, enemies: true, tags: ["defense", "spellresist"] },
            { id: "ArmorUpAreaNevermere", type: "Armor", duration: 6, power: 1.5, player: false, enemies: true, tags: ["defense", "armor"] }
        ], onhit: "", time: 6, power: 0, range: 4.9, aoe: 4.9, size: 1, damage: "" },
    { enemySpell: true, selfcast: true, buff: true, minRange: 0, name: "NevermereBoost", sfx: "MagicSlash", school: "Elements", manacost: 4, specialCD: 18, components: ["Arms"], mustTarget: true, level: 1, filterTags: ["wolfSub"],
        type: "buff", buffs: [
            { id: "NevermereBoost", aura: "#ffaaaa", type: "MoveSpeed", duration: 10, power: 1.0, player: false, enemies: true, tags: ["offense", "speed"] },
            { id: "NevermereBoost2", type: "Evasion", duration: 6, power: 0.3, player: false, enemies: true, tags: ["offense", "evasion"] },
            { id: "NevermereBoost3", type: "AttackSpeed", duration: 6, power: 0.5, player: false, enemies: true, tags: ["offense", "attackspeed"] },
        ], onhit: "", time: 6, power: 0, range: 4.9, aoe: 4.9, size: 1, damage: "" },
    { enemySpell: true, selfcast: true, buff: true, minRange: 0, name: "DollBoost", sfx: "MagicSlash", school: "Elements", manacost: 4, specialCD: 18, components: ["Arms"], mustTarget: true, level: 1, filterTags: ["smithdoll"],
        type: "buff", buffs: [
            { id: "NevermereBoost", aura: "#ffaaaa", type: "MoveSpeed", duration: 10, power: 1.0, player: false, enemies: true, tags: ["offense", "speed"] },
            { id: "NevermereBoost2", type: "Evasion", duration: 6, power: 0.3, player: false, enemies: true, tags: ["offense", "evasion"] },
            { id: "NevermereBoost3", type: "AttackSpeed", duration: 6, power: 0.5, player: false, enemies: true, tags: ["offense", "attackspeed"] },
        ], onhit: "", time: 6, power: 0, range: 4.9, aoe: 4.9, size: 1, damage: "" },
    { name: "DollConvert", tags: ["dummy"], sfx: "Dollify", school: "Illusion", manacost: 0, components: [], level: 1, type: "special", special: "DollConvert", noMiscast: true, castCondition: "dollConvert",
        onhit: "", time: 5, power: 0, range: 5.5, aoe: 5.5, size: 1, damage: "" },
    { name: "DollConvertMany", tags: ["dummy"], sfx: "Dollify", school: "Illusion", manacost: 0, components: [], level: 1, type: "special", special: "DollConvert", noMiscast: true, castCondition: "dollConvert",
        onhit: "", time: 5, power: 0, range: 5.5, aoe: 5.5, size: 1, damage: "" },
    { enemySpell: true, buff: true, name: "ParasolBuff", minRange: 0, sfx: "MagicSlash", school: "Elements", manacost: 4, components: ["Arms"], mustTarget: true, level: 3, type: "buff",
        buffs: [
            { id: "ParasolBuff", type: "Armor", duration: 5, power: 1.0, player: false, enemies: true, tags: ["defense", "armor"] },
            { id: "ParasolBuff2", type: "Evasion", duration: 5, power: 0.33, player: false, enemies: true, tags: ["defense", "evasion"] },
            { id: "ParasolBuff3", type: "SpellResist", duration: 5, power: 2.5, player: false, enemies: true, tags: ["defense", "spellresist"] },
        ], onhit: "", time: 5, power: 0, range: 6, size: 1, damage: "" },
    { enemySpell: true, commandword: true, buff: true, buffallies: true, castCondition: "commandword", name: "EnemyCM1", minRange: 0, sfx: "MagicSlash", school: "Elements", manacost: 4, components: ["Arms"], mustTarget: true, level: 3, type: "special", special: "Enemy_CM1",
        onhit: "", time: 5, power: 0, range: 6, size: 1, damage: "", noCastMsg: true },
    { enemySpell: true, commandword: true, buff: true, buffallies: true, selfbuff: true, castCondition: "commandword", name: "EnemyCM_self", minRange: 0, sfx: "MagicSlash", school: "Elements", manacost: 4, components: ["Arms"], mustTarget: true, level: 3, type: "special", special: "Enemy_CM1",
        onhit: "", time: 5, power: 0, range: 6, size: 1, damage: "", noCastMsg: true },
    { enemySpell: true, buff: true, name: "ZombieBuff", minRange: 0, sfx: "MagicSlash", school: "Elements", manacost: 4, components: ["Arms"], mustTarget: true, level: 3, type: "buff", filterTags: ["zombie", "mummy"],
        buffs: [
            { id: "ZombieBuff", type: "Armor", duration: 8, power: 2.0, player: false, enemies: true, tags: ["defense", "armor"] },
            { id: "ZombieBuff2", type: "MoveSpeed", duration: 8, power: 2.1, player: false, enemies: true, tags: ["offense", "speed"] },
        ], onhit: "", time: 5, power: 0, range: 6, size: 1, damage: "" },
    { enemySpell: true, buff: true, heal: true, name: "OrbHeal", minRange: 0, sfx: "MagicSlash", school: "Elements", manacost: 1, components: ["Arms"], mustTarget: true, level: 3, type: "hit",
        onhit: "heal", time: 2, lifetime: 1, delay: 1, power: 2, aoe: 1.5, range: 8, size: 3, damage: "inert" },
    { enemySpell: true, name: "Earthfield", selfcast: true, sfx: "Bones", school: "Illusion", manacost: 5, components: ["Verbal"], level: 1, type: "inert", buffs: [{ id: "Earthfield", type: "Armor", power: 2.0, player: false, enemies: true, noAlly: true, tags: ["armor", "defense"], range: 1.5 }], onhit: "", time: 6, aoe: 1.5, power: 0, delay: 8, range: 4, size: 3, damage: "" },
    { name: "Earthrune", selfcast: true, sfx: "Bones", school: "Illusion", manacost: 5, components: ["Verbal"], level: 1, type: "inert", buffs: [{ id: "Earthfield", type: "Armor", power: 2.0, player: true, enemies: true, onlyAlly: true, tags: ["armor", "defense"], range: 1.5 }], onhit: "", time: 9, aoe: 1.5, power: 0, delay: 9, range: 4, size: 3, damage: "" },
    { name: "Icerune", sfx: "MagicSlash", hitsfx: "Freeze", school: "Elements", manacost: 8, components: ["Verbal"], level: 1, type: "inert", onhit: "lingering", time: 1, delay: 1, range: 3, size: 3, aoe: 1.5, lifetime: 5, power: 4, lifetimeHitBonus: 3, damage: "ice" },
    { name: "Waterrune", selfcast: true, sfx: "Bones", school: "Illusion", manacost: 5, components: ["Verbal"], level: 1, type: "inert",
        buffs: [
            { id: "WaterRune", type: "SpellResist", power: 3.0, player: true, enemies: true, onlyAlly: true, tags: ["spellresist", "defense"], range: 1.5 },
            { id: "WaterRune2", type: "MoveSpeed", power: -1.0, player: false, enemies: true, noAlly: true, tags: ["slow", "debuff"], range: 1.5 },
        ], onhit: "", time: 9, aoe: 1.5, power: 0, delay: 9, range: 4, size: 3, damage: "" },
    { enemySpell: true, name: "TrapCharmWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsCharmWeak", tags: ["ribbonRestraints"], count: 4 } },
    { enemySpell: true, name: "TrapRibbons", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 4, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsRibbons", tags: ["magicRibbons"], count: 3 } },
    { enemySpell: true, name: "TrapShackleWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsShackleWeak", tags: ["shackleRestraints"], count: 2 } },
    { enemySpell: true, name: "TrapMummyWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsMummyWeak", tags: ["mummyRestraints"], count: 2 } },
    { enemySpell: true, name: "TrapRopeWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsRopeWeak", tags: ["ropeMagicWeak", "clothRestraints"], count: 3 } },
    { enemySpell: true, name: "TrapRopeStrong", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsRopeStrong", tags: ["ropeMagicStrong", "ropeAuxiliary", "clothRestraints", "tapeRestraints"], count: 4 } },
    { enemySpell: true, name: "TrapRopeHoly", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "cold", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsRopeHoly", tags: ["celestialRopes"], count: 2 } },
    { enemySpell: true, name: "TrapLeatherWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsLeatherWeak", tags: ["leatherRestraints", "leatherRestraintsHeavy"], count: 3 } },
    { enemySpell: true, name: "TrapCableWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsCableWeak", tags: ["hitechCables"], count: 3 } },
    { enemySpell: true, name: "TrapSlimeWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "glue", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsSlimeWeak", tags: ["slimeRestraints"], count: 2 } },
    { enemySpell: true, name: "TrapMagicChainsWeak", sfx: "Struggle", manacost: 4, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "chain", playerEffect: { name: "TrapBindings", text: "KinkyDungeonTrapBindingsMagicChainsWeak", tags: ["chainRestraintsMagic"], count: 3 } },
    { nonmagical: true, enemySpell: true, name: "TrapSleepDart", sfx: "Gunfire", manacost: 1, components: [], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, time: 0, delay: 0, range: 50, damage: "pain", speed: 2, playerEffect: { name: "TrapSleepDart", power: 5 } },
    { enemySpell: true, name: "TrapLustCloud", sfx: "Freeze", manacost: 1, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "glue", playerEffect: { name: "TrapLustCloud", damage: "happygas", power: 8 } },
    { enemySpell: true, name: "TrapSCloud", sfx: "Freeze", manacost: 1, components: [], level: 1, type: "inert", onhit: "aoe", passthrough: true, noTerrainHit: true, time: 5, delay: 1, power: 3, range: 2, size: 3, aoe: 1.5, lifetime: 1, damage: "glue", playerEffect: { name: "TrapSPCloud", damage: "pain", power: 5.0 } },
    { nonmagical: true, enemySpell: true, name: "SleepDart", sfx: "Miss", manacost: 1, components: [], level: 1, type: "bolt", projectileTargeting: true, onhit: "", power: 4, time: 0, delay: 0, range: 50, damage: "pain", speed: 1, playerEffect: { name: "TrapSleepDart", power: 5 } },
];
let KDSpecialBondage = {
    "Leather": {
        priority: 0,
        color: "#ad2f45",
        struggleRate: 1.0,
        powerStruggleBoost: 1.0,
        healthStruggleBoost: 1.0,
    },
    "Rope": {
        priority: -3,
        color: "#ffae70",
        struggleRate: 2.0,
        powerStruggleBoost: 1.0,
        healthStruggleBoost: 1.0,
    },
    "Metal": {
        priority: 10,
        color: "#aaaaaa",
        struggleRate: 0.5,
        powerStruggleBoost: 0.25,
        healthStruggleBoost: 1.5,
    },
    "Slime": {
        priority: -10,
        color: "#f23db7",
        struggleRate: 1.5,
        powerStruggleBoost: 2.0,
        healthStruggleBoost: 0.75,
    },
    "Tape": {
        priority: -5,
        color: "#3454f4",
        struggleRate: 1.35,
        powerStruggleBoost: 0.75,
        healthStruggleBoost: 1.5,
    },
    "Vine": {
        priority: -7,
        color: "#00ff00",
        struggleRate: 1.25,
        powerStruggleBoost: 2.0,
        healthStruggleBoost: 1.0,
    },
    "Ice": {
        priority: -15,
        color: "#00ffff",
        struggleRate: 0.6,
        powerStruggleBoost: 3.0,
        healthStruggleBoost: 0.7,
    },
};
let KDMagicDefs = {
    RopeKraken_TentacleCost: 0.05,
    RopeKraken_TentacleThreshold: 0.16,
    RopeKraken_TentacleCountMin: 1,
    RopeKraken_TentacleCountShare: 0.29,
    SarcoKraken_TentacleCost: 0.00,
    SarcoKraken_TentacleThreshold: 0.05,
    SarcoKraken_TentacleCountMin: 1,
    SarcoKraken_TentacleCountMax: 3,
    SarcoKraken_TentacleCountShare: 0.2,
};
let KDCastConditions = {
    "commandword": (enemy, target) => {
        if (KDEnemyHasFlag(enemy, "commandword"))
            return false;
        return KDEntityHasBuffTags(target, "commandword");
    },
    "dollConvert": (enemy, target, spell) => {
        if (KDNearbyEnemies(enemy.x, enemy.y, spell.range).filter((en) => { var _a; return (_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.smithdoll; }).length > 3 || KDNearbyEnemies(enemy.x, enemy.y, spell.aoe).filter((en) => { var _a; return !en.allied && ((_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.dollmakerconvert); }).length < 1)
            return false;
        return true;
    },
    "dollConvertMany": (enemy, target, spell) => {
        if (KDNearbyEnemies(enemy.x, enemy.y, spell.range).filter((en) => { var _a; return (_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.smithdoll; }).length > 8 || KDNearbyEnemies(enemy.x, enemy.y, spell.aoe).filter((en) => { var _a; return !en.allied && ((_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.dollmakerconvert); }).length < 1)
            return false;
        return true;
    },
    "wolfDrone": (enemy, target) => {
        if (KDNearbyEnemies(enemy.x, enemy.y, 10).filter((en) => { var _a; return (_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.wolfdrone; }).length > 3)
            return false;
        return true;
    },
    "wolfTapeDrone": (enemy, target) => {
        if (KDNearbyEnemies(enemy.x, enemy.y, 10).filter((en) => { var _a; return (_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.wolfdrone; }).length > 3)
            return false;
        return true;
    },
    "shadowHand3count": (enemy, target) => {
        if (KDNearbyEnemies(enemy.x, enemy.y, 10).filter((en) => { var _a; return ((_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.name) == "ShadowHand"; }).length > 3)
            return false;
        return true;
    },
    "ropeKraken": (enemy, target) => {
        if (enemy.hp <= (KDMagicDefs === null || KDMagicDefs === void 0 ? void 0 : KDMagicDefs.RopeKraken_TentacleThreshold))
            return false;
        if (KDNearbyEnemies(enemy.x, enemy.y, 10).filter((en) => { var _a; return (_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.krakententacle; }).length
            > (KDMagicDefs === null || KDMagicDefs === void 0 ? void 0 : KDMagicDefs.RopeKraken_TentacleCountMin) + Math.floor(enemy.hp / enemy.Enemy.maxhp / (KDMagicDefs === null || KDMagicDefs === void 0 ? void 0 : KDMagicDefs.RopeKraken_TentacleCountShare)))
            return false;
        return true;
    },
    "sarcoKraken": (enemy, target) => {
        if (target.player) {
            if (KinkyDungeonPlayerTags.get("Sarcophagus"))
                return false;
            let restraint = KinkyDungeonGetRestraint({ tags: ["mummyRestraints"] }, 100, "tmb");
            if (!restraint)
                return false;
        }
        if (enemy.hp <= (KDMagicDefs === null || KDMagicDefs === void 0 ? void 0 : KDMagicDefs.SarcoKraken_TentacleThreshold))
            return false;
        if (KDNearbyEnemies(enemy.x, enemy.y, 10).filter((en) => { var _a; return (_a = en.Enemy) === null || _a === void 0 ? void 0 : _a.tags.sarcotentacle; }).length
            > Math.min((KDMagicDefs === null || KDMagicDefs === void 0 ? void 0 : KDMagicDefs.SarcoKraken_TentacleCountMax) - 1, (KDMagicDefs === null || KDMagicDefs === void 0 ? void 0 : KDMagicDefs.SarcoKraken_TentacleCountMin) + Math.floor(enemy.hp / enemy.Enemy.maxhp / (KDMagicDefs === null || KDMagicDefs === void 0 ? void 0 : KDMagicDefs.SarcoKraken_TentacleCountShare))))
            return false;
        return true;
    },
    "sarcoEngulf": (enemy, target) => {
        if (target.player && !KinkyDungeonPlayerTags.get("Sarcophagus")) {
            let restraint = KinkyDungeonGetRestraint({ tags: ["mummyRestraints"] }, 100, "tmb");
            if (!restraint)
                return false;
            return true;
        }
        return false;
    },
    "sarcoHex": (enemy, target) => {
        if (target.player && !KinkyDungeonPlayerTags.get("Sarcophagus")) {
            let restraint = KinkyDungeonGetRestraint({ tags: ["mummyRestraints"] }, 100, "tmb");
            if (!restraint)
                return true;
            return false;
        }
        return false;
    },
};
let KDPlayerEffects = {
    "EnvDamage": (target, damage, playerEffect, spell, faction, bullet) => {
        let dmg = KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
        KinkyDungeonSendTextMessage(Math.min(playerEffect.power, 5), TextGet("KinkyDungeonDamageSelf").replace("DamageDealt", dmg.string), "#ff0000", 1);
        if (dmg.happened)
            return { sfx: undefined, effect: true };
        return { sfx: undefined, effect: false };
    },
    "MaidChastity": (target, damage, playerEffect, spell, faction, bullet) => {
        if (KinkyDungeonFlags.get("ChastityBelts")) {
        }
        else {
            let restrained = false;
            for (let i = 0; i < 4; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["maidVibeRestraints"] }, MiniGameKinkyDungeonLevel + (playerEffect.level || 0), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, playerEffect.tightness || 0, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "maidhead");
                    restrained = true;
                }
            }
            if (restrained)
                KinkyDungeonSendTextMessage(8, TextGet("KDMaidforceHeadBelting"), "#ff5555", 2, false, true);
            return { sfx: "LockHeavy", effect: restrained };
        }
        return { sfx: undefined, effect: false };
    },
    "ShadowBolt": (target, damage, playerEffect, spell, faction, bullet) => {
        KDPlayerEffectRestrain(spell, playerEffect.count, ["shadowHands"], "Ghost");
        KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonShadowBolt"), "yellow", playerEffect.time);
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Evil", effect: true };
    },
    "BearTrapStun": (target, damage, playerEffect, spell, faction, bullet) => {
        KDStunTurns(playerEffect.time);
        KinkyDungeonSendTextMessage(4, TextGet("KDBearTrapHit"), "yellow", playerEffect.time + 1);
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Clang", effect: true };
    },
    "RubberBolt": (target, damage, playerEffect, spell, faction, bullet) => {
        KDPlayerEffectRestrain(spell, playerEffect.count, ["redLatexBasic"], "Dollsmith");
        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonRubberBolt"), "yellow", 1);
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Dollify", effect: true };
    },
    "EncaseBolt": (target, damage, playerEffect, spell, faction, bullet) => {
        KDPlayerEffectRestrain(spell, playerEffect.count, ["latexEncaseRandom"], "Dollsmith");
        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonEncaseBolt"), "yellow", 1);
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Dollify", effect: true };
    },
    "EncaseBoltDrone": (target, damage, playerEffect, spell, faction, bullet) => {
        if (KinkyDungeonMovePoints >= 0) {
            KinkyDungeonMovePoints = -1;
            KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonEncaseBoltDroneSlow"), "yellow", 1);
        }
        else {
            KDPlayerEffectRestrain(spell, playerEffect.count, ["latexEncaseRandom"], "Dollsmith");
            KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonEncaseBoltDrone"), "yellow", 1);
        }
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Dollify", effect: true };
    },
    "RubberMissile": (target, damage, playerEffect, spell, faction, bullet) => {
        KDPlayerEffectRestrain(spell, playerEffect.count, ["latexEncaseRandom"], "Dollsmith");
        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonRubberMissile"), "yellow", 1);
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Lightning", effect: true };
    },
    "ObsidianBolt": (target, damage, playerEffect, spell, faction, bullet) => {
        KDPlayerEffectRestrain(spell, playerEffect.count, ["obsidianRestraints"], "Elemental");
        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonObsidianBolt"), "yellow", playerEffect.time);
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Evil", effect: true };
    },
    "CelestialBolt": (target, damage, playerEffect, spell, faction, bullet) => {
        KDPlayerEffectRestrain(spell, playerEffect.count, ["celestialRopes"], "Angel");
        KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonCelestialBolt"), "yellow", playerEffect.time);
        KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        return { sfx: "Evil", effect: true };
    },
    "BoundByFate": (target, damage, playerEffect, spell, faction, bullet) => {
        KDCreateAoEEffectTiles(bullet.x, bullet.y, {
            name: "FateBoundGround",
            duration: playerEffect.time + 1,
        }, 0, 2.5, undefined, undefined, undefined);
        KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonBoundByFate"), "yellow", playerEffect.time);
        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, KDBoundByFate, {
            duration: playerEffect.time,
        });
        return { sfx: "Evil", effect: true };
    },
    "StarBondage": (target, damage, playerEffect, spell, faction, bullet) => {
        KinkyDungeonSendTextMessage(8, TextGet("KinkyDungeonStarBondage"), "#ff5555", 4);
        KDPlayerEffectRestrain(spell, playerEffect.count, [playerEffect.kind], "Demon");
        return { sfx: "Evil", effect: true };
    },
    "MoonBondage": (target, damage, playerEffect, spell, faction, bullet) => {
        let dmg = KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonMoonBondage").replace("DamageTaken", dmg.string), "#ff5555", 1);
        KDPlayerEffectRestrain(spell, playerEffect.count, [playerEffect.kind], "Demon");
        return { sfx: "Evil", effect: true };
    },
    "SarcoEngulf": (target, damage, playerEffect, spell, faction, bullet) => {
        let added = [];
        let effect = false;
        for (let i = 0; i < playerEffect.power; i++) {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["mummyRestraints"] }, 100, "tmb");
            if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                added.push(restraintAdd);
                effect = true;
            }
        }
        if (added.length > 0) {
            KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonRopeEngulf"), "#ff0000", 2);
            effect = true;
        }
        else {
            let RopeDresses = ["Leotard", "Bikini", "Lingerie"];
            if (!RopeDresses.includes(KinkyDungeonCurrentDress)) {
                KinkyDungeonSetDress(RopeDresses[Math.floor(Math.random() * RopeDresses.length)], "");
                KinkyDungeonDressPlayer();
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonHexEngulfDress"), "#ff0000", 3);
                effect = true;
            }
            else {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ropeMagicHogtie"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonSarcoEngulf"), "#ff0000", 2);
                    effect = true;
                }
            }
        }
        return { sfx: "MagicSlash", effect: effect };
    },
    "SarcoHex": (target, damage, playerEffect, spell, faction, bullet) => {
        let restraintAdd = KinkyDungeonGetRestraint({ tags: ["mummyRestraints"] }, 100, "tmb");
        if (!restraintAdd && !KinkyDungeonPlayerTags.get("Sarcophagus")) {
            KDTripleBuffKill("SarcoHexEnd", KinkyDungeonPlayerEntity, 6, (tt) => {
                var _a;
                let kraken = KDNearbyEnemies(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, 10);
                for (let enemy of kraken) {
                    if (enemy.Enemy.name == "SarcoKraken" || enemy.Enemy.name == "SarcoMinion")
                        enemy.hp = 0;
                }
                let candidates = (_a = KDGameData.JailPoints) === null || _a === void 0 ? void 0 : _a.filter((point) => { return point.type == "furniture"; });
                if (candidates && candidates.length > 0) {
                    let candidate = candidates[Math.floor(KDRandom() * candidates.length)];
                    KDMovePlayer(candidate.x, candidate.y, false);
                }
                let newAdd = KinkyDungeonGetRestraint({ tags: ["sarcophagus"] }, 100, "tmb");
                if (newAdd) {
                    KinkyDungeonAddRestraintIfWeaker(newAdd, spell.power, false, undefined, false, false, undefined, faction);
                }
            }, "Blindness");
            return { sfx: "Evil", effect: true };
        }
        return { sfx: "Struggle", effect: false };
    },
};
function KDPlayerEffectRestrain(spell, count, tags, faction, noDeep, bypass) {
    let added = [];
    for (let i = 0; i < count; i++) {
        let restraintAdd = KinkyDungeonGetRestraint({ tags: tags }, MiniGameKinkyDungeonLevel + ((spell === null || spell === void 0 ? void 0 : spell.power) || 0), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
        if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, ((spell === null || spell === void 0 ? void 0 : spell.power) || 0), bypass, undefined, false, false, undefined, faction, !noDeep)) {
            KDSendStatus('bound', restraintAdd.name, "spell_" + (spell === null || spell === void 0 ? void 0 : spell.name));
            added.push(restraintAdd);
        }
    }
    return added;
}
function KinkyDungeonPlayerEffect(target, damage, playerEffect, spell, faction, bullet) {
    if (!playerEffect.name)
        return;
    let effect = false;
    let sfx = spell ? spell.hitsfx : undefined;
    if (!sfx)
        sfx = (playerEffect.power && playerEffect.power < 2) ? "DamageWeak" : "Damage";
    if (damage == "inert")
        return;
    if (playerEffect.hitTag && !KDPlayerHitBy.includes(playerEffect.hitTag))
        KDPlayerHitBy.push(playerEffect.hitTag);
    else if (playerEffect.hitTag)
        return;
    if (!playerEffect.chance || KDRandom() < playerEffect.chance) {
        if (KDPlayerEffects[playerEffect.name]) {
            let ret = KDPlayerEffects[playerEffect.name](target, damage, playerEffect, spell, faction, bullet);
            if (ret.sfx)
                sfx = ret.sfx;
            effect = ret.effect;
        }
        else if (playerEffect.name == "Ampule") {
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSpellShatter" + spell.name), "#ff0000", 1);
            effect = true;
        }
        else if (playerEffect.name == "AmpuleBlue") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["latexRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSpellShatterBind" + spell.name), "#ff0000", 1);
                effect = true;
            }
            else {
                if (KinkyDungeonCurrentDress != "BlueSuit") {
                    KinkyDungeonSetDress("BlueSuit", "Latex");
                    KinkyDungeonDressPlayer();
                    KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSpellShatterDress" + spell.name), "#ff0000", 1);
                    effect = true;
                }
                else {
                    KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSpellShatter" + spell.name), "#ff0000", 1);
                }
                let dmg = KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
                if (dmg.happened)
                    effect = true;
            }
        }
        else if (playerEffect.name == "Bind") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: [playerEffect.tag] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSpell" + spell.name + "Bind"), "#ff0000", 2);
                effect = true;
            }
            else {
                let dmg = KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSpell" + spell.name + "Damage").replace("DamageDealt", dmg.string), "#ff0000", 2);
                if (dmg.happened)
                    effect = true;
            }
        }
        else if (playerEffect.name == "ShadowStrike") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["shadowRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSpellShadowStrike"), "#ff0000", 1);
                effect = true;
            }
            let dmg = KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            if (dmg.happened)
                effect = true;
        }
        else if (playerEffect.name == "Damage") {
            let dmg = KinkyDungeonDealDamage({ damage: Math.max((spell.aoepower) ? spell.aoepower : 0, spell.power), type: spell.damage }, bullet);
            KinkyDungeonSendTextMessage(Math.min(spell.power, 5), TextGet("KinkyDungeonDamageSelf").replace("DamageDealt", dmg.string), "#ff0000", 1);
            if (dmg.happened)
                effect = true;
        }
        else if (playerEffect.name == "WitchBoulder") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KDGameData.KneelTurns = 2;
            let dmg = KinkyDungeonDealDamage({ damage: Math.max((spell.aoepower) ? spell.aoepower : 0, spell.power), type: spell.damage }, bullet);
            KinkyDungeonSendTextMessage(Math.min(spell.power, 5), TextGet("KDEffectWitchBoulder").replace("DamageDealt", dmg.string), "#ff0000", 1);
            if (dmg.happened)
                effect = true;
        }
        else if (playerEffect.name == "IceBolt") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            let dmg = KinkyDungeonDealDamage({ damage: Math.max((spell.aoepower) ? spell.aoepower : 0, spell.power), type: spell.damage }, bullet);
            KinkyDungeonSendTextMessage(Math.min(spell.power, 5), TextGet("KDEffectWitchBoulder").replace("DamageDealt", dmg.string), "#ff0000", 1);
            if (dmg.happened)
                effect = true;
        }
        else if (playerEffect.name == "Ignition") {
            let dmg = KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            KinkyDungeonSendTextMessage(playerEffect.power, TextGet("KinkyDungeonBuffIgniteDamage").replace("DamageDealt", dmg.string), "#ff0000", 1);
            if (dmg.happened)
                effect = true;
        }
        else if (playerEffect.name == "DamageNoMsg") {
            let dmg = KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            if (dmg.happened)
                effect = true;
        }
        else if (playerEffect.name == "Blind") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonBlindSelf"), "#ff0000", playerEffect.time);
            effect = true;
        }
        else if (playerEffect.name == "Hairpin") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonHairpin"), "#ff0000", playerEffect.time);
            if (spell.power > 0) {
                effect = true;
                KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            }
            effect = true;
        }
        else if (playerEffect.name == "MagicRope") {
            let roped = false;
            roped = roped || KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("WeakMagicRopeArms"), 0, false, undefined, false, false, undefined, faction) > 0;
            roped = roped || KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("WeakMagicRopeLegs"), 0, false, undefined, false, false, undefined, faction) > 0;
            if (roped)
                KDSendStatus('bound', "WeakMagicRopeArms", "spell_" + spell.name);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonMagicRopeSelf"), "#ff0000", playerEffect.time);
            if (roped)
                effect = true;
        }
        else if (playerEffect.name == "SlimeTrap") {
            let slimeWalker = false;
            for (let inv of KinkyDungeonAllRestraint()) {
                if (KDRestraint(inv).slimeWalk) {
                    slimeWalker = true;
                    break;
                }
            }
            if (!slimeWalker) {
                if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "glueDamageResist") < 0.45) {
                    let restraintAdd = KinkyDungeonGetRestraint({ tags: ["slimeRestraintsRandomLight"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                    if (restraintAdd) {
                        KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                        KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                        effect = true;
                    }
                }
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSlime"), "#ff0000", playerEffect.time);
                if (spell.power > 0) {
                    effect = true;
                    KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                }
            }
        }
        else if (playerEffect.name == "Slime") {
            if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "glueDamageResist") < 0.45) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["slimeRestraintsRandomLight"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd) {
                    KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    effect = true;
                }
                KinkyDungeonMovePoints = -1;
            }
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSlime"), "#ff0000", playerEffect.time);
            if (spell.power > 0) {
                effect = true;
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
        }
        else if (playerEffect.name == "MiniSlime") {
            if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "glueDamageResist") < 0.45 && KDRandom() < 0.33) {
                KinkyDungeonMovePoints = -1;
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonMiniSlime2"), "#ff0000", 2);
            }
            else
                KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonMiniSlime"), "#ff0000", 1);
            if (spell.power > 0) {
                effect = true;
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
        }
        else if (playerEffect.name == "RemoveLowLevelRope") {
            let restraints = [];
            for (let inv of KinkyDungeonAllRestraint()) {
                if (KDRestraint(inv).power < 5 && KDRestraint(inv).shrine && KDRestraint(inv).shrine.includes("Rope")) {
                    restraints.push(KDRestraint(inv).Group);
                }
            }
            for (let r of restraints) {
                if (effect)
                    KDSendStatus('escape', KinkyDungeonGetRestraintItem(r).name, "spell_" + spell.name);
                KinkyDungeonRemoveRestraint(r, false);
            }
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonRemoveLowLevelRope"), "lightGreen", 2);
        }
        else if (playerEffect.name == "Shock") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonShock"), "#ff0000", playerEffect.time);
            effect = true;
        }
        else if (playerEffect.name == "CoronaShock") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["celestialRopes"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
            }
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonCoronaShock"), "#ff0000", playerEffect.time);
            effect = true;
        }
        else if (playerEffect.name == "CrystalBind") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["crystalRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
            }
            KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonCrystalBind"), "#ff0000", 3);
            effect = true;
        }
        else if (playerEffect.name == "MysticShock") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonMysticShock"), "#ff0000", playerEffect.time);
            if (spell.power > 0) {
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
            effect = true;
        }
        else if (playerEffect.name == "RobotShock") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonRobotShock"), "#ff0000", playerEffect.time);
            if (spell.power > 0) {
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
            effect = true;
        }
        else if (playerEffect.name == "HeatBlast") {
            KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
            KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            KDGameData.KneelTurns = Math.max(KDGameData.KneelTurns || 0, KinkyDungeonSlowMoveTurns + 2);
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonHeatBlast"), "#ff0000", playerEffect.time + 1);
            if (spell.power > 0) {
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            }
            effect = true;
        }
        else if (playerEffect.name == "RubberBullets") {
            if (KDRandom() < 0.25 && KinkyDungeonStatWill < KinkyDungeonStatWillMax / 2) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["slimeRestraintsRandom"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd) {
                    KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonRubberBulletsAttach"), "#ff0000", 2);
                }
            }
            else
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonRubberBullets"), "#ff0000", 2);
            if (spell.power > 0) {
                KinkyDungeonDealDamage({ damage: KinkyDungeonStatWill < KinkyDungeonStatWillMax / 2 ? spell.power : spell.power * 1.5, type: spell.damage }, bullet);
            }
            effect = true;
        }
        else if (playerEffect.name == "SingleChain") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["chainRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleChain"), "#ff0000", playerEffect.time);
                effect = true;
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", playerEffect.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                effect = true;
            }
        }
        else if (playerEffect.name == "SingleMagicChain") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["chainRestraintsMagic"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleChain"), "#ff0000", playerEffect.time);
                effect = true;
            }
        }
        else if (playerEffect.name == "Spores") {
            KinkyDungeonSleepiness = Math.max(KinkyDungeonSleepiness, 6);
            KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonSpores"), "#a583ff", 2);
            KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            effect = true;
        }
        else if (playerEffect.name == "PoisonDagger") {
            KinkyDungeonSendTextMessage(6, TextGet("KDPoisonDagger"), "#33ff00", 2);
            KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "PoisonDagger", aura: "#22ff44", type: "Sleepiness", power: 1, duration: playerEffect.time, player: true, enemies: false, tags: ["sleep"], range: 1.5 });
            effect = true;
        }
        else if (playerEffect.name == "SporesSick") {
            KinkyDungeonSleepiness += 1.5;
            KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonSporesSick"), "#63ab3f", 2);
            KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            effect = true;
        }
        else if (playerEffect.name == "Flummox") {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Flummox", type: "Flummox", duration: 5, power: 1.0, player: true, mushroom: true, tags: ["overlay", "darkness"] });
            KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonFlummox"), "#a583ff", 2);
            KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
            effect = true;
        }
        else if (playerEffect.name == "NurseBola") {
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["nurseCuffRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonNurseBola"), "#ff0000", playerEffect.time);
                effect = true;
            }
        }
        else if (playerEffect.name == "SingleRope" || playerEffect.name == "BanditBola") {
            if (playerEffect.name == "BanditBola") {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            }
            let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ropeRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (restraintAdd) {
                KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction);
                KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSingleRope"), "#ff0000", playerEffect.time);
                effect = true;
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", playerEffect.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                effect = true;
            }
        }
        else if (playerEffect.name == "RestrainingDevice") {
            let added = [];
            for (let i = 0; i < playerEffect.count; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["hitechCables"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonRestrainingDevice"), "#ff0000", 2);
                effect = true;
            }
            else {
                KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, playerEffect.time);
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonRestrainingDeviceStun"), "yellow", playerEffect.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                effect = true;
            }
        }
        else if (playerEffect.name == "Glue") {
            let added = [];
            if (KinkyDungeonLastAction == "Move")
                for (let i = 0; i < playerEffect.count; i++) {
                    let restraintAdd = KinkyDungeonGetRestraint({ tags: ["glueRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                    if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                        KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                        added.push(restraintAdd);
                        effect = true;
                    }
                }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonGlue"), "yellow", 2);
                effect = true;
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonGlueSlow"), "yellow", playerEffect.time);
                if (playerEffect.power) {
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonGlueSlowDamage").replace("DamageDealt", playerEffect.power), "yellow", 2);
                    KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
                }
                else
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonGlueSlow"), "yellow", playerEffect.time);
                effect = true;
            }
        }
        else if (playerEffect.name == "RopeEngulf") {
            let added = [];
            for (let i = 0; i < playerEffect.power; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ropeMagicStrong", "ropeAuxiliary", "clothRestraints", "tapeRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonRopeEngulf"), "#ff0000", 2);
                effect = true;
            }
            else {
                let RopeDresses = ["Leotard", "Bikini", "Lingerie"];
                if (!RopeDresses.includes(KinkyDungeonCurrentDress)) {
                    KinkyDungeonSetDress(RopeDresses[Math.floor(Math.random() * RopeDresses.length)], "");
                    KinkyDungeonDressPlayer();
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonRopeEngulfDress"), "#ff0000", 3);
                    effect = true;
                }
                else {
                    let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ropeMagicHogtie"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                    if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                        KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                        KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonRopeEngulf"), "#ff0000", 2);
                        effect = true;
                    }
                    else {
                        let buff1 = { id: "KrakenEngulf", type: "Blindness", duration: 8, power: 1.0, player: true, tags: ["passout"] };
                        let buff2 = { id: "KrakenEngulf2", type: "Blindness", duration: 8, power: 2.0, player: true, tags: ["passout"] };
                        let buff3 = { id: "KrakenEngulf3", type: "Blindness", duration: 8, power: 4.0, player: true, tags: ["passout"] };
                        if (KinkyDungeonPlayerBuffs[buff3.id]) {
                            KinkyDungeonPassOut();
                        }
                        else if (KinkyDungeonPlayerBuffs[buff2.id]) {
                            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonRopeEngulfEnd3"), "#ff0000", 5);
                            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff1);
                            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff2);
                            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff3);
                        }
                        else if (KinkyDungeonPlayerBuffs[buff1.id]) {
                            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonRopeEngulfEnd2"), "#ff0000", 4);
                            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff1);
                            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff2);
                        }
                        else {
                            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonRopeEngulfEnd1"), "#ff0000", 4);
                            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff1);
                        }
                    }
                }
            }
        }
        else if (playerEffect.name == "RopeEngulfWeak") {
            let added = [];
            for (let i = 0; i < playerEffect.power; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ropeRestraints", "ropeRestraints2", "ropeRestraintsWrist"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonRopeEngulfWeak"), "#ff0000", 2);
                effect = true;
            }
            else {
                let RopeDresses = ["Leotard", "Bikini", "Lingerie"];
                if (!RopeDresses.includes(KinkyDungeonCurrentDress)) {
                    KinkyDungeonSetDress(RopeDresses[Math.floor(Math.random() * RopeDresses.length)], "");
                    KinkyDungeonDressPlayer();
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonRopeEngulfDress"), "#ff0000", 3);
                    effect = true;
                }
                else {
                    KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", playerEffect.time);
                    KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                    effect = true;
                }
            }
        }
        else if (playerEffect.name == "VineEngulf") {
            let added = [];
            for (let i = 0; i < playerEffect.power; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["vineRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonVineEngulf"), "#ff0000", 2);
                effect = true;
            }
            else {
                let RopeDresses = ["GreenLeotard", "Lingerie"];
                if (!RopeDresses.includes(KinkyDungeonCurrentDress) && KinkyDungeonCurrentDress != "Elven") {
                    KinkyDungeonSetDress(RopeDresses[Math.floor(Math.random() * RopeDresses.length)], "");
                    KinkyDungeonDressPlayer();
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonVineEngulfDress"), "#ff0000", 3);
                    effect = true;
                }
                else {
                    KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", playerEffect.time);
                    KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                    effect = true;
                }
            }
        }
        else if (playerEffect.name == "ObsidianEngulf") {
            let added = [];
            for (let i = 0; i < playerEffect.count; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["obsidianRestraints"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonObsidianEngulf"), "#ff0000", 2);
                effect = true;
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", playerEffect.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                effect = true;
            }
        }
        else if (playerEffect.name == "CharmWraps") {
            let added = [];
            for (let i = 0; i < playerEffect.power; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["ribbonRestraintsLight"] }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonCharmWraps"), "#ff0000", 2);
                effect = true;
            }
            else {
                let CharmDresses = ["Leotard", "Bikini", "Lingerie"];
                if (!CharmDresses.includes(KinkyDungeonCurrentDress) && KinkyDungeonCurrentDress != "Prisoner") {
                    KinkyDungeonSetDress(CharmDresses[Math.floor(Math.random() * CharmDresses.length)], "");
                    KinkyDungeonDressPlayer();
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonCharmWrapsDress"), "#ff0000", 3);
                    effect = true;
                }
                else {
                    KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", playerEffect.time);
                    KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                    effect = true;
                }
            }
        }
        else if (playerEffect.name == "EnchantedArrow") {
            let added = [];
            for (let i = 0; i < playerEffect.count; i++) {
                let ropeRests = ["mithrilRope"];
                if (KinkyDungeonStatStamina < KinkyDungeonStatStamina * 0.25) {
                    ropeRests.push("mithrilRopeHogtie");
                }
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ropeRests }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonEnchantedArrow"), "#ff0000", 2);
                effect = true;
            }
            else {
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonSlowedBySpell"), "yellow", playerEffect.time);
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
                effect = true;
            }
        }
        else if (playerEffect.name == "TrapBindings") {
            let added = [];
            for (let i = 0; i < playerEffect.count; i++) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: playerEffect.tags }, MiniGameKinkyDungeonLevel + spell.power, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd && KinkyDungeonAddRestraintIfWeaker(restraintAdd, spell.power, false, undefined, false, false, undefined, faction)) {
                    KDSendStatus('bound', restraintAdd.name, "spell_" + spell.name);
                    added.push(restraintAdd);
                    effect = true;
                }
            }
            if (added.length > 0) {
                KinkyDungeonSendTextMessage(6, TextGet(playerEffect.text), "#ff0000", 2);
                effect = true;
            }
            else {
                let PossibleDresses = ["Leotard", "Bikini", "Lingerie"];
                if (!PossibleDresses.includes(KinkyDungeonCurrentDress)) {
                    KinkyDungeonSetDress(PossibleDresses[Math.floor(Math.random() * PossibleDresses.length)], "");
                    KinkyDungeonDressPlayer();
                    KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonTrapBindingsDress"), "#ff0000", 3);
                    effect = true;
                }
                if (playerEffect.power > 0 && playerEffect.damage) {
                    KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
                }
            }
        }
        else if (playerEffect.name == "NurseSyringe") {
            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonNurseSyringe"), "#ff0000", 8);
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "NurseSyringe", aura: "#22ff44", type: "Sleepiness", power: 1, duration: playerEffect.time, player: true, enemies: false, tags: ["sleep"], range: 1.5 });
            effect = true;
        }
        else if (playerEffect.name == "TrapSleepDart") {
            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonTrapSleepDart"), "#ff0000", 8);
            KDStunTurns(8);
            KinkyDungeonStatBlind = 8;
            KinkyDungeonSleepiness = 8;
            KinkyDungeonAlert = 5;
            effect = true;
        }
        else if (playerEffect.name == "Drench") {
            KinkyDungeonSendTextMessage(4, TextGet("KDEffectDrench"), "#9999ff", 3);
            for (let b of spell.buffs) {
                if (b.id.includes("Drenched")) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, b);
                }
            }
            if (spell.power > 0 && spell.damage == 'acid')
                KinkyDungeonDealDamage({ damage: spell.power, type: spell.damage }, bullet);
        }
        else if (playerEffect.name == "LustBomb") {
            KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonLustBomb"), "pink", 4);
            if (playerEffect.power > 0) {
                KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            }
            effect = true;
        }
        else if (playerEffect.name == "TrapLustCloud") {
            KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonTrapLustCloud"), "yellow", 4);
            if (playerEffect.power > 0) {
                KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            }
            effect = true;
        }
        else if (playerEffect.name == "TrapSPCloud") {
            KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonTrapSPCloud"), "yellow", 4);
            if (playerEffect.power > 0) {
                KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            }
            KDGameData.StaminaPause = 10;
            effect = true;
        }
        else if (playerEffect.name == "Freeze") {
            KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonFreeze"), "#ff0000", playerEffect.time);
            if (playerEffect.power > 0) {
                KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            }
            KinkyDungeonStatFreeze = Math.max(0, playerEffect.time);
            KinkyDungeonSleepTime = CommonTime() + KinkyDungeonFreezeTime;
            effect = true;
        }
        else if (playerEffect.name == "Chill") {
            if (playerEffect.power > 0 && !KinkyDungeonFlags.get("chill")) {
                KinkyDungeonDealDamage({ damage: playerEffect.power, type: playerEffect.damage }, bullet);
            }
            if (KinkyDungeonPlayerBuffs.Drenched || KinkyDungeonPlayerBuffs.Chilled) {
                sfx = "Freeze";
                KinkyDungeonStatFreeze = Math.max(0, playerEffect.time);
                KinkyDungeonSleepTime = CommonTime() + KinkyDungeonFreezeTime;
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonFreeze"), "#ff0000", playerEffect.time);
            }
            else {
                sfx = "Bones";
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonChill"), "#ff0000", playerEffect.time);
            }
            KinkyDungeonSetFlag("chill", 1);
            effect = true;
        }
        else if (playerEffect.name == "ShadowBind") {
            KinkyDungeonStatBind = Math.max(0, playerEffect.time);
            KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonShadowBind"), "#ff0000", playerEffect.time);
            effect = true;
        }
    }
    if (sfx)
        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg");
    if (effect)
        KinkyDungeonInterruptSleep();
    return effect;
}
function KDTripleBuffKill(Name, Target, time, FinalEffect = (target) => KinkyDungeonPassOut(), buffType = "Blindness") {
    let buff1 = { id: Name + "1", type: buffType, duration: time + 3, power: 1.0, player: true, tags: ["passout"] };
    let buff2 = { id: Name + "2", type: buffType, duration: time + 3, power: 2.0, player: true, tags: ["passout"] };
    let buff3 = { id: Name + "3", type: buffType, duration: time + 3, power: 4.0, player: true, tags: ["passout"] };
    if (KinkyDungeonPlayerBuffs[buff3.id]) {
        FinalEffect(Target);
    }
    else if (KinkyDungeonPlayerBuffs[buff2.id]) {
        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeon" + Name + "3"), "#ff5555", time + 1);
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff1);
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff2);
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff3);
    }
    else if (KinkyDungeonPlayerBuffs[buff1.id]) {
        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeon" + Name + "2"), "#ff5555", time);
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff1);
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff2);
    }
    else {
        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeon" + Name + "1"), "#ff5555", time);
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff1);
    }
}
let KinkyDungeonShrineBaseCosts = {
    "Leather": 40,
    "Metal": 60,
    "Rope": 20,
    "Latex": 40,
    "Will": 20,
    "Elements": 200,
    "Conjure": 200,
    "Illusion": 200,
};
let KDWillShrineWill = 0.25;
let KinkyDungeonOrbAmount = 0;
let KDShrineRemoveCount = 30;
let KDMaxGoddessBonus = 0.2;
let KDMinGoddessBonus = 0.15;
let KinkyDungeonShrineBaseCostGrowth = {
    "Elements": 2,
    "Conjure": 2,
    "Illusion": 2,
};
let KinkyDungeonShopIndex = 0;
let KinkyDungeonShrinePoolChancePerUse = 0.2;
let KinkyDungeonShrineCosts = {};
let KinkyDungeonShrineTypeRemove = ["Charms", "Leather", "Metal", "Rope", "Latex", "Gags", "Blindfolds", "Boots"];
function KinkyDungeonShrineInit() {
    KinkyDungeonShrineCosts = {};
    KDGameData.PoolUsesGrace = 3;
    KinkyDungeonInitReputation();
}
function KDGoddessColor(Name) {
    let color = "#ffffff";
    if (Name == "Illusion")
        color = "#8154FF";
    else if (Name == "Conjure")
        color = "#D4AAFF";
    else if (Name == "Elements")
        color = "#FF0000";
    else if (Name == "Latex")
        color = "#2667FF";
    else if (Name == "Leather")
        color = "#442E1E";
    else if (Name == "Metal")
        color = "#222222";
    else if (Name == "Rope")
        color = "#7C4926";
    else if (Name == "Will")
        color = "#23FF44";
    return color;
}
function KinkyDungeonShrineAvailable(type) {
    if (type == "Commerce") {
        if (KDGameData.ShopItems.length > 0)
            return true;
        else
            return false;
    }
    if (KinkyDungeonShrineTypeRemove.includes(type) && KinkyDungeonGetRestraintsWithShrine(type).length > 0)
        return true;
    else if ((type == "Elements" || type == "Illusion" || type == "Conjure"))
        return true;
    else if (type == "Will" && (KinkyDungeonStatMana < KinkyDungeonStatManaMax || KinkyDungeonStatManaPool < KinkyDungeonStatManaPoolMax || KinkyDungeonStatWill < KinkyDungeonStatWillMax))
        return true;
    return false;
}
let KDLevelsPerCheckpoint = 4;
function KinkyDungeonGenerateShop(Level) {
    KDGameData.PoolUses = Math.min(KDGameData.PoolUses, KinkyDungeonStatsChoice.get("Blessed") ? 0 : 1);
    KinkyDungeonShopIndex = 0;
    KDGameData.ShopItems = [];
    let items_mid = 0;
    let items_high = 0;
    let itemCount = 8 + Math.floor(KDRandom() * 3);
    if (KinkyDungeonStatsChoice.has("Supermarket")) {
        items_mid = -1;
        items_high = -1;
        itemCount += 2;
    }
    for (let I = itemCount; I > 0; I--) {
        let Rarity = 0;
        if (items_high < 3) {
            Rarity = Math.floor(Level / KDLevelsPerCheckpoint);
            items_high += 1;
        }
        else if (items_mid < 5) {
            Rarity += Math.round(KDRandom() * 3);
            items_mid += 1;
        }
        let item = KinkyDungeonGetShopItem(Level, Rarity, true);
        if (item)
            KDGameData.ShopItems.push({ name: item.name, shoptype: item.shoptype, consumable: item.consumable, quantity: item.quantity, rarity: item.rarity, cost: item.cost });
    }
    KDGameData.ShopItems.sort(function (a, b) { return a.rarity - b.rarity; });
}
function KinkyDungeonItemCost(item, noScale, sell) {
    if (item.cost != null)
        return item.cost;
    if (item.rarity != null) {
        let rarity = item.rarity;
        if (item.costMod)
            rarity += item.costMod;
        let costt = 5 * Math.round((1 + MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint / 2.5 * (noScale ? 0 : 1)) * (50 + 2 * rarity * rarity * 20) / 5);
        if (costt > 100)
            costt = 10 * Math.round(costt / 10);
        if (KinkyDungeonStatsChoice.has("PriceGouging") && !sell) {
            costt *= 5;
        }
        return costt;
    }
    let costs = 15;
    if (KinkyDungeonStatsChoice.has("PriceGouging") && !sell) {
        costs *= 5;
    }
    return costs;
}
function KinkyDungeonShrineCost(type) {
    let mult = 1.0;
    let growth = 1.0;
    let noMult = false;
    if (type == "Commerce" && KinkyDungeonShopIndex < KDGameData.ShopItems.length) {
        if (!KDGameData.ShopItems)
            KDGameData.ShopItems = [];
        let item = KDGameData.ShopItems[KinkyDungeonShopIndex];
        return Math.round(KinkyDungeonItemCost(item));
    }
    else if (KinkyDungeonShrineTypeRemove.includes(type)) {
        let rest = KinkyDungeonGetRestraintsWithShrine(type);
        let maxPower = 1;
        for (let r of rest) {
            if (KDRestraint(r).power > maxPower)
                maxPower = KDRestraint(r).power;
        }
        mult = Math.sqrt(Math.max(1, Math.min(KDShrineRemoveCount, rest.length)));
        mult *= Math.pow(Math.max(1, maxPower), 0.75);
        noMult = true;
    }
    else if (type == "Will") {
        let value = 0;
        value += 120 * (1 - KinkyDungeonStatWill / KinkyDungeonStatWillMax);
        value += 70 * (1 - KinkyDungeonStatMana / KinkyDungeonStatManaMax);
        return Math.round(Math.round(value / 10) * 10 * (1 + 0.01 * KinkyDungeonDifficulty));
    }
    if (KinkyDungeonShrineBaseCostGrowth[type])
        growth = KinkyDungeonShrineBaseCostGrowth[type];
    if (KinkyDungeonShrineCosts[type] > 0 && !noMult)
        mult = Math.pow(growth, KinkyDungeonShrineCosts[type]);
    if (type == "Conjure" || type == "Illusion" || type == "Elements")
        return Math.round(150 * (1 + 0.01 * KinkyDungeonDifficulty));
    return Math.round(Math.round(KinkyDungeonShrineBaseCosts[type] * mult / 10) * 10 * (1 + 0.01 * KinkyDungeonDifficulty));
}
function KDAddBasic(item) {
    if (item.name == "RedKey") {
        KinkyDungeonRedKeys += 1;
    }
    else if (item.name == "BlueKey") {
        KinkyDungeonBlueKeys += 1;
    }
    else if (item.name == "Lockpick") {
        KinkyDungeonLockpicks += 1;
    }
    else if (item.name == "2Lockpick") {
        KinkyDungeonLockpicks += 2;
    }
    else if (item.name == "4Lockpick") {
        KinkyDungeonLockpicks += 4;
    }
    else if (item.name == "MaidUniform") {
        KinkyDungeonInventoryAddOutfit("Maid");
    }
    else if (item.consumable) {
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables[item.consumable], item.quantity);
    }
}
function KinkyDungeonPayShrine(type) {
    KinkyDungeonGold -= KinkyDungeonShrineCost(type);
    let ShrineMsg = "";
    let rep = 0;
    if (KinkyDungeonShrineTypeRemove.includes(type)) {
        rep = KinkyDungeonRemoveRestraintsWithShrine(type, KDShrineRemoveCount, true);
        KinkyDungeonChangeRep("Ghost", -rep);
        ShrineMsg = TextGet("KinkyDungeonPayShrineRemoveRestraints");
        KDSendStatus('goddess', type, 'shrineRemove');
    }
    else if (type == "Elements" || type == "Illusion" || type == "Conjure") {
        ShrineMsg = TextGet("KinkyDungeonPayShrineBuff" + type).replace("SCHOOL", TextGet("KinkyDungeonSpellsSchool" + type));
        if (type == "Elements") {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "ShrineElements", type: "event", maxCount: 10, tags: ["offense", "shrineElements"], aura: "#f1641f", power: 1.5, duration: 9999, events: [
                    { trigger: "afterDamageEnemy", type: "ShrineElements", spell: "ArcaneStrike" },
                ] });
        }
        else if (type == "Conjure") {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "ShrineConjure", type: "event", maxCount: 10, tags: ["defense", "shrineConjure"], aura: "#4572e3", power: 1.5, duration: 9999, events: [
                    { trigger: "beforeAttack", type: "CounterattackSpell", spell: "ArcaneStrike", requiredTag: "shrineConjure", prereq: "hit-hostile" },
                ] });
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "ShrineConjure2", type: "SpellResist", maxCount: 10, tags: ["defense", "shrineConjure"], power: 5, duration: 9999 });
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "ShrineConjure3", type: "Armor", maxCount: 10, tags: ["defense", "shrineConjure"], power: 5, duration: 9999 });
        }
        else if (type == "Illusion") {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "ShrineIllusion", type: "event", maxCount: 10, tags: ["defense", "shrineIllusion"], aura: "#9052bc", power: 1.5, duration: 9999, events: [
                    { trigger: "playerAttack", type: "ShadowStep", time: 6, requiredTag: "shrineIllusion" },
                ] });
        }
        KDSendStatus('goddess', type, 'shrineDonate');
        rep = 2.5;
    }
    else if (type == "Will") {
        rep = Math.ceil(5 - KinkyDungeonStatMana * 1.5 / KinkyDungeonStatManaMax - KinkyDungeonStatWill * 3.5 / KinkyDungeonStatWillMax);
        KinkyDungeonChangeMana(KinkyDungeonStatManaMax, false, 0, false, true);
        KinkyDungeonChangeWill(KDWillShrineWill * KinkyDungeonStatWillMax);
        KinkyDungeonNextDataSendStatsTime = 0;
        ShrineMsg = TextGet("KinkyDungeonPayShrineHeal");
        KDSendStatus('goddess', type, 'shrineHeal');
    }
    else if (type == "Commerce") {
        let item = KDGameData.ShopItems[KinkyDungeonShopIndex];
        if (item) {
            if (item.shoptype == "Consumable")
                KinkyDungeonChangeConsumable(KinkyDungeonConsumables[item.name], 1);
            else if (item.shoptype == "Weapon")
                KinkyDungeonInventoryAddWeapon(item.name);
            else if (item.shoptype == "Restraint") {
                let restraint = KinkyDungeonGetRestraintByName(item.name);
                KinkyDungeonInventoryAdd({ name: item.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: restraint.events });
            }
            else if (item.shoptype == "Basic") {
                KDAddBasic(item);
            }
            ShrineMsg = TextGet("KinkyDungeonPayShrineCommerce").replace("ItemBought", TextGet("KinkyDungeonInventoryItem" + item.name));
            KDGameData.ShopItems.splice(KinkyDungeonShopIndex, 1);
            if (KinkyDungeonShopIndex > 0)
                KinkyDungeonShopIndex -= 1;
            rep = item.rarity + 1;
            KDSendStatus('goddess', type, 'shrineBuy');
        }
    }
    if (ShrineMsg)
        KinkyDungeonSendActionMessage(10, ShrineMsg, "lightblue", 1);
    if (KinkyDungeonShrineCosts[type] > 0)
        KinkyDungeonShrineCosts[type] = KinkyDungeonShrineCosts[type] + 1;
    else
        KinkyDungeonShrineCosts[type] = 1;
    if (rep != 0) {
        KinkyDungeonChangeRep(type, rep);
    }
}
function KinkyDungeonHandleShrine() {
    let cost = 0;
    let type = KinkyDungeonTargetTile.Name;
    if (KinkyDungeonShrineAvailable(type))
        cost = KinkyDungeonShrineCost(type);
    if (type == "Commerce") {
        if (cost > 0) {
        }
    }
    return false;
}
function KinkyDungeonDrawShrine() {
    let cost = 0;
    let type = KinkyDungeonTargetTile.Name;
    KDModalArea = true;
    if (KinkyDungeonShrineAvailable(type))
        cost = KinkyDungeonShrineCost(type);
    if (type == "Commerce") {
        if (cost == 0) {
            DrawTextKD(TextGet("KinkyDungeonLockedShrine"), KDModalArea_x, KDModalArea_y, "#ffffff", KDTextGray2);
        }
        else {
            let shopHeight = Math.max(8, KDGameData.ShopItems.length) * 50;
            FillRectKD(kdcanvas, kdpixisprites, "shopbg", {
                Left: KDModalArea_x - 25,
                Top: KDModalArea_y + 80 - shopHeight,
                Width: 900,
                Height: shopHeight + 20,
                Color: KDTextGray0,
                LineWidth: 1,
                zIndex: 60,
                alpha: 0.4,
            });
            if (KinkyDungeonShopIndex > KDGameData.ShopItems.length) {
                KinkyDungeonShopIndex = 0;
            }
            else if (KDGameData.ShopItems.length > 0 && KDGameData.ShopItems[KinkyDungeonShopIndex]) {
            }
            DrawButtonKDEx("shrinebuy", (bdata) => {
                KDSendInput("shrineBuy", { type: type, shopIndex: KinkyDungeonShopIndex });
                return true;
            }, cost <= KinkyDungeonGold, KDModalArea_x + 550, KDModalArea_y + 25, 200, 60, TextGet("KinkyDungeonCommercePurchase").replace("ItemCost", "" + cost), (cost <= KinkyDungeonGold) ? "#ffffff" : "#ff5555", "", "");
            if (KDShopBuyConfirm) {
                DrawTextFitKD(TextGet("KDShopConfirm"), KDModalArea_x + 650, KDModalArea_y + 25 - 25, 250, "#88ff88", undefined, 20);
            }
            let ii = 0;
            for (let l of KDGameData.ShopItems) {
                if (KDGameData.ShopItems[ii]) {
                    let index = ii;
                    DrawButtonKDEx("l.name" + ii, (bdata) => {
                        KinkyDungeonShopIndex = index;
                        return true;
                    }, true, KDModalArea_x - 20, KDModalArea_y + 40 - ii * 50, 400 + 20 + 20, 45, "", "#444444", "", undefined, false, true, "#000000", undefined, undefined, {
                        alpha: 0.4
                    });
                }
                DrawTextFitKD(TextGet("KinkyDungeonInventoryItem" + l.name), KDModalArea_x + 175 / 2, KDModalArea_y + 65 - ii * 50, 200, KDGameData.ShopItems[KinkyDungeonShopIndex].name == l.name ? "white" : KDTextGray3, KDTextGray2, 20);
                DrawTextFitKD(TextGet("KinkyDungeonCommerceCost").replace("ItemCost", "" + KinkyDungeonItemCost(l)), KDModalArea_x + 300, KDModalArea_y + 65 - ii * 50, 130, KDGameData.ShopItems[KinkyDungeonShopIndex].name == l.name ? "#ffffff" : KDTextGray3, KDTextGray2, 20);
                ii++;
            }
            let textSplit = KinkyDungeonWordWrap(TextGet("KinkyDungeonInventoryItem" + KDGameData.ShopItems[KinkyDungeonShopIndex].name + "Desc"), 15, 40).split('\n');
            let textSplit2 = KinkyDungeonWordWrap(TextGet("KinkyDungeonInventoryItem" + KDGameData.ShopItems[KinkyDungeonShopIndex].name + "Desc2"), 15, 40).split('\n');
            let i = 0;
            let descSpacing = 30;
            for (let N = 0; N < textSplit.length; N++) {
                DrawTextFitKD(textSplit[N], KDModalArea_x + 650, KDModalArea_y + 120 - shopHeight + i * descSpacing, 380 * (textSplit[N].length / 40), "#ffffff", undefined, 20);
                i++;
            }
            i += 1;
            for (let N = 0; N < textSplit2.length; N++) {
                DrawTextFitKD(textSplit2[N], KDModalArea_x + 650, KDModalArea_y + 120 - shopHeight * 50 + i * descSpacing, 380 * (textSplit2[N].length / 40), "#ffffff", undefined, 20);
                i++;
            }
            KDModalArea_y = 700 - shopHeight;
            KDModalArea_height = shopHeight + 100;
        }
    }
    else {
        DrawButtonKDEx("shrineUse", (bdata) => {
            KDSendInput("shrineUse", { type: type, cost: cost, targetTile: KinkyDungeonTargetTileLocation });
            KinkyDungeonTargetTileLocation = "";
            KinkyDungeonTargetTile = null;
            return true;
        }, cost > 0, KDModalArea_x, KDModalArea_y + 25, 325, 60, TextGet(cost > 0 ? "KinkyDungeonPayShrine" : "KinkyDungeonPayShrineCant").replace("XXX", "" + cost), cost > 0 ? "#ffffff" : KDTextGray2, "", "");
        DrawButtonKDEx("drinkShrine", (bdata) => {
            KDSendInput("shrineDrink", { type: type, targetTile: KinkyDungeonTargetTileLocation });
            return true;
        }, true, KDModalArea_x + 350, KDModalArea_y + 25, 200, 60, TextGet("KinkyDungeonDrinkShrine"), (KDCanDrinkShrine(false)) ? "#AAFFFF" : KDTextGray2, "", "");
        DrawButtonKDEx("bottleShrine", (bdata) => {
            KDSendInput("shrineBottle", { type: type, targetTile: KinkyDungeonTargetTileLocation });
            return true;
        }, true, KDModalArea_x + 575, KDModalArea_y + 25, 200, 60, TextGet("KinkyDungeonBottleShrine"), (KDCanDrinkShrine(true)) ? "#AAFFFF" : KDTextGray2, "", "");
    }
}
let KDGoddessRevengeMobTypes = {
    Rope: { require: undefined, requireSingle: ["ropeTrap", "rope"], filter: ["human", "immobile"] },
    Latex: { require: undefined, requireSingle: ["slime", "latexTrap", "latex"], filter: ["human", "immobile"] },
    Metal: { require: undefined, requireSingle: ["metalTrap", "metal"], filter: ["human", "immobile"] },
    Leather: { require: undefined, requireSingle: ["leatherTrap", "leather"], filter: ["human", "immobile"] },
    Elements: { require: ["elemental"], requireSingle: ["fire", "water", "earth", "air"], filter: ["human", "immobile"] },
    Will: { requireSingle: ["nature", "beast"], require: undefined, filter: ["human", "immobile"] },
    Conjure: { require: [], requireSingle: ["book", "ribbon", "familiar"], filter: ["human", "immobile"] },
    Illusion: { require: ["ghost"], requireSingle: ["spooky"], filter: ["immobile"] },
};
function KDSummonRevengeMobs(x, y, Goddess, mult = 1.0, LevelBoost = 2) {
    let spawned = 0;
    let maxspawn = 1 + Math.round(Math.min(2 + KDRandom() * 2, KinkyDungeonDifficulty / 25) + Math.min(2 + KDRandom() * 2, 0.5 * MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint));
    if (mult)
        maxspawn *= mult;
    let types = KDGoddessRevengeMobTypes[Goddess];
    let requireTags = types ? types.require : undefined;
    let requireSingleTag = types ? types.requireSingle : undefined;
    let filter = types ? types.filter : undefined;
    let tags = ["revenge"];
    KinkyDungeonAddTags(tags, MiniGameKinkyDungeonLevel);
    for (let i = 0; i < 30 + maxspawn; i++) {
        if (spawned < maxspawn) {
            let Enemy = KinkyDungeonGetEnemy(tags, MiniGameKinkyDungeonLevel + LevelBoost, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', requireTags, false, undefined, filter, requireSingleTag);
            if (Enemy) {
                let pass = KinkyDungeonSummonEnemy(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, Enemy.name, 1, 10, false, undefined, i < 24, false, "Ambush", true, 1.5, true, undefined, true, true);
                if (pass) {
                    if (Enemy.tags.minor)
                        spawned += 0.4;
                    else
                        spawned += 1;
                }
            }
        }
    }
    return spawned;
}
function KDCanDrinkShrine(Bottle) {
    if (Bottle && KinkyDungeonIsHandsBound(true, true, 0.9))
        return false;
    return !KinkyDungeonTargetTile.drunk && (Bottle || KinkyDungeonStatMana < KinkyDungeonStatManaMax || KinkyDungeonStatManaPool < KinkyDungeonStatManaPoolMax || KinkyDungeonPlayerTags.get("slime"));
}
function KinkyDungeonShrineAngerGods(Type) {
    if (Type == "Elements") {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("ChainArms"), 2, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("ChainLegs"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), 0, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("ChainCrotch"), 0, true, KinkyDungeonGenerateLock(true));
    }
    else if (Type == "Latex") {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("LatexStraitjacket"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("LatexLegbinder"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("LatexBoots"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("LatexCorset"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), 0, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("ChainCrotch"), 0, true, KinkyDungeonGenerateLock(true));
    }
    else if (Type == "Conjure" || Type == "Rope") {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("StrongMagicRopeArms"), 4, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("StrongMagicRopeLegs"), 0, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("StrongMagicRopeCrotch"), 2, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), 0, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("StrongMagicRopeFeet"), 0, true);
    }
    else if (Type == "Illusion") {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBlindfold"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapMittens"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), 0, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), 0, true, KinkyDungeonGenerateLock(true));
    }
    else if (Type == "Leather") {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapHarness"), 4, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBlindfold"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBoots"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("SturdyLeatherBeltsFeet"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("SturdyLeatherBeltsLegs"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapArmbinder"), 4, true, KinkyDungeonGenerateLock(true));
    }
    else if (Type == "Metal") {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("WristShackles"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("AnkleShackles"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("LegShackles"), 0, true, KinkyDungeonGenerateLock(true));
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapVibe"), 0, true);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), 0, true, KinkyDungeonGenerateLock(true));
    }
    else if (Type == "Will") {
        KinkyDungeonStatMana = 0;
        KinkyDungeonStatStamina = 0;
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("GhostCollar"), 0, true);
    }
    if (KinkyDungeonGoddessRep[Type] < -45) {
        KinkyDungeonSummonEnemy(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, "OrbGuardian", 3 + Math.floor(Math.sqrt(1 + MiniGameKinkyDungeonLevel)), 10, false, 30);
    }
    KinkyDungeonChangeRep(Type, -10);
}
function KinkyDungeonGetSetPieces(Dict) {
    let ret = [];
    for (let sh of Dict) {
        if (sh.Type) {
            ret.push(sh.Type);
        }
    }
    return ret;
}
function KinkyDungeonGetMapShrines(Dict) {
    let ret = [];
    for (let sh of Dict) {
        if (sh.Type) {
            ret.push(sh.Type);
        }
    }
    return ret;
}
function KinkyDungeonTakeOrb(Amount, X, Y) {
    KinkyDungeonSetFlag("NoDialogue", 3);
    KinkyDungeonDrawState = "Orb";
    KinkyDungeonOrbAmount = Amount;
    KDOrbX = X;
    KDOrbY = Y;
}
function KinkyDungeonDrawOrb() {
    DrawTextKD(TextGet("KinkyDungeonOrbIntro" + (KinkyDungeonStatsChoice.get("randomMode") ? "Kinky" : "")), 1250, 200, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("KinkyDungeonOrbIntro2"), 1250, 250, "#ffffff", KDTextGray2);
    let i = 0;
    let maxY = 560;
    let XX = 500;
    let spacing = 60;
    let yPad = 150;
    for (let shrine in KinkyDungeonShrineBaseCosts) {
        let value = KinkyDungeonGoddessRep[shrine];
        if (value != undefined) {
            if (spacing * i > maxY) {
                if (XX == 0)
                    i = 0;
                XX = 600;
            }
            let color = "#ffff00";
            if (value < -10) {
                if (value < -30)
                    color = "#ff0000";
                else
                    color = "#ff8800";
            }
            else if (value > 10) {
                if (value > 30)
                    color = "#00ff00";
                else
                    color = "#88ff00";
            }
            DrawButtonVis(canvasOffsetX_ui + XX, yPad + canvasOffsetY_ui + spacing * i - 27, 250, 55, TextGet("KinkyDungeonShrine" + shrine), "white");
            DrawProgressBar(canvasOffsetX_ui + 275 + XX, yPad + canvasOffsetY_ui + spacing * i - spacing / 4, 200, spacing / 2, 50 + value, color, KDTextGray2);
            if (KinkyDungeonShrineBaseCosts[shrine])
                KDDrawRestraintBonus(shrine, canvasOffsetX_ui + 275 + XX - 70, yPad + canvasOffsetY_ui + spacing * i, undefined, 24);
            i++;
        }
    }
    DrawButtonVis(canvasOffsetX_ui + 525, yPad + canvasOffsetY_ui + spacing * i, 425, 55, TextGet("KinkyDungeonSurpriseMe"), "white");
    i += 2;
    DrawButtonKDEx("cancelorb", (bdata) => {
        KinkyDungeonDrawState = "Game";
        return true;
    }, true, canvasOffsetX_ui + 525, yPad + canvasOffsetY_ui + spacing * i, 425, 55, TextGet("KinkyDungeonCancel"), "white");
}
let KDOrbX = 0;
let KDOrbY = 0;
function KinkyDungeonHandleOrb() {
    let Amount = KinkyDungeonOrbAmount;
    let i = 0;
    let maxY = 560;
    let XX = 500;
    let spacing = 60;
    let yPad = 150;
    for (let shrine in KinkyDungeonShrineBaseCosts) {
        let value = KinkyDungeonGoddessRep[shrine];
        if (value != undefined) {
            if (spacing * i > maxY) {
                if (XX == 0)
                    i = 0;
                XX = 600;
            }
            if (MouseIn(canvasOffsetX_ui + XX, yPad + canvasOffsetY_ui + spacing * i - 27, 250, 55)) {
                KDSendInput("orb", { shrine: shrine, Amount: Amount, x: KDOrbX, y: KDOrbY });
                KinkyDungeonDrawState = "Game";
                return true;
            }
            i++;
        }
    }
    if (MouseIn(canvasOffsetX_ui + 525, yPad + canvasOffsetY_ui + spacing * i, 425, 55)) {
        let shrine = Object.keys(KinkyDungeonShrineBaseCosts)[Math.floor(KDRandom() * Object.keys(KinkyDungeonShrineBaseCosts).length)];
        if (KinkyDungeonMapGet(KDOrbX, KDOrbY) == 'O') {
            if (KinkyDungeonGoddessRep[shrine] < -45) {
                KinkyDungeonSummonEnemy(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, "OrbGuardian", 3 + Math.floor(Math.sqrt(1 + MiniGameKinkyDungeonLevel)), 10, false, 30);
            }
            KinkyDungeonChangeRep(shrine, Amount * -9);
            if (KinkyDungeonStatsChoice.get("randomMode")) {
                let spell = null;
                let spellList = [];
                let maxSpellLevel = 4;
                for (let k of Object.keys(KinkyDungeonSpellList)) {
                    for (let sp of KinkyDungeonSpellList[k]) {
                        if (KinkyDungeonCheckSpellPrerequisite(sp) && sp.school == k && !sp.secret) {
                            for (let iii = 0; iii < maxSpellLevel - sp.level; iii++) {
                                if (sp.level == 1 && KinkyDungeonStatsChoice.get("Novice"))
                                    spellList.push(sp);
                                spellList.push(sp);
                            }
                        }
                    }
                }
                for (let sp of KinkyDungeonSpells) {
                    for (let S = 0; S < spellList.length; S++) {
                        if (sp.name == spellList[S].name) {
                            spellList.splice(S, 1);
                            S--;
                        }
                    }
                }
                spell = spellList[Math.floor(KDRandom() * spellList.length)];
                if (spell) {
                    KinkyDungeonSpells.push(spell);
                    if (spell.autoLearn) {
                        for (let sp of spell.autoLearn) {
                            if (KinkyDungeonSpellIndex(sp) < 0) {
                                KinkyDungeonSpells.push(KinkyDungeonFindSpell(sp, true));
                            }
                        }
                    }
                    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonOrbSpell").replace("SPELL", TextGet("KinkyDungeonSpell" + spell.name)), "lightblue", 2);
                }
            }
            else {
                KinkyDungeonSpellPoints += Amount;
            }
            KinkyDungeonMapSet(KDOrbX, KDOrbY, 'o');
        }
        KinkyDungeonDrawState = "Game";
        return true;
    }
    return true;
}
let KDPerkConfirm = false;
let KDPerkOrbPerks = [];
function KinkyDungeonTakePerk(Amount, X, Y) {
    KinkyDungeonSetFlag("NoDialogue", 3);
    KDPerkOrbPerks = KinkyDungeonTilesGet(X + "," + Y).Perks;
    KinkyDungeonDrawState = "PerkOrb";
    KinkyDungeonOrbAmount = Amount;
    KDOrbX = X;
    KDOrbY = Y;
}
function KinkyDungeonDrawPerkOrb() {
    let bwidth = 350;
    let bheight = 64;
    let Twidth = 1250;
    MainCanvas.textAlign = "center";
    DrawTextKD(TextGet("KinkyDungeonPerkIntro"), 1250, 200, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("KinkyDungeonPerkIntro2"), 1250, 250, "#ffffff", KDTextGray2);
    let count = 0;
    let pspacing = 120;
    for (let p of KDPerkOrbPerks) {
        DrawTextFitKD(TextGet("KinkyDungeonStat" + KinkyDungeonStatsPresets[p].id), 1250, 350 + count * pspacing, Twidth, "#ffffff", KDTextGray2, 30);
        DrawTextFitKD(TextGet("KinkyDungeonStatDesc" + KinkyDungeonStatsPresets[p].id), 1250, 385 + count * pspacing, Twidth, "#ffffff", KDTextGray2, 22);
        FillRectKD(kdcanvas, kdpixisprites, "bg_" + KinkyDungeonStatsPresets[p].id, {
            Left: 1250 - Twidth / 2 - 10,
            Top: 350 + count * pspacing - 30,
            Width: Twidth + 20,
            Height: 70 + 20,
            Color: KDTextGray0,
            LineWidth: 1,
            zIndex: 60,
            alpha: 0.7,
        });
        count += 1;
    }
    if (KDPerkConfirm) {
        DrawTextFitKD(TextGet("KinkyDungeonPerkConfirm"), 1250, 720, 1300, "#ffffff", KDTextGray2, 30);
    }
    DrawButtonKDEx("accept", (bdata) => {
        if (KDPerkConfirm) {
            KDSendInput("perkorb", { shrine: "perk", perks: KDPerkOrbPerks, Amount: 1, x: KDOrbX, y: KDOrbY });
            KinkyDungeonDrawState = "Game";
        }
        KDPerkConfirm = true;
        return true;
    }, true, 1250 - bwidth / 2, 750, bwidth, bheight, TextGet("KinkyDungeonPerkAccept" + (KDPerkConfirm ? "Confirm" : "")), "#ffffff");
    DrawButtonKDEx("reject", (bdata) => {
        KinkyDungeonDrawState = "Game";
        return true;
    }, true, 1250 - bwidth / 2, 750 + 80, bwidth, bheight, TextGet("KinkyDungeonPerkReject"), "#ffffff");
}
function KDGetPosNegColor(value) {
    return (value ? (value > 0 ? KDGoodColor : KDCurseColor) : "#dddddd");
}
function KDGetGoddessBonus(shrine) {
    if (KinkyDungeonGoddessRep[shrine]) {
        return KinkyDungeonGoddessRep[shrine] / 50 * (KinkyDungeonGoddessRep[shrine] > 0 ? KDMaxGoddessBonus : KDMinGoddessBonus);
    }
    return 0;
}
function KDDrawRestraintBonus(shrine, x, y, width = 100, FontSize, align, zIndex, alpha, forceColor) {
    let bonus = KDGetGoddessBonus(shrine);
    let color = forceColor ? forceColor : KDGetPosNegColor(bonus);
    let str = (bonus >= 0 ? "+" : "") + Math.round(bonus * 100) + "%";
    DrawTextFitKD(str, x, y, width, color, "#000000", FontSize, align, zIndex, alpha);
}
let KDObjectMessages = {
    "Ghost": () => KinkyDungeonGhostMessage(),
    "Angel": () => KinkyDungeonAngelMessage(),
    "Food": () => KinkyDungeonFoodMessage(),
};
let KDObjectClick = {
    "Food": (x, y) => {
        let tile = KinkyDungeonTilesGet(x + "," + y);
        if (tile.Food && !tile.Eaten) {
            KinkyDungeonTargetTileLocation = x + "," + y;
            KinkyDungeonTargetTile = tile;
            KDStartDialog("TableFood", "", true, "");
        }
        else
            KinkyDungeonFoodMessage(tile);
    },
};
let KDObjectHandle = {
    "Charger": () => KinkyDungeonHandleCharger(),
};
let KDObjectDraw = {
    "Ghost": () => KinkyDungeonDrawGhost(),
    "Angel": () => KinkyDungeonDrawAngel(),
    "Charger": () => KinkyDungeonDrawCharger(),
    "Tablet": () => KinkyDungeonDrawTablet(),
    "Lock": () => KinkyDungeonDrawLock(),
    "Shrine": () => KinkyDungeonDrawShrine(),
    "Door": () => KinkyDungeonDrawDoor(),
};
function KinkyDungeonDrawDoor() {
    if (KinkyDungeonTargetTile.Lock) {
        let action = false;
        if (KinkyDungeonLockpicks > 0 && (KinkyDungeonTargetTile.Lock.includes("Red") || KinkyDungeonTargetTile.Lock.includes("Blue"))) {
            DrawButtonVis(KDModalArea_x + 313, KDModalArea_y + 25, 112, 60, TextGet("KinkyDungeonPickDoor"), "#ffffff", "", "");
            action = true;
            KDModalArea = true;
        }
        if (KinkyDungeonTargetTile.Lock.includes("Red") || KinkyDungeonTargetTile.Lock.includes("Blue")) {
            DrawButtonVis(KDModalArea_x + 175, KDModalArea_y + 25, 112, 60, TextGet("KinkyDungeonUnlockDoor"), (KinkyDungeonTargetTile.Lock.includes("Red") && KinkyDungeonRedKeys > 0)
                || (KinkyDungeonTargetTile.Lock.includes("Blue") && KinkyDungeonBlueKeys > 0) ? "#ffffff" : "#ff0000", "", "");
            action = true;
            KDModalArea = true;
        }
        if ((KinkyDungeonTargetTile.Lock.includes("Purple"))) {
            let spell = KinkyDungeonFindSpell("CommandWord", true);
            DrawButtonVis(KDModalArea_x + 175, KDModalArea_y + 25, 112, 60, TextGet("KinkyDungeonUnlockDoorPurple"), (KinkyDungeonStatMana >= KinkyDungeonGetManaCost(spell)) ? "#ffffff" : "#ff0000", "", "");
            action = true;
            KDModalArea = true;
        }
        if (!action)
            DrawTextKD(TextGet("KinkyDungeonLockedDoor"), KDModalArea_x + 300, KDModalArea_y + 50, "#ffffff", "#333333");
        if (KinkyDungeonTargetTile.Lock.includes("Red"))
            DrawTextKD(TextGet("KinkyRedLock"), KDModalArea_x + 25, KDModalArea_y + 50, "#ffffff", "#333333");
        else if (KinkyDungeonTargetTile.Lock.includes("Blue"))
            DrawTextKD(TextGet("KinkyBlueLock"), KDModalArea_x + 25, KDModalArea_y + 50, "#ffffff", "#333333");
        else if (KinkyDungeonTargetTile.Lock.includes("Purple"))
            DrawTextKD(TextGet("KinkyPurpleLock"), KDModalArea_x + 50, KDModalArea_y + 50, "#ffffff", "#333333");
    }
    else {
        KDModalArea = true;
        DrawButtonVis(KDModalArea_x + 25, KDModalArea_y + 25, 250, 60, TextGet("KinkyDungeonCloseDoor"), "#ffffff");
    }
}
function KinkyDungeonDrawLock() {
    if (KinkyDungeonTargetTile.Lock) {
        let action = false;
        if (KinkyDungeonLockpicks > 0 && (KinkyDungeonTargetTile.Lock.includes("Red") || KinkyDungeonTargetTile.Lock.includes("Blue"))) {
            DrawButtonVis(KDModalArea_x + 313, KDModalArea_y + 25, 112, 60, TextGet("KinkyDungeonPickDoor"), "#ffffff", "", "");
            action = true;
            KDModalArea = true;
        }
        if (KinkyDungeonTargetTile.Lock.includes("Red") || KinkyDungeonTargetTile.Lock.includes("Blue")) {
            DrawButtonVis(KDModalArea_x + 175, KDModalArea_y + 25, 112, 60, TextGet("KinkyDungeonUnlockDoor"), (KinkyDungeonTargetTile.Lock.includes("Red") && KinkyDungeonRedKeys > 0)
                || (KinkyDungeonTargetTile.Lock.includes("Blue") && KinkyDungeonBlueKeys > 0) ? "#ffffff" : "#ff0000", "", "");
            action = true;
            KDModalArea = true;
        }
        if ((KinkyDungeonTargetTile.Lock.includes("Purple"))) {
            let spell = KinkyDungeonFindSpell("CommandWord", true);
            DrawButtonVis(KDModalArea_x + 175, KDModalArea_y + 25, 112, 60, TextGet("KinkyDungeonUnlockDoorPurple"), (KinkyDungeonStatMana >= KinkyDungeonGetManaCost(spell)) ? "#ffffff" : "#ff0000", "", "");
            action = true;
            KDModalArea = true;
        }
        if (!action)
            DrawTextKD(TextGet("KinkyDungeonLockedDoor"), KDModalArea_x + 300, KDModalArea_y + 50, "#ffffff", "#333333");
        if (KinkyDungeonTargetTile.Lock.includes("Red"))
            DrawTextKD(TextGet("KinkyRedLock"), KDModalArea_x + 50, KDModalArea_y + 50, "#ffffff", "#333333");
        else if (KinkyDungeonTargetTile.Lock.includes("Blue"))
            DrawTextKD(TextGet("KinkyBlueLock"), KDModalArea_x + 50, KDModalArea_y + 50, "#ffffff", "#333333");
        else if (KinkyDungeonTargetTile.Lock.includes("Purple"))
            DrawTextKD(TextGet("KinkyPurpleLock"), KDModalArea_x + 50, KDModalArea_y + 50, "#ffffff", "#333333");
    }
}
function KinkyDungeonDrawGhost() {
    if (KDGameData.CurrentDialog)
        return;
    if (KinkyDungeonTargetTile.GhostDecision == 0)
        DrawTextKD(TextGet("KinkyDungeonDrawGhostHelpful"), KDModalArea_x + 200, KDModalArea_y + 50, "white", KDTextGray2);
    else
        DrawTextKD(TextGet("KinkyDungeonDrawGhostUnhelpful"), KDModalArea_x + 200, KDModalArea_y + 50, "white", KDTextGray2);
}
function KinkyDungeonDrawAngel() {
    DrawTextKD(TextGet("KinkyDungeonDrawAngelHelpful"), KDModalArea_x + 200, KDModalArea_y + 50, "white", KDTextGray2);
}
function KinkyDungeonGhostMessage() {
    if (KinkyDungeonTargetTile.Dialogue) {
        KDStartDialog(KinkyDungeonTargetTile.Dialogue, "Ghost", true, "", undefined);
        if (KinkyDungeonTargetTile.Msg && KDGameData.CurrentDialog) {
            KDGameData.CurrentDialogMsg = KinkyDungeonTargetTile.Msg;
        }
        return;
    }
    else if (KinkyDungeonTargetTile.Msg) {
        KDStartDialog("GhostInfo", "Ghost", true, "", undefined);
        if (KDGameData.CurrentDialog) {
            KDGameData.CurrentDialogMsg = KinkyDungeonTargetTile.Msg;
        }
        return;
    }
    let restraints = KinkyDungeonAllRestraint();
    let msg = "";
    if (restraints.length == 0) {
        msg = TextGet("KinkyDungeonGhostGreet" + KinkyDungeonTargetTile.GhostDecision);
    }
    else {
        if (KinkyDungeonTargetTile.GhostDecision <= 1) {
            msg = TextGet("KinkyDungeonGhostHelpful" + KinkyDungeonTargetTile.GhostDecision);
        }
        else {
            let BoundType = "Generic";
            if (!KinkyDungeonCanTalk() && Math.random() < 0.33)
                BoundType = "Gag";
            if ((KinkyDungeonIsHandsBound() || KinkyDungeonIsArmsBound()) && Math.random() < 0.33)
                BoundType = "Arms";
            if (KinkyDungeonSlowLevel > 0 && Math.random() < 0.33)
                BoundType = "Feet";
            if (KinkyDungeonChastityMult() > 0 && Math.random() < 0.33)
                BoundType = "Chaste";
            msg = TextGet("KinkyDungeonGhostUnhelpful" + BoundType + KinkyDungeonTargetTile.GhostDecision);
        }
    }
    if (msg) {
        KinkyDungeonSendActionMessage(3, msg, "white", 3);
    }
}
function KinkyDungeonAngelMessage() {
    let restraints = KinkyDungeonAllRestraint();
    let msg = "";
    if (restraints.length == 0) {
        msg = TextGet("KinkyDungeonAngelGreet");
    }
    else {
        msg = TextGet("KinkyDungeonAngelHelpful");
    }
    if (msg) {
        KinkyDungeonSendActionMessage(3, msg, "#ffffff", 1, true);
    }
}
function KinkyDungeonFoodMessage(Tile) {
    let tile = Tile || KinkyDungeonTargetTile;
    if (tile) {
        let msg = TextGet("KinkyDungeonFood" + (tile.Food ? tile.Food : ""));
        if (msg) {
            KinkyDungeonSendActionMessage(3, msg, "#ffffff", 1, true);
        }
    }
}
function KinkyDungeonMakeGhostDecision() {
    for (let tile of Object.values(KinkyDungeonTiles)) {
        if (tile.Type == "Ghost") {
            tile.GhostDecision = 0;
            let rep = KinkyDungeonGoddessRep.Ghost;
            if (rep > 0)
                tile.GhostDecision += 1;
            if (rep != undefined) {
                let mult = KinkyDungeonStatsChoice.get("Oppression") ? 1.5 : (KinkyDungeonStatsChoice.has("Dominant") ? 0.5 : 1.0);
                if (KDRandom() * 100 * mult > -rep + 75)
                    tile.GhostDecision += 1;
                if (KDRandom() * 100 * mult > -rep + 85)
                    tile.GhostDecision += 1;
                if (KDRandom() * 100 * mult > -rep + 95)
                    tile.GhostDecision += 1;
            }
        }
    }
}
function KinkyDungeonDrawCharger() {
    KDModalArea = true;
    if (KinkyDungeonTargetTile && KinkyDungeonTargetTile.Light == KDChargerLight) {
        DrawButtonVis(KDModalArea_x + 25, KDModalArea_y + 25, 400, 60, TextGet("KinkyDungeonChargerRemoveCrystal"), "white", "", "");
    }
    else {
        DrawButtonVis(KDModalArea_x + 250, KDModalArea_y + 25, 200, 60, TextGet("KinkyDungeonChargerCharge"), KinkyDungeonInventoryGet("AncientPowerSourceSpent") ? "white" : "#888888", "", "");
        DrawButtonVis(KDModalArea_x + 25, KDModalArea_y + 25, 200, 60, TextGet("KinkyDungeonChargerPlaceCrystal"), KinkyDungeonInventoryGet("AncientPowerSource") ? "white" : "#888888", "", "");
    }
}
function KinkyDungeonDrawTablet() {
    KDModalArea = true;
    if (KinkyDungeonTargetTile) {
        DrawButtonKDEx("Tablet", (bdata) => {
            KDSendInput("tabletInteract", { action: "read", targetTile: KinkyDungeonTargetTileLocation });
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = "";
            return true;
        }, true, KDModalArea_x + 25, KDModalArea_y + 25, 400, 60, TextGet("KinkyDungeonTabletRead"), "white", "", "");
    }
}
function KinkyDungeonDrawFood() {
    KDModalArea = true;
    if (KinkyDungeonTargetTile && KinkyDungeonTargetTile.Food && KinkyDungeonTargetTile.Food != "Plate") {
        DrawButtonKDEx("Food", (bdata) => {
            KDSendInput("foodInteract", { action: "eat", targetTile: KinkyDungeonTargetTileLocation });
            KinkyDungeonTargetTile = null;
            KinkyDungeonTargetTileLocation = "";
            return true;
        }, true, KDModalArea_x + 25, KDModalArea_y + 25, 400, 60, TextGet("KinkyDungeonFoodEat"), "white", "", "");
    }
}
let KDChargerLight = 6.5;
let KDChargerColor = 0xffee83;
let KDLeylineLightColor = 0x4477ff;
let KDLeylineLight = 8;
function KinkyDungeonHandleCharger() {
    if (KinkyDungeonTargetTile && KinkyDungeonTargetTile.Light == KDChargerLight) {
        if (MouseIn(KDModalArea_x + 25, KDModalArea_y + 25, 400, 60) && KinkyDungeonTargetTile) {
            KDSendInput("chargerInteract", { action: "remove", targetTile: KinkyDungeonTargetTileLocation });
            return true;
        }
    }
    else {
        if (MouseIn(KDModalArea_x + 250, KDModalArea_y + 25, 200, 60)) {
            if (KDSendInput("chargerInteract", { action: "charge", targetTile: KinkyDungeonTargetTileLocation })) {
                KinkyDungeonTargetTile = null;
                KinkyDungeonTargetTileLocation = "";
            }
            return true;
        }
        else if (MouseIn(KDModalArea_x + 25, KDModalArea_y + 25, 200, 60) && KinkyDungeonTargetTile) {
            KDSendInput("chargerInteract", { action: "place", targetTile: KinkyDungeonTargetTileLocation });
            return true;
        }
    }
    return false;
}
let KinkyDungeonGroundItems = [];
let KDDroppedItemProperties = {
    "RedKey": {
        tinyness: 2,
    },
    "Pick": {
        tinyness: 1,
    },
    "BlueKey": {
        tinyness: 2,
    },
    "Knife": {
        tinyness: 3,
    },
    "EnchKnife": {
        tinyness: 3,
    },
    "Dirk": {
        tinyness: 3,
    },
    "Scissors": {
        tinyness: 3,
    },
};
function KinkyDungeonItemDrop(x, y, dropTable, summoned) {
    if (dropTable) {
        let dropWeightTotal = 0;
        let dropWeights = [];
        for (let drop of dropTable) {
            let weight = drop.weight;
            dropWeights.push({ drop: drop, weight: dropWeightTotal });
            if (drop.ignoreInInventory && (KinkyDungeonInventoryGet(drop.name) || KinkyDungeonFlags.get("ItemDrop_" + drop.name)))
                weight = 0;
            if (drop.chance && KDRandom() > drop.chance)
                weight = 0;
            dropWeightTotal += Math.max(weight, 0);
        }
        let selection = KDRandom() * dropWeightTotal;
        for (let L = dropWeights.length - 1; L >= 0; L--) {
            if (selection > dropWeights[L].weight) {
                if (dropWeights[L].drop.name != "Nothing" && (!KinkyDungeonStatsChoice.get("Stealthy") || dropWeights[L].drop.name != "Gold") && (!summoned || !dropWeights[L].drop.noSummon)) {
                    let dropped = { x: x, y: y, name: dropWeights[L].drop.name, amount: dropWeights[L].drop.amountMin + Math.floor(KDRandom() * dropWeights[L].drop.amountMax) };
                    if (!KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(x, y))) {
                        let newPoint = KinkyDungeonGetNearbyPoint(x, y, false, undefined, true);
                        if (newPoint) {
                            dropped.x = newPoint.x;
                            dropped.y = newPoint.y;
                        }
                        else {
                            console.log("Failed to find point to drop " + TextGet("KinkyDungeonInventoryItem" + dropWeights[L].drop.name));
                        }
                    }
                    KinkyDungeonGroundItems.push(dropped);
                    KinkyDungeonSetFlag("ItemDrop_" + dropped.name, Math.round(12 + KDRandom() * 8));
                    return dropped;
                }
                return false;
            }
        }
    }
    return false;
}
function KinkyDungeonDropItem(Item, Origin, AllowOrigin, noMsg, allowEnemies) {
    let slots = [];
    for (let X = -Math.ceil(1); X <= Math.ceil(1); X++)
        for (let Y = -Math.ceil(1); Y <= Math.ceil(1); Y++) {
            if ((X != 0 || Y != 0))
                slots.push({ x: X, y: Y });
        }
    let foundslot = AllowOrigin ? { x: Origin.x, y: Origin.y } : null;
    if (!(Origin == KinkyDungeonPlayerEntity && AllowOrigin && KinkyDungeonPlayer.IsEnclose())) {
        if (!foundslot || !(KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(foundslot.x, foundslot.y))
            && (allowEnemies || KinkyDungeonNoEnemy(foundslot.x, foundslot.y, true))))
            for (let C = 0; C < 100; C++) {
                let slot = slots[Math.floor(KDRandom() * slots.length)];
                if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(Origin.x + slot.x, Origin.y + slot.y))
                    && (allowEnemies || KinkyDungeonNoEnemy(Origin.x + slot.x, Origin.y + slot.y, true))) {
                    foundslot = { x: Origin.x + slot.x, y: Origin.y + slot.y };
                    C = 100;
                }
                else
                    slots.splice(C, 1);
            }
    }
    if (foundslot) {
        let dropped = { x: foundslot.x, y: foundslot.y, name: Item.name };
        if (Item.amountMin && Item.amountMax) {
            dropped.amount = Item.amountMin + Math.floor(KDRandom() * Item.amountMax);
        }
        else if (Item.amount) {
            dropped.amount = Item.amount;
        }
        KinkyDungeonGroundItems.push(dropped);
        if (!noMsg)
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonDrop" + Item.name), "#ff0000", 2);
        return true;
    }
    return false;
}
function KinkyDungeonItemEvent(Item) {
    let color = "white";
    let priority = 1;
    let sfx = "Coins";
    let name = Item.name;
    let replace = "";
    if (KDCustomItems[name]) {
        let ret = KDCustomItems[name](Item);
        if (ret.sfx != undefined)
            sfx = ret.sfx;
        if (ret.replace != undefined)
            replace = ret.replace;
        if (ret.priority != undefined)
            priority = ret.priority;
        if (ret.color != undefined)
            color = ret.color;
        if (ret.name != undefined)
            name = ret.name;
    }
    else if (Item.name == "Gold") {
        color = "yellow";
        KinkyDungeonAddGold(Item.amount);
    }
    else if (Item.name == "Lore") {
        return KinkyDungeonNewLore();
    }
    else if (Item.name == "Pick") {
        priority = 2;
        color = "lightgreen";
        KinkyDungeonLockpicks += 1;
    }
    else if (Item.name == "MagicSword") {
        priority = 8;
        color = "orange";
        KinkyDungeonInventoryAddWeapon("MagicSword");
    }
    else if (Item.name == "Scrolls") {
        priority = 4;
        color = "lightgreen";
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollArms, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollLegs, 1);
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollVerbal, 1);
    }
    else if (Item.name == "Knife") {
        priority = 2;
        color = "lightgreen";
        KinkyDungeonInventoryAddWeapon("Knife");
    }
    else if (Item.name == "Knives") {
        priority = 3;
        color = "lightgreen";
        KinkyDungeonInventoryAddWeapon("Knife");
        if (!KinkyDungeonPlayerDamage || KinkyDungeonPlayerDamage.unarmed) {
            KDSetWeapon("Knife");
            KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
        }
    }
    else if (Item.name == "EnchKnife") {
        priority = 2;
        color = "lightgreen";
        KinkyDungeonInventoryAddWeapon("EnchKnife");
        if (!KinkyDungeonPlayerDamage || KinkyDungeonPlayerDamage.unarmed) {
            KDSetWeapon("EnchKnife");
            KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
        }
    }
    else if (Item.name == "RedKey") {
        priority = 2;
        color = "lightgreen";
        KinkyDungeonRedKeys += 1;
    }
    else if (Item.name == "BlueKey") {
        priority = 2;
        color = "lightgreen";
        KinkyDungeonBlueKeys += 1;
    }
    else if (Item.name == "PotionMana") {
        priority = 3;
        color = "lightblue";
        sfx = "PotionDrink";
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionMana, 1);
    }
    else if (Item.name == "PotionStamina") {
        priority = 3;
        sfx = "PotionDrink";
        color = "lightgreen";
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionStamina, 1);
    }
    else if (Item.name == "PotionFrigid") {
        priority = 3;
        sfx = "PotionDrink";
        color = "white";
        KinkyDungeonChangeConsumable(KinkyDungeonConsumables.PotionFrigid, 1);
    }
    else if (KinkyDungeonFindConsumable(Item.name)) {
        let item = KinkyDungeonFindConsumable(Item.name);
        priority = item.rarity;
        if (item.potion)
            sfx = "PotionDrink";
        color = "white";
        KinkyDungeonChangeConsumable(item, 1);
    }
    else if (KinkyDungeonFindWeapon(Item.name)) {
        let item = KinkyDungeonFindWeapon(Item.name);
        priority = Math.min(8, item.rarity + 4);
        color = "orange";
        KinkyDungeonInventoryAddWeapon(Item.name);
    }
    else if (Item.name == "Heart") {
        if (KinkyDungeonStatDistractionMax >= KDMaxStat && KinkyDungeonStatStaminaMax >= KDMaxStat && KinkyDungeonStatManaMax >= KDMaxStat && KinkyDungeonStatWillMax >= KDMaxStat) {
            KinkyDungeonDrawState = "Game";
            KinkyDungeonChangeStamina(30);
            KinkyDungeonChangeMana(5);
            KinkyDungeonChangeWill(2.5);
            KDGameData.HeartTaken = true;
        }
        else if (KinkyDungeonIsPlayer()) {
            KinkyDungeonDrawState = "Heart";
            KinkyDungeonInterruptSleep();
            KinkyDungeonSetFlag("NoDialogue", 3);
        }
    }
    else if (Item.name == "Keyring") {
        KDGameData.JailKey = true;
        KinkyDungeonAggroAction('key', {});
    }
    else if (KinkyDungeonGetRestraintByName(Item.name)) {
        if (!KinkyDungeonInventoryGetLoose(Item.name)) {
            KinkyDungeonInventoryAdd({ name: Item.name, id: KinkyDungeonGetItemID(), type: LooseRestraint, events: Item.events, quantity: 1 });
        }
        else {
            if (!KinkyDungeonInventoryGetLoose(Item.name).quantity)
                KinkyDungeonInventoryGetLoose(Item.name).quantity = 0;
            KinkyDungeonInventoryGetLoose(Item.name).quantity += 1;
        }
        color = "#ffffff";
        name = "Generic";
        replace = TextGet("Restraint" + Item.name);
    }
    if (KDToggles.Sound)
        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/" + sfx + ".ogg");
    KinkyDungeonSendActionMessage(priority, TextGet("ItemPickup" + name).replace("XXX", Item.amount).replace("ReplaceValue", replace), color, 1);
    if (!KDCanSeeDroppedItem(Item))
        KinkyDungeonSendActionMessage(priority + 1, TextGet("ItemFoundHidden").replace("XXX", Item.amount).replace("ReplaceValue", replace), color, 1);
}
function KinkyDungeonItemCheck(x, y, Index) {
    for (let I = 0; I < KinkyDungeonGroundItems.length; I++) {
        let item = KinkyDungeonGroundItems[I];
        if (x == item.x && y == item.y) {
            KinkyDungeonGroundItems.splice(I, 1);
            I -= 1;
            KinkyDungeonItemEvent(item);
        }
    }
}
function KDCanSeeDroppedItem(item) {
    var _a;
    if (((_a = KDDroppedItemProperties[item.name]) === null || _a === void 0 ? void 0 : _a.tinyness) <= KinkyDungeonBlindLevel)
        return false;
    return true;
}
function KinkyDungeonDrawItems(canvasOffsetX, canvasOffsetY, CamX, CamY) {
    for (let item of KinkyDungeonGroundItems) {
        let sprite = item.name;
        if (KinkyDungeonRestraintsCache.has(item.name))
            sprite = "Restraint";
        if (item.x >= CamX && item.y >= CamY && item.x < CamX + KinkyDungeonGridWidthDisplay && item.y < CamY + KinkyDungeonGridHeightDisplay && KinkyDungeonVisionGet(item.x, item.y) > 0) {
            if (KDCanSeeDroppedItem(item))
                KDDraw(kdgameboard, kdpixisprites, item.x + "," + item.y + "_" + item.name, KinkyDungeonRootDirectory + "Items/" + sprite + ".png", (item.x - CamX) * KinkyDungeonGridSizeDisplay, (item.y - CamY) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay);
        }
    }
}
function KinkyDungeonDrawHeart() {
    DrawTextKD(TextGet("KinkyDungeonHeartIntro"), 1250, 200, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("KinkyDungeonHeartIntro1"), 1250, 300, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("KinkyDungeonHeartIntro2"), 1250, 350, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("KinkyDungeonHeartIntro3"), 1250, 400, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("KinkyDungeonHeartIntro4"), 1250, 450, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("StatDistraction").replace("PERCENT", "" + Math.round(100 * KinkyDungeonStatDistractionMax / KDMaxStatStart)), 650 + 250 / 2, 650, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("StatStamina").replace("CURRENT/MAX", "" + KinkyDungeonStatStaminaMax * KDMaxStatStart), 950 + 250 / 2, 650, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("StatMana").replace("CURRENT/MAX", "" + KinkyDungeonStatManaMax * KDMaxStatStart), 1250 + 250 / 2, 650, "#ffffff", KDTextGray2);
    DrawTextKD(TextGet("StatWill").replace("CURRENT/MAX", "" + KinkyDungeonStatWillMax * KDMaxStatStart), 1550 + 250 / 2, 650, "#ffffff", KDTextGray2);
    if (!(KinkyDungeonStatDistractionMax < KDMaxStat && KinkyDungeonStatStaminaMax < KDMaxStat && KinkyDungeonStatManaMax < KDMaxStat && KinkyDungeonStatWillMax < KDMaxStat))
        KinkyDungeonDrawState = "Game";
    DrawButtonVis(650, 700, 250, 60, TextGet("KinkyDungeonHeartDistraction"), KinkyDungeonStatDistractionMax < KDMaxStat ? "#ffffff" : "#999999");
    DrawButtonVis(950, 700, 250, 60, TextGet("KinkyDungeonHeartStamina"), KinkyDungeonStatStaminaMax < KDMaxStat ? "#ffffff" : "#999999");
    DrawButtonVis(1250, 700, 250, 60, TextGet("KinkyDungeonHeartMana"), KinkyDungeonStatManaMax < KDMaxStat ? "#ffffff" : "#999999");
    DrawButtonVis(1550, 700, 250, 60, TextGet("KinkyDungeonHeartWill"), KinkyDungeonStatWillMax < KDMaxStat ? "#ffffff" : "#999999");
    DrawButtonKDEx("discardheart", (bdata) => {
        KinkyDungeonDrawState = "Game";
        return true;
    }, true, 1000, 850, 450, 60, TextGet("KinkyDungeonHeartDiscard"), KinkyDungeonStatWillMax < KDMaxStat ? "#ffffff" : "#999999");
}
function KinkyDungeonHandleHeart() {
    if (MouseIn(650, 700, 250, 60) && KinkyDungeonStatDistractionMax < KDMaxStat) {
        KDSendInput("heart", { type: "AP" });
        KinkyDungeonDrawState = "Game";
    }
    else if (MouseIn(950, 700, 250, 60) && KinkyDungeonStatStaminaMax < KDMaxStat) {
        KDSendInput("heart", { type: "SP" });
        KinkyDungeonDrawState = "Game";
    }
    else if (MouseIn(1250, 700, 250, 60) && KinkyDungeonStatManaMax < KDMaxStat) {
        KDSendInput("heart", { type: "MP" });
        KinkyDungeonDrawState = "Game";
    }
    else if (MouseIn(1550, 700, 250, 60) && KinkyDungeonStatWillMax < KDMaxStat) {
        KDSendInput("heart", { type: "WP" });
        KinkyDungeonDrawState = "Game";
    }
    return true;
}
let KDCustomItems = {
    "LeylineMap": () => {
        KDStartDialog("LeylineMap", "", true, "");
        return {
            sfx: undefined,
            replace: undefined,
            priority: undefined,
            color: undefined,
        };
    },
};
let KinkyDungeonOutfitCache = new Map();
let KDProtectedCosplay = [];
function KDOutfit(item) {
    return KinkyDungeonOutfitCache.get(item.name);
}
function KinkyDungeonRefreshOutfitCache() {
    KinkyDungeonOutfitCache = new Map();
    for (let r of KinkyDungeonOutfitsBase) {
        KinkyDungeonOutfitCache.set(r.name, r);
    }
}
let KDClothOverrides = {
    "Cloth": {
        "SleevelessTop": 24.9,
    },
};
let KinkyDungeonDefaultDefaultDress = [
    { Item: "WitchHat1", Group: "Hat", Color: "Default", Lost: false },
    { Item: "LeatherCorsetTop1", Group: "Cloth", Color: "Default", Lost: false },
    { Item: "LatexSkirt1", Group: "ClothLower", Color: "Default", OverridePriority: 17, Lost: false, Skirt: true },
    { Item: "Socks4", Group: "Socks", Color: "#444444", Lost: false },
    { Item: "Heels3", Group: "Shoes", Color: "#222222", Lost: false },
    { Item: "KittyPanties1", Group: "Panties", Color: "#222222", Lost: false },
    { Item: "FullLatexBra", Group: "Bra", Color: "Default", Lost: false },
    { Item: "LatexElbowGloves", Group: "Gloves", Color: "Default", Lost: false },
    { Item: "Necklace4", Group: "Necklace", Color: "#222222", Lost: false },
];
if (StandalonePatched) {
    KinkyDungeonDefaultDefaultDress = [
        { Item: "Maid", Group: "Costume", Color: "Default", Lost: false },
        { Item: "MaidApron", Group: "Apron", Color: "Default", Lost: false },
        { Item: "Catsuit", Group: "Catsuit", Color: "Default", Lost: false },
    ];
}
let KinkyDungeonCheckClothesLoss = false;
function KDGetDressList() {
    if (StandalonePatched)
        return KDModelDresses;
    return KinkyDungeonDresses;
}
function KinkyDungeonInitializeDresses() {
    KinkyDungeonCheckClothesLoss = true;
    KinkyDungeonUndress = 0;
    if (Object.values(KDGetDressList()).length > 0) {
        for (let d of Object.values(KDGetDressList())) {
            for (let dd of d) {
                if (dd.Lost)
                    dd.Lost = false;
            }
        }
    }
}
let KinkyDungeonNewDress = false;
function KinkyDungeonDressSet() {
    var _a, _b, _c, _d, _e, _f;
    if (KinkyDungeonNewDress) {
        KDGetDressList().Default = [];
        let C = KinkyDungeonPlayer;
        for (let A = 0; A < C.Appearance.length; A++) {
            let save = false;
            if (StandalonePatched) {
                if ((_a = C.Appearance[A].Model) === null || _a === void 0 ? void 0 : _a.Protected)
                    save = true;
                if (!((_b = C.Appearance[A].Model) === null || _b === void 0 ? void 0 : _b.Restraint))
                    save = true;
                if (save) {
                    KDGetDressList().Default.push({
                        Item: ((_c = C.Appearance[A].Model) === null || _c === void 0 ? void 0 : _c.Name) || ((_d = C.Appearance[A].Asset) === null || _d === void 0 ? void 0 : _d.Name),
                        Group: (_e = C.Appearance[A].Model) === null || _e === void 0 ? void 0 : _e.Group,
                        Filters: (_f = C.Appearance[A].Model) === null || _f === void 0 ? void 0 : _f.Filters,
                        Property: C.Appearance[A].Property,
                        Color: (C.Appearance[A].Color) ? C.Appearance[A].Color : (C.Appearance[A].Model.DefaultColor ? C.Appearance[A].Model.DefaultColor : "Default"),
                        Lost: false,
                    });
                }
            }
            else {
                if (C.Appearance[A].Asset.Group.BodyCosplay || C.Appearance[A].Asset.BodyCosplay)
                    save = true;
                else if (C.Appearance[A].Asset.Group.Underwear)
                    save = true;
                else if (C.Appearance[A].Asset.Group.Clothing)
                    save = true;
                if (save) {
                    KDGetDressList().Default.push({
                        Item: C.Appearance[A].Asset.Name,
                        Group: C.Appearance[A].Asset.Group.Name,
                        Property: C.Appearance[A].Property,
                        Color: (C.Appearance[A].Color) ? C.Appearance[A].Color : (C.Appearance[A].Asset.DefaultColor ? C.Appearance[A].Asset.DefaultColor : "Default"),
                        Lost: false,
                    });
                }
            }
        }
    }
    KinkyDungeonNewDress = false;
}
function KinkyDungeonSetDress(Dress, Outfit) {
    if (Outfit)
        KDGameData.Outfit = Outfit;
    KinkyDungeonCurrentDress = Dress;
    if (KDGetDressList()) {
        for (let clothes of KDGetDressList()[KinkyDungeonCurrentDress]) {
            clothes.Lost = false;
        }
        KinkyDungeonCheckClothesLoss = true;
        KinkyDungeonDressPlayer();
        KDRefresh = true;
    }
}
let KDNaked = false;
let KDRefresh = false;
function KinkyDungeonDressPlayer(Character) {
    var _a, _b, _c;
    if (!Character)
        Character = KinkyDungeonPlayer;
    let _CharacterRefresh = CharacterRefresh;
    let _CharacterAppearanceBuildCanvas = CharacterAppearanceBuildCanvas;
    CharacterRefresh = () => { KDRefresh = true; };
    CharacterAppearanceBuildCanvas = () => { };
    let restraints = [];
    try {
        let data = {
            updateRestraints: false,
            updateDress: false,
            updateExpression: false,
        };
        KinkyDungeonPlayer.OnlineSharedSettings = { BlockBodyCosplay: true };
        if (!KDNaked)
            KDCharacterNaked();
        if (KinkyDungeonCheckClothesLoss) {
            let clothGroups = {};
            for (let cloth of KDGetDressList()[KinkyDungeonCurrentDress]) {
                clothGroups[cloth.Group || cloth.Item] = true;
            }
            let newAppearance = {};
            for (let A = 0; A < KinkyDungeonPlayer.Appearance.length; A++) {
                if (StandalonePatched) {
                    let model = KinkyDungeonPlayer.Appearance[A].Model;
                    if (!((_a = model.Group) === null || _a === void 0 ? void 0 : _a.startsWith("Item")) && !clothGroups[model.Group || model.Name]) {
                        newAppearance[model.Group || model.Name] = KinkyDungeonPlayer.Appearance[A];
                    }
                }
                else {
                    let asset = KinkyDungeonPlayer.Appearance[A].Asset;
                    if (!asset.Group.Name.startsWith("Item") && !clothGroups[asset.Group.Name]) {
                        newAppearance[asset.Group.Name] = KinkyDungeonPlayer.Appearance[A];
                    }
                }
            }
            if (StandalonePatched) {
                if (!newAppearance.Body)
                    newAppearance.Body = { Model: JSON.parse(JSON.stringify(ModelDefs.Body)), Group: "Body", Color: "Default" };
                if (!newAppearance.Eyes)
                    newAppearance.Eyes = { Model: JSON.parse(JSON.stringify(ModelDefs.KoiEyes)), Group: "Eyes", Color: "Default" };
                if (!newAppearance.Brows)
                    newAppearance.Brows = { Model: JSON.parse(JSON.stringify(ModelDefs.KoiBrows)), Group: "Brows", Color: "Default" };
                if (!newAppearance.Mouth)
                    newAppearance.Mouth = { Model: JSON.parse(JSON.stringify(ModelDefs.KoiMouth)), Group: "Mouth", Color: "Default" };
                if (!newAppearance.Blush)
                    newAppearance.Blush = { Model: JSON.parse(JSON.stringify(ModelDefs.KoiBlush)), Group: "Blush", Color: "Default" };
                if (!newAppearance.Hair)
                    newAppearance.Hair = { Model: JSON.parse(JSON.stringify(ModelDefs.Braid)), Group: "Hair", Color: "Default" };
            }
            KinkyDungeonPlayer.Appearance = Object.values(newAppearance);
            for (let inv of KinkyDungeonAllRestraint()) {
                let renderTypes = KDRestraint(inv).shrine;
                KDApplyItem(inv, KinkyDungeonPlayerTags);
                restraints.push(inv);
                if (inv.dynamicLink) {
                    let link = inv.dynamicLink;
                    for (let I = 0; I < 30; I++) {
                        if (KDRestraint(link).alwaysRender || (KDRestraint(link).renderWhenLinked && KDRestraint(link).renderWhenLinked.some((element) => { return renderTypes.includes(element); }))) {
                            KDApplyItem(link, KinkyDungeonPlayerTags);
                            restraints.push(link);
                        }
                        if (link.dynamicLink) {
                            link = link.dynamicLink;
                        }
                        else
                            I = 1000;
                    }
                }
            }
            data.updateRestraints = true;
            KDNaked = true;
            KinkyDungeonUndress = 0;
        }
        let alreadyClothed = {};
        for (let A = 0; A < KinkyDungeonPlayer.Appearance.length; A++) {
            let asset = KinkyDungeonPlayer.Appearance[A].Asset;
            if (StandalonePatched) {
                if ((_b = KinkyDungeonPlayer.Appearance[A].Model) === null || _b === void 0 ? void 0 : _b.Group)
                    alreadyClothed[(_c = KinkyDungeonPlayer.Appearance[A].Model) === null || _c === void 0 ? void 0 : _c.Group] = true;
            }
            else
                alreadyClothed[asset.Group.Name] = true;
        }
        for (let clothes of KDGetDressList()[KinkyDungeonCurrentDress]) {
            if (alreadyClothed[clothes.Group || clothes.Item])
                continue;
            data.updateDress = true;
            if (!clothes.Lost && KinkyDungeonCheckClothesLoss) {
                if (clothes.Group == "Necklace") {
                    if (KinkyDungeonGetRestraintItem("ItemTorso") && KDRestraint(KinkyDungeonGetRestraintItem("ItemTorso")).harness)
                        clothes.Lost = true;
                    if (KinkyDungeonGetRestraintItem("ItemArms") && KDGroupBlocked("ItemBreast"))
                        clothes.Lost = true;
                }
                if (clothes.Group == "Panties" && !clothes.NoLose) {
                    if (KinkyDungeonGetRestraintItem("ItemPelvis") && KinkyDungeonGetRestraintItem("ItemPelvis") && KDRestraint(KinkyDungeonGetRestraintItem("ItemPelvis")).chastity)
                        clothes.Lost = true;
                }
                if (clothes.Group == "ClothLower" && clothes.Skirt) {
                    if (KinkyDungeonGetRestraintItem("ItemPelvis"))
                        clothes.Lost = true;
                    if (KDGroupBlocked("ItemLegs"))
                        clothes.Lost = true;
                    if (KDGroupBlocked("ClothLower"))
                        clothes.Lost = true;
                }
                if (clothes.Group == "Shoes") {
                    if (KinkyDungeonGetRestraintItem("ItemBoots"))
                        clothes.Lost = true;
                }
                for (let inv of KinkyDungeonAllRestraint()) {
                    if (KDRestraint(inv).remove) {
                        for (let remove of KDRestraint(inv).remove) {
                            if (remove == clothes.Group)
                                clothes.Lost = true;
                        }
                    }
                }
                if (clothes.Lost)
                    KinkyDungeonUndress += 1 / KDGetDressList()[KinkyDungeonCurrentDress].length;
            }
            if (!clothes.Lost) {
                if (KinkyDungeonCheckClothesLoss) {
                    let item = KDInventoryWear(clothes.Item, clothes.Group, undefined, clothes.Color, clothes.Filters);
                    alreadyClothed[clothes.Group || clothes.Item] = true;
                    if (clothes.OverridePriority) {
                        if (item) {
                            if (!item.Property)
                                item.Property = { OverridePriority: clothes.OverridePriority };
                            else
                                item.Property.OverridePriority = clothes.OverridePriority;
                        }
                    }
                    else if (KDClothOverrides[clothes.Group || clothes.Item] && KDClothOverrides[clothes.Group || clothes.Item][clothes.Item] != undefined) {
                        if (!item.Property)
                            item.Property = { OverridePriority: KDClothOverrides[clothes.Group || clothes.Item][clothes.Item] };
                        else
                            item.Property.OverridePriority = KDClothOverrides[clothes.Group || clothes.Item][clothes.Item];
                    }
                    if (clothes.Property)
                        item.Property = clothes.Property;
                }
            }
            if (clothes.Group == "Panties" && !KinkyDungeonGetRestraintItem("ItemPelvis"))
                clothes.Lost = false;
            if (clothes.Group == "Bra" && !KinkyDungeonGetRestraintItem("ItemBreast"))
                clothes.Lost = false;
        }
        for (let inv of KinkyDungeonAllRestraint()) {
            if (KinkyDungeonCheckClothesLoss)
                if (KDRestraint(inv).AssetGroup && (!KDRestraint(inv).armor || KDToggles.DrawArmor)) {
                    KDInventoryWear(KDRestraint(inv).Asset, KDRestraint(inv).AssetGroup, undefined, KDRestraint(inv).Color, KDRestraint(inv).Filters);
                }
        }
        if (KinkyDungeonCheckClothesLoss)
            KinkyDungeonWearForcedClothes(restraints);
        KinkyDungeonCheckClothesLoss = false;
        let AllowedArmPoses = KDGetAvailablePosesArms(KinkyDungeonPlayer);
        let AllowedLegPoses = KDGetAvailablePosesLegs(KinkyDungeonPlayer);
        if (KDGameData.KneelTurns > 0 || KDGameData.SleepTurns > 0) {
            if (StandalonePatched) {
                let newLegPoses = AllowedLegPoses.filter((element) => { return !STANDPOSES.includes(element); });
                if (newLegPoses.length > 0)
                    AllowedLegPoses = newLegPoses;
            }
            else {
                if (CharacterItemsHavePoseAvailable(KinkyDungeonPlayer, "BodyLower", "Kneel") && !CharacterDoItemsSetPose(KinkyDungeonPlayer, "Kneel") && !KinkyDungeonPlayer.IsKneeling()) {
                    CharacterSetActivePose(KinkyDungeonPlayer, "Kneel", false);
                }
            }
        }
        else if (KDGameData.SleepTurns < 1) {
            if (StandalonePatched) {
            }
            else {
                if (CharacterItemsHavePoseAvailable(KinkyDungeonPlayer, "BodyLower", "Kneel") && !CharacterDoItemsSetPose(KinkyDungeonPlayer, "Kneel") && KinkyDungeonPlayer.IsKneeling()) {
                    CharacterSetActivePose(KinkyDungeonPlayer, "BaseLower", false);
                }
            }
        }
        if (StandalonePatched) {
            let ArmPose = KDGetPoseOfType(KinkyDungeonPlayer, "Arms");
            let LegPose = KDGetPoseOfType(KinkyDungeonPlayer, "Legs");
            let EyesPose = KDGetPoseOfType(KinkyDungeonPlayer, "Eyes");
            let Eyes2Pose = KDGetPoseOfType(KinkyDungeonPlayer, "Eyes2");
            let BrowsPose = KDGetPoseOfType(KinkyDungeonPlayer, "Brows");
            let Brows2Pose = KDGetPoseOfType(KinkyDungeonPlayer, "Brows2");
            let BlushPose = KDGetPoseOfType(KinkyDungeonPlayer, "Blush");
            let MouthPose = KDGetPoseOfType(KinkyDungeonPlayer, "Mouth");
            let DefaultBound = "Front";
            let PreferredArm = KDDesiredPlayerPose.Arms || "Free";
            let PreferredLeg = KDDesiredPlayerPose.Legs || "Spread";
            if (!AllowedArmPoses.includes(ArmPose) || (ArmPose != PreferredArm && AllowedArmPoses.includes(PreferredArm))) {
                ArmPose = (AllowedArmPoses.includes(DefaultBound) && KinkyDungeonIsArmsBound(false, false)) ? DefaultBound : AllowedArmPoses[0];
            }
            if (!AllowedLegPoses.includes(LegPose) || (LegPose != PreferredLeg && AllowedLegPoses.includes(PreferredLeg))) {
                LegPose = AllowedLegPoses[0];
            }
            let expression = null;
            let stackedPriorities = {};
            for (let e of Object.entries(KDExpressions)) {
                if (!expression || e[1].priority > expression.priority) {
                    if (e[1].criteria(Character)) {
                        expression = e[1];
                    }
                }
                if (e[1].stackable) {
                    if (!e[1].criteria(Character))
                        continue;
                    let result = null;
                    if (e[1].priority > (stackedPriorities.EyesPose || 0)) {
                        result = result || e[1].expression(Character);
                        if (result.EyesPose) {
                            stackedPriorities.EyesPose = e[1].priority;
                            if (!KDWardrobe_CurrentPoseEyes)
                                EyesPose = result.EyesPose;
                        }
                    }
                    if (e[1].priority > (stackedPriorities.Eyes2Pose || 0)) {
                        result = result || e[1].expression(Character);
                        if (result.Eyes2Pose) {
                            stackedPriorities.Eyes2Pose = e[1].priority;
                            if (!KDWardrobe_CurrentPoseEyes2)
                                Eyes2Pose = result.Eyes2Pose;
                        }
                    }
                    if (e[1].priority > (stackedPriorities.BrowsPose || 0)) {
                        result = result || e[1].expression(Character);
                        if (result.BrowsPose) {
                            stackedPriorities.BrowsPose = e[1].priority;
                            if (!KDWardrobe_CurrentPoseBrows)
                                BrowsPose = result.BrowsPose;
                        }
                    }
                    if (e[1].priority > (stackedPriorities.Brows2Pose || 0)) {
                        result = result || e[1].expression(Character);
                        if (result.Brows2Pose) {
                            stackedPriorities.Brows2Pose = e[1].priority;
                            if (!KDWardrobe_CurrentPoseBrows2)
                                Brows2Pose = result.Brows2Pose;
                        }
                    }
                    if (e[1].priority > (stackedPriorities.BlushPose || 0)) {
                        result = result || e[1].expression(Character);
                        if (result.BlushPose) {
                            stackedPriorities.BlushPose = e[1].priority;
                            if (!KDWardrobe_CurrentPoseBlush)
                                BlushPose = result.BlushPose;
                        }
                    }
                    if (e[1].priority > (stackedPriorities.MouthPose || 0)) {
                        result = result || e[1].expression(Character);
                        if (result.MouthPose) {
                            stackedPriorities.MouthPose = e[1].priority;
                            if (!KDWardrobe_CurrentPoseMouth)
                                MouthPose = result.MouthPose;
                        }
                    }
                }
            }
            if (expression) {
                let result = expression.expression(Character);
                if (!KDWardrobe_CurrentPoseEyes && result.EyesPose)
                    EyesPose = result.EyesPose;
                if (!KDWardrobe_CurrentPoseEyes2 && result.Eyes2Pose)
                    Eyes2Pose = result.Eyes2Pose;
                if (!KDWardrobe_CurrentPoseBrows && result.BrowsPose)
                    BrowsPose = result.BrowsPose;
                if (!KDWardrobe_CurrentPoseBrows2 && result.Brows2Pose)
                    Brows2Pose = result.Brows2Pose;
                if (!KDWardrobe_CurrentPoseBlush && result.BlushPose)
                    BlushPose = result.BlushPose;
                if (!KDWardrobe_CurrentPoseMouth && result.MouthPose)
                    MouthPose = result.MouthPose;
            }
            if (KDCurrentModels.get(KinkyDungeonPlayer))
                KDCurrentModels.get(KinkyDungeonPlayer).Poses = KDGeneratePoseArray(ArmPose, LegPose, EyesPose, BrowsPose, BlushPose, MouthPose, Eyes2Pose, Brows2Pose);
        }
        if (!StandalonePatched) {
            let BlushCounter = 0;
            let Blush = "";
            let Eyes = "";
            let Eyes2 = "";
            let Eyebrows = "";
            let Mouth = "";
            let Fluids = "";
            if (KDToggles.Drool && !KinkyDungeonCanTalk()) {
                if (KinkyDungeonGagTotal() > 0.9)
                    Fluids = "DroolMessy";
                else if (KinkyDungeonGagTotal() > 0.5)
                    Fluids = "DroolMedium";
                else
                    Fluids = "DroolLow";
            }
            if (KDToggles.Drool && KDGameData.KinkyDungeonLeashedPlayer > 0) {
                if (Fluids.includes("Drool"))
                    Fluids = Fluids.replace("Drool", "DroolTears");
                else
                    Fluids = "TearsHigh";
            }
            if (KinkyDungeonSleepiness) {
                Eyes = "Dazed";
            }
            if (KinkyDungeonStatMana < KinkyDungeonStatManaMax * 0.45)
                Eyes = "Sad";
            if (KinkyDungeonStatWill <= KinkyDungeonStatWillMax * 0.33 || KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax / 2)
                Eyes = "Dazed";
            if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.167 || KinkyDungeonStatMana < KinkyDungeonStatManaMax * 0.33 || KinkyDungeonStatWill < KinkyDungeonStatWillMax * 0.33)
                Eyebrows = "Soft";
            let chastityMult = KinkyDungeonChastityMult();
            if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.67 && KinkyDungeonStatWill > KinkyDungeonStatWillMax * 0.5 && chastityMult > 0.9)
                Eyebrows = "Angry";
            if (KinkyDungeonStatDistraction >= KinkyDungeonStatDistractionMax * 0.8)
                Eyes = (Eyebrows != "Angry" && KinkyDungeonStatDistraction < KinkyDungeonStatDistractionMax * 0.99) ? "Lewd" : "Scared";
            if (KinkyDungeonStatDistraction >= 0.01 && KinkyDungeonStatDistraction <= 3)
                Eyes2 = "Closed";
            if (KDGameData.OrgasmTurns > 0) {
                Eyebrows = "Soft";
                Eyes2 = "";
                Eyes = "LewdHeart";
            }
            else if (KDGameData.OrgasmStamina > 0) {
                Eyebrows = "Soft";
            }
            else if (KDGameData.OrgasmStage > 5 && Math.random() < 0.33) {
                Eyebrows = "Angry";
            }
            else if (KDGameData.OrgasmStage > 3 && Math.random() < 0.33) {
                Eyebrows = "Angry";
            }
            if (KinkyDungeonStatWill <= 2) {
                Eyes = "Dazed";
                Eyes2 = "";
            }
            if (KinkyDungeonStatDistraction > 0.01)
                BlushCounter += 1;
            if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.33)
                BlushCounter += 1;
            if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.65)
                BlushCounter += 1;
            if (KinkyDungeonUndress > 0.4)
                BlushCounter += 1;
            if (KinkyDungeonUndress > 0.8)
                BlushCounter += 1;
            if (BlushCounter == 1)
                Blush = "Low";
            else if (BlushCounter == 2)
                Blush = "Medium";
            else if (BlushCounter == 3)
                Blush = "High";
            else if (BlushCounter == 4)
                Blush = "VeryHigh";
            else if (BlushCounter == 5)
                Blush = "Extreme";
            for (let A = 0; A < KinkyDungeonPlayer.Appearance.length; A++) {
                if (KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Blush") {
                    let property = KinkyDungeonPlayer.Appearance[A].Property;
                    if (!property || property.Expression != Blush) {
                        KinkyDungeonPlayer.Appearance[A].Property = { Expression: Blush };
                        KDRefresh = true;
                        data.updateExpression = true;
                    }
                }
                if (KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Eyebrows") {
                    let property = KinkyDungeonPlayer.Appearance[A].Property;
                    if (!property || property.Expression != Eyebrows) {
                        KinkyDungeonPlayer.Appearance[A].Property = { Expression: Eyebrows };
                        KDRefresh = true;
                        data.updateExpression = true;
                    }
                }
                if (KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Mouth") {
                    let property = KinkyDungeonPlayer.Appearance[A].Property;
                    if (!property || property.Expression != Mouth) {
                        KinkyDungeonPlayer.Appearance[A].Property = { Expression: Mouth };
                        KDRefresh = true;
                        data.updateExpression = true;
                    }
                }
                if (KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Fluids") {
                    let property = KinkyDungeonPlayer.Appearance[A].Property;
                    if (!property || property.Expression != Fluids) {
                        KinkyDungeonPlayer.Appearance[A].Property = { Expression: Fluids };
                        KDRefresh = true;
                        data.updateExpression = true;
                    }
                }
                if (KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Eyes" || KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Eyes2") {
                    let property = KinkyDungeonPlayer.Appearance[A].Property;
                    if (!property || property.Expression != ((KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Eyes2" && Eyes2) ? Eyes2 : Eyes)) {
                        KinkyDungeonPlayer.Appearance[A].Property = { Expression: ((KinkyDungeonPlayer.Appearance[A].Asset.Group.Name == "Eyes2" && Eyes2) ? Eyes2 : Eyes) };
                        KDRefresh = true;
                        data.updateExpression = true;
                    }
                }
            }
        }
        KinkyDungeonSendEvent("afterDress", data);
    }
    finally {
        CharacterRefresh = _CharacterRefresh;
        CharacterAppearanceBuildCanvas = _CharacterAppearanceBuildCanvas;
    }
    if (StandalonePatched && KDCurrentModels.get(Character))
        UpdateModels(KDCurrentModels.get(Character));
}
function KDInitProtectedGroups() {
    var _a, _b, _c;
    KDProtectedCosplay = [];
    for (let a of KinkyDungeonPlayer.Appearance) {
        if (((_b = (_a = a.Asset) === null || _a === void 0 ? void 0 : _a.Group) === null || _b === void 0 ? void 0 : _b.BodyCosplay) || ((_c = a.Model) === null || _c === void 0 ? void 0 : _c.Protected)) {
            KDProtectedCosplay.push(a.Asset.Group.Name);
        }
    }
}
function KinkyDungeonWearForcedClothes(restraints) {
    if (!restraints)
        restraints = KinkyDungeonAllRestraint();
    for (let i = restraints.length - 1; i >= 0; i--) {
        let inv = restraints[i];
        if (KDRestraint(inv).alwaysDress) {
            KDRestraint(inv).alwaysDress.forEach(dress => {
                if (dress.override || !dress.Group.includes("Item") || !InventoryGet(KinkyDungeonPlayer, dress.Group)) {
                    let canReplace = (dress.override !== null && dress.override === true) ? true : !InventoryGet(KinkyDungeonPlayer, dress.Group);
                    if (!canReplace) {
                        return;
                    }
                    if (KDProtectedCosplay.includes(dress.Group)) {
                        return;
                    }
                    let filters = dress.Filters;
                    let color = (typeof dress.Color === "string") ? [dress.Color] : dress.Color;
                    let faction = inv.faction;
                    if (inv.faction)
                        if (dress.factionColor && faction && KinkyDungeonFactionColors[faction]) {
                            for (let ii = 0; ii < dress.factionColor.length; ii++) {
                                for (let n of dress.factionColor[ii]) {
                                    if (KinkyDungeonFactionColors[faction][ii])
                                        color[n] = KinkyDungeonFactionColors[faction][ii];
                                }
                            }
                        }
                    if (dress.useHairColor && InventoryGet(KinkyDungeonPlayer, "HairFront"))
                        color = InventoryGet(KinkyDungeonPlayer, "HairFront").Color;
                    let item = KDInventoryWear(dress.Item, dress.Group, inv.name, color, filters);
                    if (dress.OverridePriority) {
                        if (item) {
                            if (!item.Property)
                                item.Property = { OverridePriority: dress.OverridePriority };
                            else
                                item.Property.OverridePriority = dress.OverridePriority;
                        }
                    }
                }
            });
        }
    }
}
function KDCharacterAppearanceSetColorForGroup(Player, Color, Group) {
    let item = InventoryGet(Player, Group);
    if (item) {
        item.Color = Color;
    }
}
function KinkyDungeonGetOutfit(Name) {
    if (KinkyDungeonOutfitCache && KinkyDungeonOutfitCache.get(Name)) {
        let outfit = {};
        Object.assign(outfit, KinkyDungeonOutfitCache.get(Name));
        return outfit;
    }
    return null;
}
function KDInventoryWear(AssetName, AssetGroup, par, color, filters) {
    const M = StandalonePatched ? ModelDefs[AssetName] : undefined;
    const A = StandalonePatched ? undefined : AssetGet(KinkyDungeonPlayer.AssetFamily, AssetGroup, AssetName);
    if ((StandalonePatched && !M) || (!StandalonePatched && !A))
        return;
    let item = StandalonePatched ?
        KDAddModel(KinkyDungeonPlayer, AssetGroup, M, color || "Default", filters)
        : KDAddAppearance(KinkyDungeonPlayer, AssetGroup, A, color || A.DefaultColor);
    CharacterRefresh(KinkyDungeonPlayer, true);
    return item;
}
function KDCharacterNaked() {
    KDCharacterAppearanceNaked();
    CharacterRefresh(KinkyDungeonPlayer);
}
function KDCharacterAppearanceNaked() {
    for (let A = KinkyDungeonPlayer.Appearance.length - 1; A >= 0; A--) {
        if (StandalonePatched) {
            if (!KinkyDungeonPlayer.Appearance[A].Model.Restraint) {
                let f = !(KinkyDungeonPlayer.Appearance[A].Model.Group
                    && (KDProtectedCosplay.includes(KinkyDungeonPlayer.Appearance[A].Model.Group)));
                if (!f) {
                    continue;
                }
                KinkyDungeonPlayer.Appearance.splice(A, 1);
            }
        }
        else {
            if (KinkyDungeonPlayer.Appearance[A].Asset.Group.AllowNone &&
                (KinkyDungeonPlayer.Appearance[A].Asset.Group.Category === "Appearance")) {
                let f = !(KinkyDungeonPlayer.Appearance[A].Asset.Group.BodyCosplay
                    && (KDProtectedCosplay.includes(KinkyDungeonPlayer.Appearance[A].Asset.Group.Name)));
                if (!f) {
                    continue;
                }
                KinkyDungeonPlayer.Appearance.splice(A, 1);
            }
        }
    }
    CharacterLoadCanvas(KinkyDungeonPlayer);
}
function KDApplyItem(inv, tags) {
    if (StandalonePatched) {
        let restraint = KDRestraint(inv);
        let AssetGroup = restraint.AssetGroup ? restraint.AssetGroup : restraint.Group;
        let faction = inv.faction ? inv.faction : "";
        let color = (typeof restraint.Color === "string") ? [restraint.Color] : restraint.Color;
        if (restraint.factionColor && faction && KinkyDungeonFactionColors[faction]) {
            for (let i = 0; i < restraint.factionColor.length; i++) {
                for (let n of restraint.factionColor[i]) {
                    color[n] = KinkyDungeonFactionColors[faction][i];
                }
            }
        }
        let placed = null;
        if (!restraint.armor || KDToggles.DrawArmor) {
            placed = KDAddModel(KinkyDungeonPlayer, AssetGroup, ModelDefs[restraint.Model || restraint.Asset], color, restraint.Filters, inv);
        }
        if (placed) {
            let type = restraint.Type;
            if (restraint.changeRenderType && Object.keys(restraint.changeRenderType).some((k) => { return tags.has(k); })) {
                let key = Object.keys(restraint.changeRenderType).filter((k) => { return tags.has(k); })[0];
                if (key) {
                    type = restraint.changeRenderType[key];
                }
            }
            placed.Property = { Type: type, Modules: restraint.Modules, Difficulty: restraint.power, LockedBy: inv.lock ? "MetalPadlock" : undefined };
            if (restraint.OverridePriority) {
                placed.Property.OverridePriority = restraint.OverridePriority;
            }
        }
        return;
    }
    KDApplyItemLegacy(inv, tags);
}
function KDApplyItemLegacy(inv, tags) {
    let _ChatRoomCharacterUpdate = ChatRoomCharacterUpdate;
    ChatRoomCharacterUpdate = () => { };
    try {
        let restraint = KDRestraint(inv);
        let AssetGroup = restraint.AssetGroup ? restraint.AssetGroup : restraint.Group;
        let faction = inv.faction ? inv.faction : "";
        let color = (typeof restraint.Color === "string") ? [restraint.Color] : Object.assign([], restraint.Color);
        if (restraint.factionColor && faction && KinkyDungeonFactionColors[faction]) {
            for (let i = 0; i < restraint.factionColor.length; i++) {
                for (let n of restraint.factionColor[i]) {
                    if (KinkyDungeonFactionColors[faction][i])
                        color[n] = KinkyDungeonFactionColors[faction][i];
                }
            }
        }
        let placed = null;
        if (!restraint.armor || KDToggles.DrawArmor) {
            placed = KDAddAppearance(KinkyDungeonPlayer, AssetGroup, AssetGet("3DCGFemale", AssetGroup, restraint.Asset), color, undefined, undefined, undefined, inv);
        }
        if (placed) {
            let type = restraint.Type;
            if (restraint.changeRenderType && Object.keys(restraint.changeRenderType).some((k) => { return tags.has(k); })) {
                let key = Object.keys(restraint.changeRenderType).filter((k) => { return tags.has(k); })[0];
                if (key) {
                    type = restraint.changeRenderType[key];
                }
            }
            placed.Property = { Type: type, Difficulty: restraint.power, LockedBy: inv.lock ? "MetalPadlock" : undefined };
            if (restraint.Modules) {
                let data = ModularItemDataLookup[AssetGroup + restraint.Asset];
                let asset = data.asset;
                let modules = data.modules;
                placed.Property = ModularItemMergeModuleValues({ asset, modules }, restraint.Modules);
                placed.Property.LockedBy = inv.lock ? "MetalPadlock" : undefined;
            }
            else if (type)
                TypedItemSetOptionByName(KinkyDungeonPlayer, placed, type, false);
            if (restraint.OverridePriority) {
                placed.Property.OverridePriority = restraint.OverridePriority;
            }
        }
    }
    finally {
        ChatRoomCharacterUpdate = _ChatRoomCharacterUpdate;
    }
}
function KinkyDungeonSendOutfitEvent(Event, data) {
    if (!KDMapHasEvent(KDEventMapOutfit, Event))
        return;
    let outfit = KDOutfit({ name: KinkyDungeonCurrentDress });
    if (outfit && outfit.events) {
        for (let e of outfit.events) {
            if (e.trigger == Event) {
                KinkyDungeonHandleOutfitEvent(Event, e, outfit, data);
            }
        }
    }
}
function KDGetExtraPoses(C) {
    let poses = [];
    if (C == KinkyDungeonPlayer) {
        if (KinkyDungeonPlayerTags.get("LinkFeet")) {
            poses.push("FeetLinked");
        }
    }
    else {
    }
    return poses;
}
function KDGetAvailablePosesLegs(C) {
    let poses = {};
    for (let p of LEGPOSES) {
        poses[p] = true;
    }
    if (C == KinkyDungeonPlayer) {
        if (KinkyDungeonPlayerTags.get("FeetLinked")) {
            delete poses.Spread;
        }
        else if (KinkyDungeonPlayerTags.get("ForceKneel")) {
            delete poses.Closed;
        }
        if (KinkyDungeonPlayerTags.get("ForceHogtie")) {
            for (let p of STANDPOSES) {
                delete poses[p];
            }
            for (let p of KNEELPOSES) {
                delete poses[p];
            }
        }
        else if (KinkyDungeonPlayerTags.get("ForceKneel")) {
            for (let p of STANDPOSES) {
                delete poses[p];
            }
        }
    }
    else {
    }
    return Object.keys(poses);
}
function KDGetAvailablePosesArms(C) {
    let poses = {};
    for (let p of ARMPOSES) {
        poses[p] = true;
    }
    if (C == KinkyDungeonPlayer) {
        if (KinkyDungeonPlayerTags.get("Yokes")) {
            poses = { Yoked: true };
        }
        else if (KinkyDungeonPlayerTags.get("Armbinders")) {
            poses = { Wristtie: true };
        }
        else if (KinkyDungeonPlayerTags.get("Boxbinders")) {
            poses = { Boxtie: true };
        }
        else if (KinkyDungeonPlayerTags.get("Straitjackets")) {
            poses = { Boxtie: true };
        }
        else if (KinkyDungeonPlayerTags.get("Boxties")) {
            poses = { Boxtie: true };
        }
        else if (KinkyDungeonPlayerTags.get("Wristties")) {
            poses = { Wristtie: true };
        }
        if (KinkyDungeonIsArmsBound(false, false)) {
            delete poses.Free;
            if (!KinkyDungeonPlayerTags.get("HandsFront")) {
                delete poses.HandsFront;
            }
            if (!KinkyDungeonPlayerTags.get("Yoked")) {
                delete poses.Yoked;
            }
        }
    }
    else {
    }
    return Object.keys(poses);
}
let KDExpressions = {
    "OrgSuccess": {
        priority: 10,
        criteria: (C) => {
            if (C == KinkyDungeonPlayer && KinkyDungeonFlags.get("OrgSuccess")) {
                return true;
            }
            return false;
        },
        expression: (C) => {
            return {
                EyesPose: "EyesSurprised",
                Eyes2Pose: "Eyes2Closed",
                BrowsPose: "BrowsSurprised",
                Brows2Pose: "Brows2Surprised",
                BlushPose: "BlushExtreme",
                MouthPose: "MouthDazed",
            };
        },
    },
    "OrgEdged": {
        priority: 8,
        criteria: (C) => {
            if (C == KinkyDungeonPlayer && KinkyDungeonFlags.get("OrgEdged")) {
                return true;
            }
            return false;
        },
        expression: (C) => {
            return {
                EyesPose: "EyesAngry",
                Eyes2Pose: "Eyes2Closed",
                BrowsPose: "BrowsAnnoyed",
                Brows2Pose: "Brows2Annoyed",
                BlushPose: "BlushExtreme",
                MouthPose: "MouthDazed",
            };
        },
    },
    "OrgDenied": {
        priority: 8,
        criteria: (C) => {
            if (C == KinkyDungeonPlayer && KinkyDungeonFlags.get("OrgDenied")) {
                return true;
            }
            return false;
        },
        expression: (C) => {
            return {
                EyesPose: "EyesSurprised",
                Eyes2Pose: "Eyes2Closed",
                BrowsPose: "BrowsAngry",
                Brows2Pose: "Brows2Angry",
                BlushPose: "BlushExtreme",
                MouthPose: "MouthEmbarrassed",
            };
        },
    },
    "VibeStart": {
        priority: 6,
        criteria: (C) => {
            if (C == KinkyDungeonPlayer && (KinkyDungeonFlags.get("VibeStarted") || KinkyDungeonFlags.get("VibeContinued"))) {
                return true;
            }
            return false;
        },
        expression: (C) => {
            return {
                EyesPose: KinkyDungeonFlags.get("VibeContinued") ? "EyesDazed" : "EyesNeutral",
                Eyes2Pose: "Eyes2Closed",
                BrowsPose: "BrowsSad",
                Brows2Pose: "Brows2Sad",
                BlushPose: "BlushHigh",
                MouthPose: "MouthDazed",
            };
        },
    },
    "Vibing": {
        stackable: true,
        priority: 2,
        criteria: (C) => {
            if (C == KinkyDungeonPlayer && KinkyDungeonVibeLevel > 0) {
                return true;
            }
            return false;
        },
        expression: (C) => {
            return {
                EyesPose: (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.5) ? "EyesAngry" : "",
                Eyes2Pose: (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.5) ? "Eyes2Angry" : "",
                BrowsPose: "BrowsNeutral",
                Brows2Pose: "Brows2Neutral",
                BlushPose: (KinkyDungeonVibeLevel > 2 || KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.5) ? "BlushMedium" : "BlushHigh",
                MouthPose: "MouthEmbarrassed",
            };
        },
    },
    "Distracted": {
        stackable: true,
        priority: 1,
        criteria: (C) => {
            if (C == KinkyDungeonPlayer && KinkyDungeonStatDistraction > 0) {
                return true;
            }
            return false;
        },
        expression: (C) => {
            return {
                EyesPose: "",
                Eyes2Pose: "",
                BrowsPose: "",
                Brows2Pose: "",
                BlushPose: (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.5) ? "BlushLow" : "BlushMedium",
                MouthPose: "",
            };
        },
    },
    "Tired": {
        stackable: true,
        priority: 1,
        criteria: (C) => {
            if (C == KinkyDungeonPlayer && KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax * 0.5) {
                return true;
            }
            return false;
        },
        expression: (C) => {
            return {
                EyesPose: (KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax * 0.25) ? "EyesClosed" : "EyesDazed",
                Eyes2Pose: "Eyes2Dazed",
                BrowsPose: "",
                Brows2Pose: "",
                BlushPose: "",
                MouthPose: "",
            };
        },
    },
    "Neutral": {
        stackable: true,
        priority: 0.1,
        criteria: (C) => {
            return true;
        },
        expression: (C) => {
            return {
                EyesPose: "EyesNeutral",
                Eyes2Pose: "Eyes2Neutral",
                BrowsPose: "BrowsNeutral",
                Brows2Pose: "Brows2Neutral",
                BlushPose: "BlushNone",
                MouthPose: "MouthNeutral",
            };
        },
    },
};
let KDLatexDmg = 1;
let KDLatexBind = 2;
let KDEffectTiles = {
    "FateBoundGround": {
        name: "Ice",
        duration: 2,
        priority: 10,
        tags: ["fate"],
    },
    "Ice": {
        name: "Ice",
        duration: 1,
        priority: 1,
        tags: ["ice", "slippery"],
    },
    "Water": {
        name: "Water",
        duration: 40,
        priority: 1,
        tags: ["water", "freezeover", "conductive", "slippery"],
    },
    "Cracked": {
        name: "Cracked",
        duration: 100,
        priority: 0,
        affinities: ["Edge"],
        tags: ["terrain", "ground", "wettable", "freezeover"],
    },
    "Slime": {
        name: "Slime",
        duration: 10,
        priority: 2,
        affinities: ["Sticky"],
        tags: ["slime", "freezeover", "flammable", "conductive"],
    },
    "Latex": {
        name: "Latex",
        duration: 80,
        priority: -2,
        affinities: ["Latex"],
        tags: ["latex", "insulator"],
    },
    "Ropes": {
        name: "Ropes",
        duration: 30,
        priority: 5,
        tags: ["bind", "rope", "flammable"],
    },
    "Fabric": {
        name: "Fabric",
        duration: 30,
        priority: 5,
        tags: ["bind", "fabric", "flammable"],
    },
    "FabricGreen": {
        name: "FabricGreen",
        duration: 30,
        priority: 5,
        brightness: 3.5,
        lightColor: 0x55ff55,
        tags: ["bind", "fabric"],
    },
    "Vines": {
        name: "Vines",
        duration: 50,
        priority: 5,
        tags: ["bind", "vine", "flammable"],
    },
    "Runes": {
        name: "Runes",
        duration: 9999,
        priority: 10,
        tags: ["runesummon", "rune", "hiddenmagic"],
    },
    "RunesTrap": {
        name: "RunesTrap",
        duration: 9999,
        priority: 10,
        tags: ["magic", "runetrap", "rune", "hiddenmagic"],
    },
    "Belts": {
        name: "Belts",
        duration: 30,
        priority: 5,
        tags: ["bind", "belt"],
    },
    "Chains": {
        name: "Chains",
        duration: 30,
        priority: 5,
        tags: ["bind", "chain", "noisy", "conductive"],
    },
    "SlimeBurning": {
        name: "SlimeBurning",
        duration: 5,
        priority: 3,
        affinities: ["Sticky"],
        tags: ["slime", "ignite", "fire", "hot", "conductive"],
    },
    "Smoke": {
        name: "Smoke",
        duration: 2,
        priority: 4,
        tags: ["smoke", "visionblock", "brightnessblock", "darkarea"],
    },
    "Inferno": {
        name: "Inferno",
        duration: 5,
        priority: 5,
        brightness: 6,
        lightColor: 0xff8933,
        tags: ["fire", "ignite", "smoke", "visionblock"],
    },
    "Ember": {
        name: "Ember",
        duration: 1,
        priority: 3,
        brightness: 3.5,
        lightColor: 0xb83716,
        tags: ["ignite", "smoke", "visionblock"],
    },
    "Sparks": {
        name: "Sparks",
        duration: 4,
        priority: 7,
        brightness: 6,
        lightColor: 0xaaaaff,
        tags: ["ignite", "electric"],
    },
    "WireSparks": {
        name: "WireSparks",
        duration: 4,
        priority: 51,
        brightness: 3,
        lightColor: 0xff5555,
        tags: ["signal"],
    },
    "WireSparksAct": {
        name: "WireSparks",
        duration: 1,
        priority: 1,
        tags: ["signalFrame"],
    },
    "Wire": {
        name: "Wire",
        duration: 9999,
        priority: 50,
        tags: ["hiddenmagic", "wire"],
    },
    "PressurePlate": {
        name: "PressurePlate",
        duration: 9999,
        priority: 50,
        tags: ["wire"],
    },
    "PressurePlateOneUse": {
        name: "PressurePlateOneUse",
        duration: 9999,
        priority: 50,
        tags: ["wire"],
    },
    "PressurePlateActive": {
        name: "PressurePlateActive",
        duration: 2,
        priority: 51,
        tags: ["ppactive"],
    },
    "PressurePlateHold": {
        name: "PressurePlateHold",
        duration: 9999,
        priority: 50,
        tags: ["wire"],
    },
    "Ignition": {
        name: "Ignition",
        duration: 1,
        priority: 0,
        brightness: 1.5,
        lightColor: 0xff8933,
        tags: ["ignite", "hot"],
    },
    "Torch": {
        name: "Torch",
        duration: 9999,
        priority: 5,
        brightness: 6,
        lightColor: 0xff8933,
        yoffset: -1,
        tags: ["hot"],
    },
    "TorchUnlit": {
        name: "TorchUnlit",
        duration: 9999,
        priority: 5,
        yoffset: -1,
        tags: [],
    },
    "Lantern": {
        name: "Lantern",
        duration: 9999,
        priority: 5,
        brightness: 6.5,
        lightColor: 0xffee83,
        affinitiesStanding: ["Hook", "Edge"],
        yoffset: -1,
        tags: ["hot"],
    },
    "LanternUnlit": {
        name: "LanternUnlit",
        duration: 9999,
        priority: 5,
        affinitiesStanding: ["Hook", "Edge"],
        yoffset: -1,
        tags: [],
    },
    "TorchOrb": {
        name: "TorchOrb",
        duration: 9999,
        priority: 5,
        brightness: 6,
        lightColor: 0x99aaff,
        affinitiesStanding: ["Hook", "Edge"],
        yoffset: -1,
        tags: [],
    },
    "IllusOrb": {
        name: "IllusOrb",
        duration: 9999,
        priority: 5,
        brightness: 4,
        lightColor: 0xffffff,
        affinitiesStanding: ["Hook", "Edge"],
        yoffset: -1,
        tags: [],
    },
    "IllusOrbDead": {
        name: "IllusOrbDead",
        duration: 9999,
        priority: 5,
        brightness: 2,
        lightColor: 0x6700ff,
        affinitiesStanding: ["Hook", "Edge"],
        yoffset: -1,
        tags: [],
    },
    "Steam": {
        name: "Steam",
        duration: 6,
        priority: 2,
        tags: ["steam", "hot", "visionblock"],
    },
};
let KinkyDungeonOutfitsBase = [
    { name: "OutfitDefault", dress: "Default", shop: false, rarity: 1 },
    { name: "Default", dress: "Default", shop: false, rarity: 1 },
    { name: "JailUniform", dress: "JailUniform", shop: false, rarity: 1 },
    { name: "Bast", dress: "Bast", shop: false, rarity: 1 },
    { name: "Bountyhunter", dress: "Bountyhunter", shop: false, rarity: 1 },
    { name: "Bikini", dress: "Bikini", shop: false, rarity: 1 },
    { name: "Maid", dress: "Maid", shop: false, rarity: 2, events: [{ trigger: "calcEvasion", type: "AccuracyBuff", requiredTag: "mold", power: 10.0 }] },
    { name: "Dragon", dress: "Dragon", shop: false, rarity: 2 },
    { name: "Elven", dress: "Elven", shop: false, rarity: 2 },
    { name: "Wolfgirl", dress: "Wolfgirl", shop: false, rarity: 2 },
    { name: "CyberDoll", dress: "CyberDoll", shop: false, rarity: 3 },
    { name: "BlueSuitPrison", dress: "BlueSuitPrison", shop: false, rarity: 2 },
    { name: "DollSuit", dress: "DollSuit", shop: false, rarity: 2 },
    { name: "BlueSuit", dress: "BlueSuit", shop: false, rarity: 2 },
    { name: "Obsidian", dress: "Obsidian", shop: false, rarity: 2 },
];
let KinkyDungeonDresses = {
    "Default": KinkyDungeonDefaultDefaultDress,
    "Prisoner": [
        { Item: "SleevelessCatsuit", Group: "Suit", Color: "#8A120C", Lost: false },
        { Item: "CatsuitPanties", Group: "SuitLower", Color: "#8A120C", Lost: false },
        { Item: "Heels1", Group: "Shoes", Color: "#8A120C", Lost: false },
        { Item: "Socks4", Group: "Socks", Color: "#222222", Lost: false },
    ],
    "GreenLeotard": [
        { Item: "SleevelessCatsuit", Group: "Suit", Color: "#267237", Lost: false },
        { Item: "CatsuitPanties", Group: "SuitLower", Color: "#267237", Lost: false },
    ],
    "Leotard": [
        { Item: "SleevelessCatsuit", Group: "Suit", Color: "#53428D", Lost: false },
        { Item: "CatsuitPanties", Group: "SuitLower", Color: "#53428D", Lost: false },
    ],
    "Bikini": [
        { Item: "KittyPanties1", Group: "Panties", Color: "#050505", Lost: false },
        { Item: "FullLatexBra", Group: "Bra", Color: "Default", Lost: false },
    ],
    "Lingerie": [
        { Item: "LaceBabydoll", Group: "Cloth", Color: "Default", Lost: false },
        { Item: "Bandeau1", Group: "Bra", Color: "Default", Lost: false },
        { Item: "FloralPanties2", Group: "Panties", Color: ['#303030', '#F0F0F0'], Lost: false },
    ],
    "LatexPrisoner": [
        { Item: "LatexPanties2", Group: "Panties", Color: "Default", Lost: false },
        { Item: "LatexCorset1", Group: "Corset", Color: "Default", Lost: false },
        { Item: "FullLatexBra", Group: "Bra", Color: "Default", Lost: false },
        { Item: "Heels1", Group: "Shoes", Color: "#222222", Lost: false },
        { Item: "LatexSocks1", Group: "Socks", Color: "Default", Lost: false },
    ],
    "Dungeon": [
        { Item: "Bandeau1", Group: "Bra", Color: "Default", Lost: false },
        { Item: "Pantyhose1", Group: "SuitLower", Color: "Default", Lost: false },
        { Item: "Corset5", Group: "Corset", Color: "#777777", Lost: false },
        { Item: "AnkleStrapShoes", Group: "Shoes", Color: "#2D2D2D", Lost: false },
        { Item: "FloralPanties2", Group: "Panties", Color: ['#303030', '#F0F0F0'], Lost: false },
    ],
    "Bast": [
        { Item: "Sarashi1", Group: "Bra", Color: "Default", Lost: false },
        { Item: "Panties7", Group: "Panties", Color: "#ffffff", Lost: false },
        { Item: "Sandals", Group: "Shoes", Color: "Default", Lost: false },
        { Item: "FaceVeil", Group: "Mask", Color: "#ffffff", Lost: false },
        { Item: "HaremPants", Group: "ClothLower", Color: "Default", OverridePriority: 28, Lost: false },
    ],
    "Dragon": [
        { Item: "Sarashi1", Group: "Bra", Color: "#444444", Lost: false },
        { Item: "SunstripePanties1", Group: "Panties", Color: "#EC1515", Lost: false },
        { Item: "LatexAnkleShoes", Group: "Shoes", Color: "#AC1818", Lost: false },
        { Item: "Corset4", Group: "Corset", Color: "#AC1818", Lost: false },
        { Item: "LatexTop", Group: "Cloth", Color: "#AC1818", Lost: false },
        { Item: "GarterBelt2", Group: "Garters", Color: "Default", Lost: false },
    ],
    "SlimeSuit": [
        { Item: "SeamlessCatsuit", Group: "Suit", Color: "#7F3C9B", Lost: false },
        { Item: "SeamlessCatsuit", Group: "SuitLower", Color: "#7F3C9B", Lost: false },
        { Item: "Catsuit", Group: "Gloves", Color: "#7F3C9B", Lost: false },
    ],
    "ProtoSlimeSuit": [
        { Item: "SeamlessCatsuit", Group: "Suit", Color: "#404973", Lost: false },
        { Item: "SeamlessCatsuit", Group: "SuitLower", Color: "#404973", Lost: false },
        { Item: "Catsuit", Group: "Gloves", Color: "#404973", Lost: false },
    ],
    "BlueSuit": [
        { Item: "SeamlessCatsuit", Group: "Suit", Color: "#3873C3", Lost: false },
        { Item: "SeamlessCatsuit", Group: "SuitLower", Color: "#3873C3", Lost: false },
        { Item: "Catsuit", Group: "Gloves", Color: "#3873C3", Lost: false },
    ],
    "DollSuit": [
        { Item: "SeamlessCatsuit", Group: "Suit", Color: "#840d26", Lost: false },
        { Item: "SeamlessCatsuit", Group: "SuitLower", Color: "#840d26", Lost: false },
        { Item: "Catsuit", Group: "Gloves", Color: "#840d26", Lost: false },
    ],
    "Bountyhunter": [
        { Item: "SeamlessCatsuit", Group: "Suit", Color: "#222222", Lost: false },
        { Item: "SeamlessCatsuit", Group: "SuitLower", Color: "#222222", Lost: false },
        { Item: "Catsuit", Group: "Gloves", Color: "#222222", Lost: false },
    ],
    "BlueSuitPrison": [
        { Item: "SeamlessCatsuit", Group: "Suit", Color: "#3873C3", Lost: false },
        { Item: "SeamlessCatsuit", Group: "SuitLower", Color: "#3873C3", Lost: false },
        { Item: "Catsuit", Group: "Gloves", Color: "#3873C3", Lost: false },
        { Item: "FaceVeil", Group: "Mask", Color: "#ffffff", Lost: false },
    ],
    "Wolfgirl": [
        { Item: "PilotSuit", Group: "Suit", Color: ['#828FA2', '#323332', '#223525', '#383838', 'Default'], Lost: false },
        { Item: "PilotPanties", Group: "SuitLower", Color: ['#828FA2', '#323332', '#223525'], Lost: false },
        { Item: "LatexSocks1", Group: "Socks", Color: "#AAAAAA", Lost: false },
    ],
    "CyberDoll": [
        { Item: "PilotSuit", Group: "Suit", Color: ['#7e1972', '#222222', '#555555', '#222222', 'Default'], Lost: false },
        { Item: "PilotSuit", Group: "SuitLower", Color: ['#7e1972', '#222222', '#555555'], Lost: false },
        { Item: "PilotSuitGloves", Group: "Gloves", Color: ['#7e1972', '#222222', '#555555'], Lost: false },
    ],
    "Maid": [
        { Item: "SleevelessCatsuit", Group: "Suit", Color: "#aaaaaa", Lost: false },
        { Item: "MaidApron2", Group: "Cloth", Color: "Default", Lost: false },
        { Item: "FullLatexBra2", Group: "Bra", Color: ["#333333", "#aaaaaa"], Lost: false },
        { Item: "Pantyhose2", Group: "SuitLower", Color: "#939393", Lost: false },
        { Item: "LaceBands", Group: "Bracelet", Color: ['Default', '#151515'], Lost: false },
        { Item: "MageSkirt", Group: "ClothLower", Color: ["#676767", "#2E2E2E"], Lost: false },
        { Item: "Corset4", Group: "Corset", Color: "#4B4B4B", Lost: false },
        { Item: "Band1", Group: "Hat", Color: "#767676", Lost: false },
        { Item: "Shoes5", Group: "Shoes", Color: "#575757", Lost: false },
        { Item: "Socks6", Group: "Socks", Color: ['#080808', 'Default'], Lost: false },
    ],
    "Elven": [
        { Item: "Swimsuit1", Group: "Bra", Color: ['#E2E2E2'], Lost: false, NoLose: true },
        { Item: "Corset4", Group: "Corset", Color: ['#FFFFFF'], Lost: false },
        { Item: "Stockings4", Group: "Socks", Color: "#000000", Lost: false },
        { Item: "FaceVeil", Group: "Mask", Color: "Default", Lost: false },
        { Item: "HairFlower1", Group: "HairAccessory3", Color: 'Default', Lost: false },
        { Item: "NecklaceKey", Group: "Necklace", Color: "Default", Lost: false },
        { Item: "MageSkirt", Group: "ClothLower", Color: ['#40824F', '#AF9225'], OverridePriority: 27, Lost: false },
        { Item: "Heels1", Group: "Shoes", Color: "#aaaaaa", Lost: false },
    ],
    "Obsidian": [
        { Item: "SleevelessSlimLatexLeotard", Group: "Suit", Color: ['#4964A5'], Lost: false, NoLose: true },
        { Item: "LatexCorset1", Group: "Corset", Color: ['#4869BD'], Lost: false },
        { Item: "Stockings3", Group: "Socks", Color: "Default", Lost: false },
        { Item: "LatexTop", Group: "Cloth", Color: "#1F175F", Lost: false },
        { Item: "CatsuitPanties", Group: "Panties", Color: '#4964A5', Lost: false },
        { Item: "FuturisticHeels2", Group: "Shoes", Color: ['#1F175F', '#FFFFFF', '#333333', '#333333', '#7A7979', '#aaaaaa'], Lost: false },
        { Item: "LatexSkirt2", Group: "ClothLower", Color: ['#2C4A95'], OverridePriority: 27, Lost: false },
    ],
};
function KDConsumable(item) {
    return KinkyDungeonConsumables[item.name];
}
function KinkyDungeonFindConsumable(Name) {
    for (let con of Object.values(KinkyDungeonConsumables)) {
        if (con.name == Name)
            return con;
    }
    return undefined;
}
function KinkyDungeonFindBasic(Name) {
    for (let con of Object.values(KinkyDungneonBasic)) {
        if (con.name == Name)
            return con;
    }
    return undefined;
}
function KinkyDungeonFindConsumableOrBasic(Name) {
    for (let con of Object.values(KinkyDungeonConsumables)) {
        if (con.name == Name)
            return con;
    }
    for (let con of Object.values(KinkyDungneonBasic)) {
        if (con.name == Name)
            return con;
    }
    return undefined;
}
function KinkyDungeonGetInventoryItem(Name, Filter = Consumable) {
    let Filtered = KinkyDungeonFilterInventory(Filter);
    for (let item of Filtered) {
        if (item.name == Name)
            return item;
    }
    return null;
}
function KinkyDungeonItemCount(Name) {
    let item = KinkyDungeonGetInventoryItem(Name);
    if (item && item.item && item.item.quantity) {
        return item.item.quantity;
    }
    return 0;
}
function KinkyDungeonGetShopItem(Level, Rarity, Shop) {
    let Table = [];
    let params = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]];
    if (params.ShopExclusives) {
        for (let exc of params.ShopExclusives) {
            Table.push(exc);
        }
    }
    let Shopable = Object.entries(KinkyDungeonConsumables).filter(([k, v]) => (v.shop));
    for (let S = 0; S < Shopable.length; S++) {
        let s = Shopable[S][1];
        s.shoptype = "Consumable";
        Table.push(s);
    }
    Shopable = Object.entries(KinkyDungneonBasic).filter(([k, v]) => (v.shop));
    for (let S = 0; S < Shopable.length; S++) {
        let s = Shopable[S][1];
        s.shoptype = "Basic";
        if (!s.ignoreInventory || !KinkyDungeonInventoryGet(s.ignoreInventory))
            Table.push(s);
    }
    Shopable = Object.entries(KinkyDungneonShopRestraints).filter(([k, v]) => (v.shop));
    for (let S = 0; S < Shopable.length; S++) {
        let s = Shopable[S][1];
        s.shoptype = "Restraint";
        if (!KinkyDungeonInventoryGet(s.name))
            Table.push(s);
    }
    Shopable = Object.entries(KinkyDungeonWeapons).filter(([k, v]) => (v.shop));
    for (let S = 0; S < Shopable.length; S++) {
        let s = Shopable[S][1];
        s.shoptype = "Weapon";
        if (!KinkyDungeonInventoryGet(s.name))
            Table.push(s);
    }
    for (let R = Rarity; R >= 0; R--) {
        let available = Table.filter((item) => (item.rarity == R && !KDGameData.ShopItems.some((item2) => { return item2.name == item.name; })));
        if (available.length > 0)
            return available[Math.floor(KDRandom() * available.length)];
    }
    return null;
}
function KinkyDungeonChangeConsumable(consumable, Quantity) {
    let item = KinkyDungeonInventoryGetConsumable(consumable.name);
    if (item) {
        item.quantity += Quantity;
        if (item.quantity <= 0) {
            KinkyDungeonInventoryRemove(item);
        }
        return true;
    }
    if (Quantity >= 0) {
        KinkyDungeonInventoryAdd({ name: consumable.name, id: KinkyDungeonGetItemID(), type: Consumable, quantity: Quantity });
    }
    return false;
}
function KinkyDungeonConsumableEffect(Consumable, type) {
    if (!type)
        type = Consumable.type;
    if (KDConsumableEffects[type]) {
        KDConsumableEffects[type](Consumable);
    }
    else if (type == "spell") {
        KinkyDungeonCastSpell(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonFindSpell(Consumable.spell, true), undefined, undefined, undefined);
        KDStunTurns(1, true);
    }
    else if (type == "targetspell") {
        KDCloseQuickInv();
        KinkyDungeonTargetingSpell = KinkyDungeonFindSpell(Consumable.spell, true);
        KinkyDungeonTargetingSpellItem = Consumable;
    }
    else if (type == "charge") {
        KDGameData.AncientEnergyLevel = Math.min(Math.max(0, KDGameData.AncientEnergyLevel + Consumable.amount), 1.0);
        if (!KinkyDungeonStatsChoice.get("LostTechnology"))
            KinkyDungeonChangeConsumable(KinkyDungeonConsumables.AncientPowerSourceSpent, 1);
    }
    else if (type == "buff") {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: Consumable.name, type: Consumable.buff, power: Consumable.power, duration: Consumable.duration, aura: Consumable.aura });
    }
    else if (type == "recharge") {
    }
    else if (type == "shrineRemove") {
        KinkyDungeonRemoveRestraintsWithShrine(Consumable.shrine);
        KDStunTurns(1, true);
    }
    else if (type == "goldKey") {
        for (let r of KinkyDungeonPlayerGetRestraintsWithLocks(["Gold"])) {
            KinkyDungeonLock(r, "Blue");
        }
    }
}
function KinkyDungeonPotionCollar() {
    for (let r of KinkyDungeonAllRestraint()) {
        if (KDRestraint(r).potionCollar)
            return true;
    }
    return false;
}
function KinkyDungeonCanDrink(byEnemy) {
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv).allowPotions)
            return true;
    }
    if (KDGroupBlocked("ItemMouth", byEnemy))
        return false;
    return KinkyDungeonCanTalk(true);
}
function KinkyDungeonAttemptConsumable(Name, Quantity) {
    if (KDGameData.SleepTurns > 0 || KinkyDungeonSlowMoveTurns > 0)
        return false;
    let item = KinkyDungeonGetInventoryItem(Name, Consumable);
    if (!item)
        return false;
    if (KDConsumable(item).prereq && KDConsumablePrereq[KDConsumable(item).prereq]) {
        if (KDConsumablePrereq[KDConsumable(item).prereq](item, Quantity)) {
            KinkyDungeonUseConsumable(Name, Quantity);
            return true;
        }
        else
            return false;
    }
    if (item.item && KDConsumable(item.item) && KDConsumable(item.item).type == "unusuable") {
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonUnusable"), "#ff0000", 1);
        return false;
    }
    if (item.item && KDConsumable(item.item) && KDConsumable(item.item).type == "goldKey") {
        if (KinkyDungeonPlayerGetRestraintsWithLocks(["Gold"]).length == 0) {
            KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonMistressKeyFail"), "#ff0000", 1);
            return false;
        }
    }
    if (item.item && KDConsumable(item.item) && KDConsumable(item.item).type == "charge" && KDGameData.AncientEnergyLevel >= 1) {
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonFullpower"), "#ff0000", 1);
        return false;
    }
    if (item.item && KDConsumable(item.item) && KDConsumable(item.item).type == "recharge") {
        KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonInventoryItemAncientPowerSourceSpentUseFail"), "#ff0000", 1);
        return false;
    }
    if (item.item && KDConsumable(item.item) && KDConsumable(item.item).type == "shrineRemove" && KinkyDungeonGetRestraintsWithShrine(KDConsumable(item.item).shrine).length < 1) {
        KinkyDungeonSendActionMessage(8, TextGet("KinkyDungeonNoItemToRemove"), "pink", 1);
        return false;
    }
    let needMouth = item.item && KDConsumable(item.item) && ((KDConsumable(item.item).potion && !KDConsumable(item.item).gagFloor) || KDConsumable(item.item).needMouth);
    let needArms = !(item.item && KDConsumable(item.item) && KDConsumable(item.item).noHands);
    let strictness = KinkyDungeonStrictness(false, "ItemHands");
    let maxStrictness = (item.item && KDConsumable(item.item) && KDConsumable(item.item).maxStrictness) ? KDConsumable(item.item).maxStrictness : 1000;
    if (needMouth && ((!KDConsumable(item.item).potion && ((KDConsumable(item.item).gagMax && KinkyDungeonGagTotal() > KDConsumable(item.item).gagMax) || (!KDConsumable(item.item).gagMax && !KinkyDungeonCanTalk(true))))
        || (KDConsumable(item.item).potion && !KinkyDungeonCanDrink()))) {
        let allowPotions = KinkyDungeonPotionCollar();
        if (KDConsumable(item.item).potion && allowPotions) {
        }
        else {
            KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonPotionGagged"), "#ff0000", 1);
            if (KinkyDungeonTextMessageTime > 0)
                KinkyDungeonDrawState = "Game";
            return false;
        }
    }
    if (!(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && needArms && !KinkyDungeonStatsChoice.get("Psychic") && !(item.item && KDConsumable(item.item).potion && !KinkyDungeonIsArmsBound() && (!KinkyDungeonStatsChoice.has("WeakGrip") || !KinkyDungeonIsHandsBound(false, false))) && (KinkyDungeonIsHandsBound(false, true) || (KinkyDungeonStatsChoice.has("WeakGrip") && item.item && KDConsumable(item.item).potion)) && !KinkyDungeonCanUseFeet()) {
        let allowPotions = KinkyDungeonPotionCollar();
        let nohands = KinkyDungeonIsHandsBound(false, true);
        if (KDConsumable(item.item).potion && allowPotions) {
        }
        else if (!nohands && KinkyDungeonCanKneel() && KDGameData.KneelTurns < 1) {
            if (!KDGameData.KneelTurns)
                KDGameData.KneelTurns = 2;
            else
                KDGameData.KneelTurns = Math.max(KDGameData.KneelTurns, 2);
            KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonCantUsePotionsKneel"), "#ffff00", 1);
            if (KinkyDungeonTextMessageTime > 0)
                KinkyDungeonDrawState = "Game";
            KinkyDungeonAdvanceTime(1, true, true);
            return false;
        }
        else if (nohands || KDGameData.KneelTurns < 1) {
            KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonCantUsePotions"), "#ff0000", 1);
            if (KinkyDungeonTextMessageTime > 0)
                KinkyDungeonDrawState = "Game";
            return false;
        }
    }
    if (strictness >= maxStrictness) {
        KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonCantUsePotionsStrict"), "#ff0000", 1);
        if (KinkyDungeonTextMessageTime > 0)
            KinkyDungeonDrawState = "Game";
        return false;
    }
    if (KDConsumable(item).postreq && KDConsumablePrereq[KDConsumable(item).postreq]) {
        if (KDConsumablePrereq[KDConsumable(item).postreq](item, Quantity)) {
            KDDelayedActionPrune(["Action", "Consume"]);
            if (KDConsumable(item.item).delay || (KDConsumable(item.item).potion && KinkyDungeonStatsChoice.has("SavourTheTaste"))) {
                KDAddDelayedAction({
                    commit: "Consumable",
                    data: {
                        Name: Name,
                        Quantity: Quantity,
                    },
                    time: KDConsumable(item.item).delay || 2,
                    tags: ["Action", "Remove", "Restrain"],
                });
                KDStunTurns(KDConsumable(item.item).delay || 2, true);
            }
            else
                KinkyDungeonUseConsumable(Name, Quantity);
            return true;
        }
        else
            return false;
    }
    KDDelayedActionPrune(["Action", "Consume"]);
    if (KDConsumable(item.item).delay || (KDConsumable(item.item).potion && KinkyDungeonStatsChoice.has("SavourTheTaste"))) {
        KDAddDelayedAction({
            commit: "Consumable",
            data: {
                Name: Name,
                Quantity: Quantity,
            },
            time: KDConsumable(item.item).delay || 2,
            tags: ["Action", "Remove", "Restrain"],
        });
        KDStunTurns(KDConsumable(item.item).delay || 2, true);
    }
    else
        KinkyDungeonUseConsumable(Name, Quantity);
    return true;
}
function KinkyDungeonUseConsumable(Name, Quantity) {
    let item = KinkyDungeonGetInventoryItem(Name, Consumable);
    if (!item || item.item.quantity < Quantity)
        return false;
    for (let I = 0; I < Quantity; I++) {
        KinkyDungeonConsumableEffect(KDConsumable(item.item));
        if (KDConsumable(item.item).sideEffects) {
            for (let effect of KDConsumable(item.item).sideEffects) {
                KinkyDungeonConsumableEffect(KDConsumable(item.item), effect);
            }
        }
    }
    if (!KDConsumable(item.item).noConsumeOnUse)
        KinkyDungeonChangeConsumable(KDConsumable(item.item), -(KDConsumable(item.item).useQuantity ? KDConsumable(item.item).useQuantity : 1) * Quantity);
    KinkyDungeonSendActionMessage(9, TextGet("KinkyDungeonInventoryItem" + Name + "Use"), "#88FF88", 1);
    if (KDConsumable(item.item).sfx) {
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/" + KDConsumable(item.item).sfx + ".ogg");
    }
    return true;
}
let KinkyDungeonConsumables = {
    "PotionMana": { name: "PotionMana", potion: true, rarity: 0, shop: true, type: "restore", mp_instant: 5, mpool_instant: 0, mp_gradual: 0, scaleWithMaxMP: true, gagFloor: 0.5, duration: 0, sfx: "PotionDrink" },
    "ManaOrb": { name: "ManaOrb", noHands: true, rarity: 2, shop: true, type: "restore", mp_instant: 0, mpool_instant: 20, mp_gradual: 0, scaleWithMaxMP: false, duration: 0, sfx: "Invis" },
    "PotionWill": { name: "PotionWill", potion: true, rarity: 0, shop: true, type: "restore", wp_instant: 2.5, wp_gradual: 0, scaleWithMaxWP: true, duration: 0, gagFloor: 0.5, sfx: "PotionDrink" },
    "PotionStamina": { name: "PotionStamina", potion: true, rarity: 1, shop: true, type: "restore", sp_instant: 5, sp_gradual: 25, scaleWithMaxSP: true, duration: 25, gagFloor: 0.5, sfx: "PotionDrink" },
    "PotionFrigid": { name: "PotionFrigid", potion: true, rarity: 1, shop: true, type: "restore", ap_instant: -10, ap_gradual: -20, duration: 50, arousalRatio: 1.0, gagFloor: 0.5, sfx: "PotionDrink" },
    "SmokeBomb": { name: "SmokeBomb", noHands: true, rarity: 2, costMod: -1, shop: true, type: "spell", spell: "Shroud", sfx: "FireSpell" },
    "PotionInvisibility": { name: "PotionInvisibility", potion: true, rarity: 3, costMod: -1, shop: true, type: "spell", spell: "Invisibility", sfx: "PotionDrink" },
    "Ectoplasm": { name: "Ectoplasm", noHands: true, rarity: 1, shop: false, type: "spell", spell: "LesserInvisibility", sfx: "Invis" },
    "EarthRune": { name: "EarthRune", rarity: 2, costMod: -1, shop: false, type: "spell", spell: "Earthrune", sfx: "HeavySwing" },
    "WaterRune": { name: "WaterRune", rarity: 2, costMod: -1, shop: false, type: "spell", spell: "Waterrune", sfx: "HeavySwing" },
    "Bola": { name: "Bola", rarity: 0, costMod: -1, shop: false, useQuantity: 1, noConsumeOnUse: true, type: "targetspell", spell: "PlayerBola" },
    "IceRune": { name: "IceRune", rarity: 2, costMod: -1, shop: false, type: "spell", spell: "Icerune", sfx: "Freeze" },
    "Bomb": { name: "Bomb", rarity: 1, costMod: -1, shop: false, type: "spell", spell: "Bomb", sfx: "MagicSlash" },
    "ElfCrystal": { name: "ElfCrystal", noHands: true, rarity: 3, costMod: -1, shop: false, type: "spell", spell: "Slippery", sfx: "MagicSlash" },
    "EnchantedGrinder": { name: "EnchantedGrinder", noHands: true, rarity: 4, shop: true, type: "spell", spell: "Cutting", sfx: "Laser" },
    "MistressKey": { name: "MistressKey", rarity: 8, costMod: -1, shop: false, type: "goldKey" },
    "AncientPowerSource": { name: "AncientPowerSource", noHands: true, rarity: 4, costMod: -1, shop: true, type: "charge", amount: 0.250 },
    "AncientPowerSourceSpent": { name: "AncientPowerSourceSpent", noHands: true, rarity: 3, costMod: -1, shop: false, type: "recharge" },
    "ScrollArms": { name: "ScrollArms", noHands: true, rarity: 2, costMod: 1, shop: true, type: "buff", buff: "NoArmsComp", duration: 12, power: 1, aura: "#aaffaa", sfx: "FireSpell" },
    "ScrollVerbal": { name: "ScrollVerbal", noHands: true, rarity: 2, costMod: 1, shop: true, type: "buff", buff: "NoVerbalComp", duration: 12, power: 1, aura: "#aaaaff", sfx: "FireSpell" },
    "ScrollLegs": { name: "ScrollLegs", noHands: true, rarity: 2, costMod: 1, shop: true, type: "buff", buff: "NoLegsComp", duration: 12, power: 1, aura: "#ffaaaa", sfx: "FireSpell" },
    "ScrollPurity": { name: "ScrollPurity", noHands: true, rarity: 4, shop: true, type: "shrineRemove", shrine: "Vibes", sfx: "FireSpell" },
    "DollID": { name: "DollID", rarity: 0, shop: false, type: "dollID", noHands: true, sfx: "FutureLock" },
};
let KDCookies = {
    "Cookie": { name: "Cookie", rarity: 0, shop: true, type: "restore", wp_instant: 1.0, wp_gradual: 0, scaleWithMaxWP: true, needMouth: true, delay: 3, gagMax: 0.59, duration: 0, sfx: "Cookie" },
    "Donut": { name: "Donut", rarity: 0, shop: true, type: "restore", wp_instant: 1.0, wp_gradual: 0, scaleWithMaxWP: true, needMouth: true, delay: 3, gagMax: 0.59, duration: 0, sfx: "Cookie" },
    "CookieJailer": { name: "CookieJailer", rarity: 0, shop: true, type: "restore", wp_instant: 1.5, wp_gradual: 0, scaleWithMaxWP: true, needMouth: true, delay: 3, gagMax: 0.59, duration: 0, sfx: "Cookie",
        sideEffects: ["subAdd"],
        data: {
            subAdd: 5,
        } },
};
Object.assign(KinkyDungeonConsumables, KDCookies);
let KDRechargeCost = 100;
let KinkyDungneonBasic = {
    "RedKey": { name: "RedKey", rarity: 0, shop: true },
    "BlueKey": { name: "BlueKey", rarity: 2, costMod: 2, shop: true },
    "Lockpick": { name: "Lockpick", rarity: 0, shop: true },
    "3Bola": { name: "3Bola", consumable: "Bola", quantity: 3, rarity: 0, shop: true },
    "3Bomb": { name: "3Bomb", consumable: "Bomb", quantity: 3, rarity: 1, shop: true },
    "MaidUniform": { name: "MaidUniform", rarity: 2, shop: true, ignoreInventory: "Maid" },
};
let KinkyDungneonShopRestraints = {
    "SlimeWalkers": { name: "SlimeWalkers", rarity: 2, shop: true },
    "PotionCollar": { name: "PotionCollar", rarity: 2, shop: true },
};
let KDConsumableEffects = {
    "subAdd": (Consumable) => {
        var _a;
        let amount = ((_a = Consumable.data) === null || _a === void 0 ? void 0 : _a.subAdd) || 5;
        KinkyDungeonChangeRep("Ghost", amount);
    },
    "dollID": (Consumable) => {
        KinkyDungeonSetFlag("DollmakerGrace", 300);
    },
    "restore": (Consumable) => {
        let multi = 1.0;
        if (Consumable.scaleWithMaxSP) {
            multi = Math.max(KinkyDungeonStatStaminaMax / KDMaxStatStart);
        }
        let Manamulti = 1.0;
        if (Consumable.scaleWithMaxMP) {
            Manamulti = Math.max(KinkyDungeonStatManaMax / KDMaxStatStart);
        }
        let Willmulti = 1.0;
        if (Consumable.scaleWithMaxWP) {
            Willmulti = Math.max(KinkyDungeonStatWillMax / KDMaxStatStart);
        }
        let Distmulti = 1.0;
        if (Consumable.scaleWithMaxAP) {
            Distmulti = Math.max(KinkyDungeonStatDistractionMax / KDMaxStatStart);
        }
        let gagFloor = Consumable.gagFloor ? Consumable.gagFloor : 0;
        let gagMult = (Consumable.potion && gagFloor != 1.0) ? Math.max(0, gagFloor + (1 - gagFloor) * (1 - Math.max(0, Math.min(1.0, KinkyDungeonGagTotal(true))))) : 1.0;
        if (gagMult < 0.999) {
            KinkyDungeonSendTextMessage(8, TextGet("KinkyDungeonConsumableLessEffective"), "#ff0000", 2);
        }
        if (Consumable.mp_instant != undefined) {
            KinkyDungeonChangeMana(Consumable.mp_instant * Manamulti * gagMult, false, Consumable.mpool_instant * Manamulti * gagMult, false, true);
        }
        if (Consumable.wp_instant)
            KinkyDungeonChangeWill(Consumable.wp_instant * Willmulti * gagMult);
        if (Consumable.sp_instant)
            KinkyDungeonChangeStamina(Consumable.sp_instant * multi * gagMult);
        if (Consumable.ap_instant)
            KinkyDungeonChangeDistraction(Consumable.ap_instant * Distmulti * gagMult, false, Consumable.arousalRatio ? Consumable.arousalRatio : 0);
        KinkyDungeonCalculateMiscastChance();
        if (Consumable.mp_gradual)
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "PotionMana", type: "restore_mp", power: Consumable.mp_gradual / Consumable.duration * gagMult * Manamulti, duration: Consumable.duration });
        if (Consumable.wp_gradual)
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "PotionWill", type: "restore_wp", power: Consumable.wp_gradual / Consumable.duration * gagMult * Willmulti, duration: Consumable.duration });
        if (Consumable.sp_gradual)
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "PotionStamina", type: "restore_sp", power: Consumable.sp_gradual / Consumable.duration * gagMult * multi, duration: Consumable.duration });
        if (Consumable.ap_gradual)
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "PotionFrigid", type: "restore_ap", power: Consumable.ap_gradual / Consumable.duration * gagMult * Distmulti, duration: Consumable.duration });
    },
};
let KDConsumablePrereq = {};
let KinkyDungeonFilters = [
    Consumable,
    Restraint,
    Weapon,
    Outfit,
    LooseRestraint,
    Misc,
];
let KinkyDungeonCurrentFilter = KinkyDungeonFilters[0];
let KinkyDungeonCurrentPageInventory = 0;
let KinkyDungeonShowInventory = false;
let KinkyDungeonInventoryOffset = 0;
function KDCloseQuickInv() {
    KinkyDungeonShowInventory = false;
    KDHideQuickInv = false;
}
function KDSwitchWeapon() {
    let previousWeapon = KDGameData.PreviousWeapon ? KDGameData.PreviousWeapon : null;
    if (!previousWeapon || KinkyDungeonInventoryGet(previousWeapon))
        KDSendInput("switchWeapon", { weapon: previousWeapon });
}
function KinkyDungeonHandleInventory() {
    let filteredInventory = KinkyDungeonFilterInventory(KinkyDungeonCurrentFilter);
    if (KinkyDungeonCurrentPageInventory > 0 && MouseIn(canvasOffsetX_ui + 100, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60)) {
        KinkyDungeonCurrentPageInventory -= 1;
        return true;
    }
    if (KinkyDungeonCurrentPageInventory < filteredInventory.length - 1 && MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale - 325, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60)) {
        KinkyDungeonCurrentPageInventory += 1;
        return true;
    }
    for (let I = 0; I < KinkyDungeonFilters.length; I++)
        if (KinkyDungeonFilterInventory(KinkyDungeonFilters[I]).length > 0 || I == 1)
            if (MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale - 20, canvasOffsetY_ui + 115 + I * 65, 225, 60)) {
                KinkyDungeonCurrentFilter = KinkyDungeonFilters[I];
                KinkyDungeonCurrentPageInventory = 0;
                return true;
            }
    if (filteredInventory.length > 0) {
        if (MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 400, canvasOffsetY_ui, 90, 40) && KinkyDungeonInventoryOffset > 0) {
            KinkyDungeonInventoryOffset -= 2;
            return true;
        }
        if (MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 400, 480 * KinkyDungeonBookScale + canvasOffsetY_ui - 15, 90, 40) && KinkyDungeonInventoryOffset + 24 < filteredInventory.length) {
            KinkyDungeonInventoryOffset += 2;
            return true;
        }
        for (let i = 0; i < 24; i++) {
            let xx = i % 2;
            let yy = Math.floor(i / 2);
            let index = i + KinkyDungeonInventoryOffset;
            if (filteredInventory[index] && filteredInventory[index].item) {
                if (MouseIn(canvasOffsetX_ui + xx * 200 + 640 * KinkyDungeonBookScale + 250, canvasOffsetY_ui + 50 + 45 * yy, 195, 40)) {
                    KinkyDungeonCurrentPageInventory = index;
                    return true;
                }
            }
        }
    }
    if (KinkyDungeonDrawInventorySelected(filteredInventory[KinkyDungeonCurrentPageInventory])) {
        if (KinkyDungeonCurrentFilter == Consumable && MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60)) {
            let item = KinkyDungeonFilterInventory(KinkyDungeonCurrentFilter)[KinkyDungeonCurrentPageInventory];
            if (!item || !item.name)
                return true;
            KDSendInput("consumable", { item: item.name, quantity: 1 });
        }
        else if (KinkyDungeonCurrentFilter == Weapon) {
            let weapon = ((filteredInventory[KinkyDungeonCurrentPageInventory] != null) ? filteredInventory[KinkyDungeonCurrentPageInventory].name : null);
            if (weapon && weapon != "Unarmed") {
                let equipped = weapon == KinkyDungeonPlayerWeapon;
                if (MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60) && !equipped) {
                    KDSendInput("switchWeapon", { weapon: weapon });
                }
                else if (MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale + 70, 350, 60) && equipped) {
                    KDSendInput("unequipWeapon", { weapon: weapon });
                }
            }
        }
        else if (KinkyDungeonCurrentFilter == Outfit && MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60)) {
            let outfit = ((filteredInventory[KinkyDungeonCurrentPageInventory] != null) ? filteredInventory[KinkyDungeonCurrentPageInventory].name : null);
            let toWear = KinkyDungeonGetOutfit(outfit);
            if (toWear) {
                let dress = toWear.dress;
                if (dress == "JailUniform" && KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]])
                    dress = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].defeat_outfit;
                KDSendInput("dress", { dress: dress, outfit: outfit });
            }
        }
        else if (KinkyDungeonCurrentFilter == LooseRestraint && MouseIn(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60)) {
            let equipped = false;
            let newItem = null;
            let currentItem = null;
            if (filteredInventory[KinkyDungeonCurrentPageInventory]
                && filteredInventory[KinkyDungeonCurrentPageInventory].item) {
                newItem = KDRestraint(filteredInventory[KinkyDungeonCurrentPageInventory].item);
                if (newItem) {
                    currentItem = KinkyDungeonGetRestraintItem(newItem.Group);
                    if (!currentItem
                        || (KinkyDungeonLinkableAndStricter(KDRestraint(currentItem), newItem, currentItem) &&
                            ((newItem.linkCategory && KDLinkCategorySize(currentItem, newItem.linkCategory) + KDLinkSize(newItem) <= 1.0)
                                || (!newItem.linkCategory && !KDDynamicLinkList(currentItem, true).some((item) => { return newItem.name == item.name; }))))) {
                        equipped = false;
                    }
                    else
                        equipped = true;
                }
            }
            if (!equipped && newItem) {
                if (KDSendInput("equip", { name: newItem.name, group: newItem.Group, curse: filteredInventory[KinkyDungeonCurrentPageInventory].item.curse, currentItem: currentItem ? currentItem.name : undefined, events: Object.assign([], filteredInventory[KinkyDungeonCurrentPageInventory].item.events) }))
                    return true;
            }
        }
    }
    return true;
}
function KinkyDungeonInventoryAddWeapon(Name) {
    if (!KinkyDungeonInventoryGetWeapon(Name) && KinkyDungeonWeapons[Name])
        KinkyDungeonInventoryAdd({ name: Name, type: Weapon, events: Object.assign([], KinkyDungeonWeapons[Name].events), id: KinkyDungeonGetItemID() });
}
function KinkyDungeonInventoryAddLoose(Name, UnlockCurse) {
    if (!KinkyDungeonInventoryGetLoose(Name) || UnlockCurse)
        KinkyDungeonInventoryAdd({ name: Name, type: LooseRestraint, curse: UnlockCurse, events: KDRestraint(KinkyDungeonGetRestraintByName(Name)).events, quantity: 1, id: KinkyDungeonGetItemID() });
    else {
        KinkyDungeonInventoryGetLoose(Name).quantity += 1;
    }
}
function KinkyDungeonInventoryAddOutfit(Name) {
    if (!KinkyDungeonInventoryGetOutfit(Name) && KinkyDungeonOutfitCache.has(Name))
        KinkyDungeonInventoryAdd({ name: Name, type: Outfit, id: KinkyDungeonGetItemID() });
}
function KDInventoryType(item) { return item.type; }
function KinkyDungeonFullInventory() {
    let ret = [];
    for (let m of KinkyDungeonInventory.values()) {
        for (let item of m.values()) {
            ret.push(item);
        }
    }
    return ret;
}
function KinkyDungeonInventoryLength() {
    let size = 0;
    for (let m of KinkyDungeonInventory.values()) {
        size += m.size;
    }
    return size;
}
function KinkyDungeonInventoryAdd(item) {
    let type = KDInventoryType(item);
    if (KinkyDungeonInventory.has(type)) {
        KinkyDungeonInventory.get(type).set(item.name, item);
    }
}
function KinkyDungeonInventoryRemove(item) {
    if (item) {
        let type = KDInventoryType(item);
        if (KinkyDungeonInventory.has(type)) {
            KinkyDungeonInventory.get(type).delete(item.name);
        }
    }
}
function KinkyDungeonInventoryGet(Name) {
    for (let m of KinkyDungeonInventory.values()) {
        if (m.has(Name))
            return m.get(Name);
    }
    return null;
}
function KinkyDungeonInventoryGetLoose(Name) {
    return KinkyDungeonInventory.get(LooseRestraint).get(Name);
}
function KinkyDungeonInventoryGetConsumable(Name) {
    return KinkyDungeonInventory.get(Consumable).get(Name);
}
function KinkyDungeonInventoryGetWeapon(Name) {
    return KinkyDungeonInventory.get(Weapon).get(Name);
}
function KinkyDungeonInventoryGetOutfit(Name) {
    return KinkyDungeonInventory.get(Outfit).get(Name);
}
function KinkyDungeonAllRestraint() {
    return KinkyDungeonInventory.get(Restraint) ? Array.from(KinkyDungeonInventory.get(Restraint).values()) : [];
}
function KinkyDungeonAllRestraintDynamic() {
    let ret = [];
    for (let inv of KinkyDungeonAllRestraint()) {
        ret.push({ item: inv, host: null });
        if (inv.dynamicLink) {
            let link = inv.dynamicLink;
            let host = inv;
            while (link) {
                ret.push({ item: link, host: host });
                link = link.dynamicLink;
            }
        }
    }
    return ret;
}
function KinkyDungeonAllLooseRestraint() {
    return KinkyDungeonInventory.get(LooseRestraint) ? Array.from(KinkyDungeonInventory.get(LooseRestraint).values()) : [];
}
function KinkyDungeonAllConsumable() {
    return KinkyDungeonInventory.get(Consumable) ? Array.from(KinkyDungeonInventory.get(Consumable).values()) : [];
}
function KinkyDungeonAllOutfit() {
    return KinkyDungeonInventory.get(Outfit) ? Array.from(KinkyDungeonInventory.get(Outfit).values()) : [];
}
function KinkyDungeonAllWeapon() {
    return KinkyDungeonInventory.get(Weapon) ? Array.from(KinkyDungeonInventory.get(Weapon).values()) : [];
}
function KDGetItemPreview(item) {
    let ret = null;
    let Group = "";
    if (item.type == Restraint && KDRestraint(item).Group)
        Group = KDRestraint(item).Group;
    else if (item.type == LooseRestraint && KDRestraint(item).Group)
        Group = KDRestraint(item).Group;
    if ((item.type == Restraint || item.type == LooseRestraint) && KDRestraint(item).AssetGroup)
        Group = KDRestraint(item).AssetGroup;
    if (Group == "ItemMouth2" || Group == "ItemMouth3")
        Group = "ItemMouth";
    if (item.type == Restraint) {
        ret = { name: item.name, item: item, preview: `Assets/Female3DCG/${Group}/Preview/${KDRestraint(item).Asset}.png` };
    }
    else if (item.type == LooseRestraint) {
        ret = { name: KDRestraint(item).name, item: item, preview: `Assets/Female3DCG/${Group}/Preview/${KDRestraint(item).Asset}.png` };
    }
    else if (item.type == Consumable)
        ret = { name: KDConsumable(item).name, item: item, preview: KinkyDungeonRootDirectory + `/Items/${KDConsumable(item).name}.png` };
    else if (item.type == Weapon)
        ret = { name: KDWeapon(item).name, item: item, preview: KinkyDungeonRootDirectory + `/Items/${KDWeapon(item).name}.png` };
    else if (item.type == Outfit)
        ret = { name: KDOutfit(item) ? KDOutfit(item).name : "Prisoner", item: item, preview: KinkyDungeonRootDirectory + `/Outfits/${KDOutfit(item).name}.png` };
    return ret;
}
function KinkyDungeonFilterInventory(Filter, enchanted, ignoreHidden) {
    let ret = [];
    let category = KinkyDungeonInventory.get(Filter);
    if (category)
        for (let item of category.values()) {
            if (ignoreHidden && KDGameData.HiddenItems && KDGameData.HiddenItems[item.name])
                continue;
            let preview = KDGetItemPreview(item);
            if (preview && (item.type != LooseRestraint || (!enchanted || KDRestraint(item).enchanted || KDRestraint(item).showInQuickInv)))
                ret.push(preview);
            if (item.dynamicLink) {
                let link = item.dynamicLink;
                for (let I = 0; I < 30; I++) {
                    preview = KDGetItemPreview(link);
                    if (preview && (link.type == Restraint))
                        ret.push(preview);
                    if (link.dynamicLink) {
                        link = link.dynamicLink;
                    }
                    else
                        I = 1000;
                }
            }
        }
    return ret;
}
function KinkyDungeonDrawInventorySelected(item, noscroll, treatAsHover, xOffset = 0) {
    if (!noscroll) {
        KDDraw(kdcanvas, kdpixisprites, "magicBook", KinkyDungeonRootDirectory + "MagicBook.png", xOffset + canvasOffsetX_ui, canvasOffsetY_ui, 640 * KinkyDungeonBookScale, 483 * KinkyDungeonBookScale, undefined, {
            zIndex: 128,
        });
    }
    if (!item)
        return false;
    let name = item.name;
    let prefix = "KinkyDungeonInventoryItem";
    if (item.item.type == Restraint || item.item.type == LooseRestraint)
        prefix = "Restraint";
    DrawTextFitKD(TextGet(prefix + name), xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5, 300, "#000000", KDTextTan, undefined, undefined, 129);
    let textSplit = KinkyDungeonWordWrap(TextGet(prefix + name + "Desc"), 12, 28).split('\n');
    let textSplit2 = KinkyDungeonWordWrap(TextGet(prefix + name + "Desc2"), 12, 28).split('\n');
    let showpreview = (item.preview && !MouseIn(xOffset + canvasOffsetX_ui, canvasOffsetY_ui, 840, 583));
    let i = 2;
    if (showpreview) {
        if (!treatAsHover) {
            KDDraw(kdcanvas, kdpixisprites, "preview", item.preview, xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35 - 100, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 45, 200, 200, undefined, {
                zIndex: 129,
            });
        }
        else {
            for (let N = 0; N < textSplit.length; N++) {
                DrawTextKD(textSplit[N], xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + i * 40, "#000000", KDTextTan, 24, undefined, 130);
                i++;
            }
        }
        if (item.item.type == Restraint || item.item.type == LooseRestraint) {
            let restraint = KDRestraint(item.item);
            DrawTextKD(TextGet("KinkyDungeonRestraintLevel").replace("RestraintLevel", "" + Math.max(1, restraint.displayPower != undefined ? restraint.displayPower : restraint.power)).replace("Rarity", TextGet("KinkyDungeonRarity" + Math.max(0, Math.min(Math.floor((restraint.displayPower != undefined ? restraint.displayPower : restraint.power) / 3), 10)))), xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 330, "#000000", KDTextTan, undefined, undefined, 130);
            DrawTextKD(restraint.escapeChance ? (item.item.lock ? (TextGet("KinkyLocked") + " " + TextGet("Kinky" + item.item.lock + "LockType")) :
                (restraint.DefaultLock && !restraint.HideDefaultLock ? (TextGet("KinkyLocked") + " " + TextGet("Kinky" + restraint.DefaultLock + "LockType")) : TextGet("KinkyUnlocked")))
                : (restraint.escapeChance.Pick != null ? TextGet("KinkyLockable") : TextGet("KinkyNonLockable")), xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 370, "#000000", KDTextTan, undefined, undefined, 130);
            let goddesses = "";
            if (restraint.shrine)
                for (let shrine of restraint.shrine) {
                    if (KinkyDungeonGoddessRep[shrine] != undefined) {
                        if (goddesses) {
                            goddesses = goddesses + ", ";
                        }
                        goddesses = goddesses + TextGet("KinkyDungeonShrine" + shrine);
                    }
                }
            if (goddesses)
                DrawTextFitKD("Goddess: " + goddesses, xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 425, 300, "#000000", KDTextTan, undefined, undefined, 130);
        }
        else if (item.item.type == Consumable) {
            let consumable = KDConsumable(item.item);
            DrawTextKD(TextGet("KinkyDungeonConsumableQuantity") + item.item.quantity, xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 330, "#000000", KDTextTan, undefined, undefined, 130);
            DrawTextKD(TextGet("KinkyDungeonRarity") + TextGet("KinkyDungeonRarity" + consumable.rarity), xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 370, "#000000", KDTextTan, undefined, undefined, 130);
        }
        else if (item.item.type == Weapon) {
            let weapon = KDWeapon(item.item);
            DrawTextKD(TextGet("KinkyDungeonWeaponDamage") + (weapon.dmg * 10), xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 310, "#000000", KDTextTan, undefined, undefined, 130);
            DrawTextKD(TextGet("KinkyDungeonWeaponAccuracy") + Math.round(weapon.chance * 100) + "%", xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 350, "#000000", KDTextTan, undefined, undefined, 130);
            let cost = -KinkyDungeonStatStaminaCostAttack;
            if (weapon.staminacost)
                cost = weapon.staminacost;
            DrawTextKD(TextGet("KinkyDungeonWeaponStamina") + Math.round(-10 * cost), xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + 390, "#000000", KDTextTan, undefined, undefined, 130);
        }
    }
    else {
        for (let N = 0; N < textSplit.length; N++) {
            DrawTextKD(textSplit[N], xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale / 3.35, canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + i * 40, "#000000", KDTextTan, 24, undefined, 130);
            i++;
        }
    }
    i = 0;
    for (let N = 0; N < textSplit2.length; N++) {
        DrawTextKD(textSplit2[N], xOffset + canvasOffsetX_ui + 640 * KinkyDungeonBookScale * (1 - 1 / 3.35), canvasOffsetY_ui + 483 * KinkyDungeonBookScale / 5 + i * 40, "#000000", KDTextTan, 24, undefined, 130);
        i++;
    }
    i = 0;
    return true;
}
function KinkyDungeonDrawInventory() {
    KinkyDungeonDrawMessages(true);
    let filteredInventory = KinkyDungeonFilterInventory(KinkyDungeonCurrentFilter);
    if (KinkyDungeonCurrentPageInventory >= filteredInventory.length)
        KinkyDungeonCurrentPageInventory = 0;
    let defaultIndex = 0;
    if (KinkyDungeonFilterInventory(KinkyDungeonFilters[0]).length == 0)
        defaultIndex = 1;
    for (let I = 0; I < KinkyDungeonFilters.length; I++) {
        let col = KDTextGray2;
        if (KinkyDungeonFilterInventory(KinkyDungeonFilters[I]).length > 0 || I == defaultIndex) {
            col = "#888888";
        }
        else if (KinkyDungeonFilters.indexOf(KinkyDungeonCurrentFilter) == I)
            KinkyDungeonCurrentFilter = KinkyDungeonFilters[defaultIndex];
        DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale - 20, canvasOffsetY_ui + 115 + I * 65, 225, 60, TextGet("KinkyDungeonCategoryFilter" + KinkyDungeonFilters[I]), (KinkyDungeonCurrentFilter == KinkyDungeonFilters[I]) ? "White" : col, "", "");
    }
    if (filteredInventory.length > 0) {
        DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 400, canvasOffsetY_ui, 90, 40, "", KinkyDungeonInventoryOffset > 0 ? "white" : "#888888", KinkyDungeonRootDirectory + "Up.png");
        DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 400, 480 * KinkyDungeonBookScale + canvasOffsetY_ui - 15, 90, 40, "", (KinkyDungeonInventoryOffset + 24 < filteredInventory.length) ? "white" : "#888888", KinkyDungeonRootDirectory + "Down.png");
        for (let i = 0; i < 24; i++) {
            let xx = i % 2;
            let yy = Math.floor(i / 2);
            let index = i + KinkyDungeonInventoryOffset;
            if (filteredInventory[index] && filteredInventory[index].item) {
                let text = "KinkyDungeonInventoryItem" + filteredInventory[index].name;
                if (filteredInventory[index].item.type == Restraint || filteredInventory[index].item.type == LooseRestraint)
                    text = "Restraint" + filteredInventory[index].name;
                let suff = "";
                if (filteredInventory[index].item.quantity) {
                    suff = " x" + filteredInventory[index].item.quantity;
                }
                DrawButtonVis(canvasOffsetX_ui + xx * 200 + 640 * KinkyDungeonBookScale + 250, canvasOffsetY_ui + 50 + 45 * yy, 195, 40, TextGet(text) + suff, index == KinkyDungeonCurrentPageInventory ? "white" : "#888888");
            }
            else {
                if (i + KinkyDungeonInventoryOffset > filteredInventory.length + 2)
                    KinkyDungeonInventoryOffset = 0;
                break;
            }
        }
    }
    if (KinkyDungeonDrawInventorySelected(filteredInventory[KinkyDungeonCurrentPageInventory])) {
        if (KinkyDungeonCurrentFilter == Consumable)
            DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60, TextGet("KinkyDungeonConsume"), "White", "", "");
        if (KinkyDungeonCurrentFilter == Weapon && filteredInventory[KinkyDungeonCurrentPageInventory].name != "Unarmed") {
            let equipped = filteredInventory[KinkyDungeonCurrentPageInventory] && filteredInventory[KinkyDungeonCurrentPageInventory].name == KinkyDungeonPlayerWeapon;
            DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60, TextGet(equipped ? "KinkyDungeonEquipped" : "KinkyDungeonEquip"), equipped ? "grey" : "White", "", "");
            if (equipped)
                DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale + 70, 350, 60, TextGet("KinkyDungeonUnEquip"), "White", "", "");
        }
        if (KinkyDungeonCurrentFilter == Outfit) {
            let outfit = ((filteredInventory[KinkyDungeonCurrentPageInventory] != null) ? filteredInventory[KinkyDungeonCurrentPageInventory].name : "");
            let toWear = KinkyDungeonGetOutfit(outfit);
            if (toWear) {
                DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60, TextGet("KinkyDungeonEquip"), KDGameData.Outfit == outfit ? "grey" : "White", "", "");
            }
        }
        if (KinkyDungeonCurrentFilter == LooseRestraint) {
            let equipped = false;
            if (filteredInventory[KinkyDungeonCurrentPageInventory]
                && filteredInventory[KinkyDungeonCurrentPageInventory].item) {
                let newItem = KDRestraint(filteredInventory[KinkyDungeonCurrentPageInventory].item);
                if (newItem) {
                    let currentItem = KinkyDungeonGetRestraintItem(newItem.Group);
                    if (!currentItem
                        || (KinkyDungeonLinkableAndStricter(KDRestraint(currentItem), newItem, currentItem) &&
                            ((newItem.linkCategory && KDLinkCategorySize(currentItem, newItem.linkCategory) + KDLinkSize(newItem) <= 1.0)
                                || (!newItem.linkCategory && !KDDynamicLinkList(currentItem, true).some((item) => { return newItem.name == item.name; }))))) {
                        equipped = false;
                    }
                    else
                        equipped = true;
                }
            }
            DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale + 25, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 350, 60, TextGet("KinkyDungeonEquip"), equipped ? "grey" : "White", "", "");
        }
    }
    if (KinkyDungeonCurrentPageInventory >= filteredInventory.length)
        KinkyDungeonCurrentPageInventory = Math.max(0, KinkyDungeonCurrentPageInventory - 1);
    if (KinkyDungeonCurrentPageInventory > 0) {
        DrawButtonVis(canvasOffsetX_ui + 100, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60, TextGet("KinkyDungeonBookLastPage"), "White", "", "");
    }
    if (KinkyDungeonCurrentPageInventory < filteredInventory.length - 1) {
        DrawButtonVis(canvasOffsetX_ui + 640 * KinkyDungeonBookScale - 325, canvasOffsetY_ui + 483 * KinkyDungeonBookScale, 250, 60, TextGet("KinkyDungeonBookNextPage"), "White", "", "");
    }
}
function KinkyDungeonSendInventoryEvent(Event, data) {
    var _a;
    if (!KDMapHasEvent(KDEventMapInventory, Event))
        return;
    for (let item of KinkyDungeonAllRestraint()) {
        if (item.dynamicLink)
            for (let d_item of KDDynamicLinkList(item)) {
                let oldEvents = d_item.events;
                if (oldEvents)
                    for (let e of oldEvents) {
                        if (e.inheritLinked && e.trigger === Event && (!e.requireEnergy || ((!e.energyCost && KDGameData.AncientEnergyLevel > 0) || (e.energyCost && KDGameData.AncientEnergyLevel > e.energyCost)))) {
                            KinkyDungeonHandleInventoryEvent(Event, e, d_item, data);
                        }
                    }
            }
        if (item.events) {
            for (let e of item.events) {
                if (e.trigger === Event && (!e.requireEnergy || ((!e.energyCost && KDGameData.AncientEnergyLevel > 0) || (e.energyCost && KDGameData.AncientEnergyLevel > e.energyCost)))) {
                    KinkyDungeonHandleInventoryEvent(Event, e, item, data);
                }
            }
        }
        if (item.curse && ((_a = KDCurses[item.curse]) === null || _a === void 0 ? void 0 : _a.events)) {
            for (let e of KDCurses[item.curse].events) {
                if (e.trigger === Event && (!e.requireEnergy || ((!e.energyCost && KDGameData.AncientEnergyLevel > 0) || (e.energyCost && KDGameData.AncientEnergyLevel > e.energyCost)))) {
                    KinkyDungeonHandleInventoryEvent(Event, e, item, data);
                }
            }
        }
    }
}
let KinkyDungeonInvDraw = [];
function KinkyDungeonQuickGrid(I, Width, Height, Xcount) {
    let i = 0;
    let h = 0;
    let v = 0;
    while (i < I) {
        if (h < Xcount - 1)
            h++;
        else {
            h = 0;
            v++;
        }
        i++;
    }
    return { x: Width * h, y: Height * v };
}
let KDScrollOffset = {
    "Consumable": 0,
    "Restraint": 0,
    "Weapon": 0,
};
let KDItemsPerScreen = {
    "Consumable": 18,
    "Restraint": 18,
    "Weapon": 18,
};
let KDScrollAmount = 6;
let KDHideQuickInv = false;
function KinkyDungeonDrawQuickInv() {
    let H = 80;
    let V = 80;
    let fC = KinkyDungeonFilterInventory(Consumable, false, !KDHideQuickInv);
    let consumables = fC.slice(KDScrollOffset.Consumable, KDScrollOffset.Consumable + KDItemsPerScreen.Consumable);
    let fW = KinkyDungeonFilterInventory(Weapon, false, !KDHideQuickInv);
    let weapons = fW.slice(KDScrollOffset.Weapon, KDScrollOffset.Weapon + KDItemsPerScreen.Weapon);
    let fR = KinkyDungeonFilterInventory(LooseRestraint, true, !KDHideQuickInv);
    let restraints = fR.slice(KDScrollOffset.Restraint, KDScrollOffset.Restraint + KDItemsPerScreen.Restraint);
    let Wheight = KinkyDungeonQuickGrid(weapons.length - 1, H, V, 6).y;
    let Rheight = 480;
    KDScrollOffset.Consumable = Math.max(0, Math.min(Math.ceil((fC.length - KDItemsPerScreen.Consumable) / KDScrollAmount) * KDScrollAmount, KDScrollOffset.Consumable));
    KDScrollOffset.Restraint = Math.max(0, Math.min(Math.ceil((fR.length - KDItemsPerScreen.Consumable) / KDScrollAmount) * KDScrollAmount, KDScrollOffset.Restraint));
    KDScrollOffset.Weapon = Math.max(0, Math.min(Math.ceil((fW.length - KDItemsPerScreen.Consumable) / KDScrollAmount) * KDScrollAmount, KDScrollOffset.Weapon));
    if (fC.length > KDItemsPerScreen.Consumable) {
        DrawButtonVis(510, 5, 90, 40, "", "white", KinkyDungeonRootDirectory + "Up.png");
        DrawButtonVis(510, 50, 90, 40, "", "white", KinkyDungeonRootDirectory + "Down.png");
    }
    if (fW.length > KDItemsPerScreen.Weapon) {
        DrawButtonVis(510, 705, 90, 40, "", "white", KinkyDungeonRootDirectory + "Up.png");
        DrawButtonVis(510, 750, 90, 40, "", "white", KinkyDungeonRootDirectory + "Down.png");
    }
    if (fR.length > KDItemsPerScreen.Restraint) {
        DrawButtonVis(510, 455, 90, 40, "", "white", KinkyDungeonRootDirectory + "Up.png");
        DrawButtonVis(510, 500, 90, 40, "", "white", KinkyDungeonRootDirectory + "Down.png");
    }
    FillRectKD(kdcanvas, kdpixisprites, "quickinvbg", {
        Left: 5,
        Top: 5,
        Width: 490,
        Height: 990,
        Color: "#000000",
        LineWidth: 1,
        zIndex: 59,
        alpha: 0.9
    });
    DrawButtonKDEx("inventoryhide", (bdata) => {
        if (!KDGameData.HiddenItems)
            KDGameData.HiddenItems = {};
        KDHideQuickInv = !KDHideQuickInv;
        return true;
    }, true, 510, 625, 120, 60, "", "white", KinkyDungeonRootDirectory + (KDHideQuickInv ? "InvHide.png" : "InvNoHide.png"));
    for (let c = 0; c < consumables.length; c++) {
        let item = consumables[c];
        if (item.preview) {
            let point = KinkyDungeonQuickGrid(c, H, V, 6);
            if (MouseIn(point.x + 1, 1 + point.y + 30, H - 2, V - 2)) {
                FillRectKD(kdcanvas, kdpixisprites, "consumables" + c, {
                    Left: point.x,
                    Top: point.y + 30,
                    Width: H,
                    Height: V,
                    Color: KDTextGray3,
                    LineWidth: 1,
                    zIndex: 60,
                    alpha: 0.5
                });
                KinkyDungeonDrawInventorySelected(item, false, true);
            }
            KDDraw(kdcanvas, kdpixisprites, "consumablesicon" + c, item.preview, point.x, point.y + 30, 80, 80, undefined, {
                zIndex: 109,
            });
            if (KDGameData.HiddenItems && KDGameData.HiddenItems[item.name]) {
                KDDraw(kdcanvas, kdpixisprites, "consumablesiconhidden" + c, KinkyDungeonRootDirectory + "InvHidden.png", point.x, point.y + 30, 80, 80, undefined, {
                    zIndex: 110,
                });
            }
            DrawTextKD("" + item.item.quantity, point.x + 1, point.y + 1 + 30, "black", undefined, "left");
            DrawTextKD("" + item.item.quantity, point.x, point.y + 30, "white", undefined, "left");
        }
    }
    for (let w = 0; w < weapons.length; w++) {
        let item = weapons[w];
        if (item.preview) {
            let point = KinkyDungeonQuickGrid(w, H, V, 6);
            if (MouseIn(point.x + 1, 1 + 1000 - V - Wheight + point.y, H - 2, V - 2)) {
                FillRectKD(kdcanvas, kdpixisprites, "weapons" + w, {
                    Left: point.x,
                    Top: 1000 - V - Wheight + point.y,
                    Width: H,
                    Height: V,
                    Color: KDTextGray3,
                    LineWidth: 1,
                    zIndex: 60,
                    alpha: 0.5
                });
                KinkyDungeonDrawInventorySelected(item, false, true);
            }
            KDDraw(kdcanvas, kdpixisprites, "weaponsicon" + w, item.preview, point.x, 1000 - V - Wheight + point.y, 80, 80, undefined, {
                zIndex: 109,
            });
            if (KDGameData.HiddenItems && KDGameData.HiddenItems[item.name]) {
                KDDraw(kdcanvas, kdpixisprites, "weaponsiconhid" + w, KinkyDungeonRootDirectory + "InvHidden.png", point.x, 1000 - V - Wheight + point.y, 80, 80, undefined, {
                    zIndex: 110,
                });
            }
        }
    }
    for (let w = 0; w < restraints.length; w++) {
        let item = restraints[w];
        if (item.preview) {
            let point = KinkyDungeonQuickGrid(w, H, V, 6);
            if (MouseIn(point.x + 1, 1 + 1000 - V - Rheight + point.y, H - 2, V - 2)) {
                FillRectKD(kdcanvas, kdpixisprites, "restraints" + w, {
                    Left: point.x,
                    Top: 1000 - V - Rheight + point.y,
                    Width: H,
                    Height: V,
                    Color: KDTextGray3,
                    LineWidth: 1,
                    zIndex: 60,
                    alpha: 0.5
                });
                KinkyDungeonDrawInventorySelected(item, false, true);
            }
            KDDraw(kdcanvas, kdpixisprites, "restraintsicon" + w, item.preview, point.x, 1000 - V - Rheight + point.y, 80, 80, undefined, {
                zIndex: 109,
            });
            if (KDGameData.HiddenItems && KDGameData.HiddenItems[item.name]) {
                KDDraw(kdcanvas, kdpixisprites, "restraintsiconhid" + w, KinkyDungeonRootDirectory + "InvHidden.png", point.x, 1000 - V - Rheight + point.y, 80, 80, undefined, {
                    zIndex: 109,
                });
            }
        }
    }
}
function KinkyDungeonhandleQuickInv(NoUse) {
    let H = 80;
    let V = 80;
    let fC = KinkyDungeonFilterInventory(Consumable, false, !KDHideQuickInv);
    let consumables = fC.slice(KDScrollOffset.Consumable, KDScrollOffset.Consumable + KDItemsPerScreen.Consumable);
    let fW = KinkyDungeonFilterInventory(Weapon, false, !KDHideQuickInv);
    let weapons = fW.slice(KDScrollOffset.Weapon, KDScrollOffset.Weapon + KDItemsPerScreen.Weapon);
    let fR = KinkyDungeonFilterInventory(LooseRestraint, true, !KDHideQuickInv);
    let restraints = fR.slice(KDScrollOffset.Restraint, KDScrollOffset.Restraint + KDItemsPerScreen.Restraint);
    let Wheight = KinkyDungeonQuickGrid(weapons.length - 1, H, V, 6).y;
    let Rheight = 480;
    if (fC.length > KDItemsPerScreen.Consumable) {
        if (MouseIn(510, 5, 90, 40)) {
            KDScrollOffset.Consumable = Math.max(0, KDScrollOffset.Consumable - KDScrollAmount);
            return true;
        }
        if (MouseIn(510, 50, 90, 40)) {
            KDScrollOffset.Consumable = Math.min(Math.ceil((fC.length - KDItemsPerScreen.Consumable) / KDScrollAmount) * KDScrollAmount, KDScrollOffset.Consumable + KDScrollAmount);
            return true;
        }
    }
    if (fW.length > KDItemsPerScreen.Weapon) {
        if (MouseIn(510, 705, 90, 40)) {
            KDScrollOffset.Weapon = Math.max(0, KDScrollOffset.Weapon - KDScrollAmount);
            return true;
        }
        if (MouseIn(510, 750, 90, 40)) {
            KDScrollOffset.Weapon = Math.min(Math.ceil((fW.length - KDItemsPerScreen.Consumable) / KDScrollAmount) * KDScrollAmount, KDScrollOffset.Weapon + KDScrollAmount);
            return true;
        }
    }
    if (fR.length > KDItemsPerScreen.Restraint) {
        if (MouseIn(510, 455, 90, 40)) {
            KDScrollOffset.Restraint = Math.max(0, KDScrollOffset.Restraint - KDScrollAmount);
            return true;
        }
        if (MouseIn(510, 500, 90, 40)) {
            KDScrollOffset.Restraint = Math.min(Math.ceil((fR.length - KDItemsPerScreen.Consumable) / KDScrollAmount) * KDScrollAmount, KDScrollOffset.Restraint + KDScrollAmount);
            return true;
        }
    }
    if (NoUse) {
        return false;
    }
    if (MouseX > 500) {
        KDCloseQuickInv();
        return false;
    }
    for (let c = 0; c < consumables.length; c++) {
        let item = consumables[c];
        if (item.preview) {
            let point = KinkyDungeonQuickGrid(c, H, V, 6);
            if (MouseIn(point.x, point.y + 30, H, V)) {
                if (KDHideQuickInv) {
                    KDGameData.HiddenItems[item.name] = !KDGameData.HiddenItems[item.name];
                }
                else {
                    KDSendInput("consumable", { item: item.name, quantity: 1 });
                }
            }
        }
    }
    for (let w = 0; w < weapons.length; w++) {
        let item = weapons[w];
        if (item.preview) {
            let point = KinkyDungeonQuickGrid(w, H, V, 6);
            if (MouseIn(point.x, 1000 - V - Wheight + point.y, H, V)) {
                if (KDHideQuickInv) {
                    KDGameData.HiddenItems[item.name] = !KDGameData.HiddenItems[item.name];
                }
                else {
                    let weapon = item.name != "Unarmed" ? item.name : null;
                    KDSendInput("switchWeapon", { weapon: weapon });
                    KDCloseQuickInv();
                }
            }
        }
    }
    for (let w = 0; w < restraints.length; w++) {
        let item = restraints[w];
        if (item.preview) {
            let point = KinkyDungeonQuickGrid(w, H, V, 6);
            if (MouseIn(point.x, 1000 - V - Rheight + point.y, H, V)) {
                if (KDHideQuickInv) {
                    KDGameData.HiddenItems[item.name] = !KDGameData.HiddenItems[item.name];
                }
                else {
                    let equipped = false;
                    let newItem = null;
                    let currentItem = null;
                    if (item
                        && item.item) {
                        newItem = KDRestraint(item.item);
                        if (newItem) {
                            currentItem = KinkyDungeonGetRestraintItem(newItem.Group);
                            if (!currentItem
                                || (KinkyDungeonLinkableAndStricter(KDRestraint(currentItem), newItem, currentItem) &&
                                    ((newItem.linkCategory && KDLinkCategorySize(currentItem, newItem.linkCategory) + KDLinkSize(newItem) <= 1.0)
                                        || (!newItem.linkCategory && !KDDynamicLinkList(currentItem, true).some((ii) => { return newItem.name == ii.name; }))))) {
                                equipped = false;
                            }
                            else
                                equipped = true;
                        }
                    }
                    if (!equipped && newItem) {
                        if (KDSendInput("equip", { name: newItem.name, group: newItem.Group, curse: item.item.curse, currentItem: currentItem ? currentItem.name : undefined, events: Object.assign([], item.item.events) }))
                            return true;
                    }
                }
            }
        }
    }
    return false;
}
function KinkyDungeonMultiplayerUpdate(Delay) {
    if (KinkyDungeonIsPlayer() && ChatRoomCharacter && ChatRoomCharacter.length > 1 && DialogGamingPreviousRoom == "ChatRoom" && KinkyDungeonNextDataSendTime + Delay < CommonTime()) {
        let MN = [];
        for (let C = 0; C < ChatRoomCharacter.length; C++) {
            let Char = ChatRoomCharacter[C];
            if (KinkyDungeonStreamingPlayers.includes(Char.MemberNumber) && Char.ID != 0 && Char.Effect.includes("VR"))
                MN.push(Char.MemberNumber);
        }
        if (MN.length > 0) {
            let data = KinkyDungeonPackData(KinkyDungeonGrid_Last != KinkyDungeonGrid, true, KinkyDungeonMultiplayerInventoryFlag, CommonTime() > KinkyDungeonNextDataSendStatsTime + KinkyDungeonNextDataSendStatsTimeDelay);
            KinkyDungeonSendData(data);
        }
        KinkyDungeonNextDataSendTime = CommonTime();
        if (CommonTime() > KinkyDungeonNextDataSendStatsTime + KinkyDungeonNextDataSendStatsTimeDelay)
            KinkyDungeonNextDataSendStatsTime = CommonTime();
        KinkyDungeonGrid_Last = KinkyDungeonGrid;
        KinkyDungeonMultiplayerInventoryFlag = false;
    }
}
function KinkyDungeonUnpackData(KinkyData) {
    if (CurrentScreen != "KinkyDungeon" || KinkyDungeonState != "Game" || !KinkyDungeonPlayerCharacter)
        return;
    if (KinkyDungeonIsPlayer())
        return;
    let data = JSON.parse(LZString.decompressFromBase64(KinkyData));
    if (!KinkyDungeonGameData)
        KinkyDungeonGameData = {};
    if (!data)
        return;
    if (data.enemies != null) {
        KinkyDungeonGameData.enemies = data.enemies;
    }
    if (data.items != null) {
        KinkyDungeonGameData.items = data.items;
    }
    if (data.bullets != null) {
        KinkyDungeonGameData.bullets = data.bullets;
    }
    if (data.map != null) {
        KinkyDungeonGameData.map = data.map;
    }
    if (data.inventory != null) {
        KinkyDungeonGameData.inventory = data.inventory;
    }
    if (data.meta != null) {
        KinkyDungeonGameData.meta = data.meta;
    }
    KinkyDungeonUpdateFromData();
    KinkyDungeonNextDataLastTimeReceived = CommonTime();
}
function KinkyDungeonUpdateFromData() {
    if (KinkyDungeonGameData.map == null ||
        KinkyDungeonGameData.inventory == null ||
        KinkyDungeonGameData.bullets == null ||
        KinkyDungeonGameData.items == null ||
        KinkyDungeonGameData.enemies == null) {
        KinkyDungeonGameData = null;
        return false;
    }
    if (KinkyDungeonGameData.enemies) {
        KinkyDungeonEntities = [];
        KDUpdateEnemyCache = true;
        let enemies = JSON.parse(KinkyDungeonGameData.enemies);
        for (let N = 0; N < enemies.length; N++) {
            let enemy = enemies[N].split('/');
            let i = 1;
            KDAddEntity({ Enemy: { name: enemy[i++] }, stun: enemy[i++], x: enemy[i++], y: enemy[i++] });
        }
    }
    if (KinkyDungeonGameData.inventory) {
        KDInitInventory();
        let inventory = JSON.parse(KinkyDungeonGameData.inventory);
        CharacterReleaseTotal(KinkyDungeonPlayer);
        if (typeof inventory !== "string")
            for (let N = 0; N < inventory.length; N++) {
                let item = inventory[N].split('/');
                if (item.length > 1) {
                    let i = 1;
                    let restraint = KinkyDungeonGetRestraintByName(item[i++]);
                    KinkyDungeonAddRestraint(restraint, 0, true);
                    let createdrestraint = KinkyDungeonGetRestraintItem(restraint.Group);
                    if (createdrestraint)
                        createdrestraint.lock = undefined;
                }
            }
        KinkyDungeonUpdateStats(0);
        KinkyDungeonDressPlayer();
    }
    if (KinkyDungeonGameData.bullets) {
        KinkyDungeonBullets = [];
        let bullets = JSON.parse(KinkyDungeonGameData.bullets);
        for (let N = 0; N < bullets.length; N++) {
            let bullet = bullets[N].split('/');
            let i = 1;
            let name = bullet[i++];
            KinkyDungeonBullets.push({ spriteID: name + CommonTime(), x: bullet[i], xx: bullet[i++], y: bullet[i], yy: bullet[i++], vx: bullet[i++], vy: bullet[i++],
                bullet: { name: name, width: bullet[i++], height: bullet[i++] } });
        }
    }
    if (KinkyDungeonGameData.items) {
        KinkyDungeonGroundItems = [];
        let items = JSON.parse(KinkyDungeonGameData.items);
        for (let N = 0; N < items.length; N++) {
            let item = items[N].split('/');
            let i = 1;
            KinkyDungeonGroundItems.push({ name: item[i++], x: item[i++], y: item[i++] });
        }
    }
    if (KinkyDungeonGameData.map)
        KinkyDungeonGrid = KinkyDungeonGameData.map;
    if (KinkyDungeonGameData.meta) {
        KinkyDungeonUpdateLightGrid = true;
        KinkyDungeonGridWidth = Math.round(KinkyDungeonGameData.meta.w);
        KinkyDungeonGridHeight = Math.round(KinkyDungeonGameData.meta.h);
        KinkyDungeonPlayerEntity.x = Math.round(KinkyDungeonGameData.meta.x);
        KinkyDungeonPlayerEntity.y = Math.round(KinkyDungeonGameData.meta.y);
        if (KinkyDungeonGameData.meta.sp != null)
            KinkyDungeonStatStamina = Math.round(KinkyDungeonGameData.meta.sp);
        if (KinkyDungeonGameData.meta.mp != null)
            KinkyDungeonStatMana = Math.round(KinkyDungeonGameData.meta.mp);
        if (KinkyDungeonGameData.meta.ap != null)
            KinkyDungeonStatDistraction = Math.round(KinkyDungeonGameData.meta.ap);
        if (KinkyDungeonGameData.meta.rk != null)
            KinkyDungeonRedKeys = Math.round(KinkyDungeonGameData.meta.rk);
        if (KinkyDungeonGameData.meta.bk != null)
            KinkyDungeonBlueKeys = Math.round(KinkyDungeonGameData.meta.bk);
        if (KinkyDungeonGameData.meta.lp != null)
            KinkyDungeonLockpicks = Math.round(KinkyDungeonGameData.meta.lp);
        if (KinkyDungeonGameData.meta.gp != null)
            KinkyDungeonGold = Math.round(KinkyDungeonGameData.meta.gp);
        if (KinkyDungeonGameData.meta.lv != null) {
            MiniGameKinkyDungeonLevel = Math.round(KinkyDungeonGameData.meta.lv);
            if (KinkyDungeonGameData.meta.cp)
                KinkyDungeonSetCheckPoint(KinkyDungeonGameData.meta.cp);
            else
                KinkyDungeonSetCheckPoint();
        }
    }
}
function KinkyDungeonPackData(IncludeMap, IncludeItems, IncludeInventory, IncludeStats) {
    let enemies = JSON.stringify(KinkyDungeonEntities, (key, value) => {
        if (CommonIsNumeric(key) && typeof value === "object") {
            if (value.Enemy) {
                return "E/" + value.Enemy.name + "/" + (value.stun ? value.stun : 0) + "/" + value.x + "/" + value.y;
            }
        }
        return value;
    });
    let items = IncludeItems ? JSON.stringify(KinkyDungeonGroundItems, (key, value) => {
        if (CommonIsNumeric(key) && typeof value === "object") {
            if (value.name) {
                return "G/" + value.name + "/" + value.x + "/" + value.y;
            }
        }
        return value;
    }) : "";
    let bullets = JSON.stringify(KinkyDungeonBullets, (key, value) => {
        if (CommonIsNumeric(key) && typeof value === "object") {
            if (value.bullet) {
                return "B/" + value.bullet.name + "/" + value.x + "/" + value.y + "/" + (Math.round(value.vx * 10) / 10) + "/" + (Math.round(value.vy * 10) / 10 + "/" + value.bullet.width + "/" + value.bullet.height);
            }
        }
        return "";
    });
    let map = IncludeMap ? KinkyDungeonGrid : "";
    let inventory = IncludeInventory ? JSON.stringify(Array.from(KinkyDungeonInventory.get(Restraint).values()), (key, value) => {
        if (CommonIsNumeric(key) && typeof value === "object") {
            if (value.restraint) {
                return "I/" + value.restraint.name + "/l" + value.lock;
            }
        }
        return "";
    }) : "";
    let meta = { w: KinkyDungeonGridWidth, h: KinkyDungeonGridHeight, x: KinkyDungeonPlayerEntity ? KinkyDungeonPlayerEntity.x : 0, y: KinkyDungeonPlayerEntity ? KinkyDungeonPlayerEntity.y : 0, };
    if (IncludeStats) {
        meta.sp = Math.round(KinkyDungeonStatStamina);
        meta.mp = Math.round(KinkyDungeonStatMana);
        meta.ap = Math.round(KinkyDungeonStatDistraction);
        meta.rk = KinkyDungeonRedKeys;
        meta.bk = KinkyDungeonBlueKeys;
        meta.lp = KinkyDungeonLockpicks;
        meta.gp = KinkyDungeonGold;
        meta.lv = MiniGameKinkyDungeonLevel;
        meta.cp = MiniGameKinkyDungeonCheckpoint;
    }
    let result = {
        enemies: enemies,
        items: items,
        bullets: bullets,
        map: map,
        inventory: inventory,
        meta: meta,
    };
    let stringToSend = LZString.compressToBase64(JSON.stringify(result));
    return stringToSend;
}
function KinkyDungeonSendData(data) {
    ServerSend("ChatRoomGame", { KinkyDungeon: data });
}
function KinkyDungeonHandleData(data, SourceMemberNumber) {
    if (CurrentScreen == "KinkyDungeon" && SourceMemberNumber == KinkyDungeonPlayerCharacter.MemberNumber)
        KinkyDungeonUnpackData(data);
}
let KinkyDungeonCurrentLore = -1;
let KinkyDungeonCurrentLoreTab = -1;
let KinkyDungeonCurrentLoreTabs = [-1];
let KinkyDungeonCurrentLoreItems = [];
let KinkyDungeonCurrentLoreItemOffset = 0;
let KinkyDungeonCurrentLoreTabOffset = 0;
let KinkyDungeonLore = [0, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28];
let KinkyDungeonCheckpointLore = {
    "Combat": [23, 24, 25, 26, 27],
    "School": [20, 21, 22, 28],
    "History": [29, 30, 31, 32, 33, 34, 35, 36, 37],
    "Enemy": [4, 5, 6, 19, 101, 102, 103, 104, 105, 106, 107, 108, 109, 111, 112, 1100, 1104, 201, 203],
    "grv": [29, 1, 19],
    "tmb": [30, 9, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112],
    "cat": [31, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 9,],
    "lib": [32],
    "jng": [33, 29, 201, 202, 203, 204, 205],
    "cry": [34],
    "tmp": [35],
    "ore": [36, 1400, 1401, 1402],
    "bel": [37, 400],
};
let KinkyDungeonLoreScale = 1.5;
let KinkyDungeonRepeatLoreChance = 0.4;
let KinkyDungeonGenericLoreChance = 0.33;
let KinkyDungeonNewLoreList = localStorage.getItem("kinkydungeonnewlore") ? JSON.parse(localStorage.getItem("kinkydungeonnewlore")) : [];
function KinkyDungeonNewLore() {
    let availableLore = [];
    let exploredLore = localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : [];
    let newLore = localStorage.getItem("kinkydungeonnewlore") ? JSON.parse(localStorage.getItem("kinkydungeonnewlore")) : [];
    let checkpoint = KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint];
    if (!exploredLore || exploredLore.length == 0) {
        availableLore = [0];
    }
    else if (KinkyDungeonCheckpointLore[checkpoint]) {
        for (let L = 0; L < KinkyDungeonCheckpointLore[checkpoint].length; L++) {
            availableLore.push(KinkyDungeonCheckpointLore[checkpoint][L]);
        }
        if (Math.random() < KinkyDungeonRepeatLoreChance) {
            if (Math.random() > KinkyDungeonGenericLoreChance) {
                availableLore = KinkyDungeonLore;
            }
            else {
                availableLore = [];
            }
        }
        else
            KinkyDungeonLore.forEach((element) => { if (!exploredLore.includes(element)) {
                availableLore.push(element);
            } });
    }
    let result = false;
    if (availableLore.length > 0) {
        KinkyDungeonCurrentLore = availableLore[Math.floor(Math.random() * availableLore.length)];
        if (!exploredLore.includes(KinkyDungeonCurrentLore)) {
            KinkyDungeonSendActionMessage(5, TextGet("ItemPickupLore"), "white", 2);
            exploredLore.push(KinkyDungeonCurrentLore);
            newLore.push(KinkyDungeonCurrentLore);
            KinkyDungeonCurrentLoreTab = -1;
            for (let i = 0; i < Object.keys(KinkyDungeonCheckpointLore).length; i++) {
                if (Object.values(KinkyDungeonCheckpointLore)[i].includes(KinkyDungeonCurrentLore)) {
                    KinkyDungeonCurrentLoreTab = i;
                    break;
                }
            }
        }
        else {
            KinkyDungeonSendActionMessage(4, TextGet("ItemPickupLoreOld"), "gray", 2);
            KinkyDungeonCurrentLore = -(1 + Math.floor(Math.random() * 10));
        }
        result = true;
    }
    else {
        KinkyDungeonSendActionMessage(4, TextGet("ItemPickupLoreOld"), "gray", 2);
        KinkyDungeonCurrentLore = -(1 + Math.floor(Math.random() * 10));
    }
    localStorage.setItem("kinkydungeonexploredlore", JSON.stringify(exploredLore));
    KinkyDungeonNewLoreList = newLore;
    localStorage.setItem("kinkydungeonnewlore", JSON.stringify(newLore));
    KinkyDungeonUpdateTabs(exploredLore);
    return result;
}
function KinkyDungeonUpdateTabs(exploredLore) {
    KinkyDungeonCurrentLoreTabs = [-1];
    for (let lore of exploredLore) {
        for (let i = 0; i < Object.keys(KinkyDungeonCheckpointLore).length; i++) {
            if (Object.values(KinkyDungeonCheckpointLore)[i].includes(lore))
                KinkyDungeonCurrentLoreTabs.push(Object.keys(KinkyDungeonCheckpointLore)[i]);
        }
    }
}
KinkyDungeonUpdateTabs(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
function KinkyDungeonDrawLore() {
    KDDraw(kdcanvas, kdpixisprites, "magicbook", KinkyDungeonRootDirectory + "MagicBook.png", canvasOffsetX_ui, canvasOffsetY_ui - 100, 640 * KinkyDungeonLoreScale, 483 * KinkyDungeonLoreScale);
    let loreOrig = TextGet("KinkyDungeonLore" + KinkyDungeonCurrentLore).split('|');
    let lore = [];
    for (let str of loreOrig) {
        lore.push(...(KinkyDungeonWordWrap(str, 19, 45).split('\n')));
    }
    let i = 0;
    for (let N = 0; N < lore.length; N++) {
        DrawTextFitKD(lore[N], canvasOffsetX_ui + 640 * KinkyDungeonLoreScale / 8, canvasOffsetY_ui - 100 + 483 * KinkyDungeonLoreScale / 6 + i * 40, 0.75 * 640 * KinkyDungeonLoreScale, "#000000", KDTextTan, undefined, "left");
        i++;
    }
    if (KinkyDungeonNewLoreList.includes(KinkyDungeonCurrentLore)) {
        KinkyDungeonNewLoreList.splice(KinkyDungeonNewLoreList.indexOf(KinkyDungeonCurrentLore), 1);
        localStorage.setItem("kinkydungeonnewlore", JSON.stringify(KinkyDungeonNewLoreList));
    }
    let tabs = Object.values(KinkyDungeonCheckpointLore);
    let tabNames = Object.keys(KinkyDungeonCheckpointLore);
    let numTabs = 20;
    for (i = -1; i < numTabs; i++) {
        if (i + KinkyDungeonCurrentLoreTabOffset < tabs.length) {
            let newLore = false;
            for (let ll of KinkyDungeonNewLoreList) {
                if ((i == -1 && KinkyDungeonLore.includes(ll)) || (i >= 0 && KinkyDungeonCheckpointLore[tabNames[i + KinkyDungeonCurrentLoreTabOffset]].includes(ll))) {
                    newLore = true;
                    break;
                }
            }
            if (i == -1)
                DrawButtonVis(1800, 142 + i * 42, 190, 40, TextGet("KinkyDungeonCheckpointLore-1"), tabNames[i + KinkyDungeonCurrentLoreTabOffset] == KinkyDungeonCurrentLoreTab ? "white" : (newLore ? "#88ff88" : "#888888"));
            else
                DrawButtonVis(1800, 142 + i * 42, 190, 40, KinkyDungeonCurrentLoreTabs.includes(tabNames[i + KinkyDungeonCurrentLoreTabOffset]) ?
                    TextGet("KinkyDungeonCheckpointLore" + tabNames[i + KinkyDungeonCurrentLoreTabOffset]) :
                    TextGet("KinkyDungeonCheckpointLoreUnknown"), tabNames[i + KinkyDungeonCurrentLoreTabOffset] == KinkyDungeonCurrentLoreTab ? "white" : (newLore ? "#88ff88" : "#888888"));
        }
        else {
            if (i + KinkyDungeonCurrentLoreTabOffset > tabs.length + 3)
                KinkyDungeonCurrentLoreTabOffset = 0;
            break;
        }
        DrawButtonVis(1850, 30, 90, 40, "", KinkyDungeonCurrentLoreTabOffset > 0 ? "white" : "#888888", KinkyDungeonRootDirectory + "Up.png");
        DrawButtonVis(1850, 930, 90, 40, "", numTabs + KinkyDungeonCurrentLoreTabOffset < KinkyDungeonCurrentLoreTabs.length ? "white" : "#888888", KinkyDungeonRootDirectory + "Down.png");
    }
    let numNotes = 57;
    DrawButtonVis(1550, 80, 90, 40, "", KinkyDungeonCurrentLoreItemOffset > 0 ? "white" : "#888888", KinkyDungeonRootDirectory + "Up.png");
    DrawButtonVis(1550, 860, 90, 40, "", numNotes + KinkyDungeonCurrentLoreItemOffset < KinkyDungeonCurrentLoreItems.length ? "white" : "#888888", KinkyDungeonRootDirectory + "Down.png");
    for (i = 0; i < numNotes; i++) {
        let ii = Math.floor(i / 3);
        let xx = i % 3;
        if (i + KinkyDungeonCurrentLoreItemOffset < KinkyDungeonCurrentLoreItems.length) {
            let loreNum = KinkyDungeonCurrentLoreItems[i + KinkyDungeonCurrentLoreItemOffset];
            DrawButtonVis(1450 + 100 * xx, 142 + (ii) * 42, 90, 40, "#" + loreNum, loreNum == KinkyDungeonCurrentLore ? "white" : (KinkyDungeonNewLoreList.includes(loreNum) ? "#88ff88" : "#888888"));
        }
        else {
            if (i + KinkyDungeonCurrentLoreItemOffset > KinkyDungeonCurrentLoreItems.length + 3)
                KinkyDungeonCurrentLoreItemOffset = 0;
            break;
        }
    }
}
function KinkyDungeonUpdateLore(exploredLore) {
    KinkyDungeonCurrentLoreItems = [];
    for (let lore of exploredLore) {
        if (KinkyDungeonCurrentLoreTab == -1 && KinkyDungeonLore.includes(lore)) {
            KinkyDungeonCurrentLoreItems.push(lore);
        }
        else if (KinkyDungeonCheckpointLore[KinkyDungeonCurrentLoreTab] && KinkyDungeonCheckpointLore[KinkyDungeonCurrentLoreTab].includes(lore)) {
            KinkyDungeonCurrentLoreItems.push(lore);
        }
    }
}
function KinkyDungeonHandleLore() {
    let tabs = Object.values(KinkyDungeonCheckpointLore);
    let tabNames = Object.keys(KinkyDungeonCheckpointLore);
    let numTabs = 20;
    for (let i = -1; i + KinkyDungeonCurrentLoreTabOffset < tabs.length && i < numTabs; i++) {
        if (MouseIn(1800, 142 + i * 42, 190, 40) && (KinkyDungeonCurrentLoreTabs.includes(tabNames[i + KinkyDungeonCurrentLoreTabOffset]) || i == -1)) {
            if (tabNames[i + KinkyDungeonCurrentLoreTabOffset]) {
                KinkyDungeonCurrentLoreTab = tabNames[i + KinkyDungeonCurrentLoreTabOffset];
                KinkyDungeonUpdateLore(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
            }
            else if (i == -1) {
                KinkyDungeonCurrentLoreTab = -1;
                KinkyDungeonUpdateLore(localStorage.getItem("kinkydungeonexploredlore") ? JSON.parse(localStorage.getItem("kinkydungeonexploredlore")) : []);
            }
        }
    }
    if (MouseIn(1850, 30, 90, 40) && KinkyDungeonCurrentLoreTabOffset > 0)
        KinkyDungeonCurrentLoreTabOffset -= 3;
    if (MouseIn(1850, 930, 90, 40) && numTabs + KinkyDungeonCurrentLoreTabOffset < KinkyDungeonCurrentLoreTabs.length)
        KinkyDungeonCurrentLoreTabOffset += 3;
    let numNotes = 57;
    if (MouseIn(1550, 80, 90, 40) && KinkyDungeonCurrentLoreItemOffset > 0)
        KinkyDungeonCurrentLoreItemOffset -= 3;
    if (MouseIn(1550, 860, 90, 40) && numNotes + KinkyDungeonCurrentLoreItemOffset < KinkyDungeonCurrentLoreItems.length)
        KinkyDungeonCurrentLoreItemOffset += 3;
    for (let i = 0; i < numNotes; i++) {
        let ii = Math.floor(i / 3);
        let xx = i % 3;
        if (i + KinkyDungeonCurrentLoreItemOffset < KinkyDungeonCurrentLoreItems.length) {
            let loreNum = KinkyDungeonCurrentLoreItems[i + KinkyDungeonCurrentLoreItemOffset];
            if (MouseIn(1450 + 100 * xx, 142 + (ii) * 42, 90, 40)) {
                KinkyDungeonCurrentLore = loreNum;
            }
        }
        else {
            break;
        }
    }
    return true;
}
const KDANGER = -19;
const KDRAGE = -31;
const KDPLEASED = 15;
const KDFRIENDLY = 35;
let KDFactionGoddess = {
    "Metal": {
        "Angel": 0.002,
        "Demon": -0.001,
        "Nevermere": -0.001,
        "AncientRobot": 0.007,
        "Elemental": 0.001,
    },
    "Rope": {
        "Angel": 0.002,
        "Demon": -0.001,
        "KinkyConstruct": 0.005,
        "Dressmaker": 0.005,
        "Bountyhunter": 0.002,
        "Bast": 0.0025,
        "AncientRobot": 0.001,
    },
    "Elements": {
        "Angel": 0.007,
        "Demon": -0.001,
        "Witch": 0.003,
        "Apprentice": 0.0015,
        "Elemental": 0.01,
        "AncientRobot": -0.001,
    },
    "Leather": {
        "Angel": 0.002,
        "Demon": -0.001,
        "Elf": 0.001,
        "Dragon": 0.005,
        "Bandit": 0.01,
        "Elemental": 0.002,
        "AncientRobot": 0.001,
    },
    "Latex": {
        "Angel": 0.002,
        "Demon": -0.001,
        "Maidforce": 0.0015,
        "Alchemist": 0.01,
        "Nevermere": 0.003,
        "AncientRobot": 0.001,
    },
    "Will": {
        "Angel": 0.007,
        "Demon": -0.005,
        "Elf": 0.005,
        "Bast": 0.005,
        "Apprentice": 0.001,
        "AncientRobot": -0.001,
    },
    "Conjure": {
        "Angel": 0.007,
        "Demon": -0.001,
        "Alchemist": 0.002,
        "Witch": 0.003,
        "Apprentice": 0.0015,
        "Dressmaker": 0.005,
        "AncientRobot": -0.001,
    },
    "Illusion": {
        "Angel": 0.007,
        "Demon": -0.001,
        "Witch": 0.003,
        "Apprentice": 0.0015,
        "Maidforce": 0.007,
        "Bountyhunter": 0.002,
        "AncientRobot": -0.001,
    },
};
let KinkyDungeonGoddessRep = {};
let KinkyDungeonRescued = {};
let KinkyDungeonAid = {};
let KDRepSelectionMode = "";
let KDBlessedRewards = {
    "Latex": ["TheEncaser"],
    "Rope": ["MoiraiScissors"],
    "Metal": ["BondageBuster"],
    "Leather": ["Dragonslaver"],
    "Will": ["MessengerOfLove"],
    "Elements": ["FourSeasons",],
    "Conjure": ["Arbiter"],
    "Illusion": ["Dreamcatcher"],
};
function KDPearlRequirement() {
    let has = false;
    for (let rep of Object.entries(KinkyDungeonGoddessRep)) {
        let rewards = KDBlessedRewards[rep[0]];
        if (rewards) {
            let missing = true;
            for (let r of rewards) {
                if (KinkyDungeonInventoryGet(r)) {
                    missing = false;
                    break;
                }
            }
            if (missing && rep[1] > 45) {
                has = true;
                break;
            }
        }
    }
    return has;
}
function KinkyDungeonInitReputation() {
    KinkyDungeonGoddessRep = { "Ghost": -50, "Prisoner": -50 };
    for (let shrine in KinkyDungeonShrineBaseCosts) {
        KinkyDungeonGoddessRep[shrine] = KinkyDungeonStatsChoice.get("Cursed") ? -50 : 0;
    }
    if (KinkyDungeonStatsChoice.get("Wanted"))
        KinkyDungeonChangeRep("Prisoner", 100);
    if (KinkyDungeonStatsChoice.get("Submissive"))
        KinkyDungeonChangeRep("Ghost", 100);
    if (KinkyDungeonStatsChoice.get("Unchained"))
        KinkyDungeonChangeRep("Metal", 10);
    if (KinkyDungeonStatsChoice.get("Artist"))
        KinkyDungeonChangeRep("Rope", 10);
    if (KinkyDungeonStatsChoice.get("Slippery"))
        KinkyDungeonChangeRep("Latex", 10);
    if (KinkyDungeonStatsChoice.get("Escapee"))
        KinkyDungeonChangeRep("Leather", 10);
    if (KinkyDungeonStatsChoice.get("Damsel"))
        KinkyDungeonChangeRep("Metal", -10);
    if (KinkyDungeonStatsChoice.get("Bunny"))
        KinkyDungeonChangeRep("Rope", -10);
    if (KinkyDungeonStatsChoice.get("Doll"))
        KinkyDungeonChangeRep("Latex", -10);
    if (KinkyDungeonStatsChoice.get("Dragon"))
        KinkyDungeonChangeRep("Leather", -10);
}
function KinkyDungeonRepName(Amount) {
    let name = "";
    if (Amount >= 10)
        name = "Thankful";
    if (Amount >= 30)
        name = "Pleased";
    if (Amount >= 45)
        name = "Blessed";
    if (Amount < KDANGER)
        name = "Angered";
    if (Amount < KDRAGE)
        name = "Enraged";
    if (Amount < -45)
        name = "Cursed";
    return TextGet("KinkyDungeonRepName" + name);
}
function KinkyDungeonRepNameFaction(Amount) {
    let name = "";
    if (Amount > 0.2)
        name = "Thankful";
    if (Amount >= 0.4)
        name = "Pleased";
    if (Amount > 0.7)
        name = "Blessed";
    if (Amount < -0.1)
        name = "Angered";
    if (Amount <= -0.5)
        name = "Enraged";
    if (Amount < -0.9)
        name = "Cursed";
    return TextGet("KinkyDungeonRepNameFaction" + name);
}
function KinkyDungeonChangeFactionRep(Rep, Amount) {
    let last = KDFactionRelation("Player", Rep);
    KDChangeFactionRelation("Player", Rep, Amount);
    let curr = KDFactionRelation("Player", Rep);
    if (curr != last) {
        let amount = 0.5 * Math.round((curr - last) * 1000) / 10;
        KinkyDungeonSendFloater({ x: 1100, y: 800 - KDRecentRepIndex * 40 }, `${amount > 0 ? '+' : ''}${amount}% ${TextGet("KinkyDungeonFaction" + Rep)} rep`, "white", 5, true);
        KDRecentRepIndex += 1;
    }
    return false;
}
function KinkyDungeonChangeRep(Rep, Amount) {
    if (KinkyDungeonGoddessRep[Rep] != undefined) {
        let last = KinkyDungeonGoddessRep[Rep];
        let minimum = (Rep == "Ghost" && KinkyDungeonStatsChoice.get("Submissive")) || (Rep == "Prisoner" && KinkyDungeonStatsChoice.get("Wanted")) ? 20 : -50;
        let maximum = (KinkyDungeonStatsChoice.get("Cursed") && (Rep != "Ghost" && Rep != "Prisoner")) ? -25 : 50;
        let start = KinkyDungeonGoddessRep[Rep];
        KinkyDungeonGoddessRep[Rep] += Amount;
        KinkyDungeonGoddessRep[Rep] = Math.min(maximum, Math.max(minimum, KinkyDungeonGoddessRep[Rep]));
        if (Math.abs(KinkyDungeonGoddessRep[Rep] - start) > 0.1) {
            let value = KinkyDungeonGoddessRep[Rep] - start;
            let amount = Math.round((value) * 10) / 10;
            KinkyDungeonSendFloater({ x: 1100, y: 800 - KDRecentRepIndex * 40 }, `${amount > 0 ? '+' : ''}${amount}% ${TextGet("KinkyDungeonShrine" + Rep)} rep`, "white", 5, true);
            KDRecentRepIndex += 1;
        }
        if (KDFactionGoddess[Rep]) {
            for (let f of Object.entries(KDFactionGoddess[Rep])) {
                let mult = (Amount > 0 ? 1 : 1);
                if (Amount > 0) {
                    if (KDFactionRelation("Player", f[0]) <= -0.25)
                        mult *= 0.5;
                    else if (KDFactionRelation("Player", f[0]) <= -0.1)
                        mult *= 0.75;
                    else if (KDFactionRelation("Player", f[0]) >= 0.55)
                        mult *= 0;
                    else if (KDFactionRelation("Player", f[0]) >= 0.35)
                        mult *= 0.25;
                    else if (KDFactionRelation("Player", f[0]) >= 0.25)
                        mult *= 0.5;
                    else if (KDFactionRelation("Player", f[0]) >= 0.1)
                        mult *= 0.75;
                }
                KDChangeFactionRelation("Player", f[0], f[1] * mult * Amount);
            }
        }
        if (KinkyDungeonGoddessRep[Rep] != last)
            return true;
        return false;
    }
    return false;
}
function KinkyDungeonHandleReputation() {
    let i = 0;
    let maxY = 560;
    let XX = 0;
    let spacing = 60;
    let yPad = 50;
    if (KDFactionRepIndex < 0.1)
        for (let rep in KinkyDungeonGoddessRep) {
            let value = KinkyDungeonGoddessRep[rep];
            if (rep) {
                if (spacing * i > maxY) {
                    if (XX == 0)
                        i = 0;
                    XX = 600;
                }
                if (KinkyDungeonShrineBaseCosts[rep]) {
                    if (KDRepSelectionMode == "" && KinkyDungeonAllRestraint().length > 0 && MouseIn(600, 800, 250, 50)) {
                        KDRepSelectionMode = "Rescue";
                        return true;
                    }
                    else if (KDRepSelectionMode == "" && MouseIn(900, 800, 250, 50)) {
                        KDRepSelectionMode = "Champion";
                        return true;
                    }
                    if (KDRepSelectionMode == "Aid" && MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40) && KinkyDungeonCanAidMana(rep, value)) {
                        KDSendInput("aid", { rep: rep, value: value });
                        KinkyDungeonDrawState = "Game";
                        KDRepSelectionMode = "";
                    }
                    else if (KDRepSelectionMode == "Rescue" && MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40) && KinkyDungeonCanRescue(rep, value)) {
                        if (KDSendInput("rescue", { rep: rep, value: value }) != "FailRescue") {
                            KinkyDungeonDrawState = "Game";
                            KDRepSelectionMode = "";
                        }
                        return true;
                    }
                    else if (KDRepSelectionMode == "Penance" && MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40) && KinkyDungeonCanPenance(rep, value)) {
                        KDSendInput("penance", { rep: rep, value: value });
                        KDRepSelectionMode = "";
                        KinkyDungeonDrawState = "Game";
                        return true;
                    }
                    else if (KDRepSelectionMode == "Champion" && MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40)) {
                        KDSendInput("champion", { rep: rep, value: value });
                        return true;
                    }
                }
                i++;
            }
        }
    KDRepSelectionMode = "";
    return true;
}
function KinkyDungeonDrawReputation() {
    KinkyDungeonDrawMessages(true);
    let i = 0;
    let XX = 0;
    let spacing = 600 / Object.keys(KinkyDungeonGoddessRep).length;
    let yPad = 50;
    let tooltip = "";
    if (!KDRepSelectionMode) {
        tooltip = KinkyDungeonDrawFactionRep();
    }
    for (let rep in KinkyDungeonGoddessRep) {
        let value = KinkyDungeonGoddessRep[rep];
        if (rep) {
            let color = "#ffff00";
            let goddessColor = "white";
            let goddessSuff = "";
            if (value < -10) {
                if (value < -30)
                    color = "#ff0000";
                else
                    color = "#ff8800";
            }
            else if (value >= 10) {
                if (value >= 30)
                    color = "#00ff00";
                else
                    color = "#88ff00";
            }
            if (tooltip) {
                goddessColor = "#888888";
                if (KDFactionGoddess[rep] && KDFactionGoddess[rep][tooltip] != 0) {
                    goddessColor = KDFactionGoddess[rep][tooltip] > 0 ? "#ffffff" : (KDFactionGoddess[rep][tooltip] < 0 ? "#ff5555" : "#999999");
                    if (KDFactionGoddess[rep][tooltip] >= 0.006)
                        goddessSuff = "+++";
                    else if (KDFactionGoddess[rep][tooltip] >= 0.003)
                        goddessSuff = "++";
                    else if (KDFactionGoddess[rep][tooltip] >= 0.00001)
                        goddessSuff = "+";
                    else if (KDFactionGoddess[rep][tooltip] <= -0.00001)
                        goddessSuff = "-";
                    else if (KDFactionGoddess[rep][tooltip] <= 0.004)
                        goddessSuff = "--";
                    else if (KDFactionGoddess[rep][tooltip] <= 0.006)
                        goddessSuff = "---";
                }
            }
            let suff = "";
            if (rep != "Ghost" && rep != "Prisoner")
                suff = "" + KinkyDungeonRepName(value);
            DrawTextKD(TextGet("KinkyDungeonShrine" + rep) + goddessSuff, canvasOffsetX_ui + XX, yPad + canvasOffsetY_ui + spacing * i, goddessColor, "black", undefined, "left");
            if (suff) {
                DrawTextFitKD(suff, canvasOffsetX_ui + 275 + XX + 250, yPad + canvasOffsetY_ui + spacing * i, 100, "white", "black", undefined, "left");
            }
            DrawProgressBar(canvasOffsetX_ui + 275 + XX, yPad + canvasOffsetY_ui + spacing * i - spacing / 4, 200, spacing / 2, 50 + value, color, KDTextGray2);
            if (KinkyDungeonShrineBaseCosts[rep])
                KDDrawRestraintBonus(rep, canvasOffsetX_ui + 275 + XX - 70, yPad + canvasOffsetY_ui + spacing * i, undefined, 24);
            DrawTextKD(" " + (Math.round(value) + 50) + " ", canvasOffsetX_ui + 275 + XX + 100, 2 + yPad + canvasOffsetY_ui + spacing * i, "white", "black");
            if (KDFactionRepIndex < 0.1) {
                if (KDRepSelectionMode == "") {
                    DrawButtonVis(600, 800, 250, 50, TextGet("KinkyDungeonAskRescue"), KinkyDungeonAllRestraint().length > 0 ? "white" : "#999999");
                    DrawButtonVis(900, 800, 250, 50, TextGet("KinkyDungeonAskChampion"), "white");
                }
                else {
                    DrawButtonVis(900, 800, 250, 50, TextGet("KinkyDungeonBack"), "white");
                }
                if (KinkyDungeonShrineBaseCosts[rep]) {
                    if (KDRepSelectionMode == "Rescue") {
                        DrawButtonVis(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40, TextGet("KinkyDungeonRescue"), (KinkyDungeonCanRescue(rep, value)) ? "white" : (KinkyDungeonAllRestraint().length > 0 && !KinkyDungeonRescued[rep] ? "pink" : "#999999"));
                        if (MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40)) {
                            DrawTextFitKD(TextGet("KinkyDungeonRescueDesc"), 1100, 900, 1250, "white", "black");
                        }
                    }
                    if (KDRepSelectionMode == "Penance") {
                        DrawButtonVis(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40, TextGet("KinkyDungeonPenance"), (KinkyDungeonCanPenance(rep, value)) ? "white" : (KDGameData.KinkyDungeonPenance ? "purple" : "#999999"));
                        if (MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40)) {
                            DrawTextFitKD(TextGet("KinkyDungeonPenanceDesc").replace("AMOUNT", "" + KinkyDungeonPenanceCost(rep)), 1100, 900, 1250, "white", "black");
                        }
                    }
                    if (KDRepSelectionMode == "Aid") {
                        DrawButtonVis(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40, TextGet("KinkyDungeonAidMana"), (KinkyDungeonCanAidMana(rep, value)) ? "white" : "#999999");
                        if (MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40)) {
                            DrawTextFitKD(TextGet("KinkyDungeonAidManaDesc").replace("AMOUNT", "" + (KinkyDungeonAidManaCost(rep, value))).replace("MANALEVEL", "" + (KinkyDungeonAidManaAmount(rep, value) * 10)), 1100, 900, 1250, "white", "black");
                        }
                    }
                    if (KDRepSelectionMode == "Champion") {
                        let isChampion = KDGameData.Champion == rep;
                        DrawButtonVis(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40, TextGet(isChampion ? "KinkyDungeonChampionCurrent" : "KinkyDungeonChampionSwitch"), (isChampion) ? "white" : "#999999");
                        if (MouseIn(canvasOffsetX_ui + 275 + XX + 520, yPad + canvasOffsetY_ui + spacing * i - 20, 150, 40)) {
                            DrawTextFitKD(TextGet("KinkyDungeonChampionDesc"), 1100, 900, 1250, "white", "black");
                        }
                    }
                }
            }
            else
                KDRepSelectionMode = "";
            i++;
        }
    }
}
let KDFactionRepIndex = 0;
let KDMaxFactionsPerBar = 14;
function KinkyDungeonDrawFactionRep() {
    let i = 0;
    let XX = 675;
    let spacing = 42;
    let yPad = 45;
    let barSpacing = 375;
    let tooltip = "";
    let index = 0;
    for (let e of Object.keys(KinkyDungeonFactionRelations.Player)) {
        let rep = e;
        if (rep && !KinkyDungeonHiddenFactions.includes(rep)) {
            index++;
            if (index < KDFactionRepIndex * KDMaxFactionsPerBar + 1)
                continue;
            if (index > KDFactionRepIndex * KDMaxFactionsPerBar + KDMaxFactionsPerBar)
                continue;
            if (!tooltip && MouseIn(canvasOffsetX_ui + XX, yPad + canvasOffsetY_ui + spacing * i - spacing / 2, barSpacing + 200, yPad)) {
                tooltip = rep;
            }
            i++;
        }
    }
    i = 0;
    index = 0;
    DrawButtonKDEx("FactionIndexUp", () => {
        KDFactionRepIndex -= 0.5;
        return true;
    }, KDFactionRepIndex > 0, 1802, 140, 90, 40, "", KDFactionRepIndex > 0 ? "white" : "#888888", KinkyDungeonRootDirectory + "Up.png");
    DrawButtonKDEx("FactionIndexDown", () => {
        KDFactionRepIndex += 0.5;
        return true;
    }, KDFactionRepIndex < (Object.keys(KinkyDungeonFactionRelations.Player).length - KinkyDungeonHiddenFactions.length) / KDMaxFactionsPerBar, 1802, 790, 90, 40, "", KDFactionRepIndex < (Object.keys(KinkyDungeonFactionRelations.Player).length - KinkyDungeonHiddenFactions.length) / KDMaxFactionsPerBar ? "white" : "#888888", KinkyDungeonRootDirectory + "Down.png");
    let text = false;
    for (let e of Object.keys(KinkyDungeonFactionRelations.Player)) {
        let rep = e;
        if (rep && !KinkyDungeonHiddenFactions.includes(rep)) {
            index++;
            if (index < KDFactionRepIndex * KDMaxFactionsPerBar + 1)
                continue;
            if (index > KDFactionRepIndex * KDMaxFactionsPerBar + KDMaxFactionsPerBar)
                continue;
            let value = KinkyDungeonFactionRelations.Player[rep];
            let color = "#ffff00";
            if (value <= -0.1) {
                if (value <= -0.5)
                    color = "#ff0000";
                else
                    color = "#ff8800";
            }
            else if (value >= 0.1) {
                if (value >= 0.5)
                    color = "#00ff00";
                else
                    color = "#88ff00";
            }
            let suff = KinkyDungeonRepNameFaction(value);
            let tcolor = "white";
            switch (rep) {
                case "Bountyhunter":
                    tcolor = "#448844";
                    break;
                case "Bandit":
                    tcolor = "orange";
                    break;
                case "Alchemist":
                    tcolor = "lightgreen";
                    break;
                case "Nevermere":
                    tcolor = "teal";
                    break;
                case "Apprentice":
                    tcolor = "lightblue";
                    break;
                case "Dressmaker":
                    tcolor = "#ceaaed";
                    break;
                case "Witch":
                    tcolor = "purple";
                    break;
                case 'Elemental':
                    tcolor = "#f1641f";
                    break;
                case 'Dragon':
                    tcolor = "#b9451d";
                    break;
                case 'Maidforce':
                    tcolor = "white";
                    break;
                case "Bast":
                    tcolor = "#ff0000";
                    break;
                case "Elf":
                    tcolor = "#42a459";
                    break;
                case 'AncientRobot':
                    tcolor = "grey";
                    break;
            }
            if (MouseIn(canvasOffsetX_ui + XX, yPad + canvasOffsetY_ui + spacing * i - spacing / 2, barSpacing + 200, yPad)) {
                let allytext = "";
                let enemytext = "";
                let friendstext = "";
                for (let ee of Object.keys(KinkyDungeonFactionRelations.Player)) {
                    if (!KinkyDungeonHiddenFactions.includes(ee)) {
                        if (rep != ee && KDFactionRelation(rep, ee) >= 0.5) {
                            if (allytext)
                                allytext += ", ";
                            allytext += TextGet("KinkyDungeonFaction" + ee);
                        }
                        if (rep != ee && KDFactionRelation(rep, ee) > 0.15 && KDFactionRelation(rep, ee) < 0.5) {
                            if (friendstext)
                                friendstext += ", ";
                            friendstext += TextGet("KinkyDungeonFaction" + ee);
                        }
                        if (rep != ee && KDFactionRelation(rep, ee) <= -0.5) {
                            if (enemytext)
                                enemytext += ", ";
                            enemytext += TextGet("KinkyDungeonFaction" + ee);
                        }
                    }
                }
                let loc = { x: 1175, y: 812, fit: 600 };
                if (KDFactionRepIndex > 0.1) {
                    loc = { x: canvasOffsetX_ui, y: 820, fit: 1400 };
                }
                if (!text) {
                    if (enemytext) {
                        text = true;
                        DrawTextFitKD(TextGet("KDFriendsWith") + friendstext, loc.x, loc.y, loc.fit, "white", KDTextGray1, 20);
                    }
                    if (allytext) {
                        text = true;
                        DrawTextFitKD(TextGet("KDAlliedWith") + allytext, loc.x, loc.y + 30, loc.fit, "white", KDTextGray1, 20);
                    }
                    if (enemytext) {
                        text = true;
                        DrawTextFitKD(TextGet("KDHostileWith") + enemytext, loc.x, loc.y + 60, loc.fit, "white", KDTextGray1, 20);
                    }
                }
            }
            if (tooltip && tooltip != rep) {
                tcolor = "gray";
                if (KDFactionRelation(rep, tooltip) <= -0.5)
                    tcolor = "#ff0000";
                else if (KDFactionRelation(rep, tooltip) <= -0.25)
                    tcolor = "orange";
                else if (KDFactionRelation(rep, tooltip) <= -0.1)
                    tcolor = "yellow";
                else if (KDFactionRelation(rep, tooltip) >= 0.5)
                    tcolor = "cyan";
                else if (KDFactionRelation(rep, tooltip) >= 0.25)
                    tcolor = "#569eb8";
                else if (KDFactionRelation(rep, tooltip) >= 0.1)
                    tcolor = "#597085";
            }
            else if (tooltip == rep) {
                tcolor = "white";
            }
            DrawTextKD(TextGet("KinkyDungeonFaction" + rep), canvasOffsetX_ui + XX, yPad + canvasOffsetY_ui + spacing * i, tcolor, KDTextGray1, undefined, "left");
            if (suff) {
                DrawTextFitKD(suff, canvasOffsetX_ui + barSpacing + XX + 250, yPad + canvasOffsetY_ui + spacing * i, 100, "white", "black", undefined, "left");
            }
            DrawProgressBar(canvasOffsetX_ui + barSpacing + XX, yPad + canvasOffsetY_ui + spacing * i - spacing / 4, 200, spacing / 2, 50 + value * 50, color, KDTextGray2);
            DrawTextKD(" " + (Math.round(value * 50) + 50) + " ", canvasOffsetX_ui + barSpacing + XX + 100, 1 + yPad + canvasOffsetY_ui + spacing * i, "white", "black");
            i++;
            if (i > KDMaxFactionsPerBar + 1) {
                break;
            }
        }
    }
    return tooltip;
}
let KinkyDungeonPenanceCosts = {};
let KinkyDungeonPenanceRepBonus = 5;
let KinkyDungeonPenanceRepBonusFail = 1;
let KinkyDungeonPenanceCostGrowth = 50;
let KinkyDungeonPenanceCostDefault = 200;
function KinkyDungeonPenanceCost(rep) {
    if (KinkyDungeonGoddessRep[rep]) {
        if (KinkyDungeonPenanceCosts[rep]) {
            return KinkyDungeonPenanceCosts[rep];
        }
    }
    return KinkyDungeonPenanceCostDefault;
}
function KinkyDungeonCanPenance(rep, value) {
    return value < 40 && !KDGameData.KinkyDungeonPenance && KinkyDungeonBullets.length < 1;
}
function KinkyDungeonAidManaCost(rep, value) {
    let percent = (value + 50) / 100;
    return Math.ceil((1 - KinkyDungeonStatMana / KinkyDungeonStatManaMax) * 15 * Math.max(0.3, Math.min(1, 1.3 - percent)));
}
function KinkyDungeonAidManaAmount(rep, value) {
    return KinkyDungeonStatManaMax - KinkyDungeonStatMana;
}
function KinkyDungeonCanAidMana(rep, value) {
    return value > -30 && KinkyDungeonStatMana < KinkyDungeonStatManaMax;
}
function KinkyDungeonRescueTiles() {
    let tiles = [];
    for (let X = KinkyDungeonPlayerEntity.x - 1; X <= KinkyDungeonPlayerEntity.x + 1; X++)
        for (let Y = KinkyDungeonPlayerEntity.y - 1; Y <= KinkyDungeonPlayerEntity.y + 1; Y++) {
            if (X != 0 || Y != 0) {
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y)) && KinkyDungeonNoEnemy(X, Y, true)) {
                    tiles.push({ x: X, y: Y });
                }
            }
        }
    return tiles;
}
function KinkyDungeonCanRescue(rep, value) {
    return KinkyDungeonAllRestraint().length > 0 && value > KDRAGE && !KinkyDungeonRescued[rep] && KinkyDungeonRescueTiles().length > 0;
}
function KinkyDungeonUpdateAngel(delta) {
    if (KinkyDungeonFlags.get("AngelHelp") > 0 && KinkyDungeonFlags.get("AngelHelp") < 5) {
        for (let t of Object.entries(KinkyDungeonTiles)) {
            if (t[1].Type == "Angel") {
                let x = parseInt(t[0].split(',')[0]);
                let y = parseInt(t[0].split(',')[1]);
                if (x && y) {
                    if (t[0] == KinkyDungeonTargetTile) {
                        KinkyDungeonTargetTile = null;
                        KinkyDungeonTargetTileLocation = "";
                    }
                    KinkyDungeonTilesDelete(t[0]);
                    KinkyDungeonMapSet(x, y, '0');
                }
            }
        }
    }
    if (KDGameData.KinkyDungeonPenance) {
        if (!KinkyDungeonAngel()) {
            KinkyDungeonCreateAngel(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
        }
        if (KinkyDungeonAngel()) {
            KinkyDungeonAngel().gx = KinkyDungeonPlayerEntity.x;
            KinkyDungeonAngel().gy = KinkyDungeonPlayerEntity.y;
            if (KDGameData.KDPenanceMode == "") {
                KinkyDungeonBullets = [];
                if (KDGameData.KDPenanceStage == 0) {
                    let divineRestraints = [];
                    for (let inv of KinkyDungeonAllRestraint()) {
                        if (KDRestraint(inv).divine) {
                            divineRestraints.push(inv);
                        }
                    }
                    if (divineRestraints.length > 0) {
                        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonAngelUnlock"), "yellow", 3);
                        for (let r of divineRestraints) {
                            KinkyDungeonRemoveRestraint(KDRestraint(r).Group, false, false, true, true);
                        }
                    }
                    else
                        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonAngelIntro"), "yellow", 2);
                }
                if (KDGameData.KDPenanceStage > 1 && (KDistChebyshev(KinkyDungeonAngel().x - KinkyDungeonPlayerEntity.x, KinkyDungeonAngel().y - KinkyDungeonPlayerEntity.y) < 1.5 || KDGameData.KDPenanceStage > 3)) {
                    if (KinkyDungeonGold >= KDGameData.KinkyDungeonPenanceCostCurrent) {
                        KDGameData.KDPenanceMode = "Success";
                        KDGameData.KDPenanceStage = -delta;
                    }
                    else {
                        KDGameData.KDPenanceMode = "Anger";
                        KDGameData.KDPenanceStage = -delta;
                    }
                }
                if (KDGameData.KDPenanceStage > 1) {
                    if (KDGameData.KDPenanceStage == 1)
                        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonAngelWarn"), "yellow", 2);
                }
                KDGameData.KDPenanceStage += delta;
            }
            else if (KDGameData.KDPenanceMode == "Success") {
                if (KDGameData.KDPenanceStage < 2)
                    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonAngel" + KDGameData.KDPenanceMode + KDGameData.KDPenanceStage), "yellow", 2);
                KDGameData.KDPenanceStage += delta;
                if (KinkyDungeonGold >= KDGameData.KinkyDungeonPenanceCostCurrent) {
                    if (KDGameData.KDPenanceStage >= 2) {
                        KinkyDungeonAddGold(-KDGameData.KinkyDungeonPenanceCostCurrent);
                        KinkyDungeonChangeRep(KDGameData.AngelCurrentRep, KinkyDungeonPenanceRepBonus);
                        KDGameData.KinkyDungeonPenance = false;
                    }
                }
                else {
                    KDGameData.KDPenanceMode = "Anger";
                    KDGameData.KDPenanceStage = 0;
                    KDGameData.KDPenanceStageEnd = 0;
                }
            }
            else if (KDGameData.KDPenanceMode == "Anger") {
                if (KDGameData.KDPenanceStage < 4)
                    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonAngel" + KDGameData.KDPenanceMode + ("" + (KDGameData.KDPenanceStage))), "yellow", 2);
                else {
                    KinkyDungeonAggro(KinkyDungeonAngel());
                }
                KDGameData.KDPenanceStage += delta;
            }
        }
    }
    if (!KDGameData.KinkyDungeonPenance || (KinkyDungeonAngel())) {
        if (KDGameData.KinkyDungeonAngel) {
            KDGameData.KDPenanceStageEnd += delta;
            if (!KinkyDungeonEntities.includes(KinkyDungeonAngel())) {
                KDGameData.KinkyDungeonAngel = 0;
            }
            else if (KDAllied(KinkyDungeonAngel()) && KinkyDungeonAngel() && (!KDGameData.KinkyDungeonPenance || KDHostile(KinkyDungeonAngel())) && (KDGameData.KDPenanceStageEnd > 10 && KDRandom() < 0.2)) {
                KDClearItems(KinkyDungeonAngel());
                KDSpliceIndex(KinkyDungeonEntities.indexOf(KinkyDungeonAngel()), 1);
                KDGameData.KinkyDungeonAngel = 0;
                KDGameData.KinkyDungeonPenance = false;
            }
        }
    }
}
function KinkyDungeonCreateAngel(x, y) {
    let point = KinkyDungeonGetNearbyPoint(x, y, true, undefined, true);
    if (point) {
        let Enemy = KinkyDungeonGetEnemyByName("Angel");
        let angel = { summoned: true, Enemy: Enemy, id: KinkyDungeonGetEnemyID(),
            x: point.x, y: point.y, gx: point.x, gy: point.y,
            hp: (Enemy && Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0 };
        KDGameData.KinkyDungeonAngel = angel.id;
        KDAddEntity(angel);
    }
}
let KinkyDungeonTrapMoved = false;
function KinkyDungeonHandleStepOffTraps(entity, x, y, moveX, moveY) {
    let flags = {
        AllowTraps: true,
    };
    let tile = KinkyDungeonTilesGet(x + "," + y);
    if (tile && tile.StepOffTrap && !KinkyDungeonFlags.has("nojailbreak")) {
        if (!tile.StepOffTiles || tile.StepOffTiles.includes(moveX + "," + moveY)) {
            KinkyDungeonSendEvent("beforeStepOffTrap", { x: x, y: y, tile: tile, flags: flags });
            let msg = "";
            let color = "#ff0000";
            let lifetime = tile.Lifetime ? tile.Lifetime : undefined;
            if (tile.StepOffTrap == "DoorLock" && KinkyDungeonNoEnemy(x, y)) {
                KinkyDungeonMapSet(x, y, 'D');
                let spawned = 0;
                let maxspawn = 1 + Math.round(Math.min(2 + KDRandom() * 2, KinkyDungeonDifficulty / 25) + Math.min(2 + KDRandom() * 2, 0.5 * MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint));
                if (tile.SpawnMult)
                    maxspawn *= tile.SpawnMult;
                let requireTags = ["doortrap"];
                let tags = ["doortrap"];
                KinkyDungeonAddTags(tags, MiniGameKinkyDungeonLevel);
                for (let i = 0; i < 30; i++) {
                    if (spawned < maxspawn) {
                        let Enemy = KinkyDungeonGetEnemy(tags, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', requireTags, true);
                        if (Enemy) {
                            KinkyDungeonSummonEnemy(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, Enemy.name, 1, 7, true, Enemy.tags.construct ? 23 : undefined, undefined, true, "Ambush", true, 1.5, true, undefined, true);
                            if (Enemy.tags.minor)
                                spawned += 0.4;
                            else
                                spawned += 1;
                        }
                    }
                }
                if (spawned > 0) {
                    KinkyDungeonMapSet(x, y, 'd');
                    let created = KinkyDungeonSummonEnemy(x, y, "DoorLock", 1, 0, false, lifetime);
                    if (created > 0) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/MagicSlash.ogg");
                        msg = "Default";
                        KinkyDungeonMakeNoise(12, x, y);
                        KinkyDungeonTilesDelete(x + "," + y);
                        KinkyDungeonMapSet(x, y, 'D');
                    }
                }
                else
                    KinkyDungeonMapSet(x, y, 'd');
            }
            if (msg) {
                KDTrigPanic();
                if (msg == "Default")
                    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonTrap" + tile.StepOffTrap), color, 2);
                else
                    KinkyDungeonSendTextMessage(10, msg, color, 2);
            }
        }
    }
}
function KinkyDungeonHandleTraps(entity, x, y, Moved) {
    let flags = {
        AllowTraps: true,
    };
    let tile = KinkyDungeonTilesGet(x + "," + y);
    if (tile && tile.Type == "Trap" && !KinkyDungeonFlags.has("nojailbreak")) {
        KinkyDungeonSendEvent("beforeTrap", { x: x, y: y, tile: tile, flags: flags });
        if (flags.AllowTraps && Moved) {
            let msg = "";
            let triggered = false;
            let color = "#ff0000";
            if (KinkyDungeonStatsChoice.has("Rusted") && KDRandom() < 0.25) {
                msg = TextGet("KDTrapMisfire");
            }
            else {
                if (tile.Trap === "SpawnEnemies") {
                    let radius = tile.Power > 4 ? 4 : 2;
                    let created = KinkyDungeonSummonEnemy(x, y, tile.Enemy, tile.Power, radius, true, undefined, undefined, true, "Ambush", true, 1.5, true);
                    if (created > 0) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                        msg = TextGet("KinkyDungeonTrapSpawn" + tile.Enemy);
                        KinkyDungeonTilesDelete(x + "," + y);
                        triggered = true;
                    }
                }
                if (tile.Trap == "SpecificSpell") {
                    let spell = KinkyDungeonFindSpell(tile.Spell, true);
                    if (spell) {
                        let xx = 0;
                        let yy = 0;
                        if (!tile.noVary) {
                            for (let i = 0; i < 10; i++) {
                                xx = Math.floor(KDRandom() * 3 - 1);
                                yy = Math.floor(KDRandom() * 3 - 1);
                                if (xx != 0 || yy != 0)
                                    i = 1000;
                            }
                        }
                        KinkyDungeonCastSpell(x + xx, y + yy, spell, undefined, undefined, undefined, "Trap");
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                        msg = "";
                        triggered = true;
                        KinkyDungeonTilesDelete(x + "," + y);
                        let etiles = Object.values(KDGetEffectTiles(x, y)).filter((etile) => {
                            return etile.tags && etile.tags.includes("runetrap");
                        });
                        if ((etiles === null || etiles === void 0 ? void 0 : etiles.length) > 0) {
                            for (let et of etiles) {
                                et.duration = 0;
                            }
                        }
                    }
                }
                if (tile.Trap == "BarrelTrap") {
                    if (entity.player)
                        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("BarrelTrap"), 0, true);
                    if (KDToggles.Sound)
                        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                    msg = TextGet("KDBarrelTrap");
                    triggered = true;
                    tile.Trap = undefined;
                    tile.Type = undefined;
                }
                if (tile.Trap == "CageTrap") {
                    if (entity.player)
                        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("CageTrap"), 0, true);
                    if (KDToggles.Sound)
                        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                    msg = TextGet("KDCageTrap");
                    triggered = true;
                    tile.Trap = undefined;
                    tile.Type = undefined;
                }
                if (tile.Trap == "BedTrap") {
                    if (entity.player)
                        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("BedTrap"), 0, true);
                    if (KDToggles.Sound)
                        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                    msg = TextGet("KDBedTrap");
                    triggered = true;
                    tile.Trap = undefined;
                    tile.Type = undefined;
                    KinkyDungeonMakeNoise(10, x, y);
                }
                if (tile.Trap === "CustomSleepDart") {
                    let spell = KinkyDungeonFindSpell("TrapSleepDart", true);
                    if (spell) {
                        let startX = x;
                        let startY = y;
                        let possible_coords = [
                            { x: -4, y: 0 }, { x: 4, y: 0 }, { x: 0, y: -4 }, { x: 0, y: 4 },
                            { x: -3, y: 0 }, { x: 3, y: 0 }, { x: 0, y: -3 }, { x: 0, y: 3 },
                            { x: -2, y: 0 }, { x: 2, y: 0 }, { x: 0, y: -2 }, { x: 0, y: 2 },
                        ];
                        let success = false;
                        for (let coord of possible_coords) {
                            if (KinkyDungeonCheckProjectileClearance(startX + coord.x, startY + coord.y, startX, startY)) {
                                startX += coord.x;
                                startY += coord.y;
                                success = true;
                                break;
                            }
                        }
                        if (success) {
                            triggered = true;
                            let player = KinkyDungeonEnemyAt(x, y) ? KinkyDungeonEnemyAt(x, y) : KinkyDungeonPlayerEntity;
                            KinkyDungeonCastSpell(x, y, spell, { x: startX, y: startY }, player, undefined);
                            if (KDToggles.Sound)
                                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                            msg = "";
                            KinkyDungeonTilesDelete(x + "," + y);
                        }
                        else {
                            triggered = true;
                            spell = KinkyDungeonFindSpell("SleepGas", true);
                            if (spell) {
                                KinkyDungeonCastSpell(x, y, spell, undefined, undefined, undefined);
                                if (KDToggles.Sound)
                                    AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                                msg = "KinkyDungeonSpellCast" + spell.name;
                                KinkyDungeonTilesDelete(x + "," + y);
                            }
                        }
                    }
                }
                if (tile.Trap === "CustomVine") {
                    let restraint = KinkyDungeonGetRestraintByName("VinePlantFeet");
                    if (restraint) {
                        KDSendStatus('bound', tile.Trap, "trap");
                        if (entity.player)
                            KinkyDungeonAddRestraintIfWeaker(restraint, tile.Power, false);
                    }
                    triggered = true;
                    let created = KinkyDungeonSummonEnemy(x, y, "VinePlant", tile.Power, 1);
                    if (created > 0) {
                        if (KDToggles.Sound)
                            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Trap.ogg");
                        msg = "Default";
                        KinkyDungeonTilesDelete(x + "," + y);
                    }
                }
            }
            if (entity.player && (msg || triggered)) {
                KDTrigPanic();
            }
            if (msg) {
                if (msg == "Default")
                    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonTrap" + tile.Trap + (tile.extraTag || "")), color, 2 + KinkyDungeonSlowMoveTurns);
                else
                    KinkyDungeonSendTextMessage(10, msg, color, 2 + KinkyDungeonSlowMoveTurns);
            }
        }
    }
    KinkyDungeonTrapMoved = false;
}
function KDTrigPanic() {
    if (KinkyDungeonStatsChoice.has("Panic")) {
        KinkyDungeonSendActionMessage(10, TextGet("KDPanic"), "#ff0000", 3);
        KinkyDungeonSlowMoveTurns = Math.max(KinkyDungeonSlowMoveTurns, 2);
    }
}
function KinkyDungeonGetGoddessTrapTypes() {
    let trapTypes = [];
    if (KinkyDungeonGoddessRep.Rope < KDANGER) {
        trapTypes.push({ Name: "SpecificSpell", Spell: "TrapRopeWeak", Level: 0, Power: 3, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Ninja", Level: 0, Power: 3, Weight: 10 });
    }
    if (KinkyDungeonGoddessRep.Rope < KDRAGE) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "RopeKraken", Level: 0, Power: 1, Weight: 10 });
        trapTypes.push({ Name: "SpecificSpell", Spell: "TrapRopeStrong", Level: 0, Power: 3, Weight: 40 });
    }
    if (KinkyDungeonGoddessRep.Leather < KDANGER) {
        trapTypes.push({ Name: "SpecificSpell", Spell: "TrapLeatherWeak", Level: 0, Power: 3, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Dragon", Level: 0, Power: 3, Weight: 10 });
    }
    if (KinkyDungeonGoddessRep.Leather < KDRAGE) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "DragonLeader", Level: 0, Power: 2, Weight: 50 });
    }
    if (KinkyDungeonGoddessRep.Metal < KDANGER) {
        trapTypes.push({ Name: "SpecificSpell", Spell: "TrapCableWeak", Level: 0, Power: 3, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Drone", Level: 0, Power: 3, Weight: 10 });
    }
    if (KinkyDungeonGoddessRep.Metal < KDRAGE) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Wolfgirl", Level: 0, Power: 3, Weight: 50 });
    }
    if (KinkyDungeonGoddessRep.Latex < KDANGER) {
        trapTypes.push({ Name: "SpecificSpell", Spell: "TrapSlimeWeak", Level: 0, Power: 3, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Alkahestor", Level: 0, Power: 1, Weight: 5 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "SmallSlime", Level: 0, Power: 6, Weight: 10 });
    }
    if (KinkyDungeonGoddessRep.Latex < KDRAGE) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "SlimeEnthusiast", Level: 0, Power: 2, Weight: 20 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "BigSlime", Level: 0, Power: 3, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalLatex", Level: 0, Power: 2, Weight: 20 });
    }
    if (KinkyDungeonGoddessRep.Elements < KDANGER) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalFire", Level: 0, Power: 2, Weight: 5 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalIce", Level: 0, Power: 2, Weight: 5 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalWater", Level: 0, Power: 2, Weight: 5 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalEarth", Level: 0, Power: 2, Weight: 5 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalAir", Level: 0, Power: 2, Weight: 5 });
    }
    if (KinkyDungeonGoddessRep.Elements < KDRAGE) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalFire", Level: 0, Power: 4, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalIce", Level: 0, Power: 4, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalWater", Level: 0, Power: 4, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalEarth", Level: 0, Power: 4, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ElementalAir", Level: 0, Power: 4, Weight: 10 });
    }
    if (KinkyDungeonGoddessRep.Conjure < KDANGER) {
        trapTypes.push({ Name: "SpecificSpell", Spell: "TrapMagicChainsWeak", Level: 0, Power: 3, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "TickleHand", Level: 0, Power: 6, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Dressmaker", Level: 0, Power: 2, Weight: 5 });
    }
    if (KinkyDungeonGoddessRep.Conjure < KDRAGE) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Conjurer", Level: 0, Power: 1, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Dressmaker", Level: 0, Power: 2, Weight: 25 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "ConjurerTickler", Level: 0, Power: 1, Weight: 25 });
    }
    if (KinkyDungeonGoddessRep.Illusion < KDANGER) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Maidforce", Level: 0, Power: 3, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "MaidforcePara", Level: 0, Power: 2, Weight: 10 });
        trapTypes.push({ Name: "SpecificSpell", Spell: "TrapRopeHoly", Level: 2, Power: 3, Weight: 30 });
    }
    if (KinkyDungeonGoddessRep.Illusion < KDRAGE) {
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "Maidforce", Level: 0, Power: 4, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "MaidforcePara", Level: 0, Power: 3, Weight: 15 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "MaidforceMafia", Level: 0, Power: 3, Weight: 10 });
        trapTypes.push({ Name: "SpawnEnemies", strict: true, Enemy: "MaidforceHead", Level: 0, Power: 1, Weight: 10 });
    }
    return trapTypes;
}
function KinkyDungeonGetTrap(trapTypes, Level, tags) {
    let trapWeightTotal = 0;
    let trapWeights = [];
    for (let trap of trapTypes) {
        let effLevel = Level;
        let weightMulti = 1.0;
        let weightBonus = 0;
        if (effLevel >= trap.Level) {
            trapWeights.push({ trap: trap, weight: trapWeightTotal });
            let weight = trap.Weight + weightBonus;
            if (trap.terrainTags)
                for (let tag of tags)
                    if (trap.terrainTags[tag])
                        weight += trap.terrainTags[tag];
            trapWeightTotal += Math.max(0, weight * weightMulti);
        }
    }
    let selection = KDRandom() * trapWeightTotal;
    for (let L = trapWeights.length - 1; L >= 0; L--) {
        if (selection > trapWeights[L].weight) {
            return {
                Name: trapWeights[L].trap.Name,
                Restraint: trapWeights[L].trap.Restraint,
                Enemy: trapWeights[L].trap.Enemy,
                Spell: trapWeights[L].trap.Spell,
                Power: trapWeights[L].trap.Power,
                extraTag: trapWeights[L].trap.extraTag,
            };
        }
    }
}
function KDSmokePuff(x, y, radius, density, nomsg) {
    if (!nomsg)
        KinkyDungeonSendTextMessage(2, TextGet("KDSmokePuff"), "white", 2);
    for (let X = x - Math.floor(radius); X <= x + Math.floor(radius); X++)
        for (let Y = y - Math.floor(radius); Y <= y + Math.floor(radius); Y++) {
            if ((!density || KDRandom() < density || (X == x && Y == Y)) && KDistEuclidean(X - x, Y - y) <= radius) {
                let spell = KinkyDungeonFindSpell("SmokePuff", true);
                if (spell) {
                    KinkyDungeonCastSpell(X, Y, spell, undefined, undefined, undefined);
                }
            }
        }
}
function KDSteamPuff(x, y, radius, density, nomsg) {
    if (!nomsg)
        KinkyDungeonSendTextMessage(2, TextGet("KDSteamPuff"), "white", 2);
    for (let X = x - Math.floor(radius); X <= x + Math.floor(radius); X++)
        for (let Y = y - Math.floor(radius); Y <= y + Math.floor(radius); Y++) {
            if ((!density || KDRandom() < density || (X == x && Y == Y)) && KDistEuclidean(X - x, Y - y) <= radius) {
                let spell = KinkyDungeonFindSpell("SteamPuff", true);
                if (spell) {
                    KinkyDungeonCastSpell(X, Y, spell, undefined, undefined, undefined);
                }
            }
        }
}
function KDWettable(entity) {
    return entity.player || (!entity.Enemy.tags.acidimmune && !entity.Enemy.tags.acidresist && !entity.Enemy.tags.fire && !entity.Enemy.tags.nowet);
}
function KDConducting(entity) {
    return entity.player || (!entity.Enemy.tags.electricimmune && !entity.Enemy.tags.electricresist && !entity.Enemy.tags.electric && !entity.Enemy.tags.noconduct);
}
function KinkyDungeonHandleTilesEnemy(enemy, delta) {
    let tile = KinkyDungeonMapGet(enemy.x, enemy.y);
    if (tile == 'w') {
    }
}
function KDPeripheralTileEffects(delta) {
    let tileUp = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y - 1);
    let tileL = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x - 1, KinkyDungeonPlayerEntity.y);
    let tileR = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x + 1, KinkyDungeonPlayerEntity.y);
    let tileD = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y + 1);
    if (tileUp == ",") {
        KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonHookLow"), "lightgreen", 1, true);
    }
    else if (tileUp == "4" || tileL == '4' || tileR == '4' || tileD == '4') {
        KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonCrack"), "lightgreen", 1, true);
    }
}
function KinkyDungeonUpdateTileEffects(delta) {
    let tile = KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
    if (KDTileUpdateFunctions[tile] && KDTileUpdateFunctions[tile](delta)) {
    }
    else {
        KDPeripheralTileEffects(delta);
    }
    for (let X = 1; X < KinkyDungeonGridWidth - 1; X++) {
        for (let Y = 1; Y < KinkyDungeonGridHeight - 1; Y++) {
            let tt = KinkyDungeonMapGet(X, Y);
            if (KDTileUpdateFunctionsLocal[tt])
                KDTileUpdateFunctionsLocal[tt](delta, X, Y);
        }
    }
}
let KinkyDungeonChestConfirm = false;
function KinkyDungeonHandleMoveToTile(toTile) {
    if (toTile == 's' || toTile == 'H') {
        if (KinkyDungeonConfirmStairs && KinkyDungeonLastAction == "Wait") {
            KinkyDungeonConfirmStairs = false;
            KinkyDungeonHandleStairs(toTile);
        }
        else if (!(KDGameData.SleepTurns > 0)) {
            if (KinkyDungeonLastAction == "Move" || KinkyDungeonLastAction == "Wait")
                KinkyDungeonConfirmStairs = true;
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonConfirmStairs"), "white", 1, true);
        }
    }
}
function KDCanEscape() {
    return KDGameData.JailKey || KinkyDungeonFlags.has("BossUnlocked");
}
function KDEffectTileTags(x, y) {
    let ret = {};
    let tiles = KDGetEffectTiles(x, y);
    if (tiles) {
        for (let t of Object.values(tiles)) {
            if (t.tags) {
                for (let tag of t.tags) {
                    ret[tag] = true;
                }
            }
        }
    }
    return ret;
}
function KinkyDungeonHandleStairs(toTile, suppressCheckPoint) {
    var _a;
    if (!KDCanEscape()) {
        KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonNeedJailKey"), "#ffffff", 1);
    }
    else {
        if (!KinkyDungeonJailGuard() || !KinkyDungeonTetherLength() || (!(KDistEuclidean(KinkyDungeonJailGuard().x - KinkyDungeonPlayerEntity.x, KinkyDungeonJailGuard().y - KinkyDungeonPlayerEntity.y) <= KinkyDungeonTetherLength() + 2))) {
            let data = {
                toTile: toTile,
                overrideRoomType: false,
                overrideProgression: false,
                overrideJourney: false,
                mapMod: (_a = KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y)) === null || _a === void 0 ? void 0 : _a.MapMod,
            };
            KinkyDungeonSendEvent("beforeHandleStairs", data);
            if (MiniGameKinkyDungeonLevel > Math.max(KinkyDungeonRep, ReputationGet("Gaming")) || Math.max(KinkyDungeonRep, ReputationGet("Gaming")) > KinkyDungeonMaxLevel) {
                KinkyDungeonRep = Math.max(KinkyDungeonRep, MiniGameKinkyDungeonLevel);
                DialogSetReputation("Gaming", KinkyDungeonRep);
            }
            MiniGameVictory = false;
            let roomType = "";
            let currCheckpoint = MiniGameKinkyDungeonCheckpoint;
            let altRoom = KinkyDungeonAltFloor(KDGameData.RoomType);
            if (KDGameData.RoomType == "Tunnel" || (altRoom && altRoom.skiptunnel)) {
                if (!data.overrideProgression) {
                    MiniGameKinkyDungeonLevel += 1;
                    if (KDGameData.PriorJailbreaks > 0)
                        KDGameData.PriorJailbreaksDecay = (KDGameData.PriorJailbreaksDecay + 1) || 1;
                    if (MiniGameKinkyDungeonLevel > 1) {
                        if (MiniGameKinkyDungeonCheckpoint != currCheckpoint)
                            KinkyDungeonChangeRep("Prisoner", -5);
                        else
                            KinkyDungeonChangeRep("Prisoner", -1);
                        if (KinkyDungeonStatsChoice.get("Trespasser")) {
                            KinkyDungeonChangeRep("Rope", -1);
                            KinkyDungeonChangeRep("Metal", -1);
                            KinkyDungeonChangeRep("Leather", -1);
                            KinkyDungeonChangeRep("Latex", -1);
                            KinkyDungeonChangeRep("Will", -1);
                            KinkyDungeonChangeRep("Elements", -1);
                            KinkyDungeonChangeRep("Conjure", -1);
                            KinkyDungeonChangeRep("Illusion", -1);
                        }
                    }
                    if (MiniGameKinkyDungeonLevel >= KinkyDungeonMaxLevel) {
                        MiniGameKinkyDungeonLevel = 1;
                        KDGameData.MainPath = "grv";
                        KinkyDungeonState = "End";
                        MiniGameVictory = true;
                        suppressCheckPoint = true;
                    }
                }
                if (!data.overrideRoomType) {
                    if (KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel)) {
                        roomType = "";
                    }
                    else {
                        roomType = "";
                    }
                }
            }
            else {
                if (!data.overrideRoomType) {
                    roomType = "PerkRoom";
                    KDGameData.MapMod = "";
                }
            }
            if (!data.overrideRoomType) {
                KDGameData.RoomType = roomType;
            }
            if (KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y)) {
                let MapMod = data.mapMod;
                if (MapMod) {
                    KDGameData.MapMod = MapMod;
                    KDGameData.MapFaction = KDMapMods[KDGameData.MapMod].faction;
                }
                else {
                    KDGameData.MapMod = "";
                    KDGameData.MapFaction = "";
                }
                if (!data.overrideJourney) {
                    let Journey = KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y).Journey;
                    if (Journey) {
                        KDGameData.Journey = Journey;
                        KDInitializeJourney(KDGameData.Journey);
                    }
                }
                if (!data.overrideRoomType) {
                    let RoomType = KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y).RoomType;
                    if (RoomType) {
                        KDGameData.RoomType = RoomType;
                    }
                }
            }
            if (toTile == 's') {
                KinkyDungeonSendActionMessage(10, TextGet("ClimbDown"), "#ffffff", 1);
                KinkyDungeonSetCheckPoint(KDGameData.MainPath, true, suppressCheckPoint);
            }
            else if (toTile == 'H') {
                KinkyDungeonSendActionMessage(10, TextGet("ClimbDownShortcut"), "#ffffff", 1);
                KinkyDungeonSetCheckPoint(KDGameData.ShortcutPath, true, suppressCheckPoint);
            }
            if (KinkyDungeonState != "End") {
                KinkyDungeonSendEvent("afterHandleStairs", {
                    toTile: toTile,
                });
                KDGameData.HeartTaken = false;
                KinkyDungeonCreateMap(KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]], MiniGameKinkyDungeonLevel, undefined, undefined);
                let saveData = KinkyDungeonSaveGame(true);
                if (KDGameData.RoomType == "PerkRoom" && MiniGameKinkyDungeonLevel >= 1) {
                    if ((!KinkyDungeonStatsChoice.get("saveMode")) && !suppressCheckPoint) {
                        KinkyDungeonState = "Save";
                        ElementCreateTextArea("saveDataField");
                        ElementValue("saveDataField", saveData);
                    }
                }
                KinkyDungeonSaveGame();
                KDSendStatus('nextLevel');
            }
            else {
                KDSendStatus('end');
            }
        }
        else {
            KinkyDungeonSendActionMessage(10, TextGet("ClimbDownFail"), "#ffffff", 1);
        }
    }
}
let KinkyDungeonConfirmStairs = false;
function KinkyDungeonHandleMoveObject(moveX, moveY, moveObject) {
    if (KDMoveObjectFunctions[moveObject]) {
        return KDMoveObjectFunctions[moveObject](moveX, moveY);
    }
    return false;
}
function KDHasEffectTile(x, y) {
    return KinkyDungeonEffectTilesGet(x + "," + y) != undefined;
}
function KDGetEffectTiles(x, y) {
    let str = x + "," + y;
    return KinkyDungeonEffectTilesGet(str) ? KinkyDungeonEffectTilesGet(str) : {};
}
function KDGetSpecificEffectTile(x, y, tile) {
    return KDGetEffectTiles(x, y)[tile];
}
function KDCreateEffectTile(x, y, tile, durationMod) {
    if (x < 1 || y < 1 || x >= KinkyDungeonGridWidth || y >= KinkyDungeonGridHeight)
        return null;
    let existingTile = KDGetSpecificEffectTile(x, y);
    let duration = (tile.duration ? tile.duration : KDEffectTiles[tile.name].duration) + KDRandom() * (durationMod ? durationMod : 0);
    let createdTile = existingTile;
    if (existingTile && existingTile.duration < tile.duration) {
        existingTile.duration = duration;
    }
    else {
        let tt = Object.assign({ x: x, y: y }, KDEffectTiles[tile.name]);
        Object.assign(tt, tile);
        tt.duration = duration;
        if (!KinkyDungeonEffectTilesGet(x + "," + y)) {
            KinkyDungeonEffectTilesSet(x + "," + y, {});
        }
        KDGetEffectTiles(x, y)[tt.name] = tt;
        createdTile = tt;
    }
    if (createdTile) {
        KDInteractNewTile(createdTile);
        return createdTile;
    }
    return null;
}
function KDInteractNewTile(newTile) {
    let Creator = KDEffectTileCreateFunctionsCreator[newTile.name];
    let Existing = null;
    for (let tile of Object.values(KDGetEffectTiles(newTile.x, newTile.y))) {
        if (tile != newTile) {
            if (Creator)
                Creator(newTile, tile);
            if (tile.duration > 0) {
                Existing = KDEffectTileCreateFunctionsExisting[tile.name];
                if (Existing)
                    Existing(newTile, tile);
            }
        }
    }
}
function KDCreateAoEEffectTiles(x, y, tile, durationMod, rad, avoidPoint, density, mod = "") {
    for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
        for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
            if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(x + X, Y + y)) && AOECondition(x, y, x + X, y + Y, rad, mod) && (!avoidPoint || avoidPoint.x != X + x || avoidPoint.y != Y + y) && (density == undefined || KDRandom() < density)) {
                KDCreateEffectTile(x + X, y + Y, tile, durationMod);
            }
        }
}
function KDRemoveAoEEffectTiles(x, y, tagsToRemove, rad, avoidPoint, density, mod = "") {
    for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
        for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
            if (AOECondition(x, y, x + X, y + Y, rad, mod) && (!avoidPoint || avoidPoint.x != X + x || avoidPoint.y != Y + y) && (density == undefined || KDRandom() < density)) {
                let tiles = KDGetEffectTiles(x + X, y + Y);
                for (let tile of Object.values(tiles)) {
                    for (let tag of tagsToRemove) {
                        if (tile.tags && tile.tags.includes(tag)) {
                            tile.duration = 0;
                            break;
                        }
                    }
                }
            }
        }
}
function KDApplyAlpha(id, alpha, fade, delta) {
    if (!fade)
        return 1.0;
    switch (fade) {
        case "random": {
            if (alpha >= 1 || alpha <= 0)
                KDTileModes[id] = !KDTileModes[id];
            return Math.max(0, Math.min(1, alpha + (KDTileModes[id] ? -delta * 0.001 : delta * 0.001)));
        }
    }
}
let KDTileModes = {};
let KDLastEffTileUpdate = 0;
function KDDrawEffectTiles(canvasOffsetX, canvasOffsetY, CamX, CamY) {
    var _a;
    let delta = CommonTime() - KDLastEffTileUpdate;
    KDLastEffTileUpdate = CommonTime();
    for (let tileLocation of Object.values(KinkyDungeonEffectTiles)) {
        for (let tile of Object.values(tileLocation)) {
            let sprite = (tile.pauseDuration > 0 && tile.pauseSprite) ? tile.pauseSprite : (tile.skin ? tile.skin : tile.name);
            if (tile.x >= CamX && tile.y >= CamY && tile.x < CamX + KinkyDungeonGridWidthDisplay && tile.y < CamY + KinkyDungeonGridHeightDisplay && KinkyDungeonVisionGet(tile.x, tile.y) > 0) {
                if (!KDCanSeeEffectTile(tile))
                    continue;
                let tileid = tile.x + "," + tile.y + "_" + sprite;
                KDDraw(kdgameboard, kdpixisprites, tileid, KinkyDungeonRootDirectory + "EffectTiles/" + sprite + ".png", (tile.x + (tile.xoffset ? tile.xoffset : 0) - CamX) * KinkyDungeonGridSizeDisplay, (tile.y - CamY + (tile.yoffset ? tile.yoffset : 0)) * KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, KinkyDungeonGridSizeDisplay, 0, {
                    zIndex: -0.1 + 0.01 * tile.priority,
                    alpha: KDApplyAlpha(tileid, (_a = kdpixisprites.get(tileid)) === null || _a === void 0 ? void 0 : _a.alpha, tile.fade, delta),
                });
            }
        }
    }
}
function KDCanSeeEffectTile(tile) {
    var _a;
    if (KinkyDungeonState != "TileEditor" && ((_a = tile.tags) === null || _a === void 0 ? void 0 : _a.includes("hiddenmagic"))) {
        let rad = KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "MagicalSight");
        if (rad <= 0 || KDistEuclidean(tile.x - KinkyDungeonPlayerEntity.x, tile.y - KinkyDungeonPlayerEntity.y) > rad)
            return false;
    }
    return true;
}
function KDUpdateEffectTiles(delta) {
    for (let examinedTile of Object.values(KDGetEffectTiles(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y))) {
        if (examinedTile)
            KinkyDungeonUpdateSingleEffectTile(delta, KinkyDungeonPlayerEntity, examinedTile);
    }
    for (let enemy of KinkyDungeonEntities) {
        for (let examinedTile of Object.values(KDGetEffectTiles(enemy.x, enemy.y))) {
            if (examinedTile)
                if (examinedTile)
                    KinkyDungeonUpdateSingleEffectTile(delta, enemy, examinedTile);
        }
    }
    for (let loc of Object.entries(KinkyDungeonEffectTiles)) {
        let location = loc[1];
        for (let t of Object.entries(location)) {
            if (t[1].pauseDuration > 0) {
                t[1].pauseDuration -= delta;
            }
            else {
                if (t[1].duration > 0 && t[1].duration < 9000)
                    t[1].duration -= delta;
            }
            if (t[1].pauseDuration <= 0.001)
                t[1].pauseSprite = undefined;
            if (t[1].duration <= 0.001)
                delete location[t[0]];
            else {
                KinkyDungeonUpdateSingleEffectTileStandalone(delta, t[1]);
            }
        }
        if (Object.values(loc[1]).length < 1) {
            delete KinkyDungeonEffectTiles[loc[0]];
        }
    }
}
function KinkyDungeonUpdateSingleEffectTile(delta, entity, tile) {
    if (tile.duration > 0 && KDEffectTileFunctions[tile.name]) {
        KDEffectTileFunctions[tile.name](delta, entity, tile);
    }
}
function KinkyDungeonUpdateSingleEffectTileStandalone(delta, tile) {
    if (tile.duration > 0 && KDEffectTileFunctionsStandalone[tile.name]) {
        KDEffectTileFunctionsStandalone[tile.name](delta, tile);
    }
}
function KinkyDungeonBulletInteractionSingleEffectTile(b, tile, d) {
    if (tile.duration > 0 && KDEffectTileBulletFunctions[tile.name]) {
        KDEffectTileBulletFunctions[tile.name](b, tile, d);
    }
}
function KDEffectTileInteractions(x, y, b, d) {
    for (let examinedTile of Object.values(KDGetEffectTiles(x, y))) {
        if (examinedTile)
            KinkyDungeonBulletInteractionSingleEffectTile(b, examinedTile, d);
    }
}
function KDMoveEntity(enemy, x, y, willing, dash, forceHitBullets, ignoreBlocked) {
    enemy.lastx = enemy.x;
    enemy.lasty = enemy.y;
    let cancel = { cancelmove: false, returnvalue: false };
    for (let newTile of Object.values(KDGetEffectTiles(x, y))) {
        if (newTile.duration > 0 && KDEffectTileMoveOnFunctions[newTile.name]) {
            cancel = KDEffectTileMoveOnFunctions[newTile.name](enemy, newTile, willing, { x: x - enemy.x, y: y - enemy.y }, dash);
        }
    }
    if (!ignoreBlocked && KinkyDungeonEntityAt(x, y))
        cancel.cancelmove = true;
    if (!cancel.cancelmove) {
        enemy.x = x;
        enemy.y = y;
        KinkyDungeonSendEvent("enemyMove", {
            cancelmove: cancel.cancelmove,
            returnvalue: cancel.returnvalue,
            willing: willing,
            sprint: dash,
            lastX: enemy.lastx,
            lastY: enemy.lasty,
            moveX: x,
            moveY: y,
            enemy: enemy,
        });
        KDCheckCollideableBullets(enemy, forceHitBullets);
        enemy.fx = undefined;
        enemy.fy = undefined;
        if (enemy.x != enemy.lastx || enemy.y != enemy.lasty)
            KDUpdateEnemyCache = true;
    }
    return cancel.returnvalue;
}
function KDStaggerEnemy(enemy) {
    enemy.fx = undefined;
    enemy.fy = undefined;
    enemy.movePoints = 0;
}
function KDMovePlayer(moveX, moveY, willing, sprint, forceHitBullets) {
    KinkyDungeonPlayerEntity.lastx = KinkyDungeonPlayerEntity.x;
    KinkyDungeonPlayerEntity.lasty = KinkyDungeonPlayerEntity.y;
    let cancel = { cancelmove: false, returnvalue: false };
    for (let newTile of Object.values(KDGetEffectTiles(moveX, moveY))) {
        if (newTile.duration > 0 && KDEffectTileMoveOnFunctions[newTile.name]) {
            cancel = KDEffectTileMoveOnFunctions[newTile.name](KinkyDungeonPlayerEntity, newTile, willing, { x: moveX - KinkyDungeonPlayerEntity.x, y: moveY - KinkyDungeonPlayerEntity.y }, sprint);
        }
    }
    if (!cancel.cancelmove) {
        KinkyDungeonPlayerEntity.x = moveX;
        KinkyDungeonPlayerEntity.y = moveY;
    }
    KinkyDungeonSendEvent("playerMove", {
        cancelmove: cancel.cancelmove,
        returnvalue: cancel.returnvalue,
        willing: willing,
        sprint: sprint,
        lastX: KinkyDungeonPlayerEntity.lastx,
        lastY: KinkyDungeonPlayerEntity.lasty,
        moveX: moveX,
        moveY: moveY,
    });
    if (!cancel.cancelmove) {
        KDCheckCollideableBullets(KinkyDungeonPlayerEntity, forceHitBullets);
        KinkyDungeonHandleTraps(KinkyDungeonPlayerEntity, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonTrapMoved);
    }
    return cancel.returnvalue;
}
function KDSlip(dir) {
    let maxSlip = 2;
    let maxReached = 0;
    for (let i = 0; i < maxSlip; i++) {
        let newTiles = KDGetEffectTiles(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
        let oldTiles = KDGetEffectTiles(KinkyDungeonPlayerEntity.x + dir.x, KinkyDungeonPlayerEntity.y + dir.y);
        if ((Object.values(newTiles).some((tile) => {
            var _a, _b, _c;
            return ((_a = tile.tags) === null || _a === void 0 ? void 0 : _a.includes("slippery"))
                || ((((_b = tile.statuses) === null || _b === void 0 ? void 0 : _b.frozen) || tile.name.includes("Frozen")) && ((_c = tile.tags) === null || _c === void 0 ? void 0 : _c.includes("slipperywhenfrozen")));
        })
            || Object.values(oldTiles).some((tile) => {
                var _a, _b, _c;
                return ((_a = tile.tags) === null || _a === void 0 ? void 0 : _a.includes("slippery"))
                    || ((((_b = tile.statuses) === null || _b === void 0 ? void 0 : _b.frozen) || tile.name.includes("Frozen")) && ((_c = tile.tags) === null || _c === void 0 ? void 0 : _c.includes("slipperywhenfrozen")));
            }))
            && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(KinkyDungeonPlayerEntity.x + dir.x, KinkyDungeonPlayerEntity.y + dir.y))
            && !KinkyDungeonEnemyAt(KinkyDungeonPlayerEntity.x + dir.x, KinkyDungeonPlayerEntity.y + dir.y)) {
            KDMovePlayer(KinkyDungeonPlayerEntity.x + dir.x, KinkyDungeonPlayerEntity.y + dir.y, false, true);
            KinkyDungeonHandleStepOffTraps(KinkyDungeonPlayerEntity, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonPlayerEntity.x + dir.x, KinkyDungeonPlayerEntity.y + dir.y);
            KinkyDungeonHandleTraps(KinkyDungeonPlayerEntity, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, true);
            maxReached = i;
        }
        else {
            i = maxSlip;
        }
    }
    if (maxReached) {
        KinkyDungeonSendActionMessage(10, TextGet("KDSlipIce"), "yellow", maxReached + 1);
        KinkyDungeonSlowMoveTurns = Math.max(KinkyDungeonSlowMoveTurns, 1);
        KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "Slipping", type: "none", power: 1.0, duration: 1, });
        return true;
    }
    return false;
}
function KDInferno(existingTile, newTile, duration) {
    if (newTile.tags.includes("fire") || newTile.tags.includes("ignite")) {
        existingTile.duration = 0;
        KDCreateEffectTile(existingTile.x, existingTile.y, {
            name: "Inferno",
            duration: duration,
        }, 2);
    }
}
function KDIgnition(b, tile, d) {
    if (b.bullet.damage) {
        let type = b.bullet.damage.type;
        if ((KDIgnitionSources.includes(type)) && b.bullet.damage.damage > 0) {
            KDCreateEffectTile(tile.x, tile.y, {
                name: "Ember",
                duration: 2,
            }, 1);
        }
    }
}
function KDConveyor(delta, X, Y) {
    let tile = KinkyDungeonTilesGet(X + "," + Y);
    if (!tile || tile.SwitchMode == "Off")
        return;
    let entity = KinkyDungeonEntityAt(X, Y);
    let tiletype = KinkyDungeonMapGet(X + (tile.DX || 0), Y + (tile.DY || 0));
    if (entity && KinkyDungeonMovableTilesEnemy.includes(tiletype) && !KinkyDungeonEntityAt(X + (tile.DX || 0), Y + (tile.DY || 0))) {
        if (entity.player) {
            if (!KinkyDungeonFlags.get("conveyed")) {
                KinkyDungeonSetFlag("conveyed", 2);
                KDMovePlayer(X + (tile.DX || 0), Y + (tile.DY || 0), false, false, true);
                KinkyDungeonSendTextMessage(4, TextGet("KDConveyorPush"), "#ffff44", 2);
            }
        }
        else if (!KDIsImmobile(entity) && !entity.Enemy.tags.flying && !entity.Enemy.tags.ignoreconveyor && !entity.Enemy.ethereal
            && !(entity.Enemy.tags.unstoppable || (entity.Enemy.tags.unflinching && !KinkyDungeonIsDisabled(entity)))) {
            if (entity.Enemy.tags.prisoner)
                KDStaggerEnemy(entity);
            if (!KDEnemyHasFlag(entity, "conveyed")) {
                KinkyDungeonSetEnemyFlag(entity, "conveyed", 2);
                KDMoveEntity(entity, X + (tile.DX || 0), Y + (tile.DY || 0), false, false, true);
            }
        }
    }
}
let KDTileUpdateFunctionsLocal = {
    'z': (delta, X, Y) => {
        let entity = KinkyDungeonEntityAt(X, Y);
        if (entity)
            return;
        let mapTile = KinkyDungeonTilesGet(X + "," + Y);
        if ((mapTile === null || mapTile === void 0 ? void 0 : mapTile.wireType) == "AutoDoor_HoldOpen" || (mapTile === null || mapTile === void 0 ? void 0 : mapTile.wireType) == "AutoDoor_HoldClosed") {
            let tags = KDEffectTileTags(X, Y);
            if ((!tags.signal && mapTile.wireType == "AutoDoor_HoldOpen")
                || (tags.signal && mapTile.wireType == "AutoDoor_HoldClosed")) {
                KinkyDungeonMapSet(X, Y, 'Z');
            }
        }
    },
    'Z': (delta, X, Y) => {
        let mapTile = KinkyDungeonTilesGet(X + "," + Y);
        if ((mapTile === null || mapTile === void 0 ? void 0 : mapTile.wireType) == "AutoDoor_HoldOpen" || (mapTile === null || mapTile === void 0 ? void 0 : mapTile.wireType) == "AutoDoor_HoldClosed") {
            let tags = KDEffectTileTags(X, Y);
            if ((tags.signal && mapTile.wireType == "AutoDoor_HoldOpen")
                || (!tags.signal && mapTile.wireType == "AutoDoor_HoldClosed")) {
                KinkyDungeonMapSet(X, Y, 'z');
            }
        }
    },
    "w": (delta, X, Y) => {
        KDCreateEffectTile(X, Y, {
            name: "Water",
            duration: 2,
        }, 0);
    },
    "V": (delta, X, Y) => {
        KDConveyor(delta, X, Y);
    },
    "N": (delta, X, Y) => {
        var _a;
        let tile = KinkyDungeonTilesGet(X + "," + Y);
        let tU = KinkyDungeonTilesGet(X + "," + (Y - 1));
        let tD = KinkyDungeonTilesGet(X + "," + (Y + 1));
        let tR = KinkyDungeonTilesGet((X + 1) + "," + Y);
        let tL = KinkyDungeonTilesGet((X - 1) + "," + Y);
        if ((tU === null || tU === void 0 ? void 0 : tU.DY) == 1)
            tile.DY = 1;
        else if ((tD === null || tD === void 0 ? void 0 : tD.DY) == -1)
            tile.DY = -1;
        else if ((tL === null || tL === void 0 ? void 0 : tL.DX) == 1)
            tile.DX = 1;
        else if ((tR === null || tR === void 0 ? void 0 : tR.DX) == -1)
            tile.DX = -1;
        let entity = KinkyDungeonEntityAt(X, Y);
        let BMType = KDBondageMachineFunctions[tile.Binding];
        if (entity) {
            let eligible = false;
            if (entity.player) {
                if (!KinkyDungeonFlags.get("processed")) {
                    eligible = BMType.eligible_player(tile, X, Y, entity);
                    if (eligible) {
                        if (BMType.function_player(tile, delta, X, Y, entity))
                            return;
                    }
                }
            }
            else if ((_a = entity.Enemy) === null || _a === void 0 ? void 0 : _a.bound) {
                if (entity.Enemy.tags.prisoner)
                    KDStaggerEnemy(entity);
                if (!KDEnemyHasFlag(entity, "processed")) {
                    eligible = BMType.eligible_enemy(tile, X, Y, entity);
                    if (eligible) {
                        if (BMType.function_enemy(tile, delta, X, Y, entity))
                            return;
                    }
                }
            }
        }
        KDConveyor(delta, X, Y);
    },
    "u": (delta, X, Y) => {
        let tile = KinkyDungeonTilesGet(X + "," + Y);
        if (!tile.cd)
            tile.cd = 0;
        if (tile.cd <= 0) {
            if (tile.count == undefined || tile.count > 0) {
                if (KDGameData.DollCount > 30)
                    return;
                let nearbyEnemyCount = KDNearbyEnemies(X, Y, 4.5);
                if (nearbyEnemyCount.length > 6)
                    return;
                let start = true;
                let ind = tile.index;
                while (start || ind != tile.index) {
                    start = false;
                    let tx = ind == 0 ? -1 : (ind == 2 ? 1 : 0);
                    let ty = ind == 1 ? -1 : (ind == 3 ? 1 : 0);
                    let entity = KinkyDungeonEntityAt(X + tx, Y + ty);
                    let tiletype = KinkyDungeonMapGet(X + tx, Y + ty);
                    let tiledest = KinkyDungeonTilesGet((X + tx) + ',' + (Y + ty));
                    if (tiletype == 'V' && (tiledest === null || tiledest === void 0 ? void 0 : tiledest.SwitchMode) != "Off" && !entity) {
                        tile.cd = tile.rate;
                        let e = DialogueCreateEnemy(X + tx, Y + ty, tile.dollType || "FactoryDoll");
                        KinkyDungeonSetEnemyFlag(e, "conveyed", 1);
                        if (tile.count != undefined)
                            tile.count -= 1;
                        break;
                    }
                    ind += 1;
                    ind = ind % 4;
                }
                tile.index = ind;
            }
        }
        else {
            tile.cd -= delta;
        }
    },
    "t": (delta, X, Y) => {
        var _a;
        let entity = KinkyDungeonEntityAt(X, Y);
        if (entity && !entity.player) {
            if (((_a = entity.Enemy) === null || _a === void 0 ? void 0 : _a.tags.prisoner) || KDHelpless(entity)) {
                KDStaggerEnemy(entity);
                if (!KDEnemyHasFlag(entity, "conveyed")) {
                    KDClearItems(entity);
                    entity.hp = 0;
                }
            }
            else {
                KDKickEnemyLocal(entity);
            }
        }
        else if ((entity === null || entity === void 0 ? void 0 : entity.player) && !KinkyDungeonFlags.get("nodollterm")) {
            if (KinkyDungeonFlags.get("conveyed")) {
                KDStartDialog("DollTerminal_Forced", "", true, "");
            }
            else {
                KDStartDialog("DollTerminal_Step", "", true, "");
            }
        }
    },
};
let KDBondageMachineFunctions = {
    "Latex": {
        eligible_player: (tile, x, y, entity) => {
            return KDGetRestraintsEligible({ tags: ['latexEncase'] }, 10, 'grv', false, undefined, undefined, undefined, false).length > 0;
        },
        function_player: (tile, delta, x, y, entity) => {
            KDBasicRestraintsMachine_Player(['latexEncase'], 2, "KDEncasement");
            return false;
        },
        eligible_enemy: (tile, x, y, entity) => {
            return true;
        },
        function_enemy: (tile, delta, x, y, entity) => {
            KDTieUpEnemy(entity, 4.0, "Slime", "glue");
            if (KDBoundEffects(entity) > 2) {
                KDTieUpEnemy(entity, 4.0, "Slime", "glue");
                KinkyDungeonApplyBuffToEntity(entity, KDEncasedDoll);
            }
            if (KDBoundEffects(entity) < 1) {
                KinkyDungeonSetEnemyFlag(entity, "conveyed", 1);
                KinkyDungeonSetEnemyFlag(entity, "processed", 1);
                return true;
            }
            return false;
        },
    },
    "Metal": {
        eligible_player: (tile, x, y, entity) => {
            return KDGetRestraintsEligible({ tags: ["hitechCables", "cableGag", "controlHarness"] }, 10, 'grv', false, undefined, undefined, undefined, false).length > 0;
        },
        function_player: (tile, delta, x, y, entity) => {
            KDBasicRestraintsMachine_Player(["hitechCables", "cableGag", "controlHarness"], 2, "KDMetalMachine");
            return false;
        },
        eligible_enemy: (tile, x, y, entity) => {
            return true;
        },
        function_enemy: (tile, delta, x, y, entity) => {
            KDTieUpEnemy(entity, 4.0, "Metal", "chain");
            if (KDBoundEffects(entity) < 1) {
                KinkyDungeonSetEnemyFlag(entity, "conveyed", 1);
                KinkyDungeonSetEnemyFlag(entity, "processed", 1);
                return true;
            }
            return false;
        },
    },
    "Tape": {
        eligible_player: (tile, x, y, entity) => {
            return KDGetRestraintsEligible({ tags: ["autoTape"] }, 10, 'grv', false, undefined, undefined, undefined, false).length > 0;
        },
        function_player: (tile, delta, x, y, entity) => {
            KDBasicRestraintsMachine_Player(["autoTape"], 2, "KDTapeMachine");
            return false;
        },
        eligible_enemy: (tile, x, y, entity) => {
            return true;
        },
        function_enemy: (tile, delta, x, y, entity) => {
            KDTieUpEnemy(entity, 4.0, "Tape", "glue");
            if (KDBoundEffects(entity) < 1) {
                KinkyDungeonSetEnemyFlag(entity, "conveyed", 1);
                KinkyDungeonSetEnemyFlag(entity, "processed", 1);
                return true;
            }
            return false;
        },
    },
    "Plug": {
        eligible_player: (tile, x, y, entity) => {
            return KDGetRestraintsEligible({ tags: ['machinePlug'] }, 10, 'grv', false, undefined, undefined, undefined, false).length > 0;
        },
        function_player: (tile, delta, x, y, entity) => {
            return KDBasicRestraintsMachine_Player(['machinePlug'], 1, "KDPlugMachine") != 0;
        },
        eligible_enemy: (tile, x, y, entity) => {
            return (entity.boundLevel > 0 || KDEntityGetBuff(entity, "Chastity")) && !(entity.buffs && KinkyDungeonGetBuffedStat(entity.buffs, "Plug") >= 2);
        },
        function_enemy: (tile, delta, x, y, entity) => {
            KDPlugEnemy(entity);
            if (KinkyDungeonGetBuffedStat(entity.buffs, "Plug") > 0) {
                KinkyDungeonSetEnemyFlag(entity, "conveyed", 1);
                KinkyDungeonSetEnemyFlag(entity, "processed", 1);
                return true;
            }
            return false;
        },
    },
    "Chastity": {
        eligible_player: (tile, x, y, entity) => {
            return KDGetRestraintsEligible({ tags: ['machineChastity'] }, 10, 'grv', false, undefined, undefined, undefined, false).length > 0;
        },
        function_player: (tile, delta, x, y, entity) => {
            return KDBasicRestraintsMachine_Player(['machineChastity'], 1, "KDChastityMachine") != 0;
        },
        eligible_enemy: (tile, x, y, entity) => {
            return entity.boundLevel > 0 && !KDEntityGetBuff(entity, "Chastity");
        },
        function_enemy: (tile, delta, x, y, entity) => {
            KDTieUpEnemy(entity, 2.0, "Metal", "chain");
            KinkyDungeonApplyBuffToEntity(entity, KDChastity);
            if (KDEntityGetBuff(entity, "Chastity")) {
                KinkyDungeonSetEnemyFlag(entity, "conveyed", 1);
                KinkyDungeonSetEnemyFlag(entity, "processed", 1);
                return true;
            }
            return false;
        },
    },
};
function KDBasicRestraintsMachine_Player(tags, count, msg) {
    let succ = 0;
    for (let i = 0; i < count; i++) {
        let restraint = KinkyDungeonGetRestraint({ tags: tags }, 10, 'grv', false, undefined, undefined, undefined, false);
        if (restraint) {
            succ = KinkyDungeonAddRestraintIfWeaker(restraint, MiniGameKinkyDungeonLevel, false, undefined, undefined, undefined, undefined, "AncientRobot", true) || succ;
        }
    }
    if (succ) {
        KinkyDungeonSetFlag("conveyed", 2);
        KinkyDungeonSetFlag("processed", 3);
        KinkyDungeonSendTextMessage(8, TextGet(msg), "#ffff44", 2);
    }
    return succ;
}
let KDTileUpdateFunctions = {
    "]": (delta) => {
        KinkyDungeonChangeDistraction(1 * delta, false, 0.1);
        KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonHappyGas"), "pink", 1);
        return true;
    },
    "[": (delta) => {
        KinkyDungeonSleepiness = Math.max(KinkyDungeonSleepiness + 2, 5);
        KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSporeGas"), "pink", 1);
        return true;
    },
    "L": (delta) => {
        if (KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y)
            && KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y).Furniture) {
            let furn = KDFurniture[KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y).Furniture];
            if (furn) {
                furn.tickFunction(delta);
            }
        }
        else {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "barrel", type: "SlowDetection", duration: 1, power: 9.0, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["SlowDetection", "move", "cast"] });
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "barrel3", type: "Sneak", duration: 1, power: 1.95, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Sneak", "darkness", "move", "cast"] });
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "barrel2", type: "SlowLevel", duration: 1, power: 1, player: true, enemies: true, endSleep: true, maxCount: 1, tags: ["Slow", "move", "cast"] });
            KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonBarrel"), "lightgreen", 1, true);
        }
        return true;
    },
    "?": (delta) => {
        KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonHookHigh"), "lightgreen", 1, true);
        return true;
    },
    "/": (delta) => {
        KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonScrap"), "lightgreen", 1, true);
        return true;
    },
};
let KDMoveObjectFunctions = {
    'B': (moveX, moveY) => {
        if (!KinkyDungeonFlags.get("slept") && !KinkyDungeonFlags.get("nobed") && KinkyDungeonStatWill < KinkyDungeonStatWillMax * 0.49) {
            KDStartDialog("Bed", "", true);
        }
        return false;
    },
    '@': (moveX, moveY) => {
        if (!KinkyDungeonFlags.get("nobutton")) {
            KDStartDialog("Button", "", true);
        }
        return false;
    },
    'l': (moveX, moveY) => {
        if (!KinkyDungeonFlags.get("noleyline") && KinkyDungeonStatManaPool < KinkyDungeonStatManaPoolMax && KDTile(moveX, moveY) && KDTile(moveX, moveY).Leyline) {
            KDStartDialog("Leyline", "", true);
        }
        return false;
    },
    'D': (moveX, moveY) => {
        KinkyDungeonAdvanceTime(1, true);
        let open = !KinkyDungeonStatsChoice.get("Doorknobs") || !KinkyDungeonIsHandsBound(true, true, 0.45);
        if (!open) {
            if (KinkyDungeonCanUseFeet()) {
                KinkyDungeonSendActionMessage(10, TextGet("KDDoorknobFeet"), "#88ff88", 2);
                open = true;
            }
            else {
                let grace = 0;
                if (KinkyDungeonFlags.get("failUnfairFirst") && !KinkyDungeonFlags.get("failUnfair"))
                    grace = 0.4;
                let armsbound = KinkyDungeonIsArmsBound(true, true);
                if (KDRandom() - grace < (armsbound ? KDDoorKnobChance : KDDoorKnobChanceArms)) {
                    KinkyDungeonSendActionMessage(10, TextGet("KDDoorknobSuccess" + ((armsbound) ? "" : "Arms")), "#88ff88", 2);
                    open = true;
                }
                else if (KDRandom() - grace < (armsbound ? KDDoorAttractChance : KDDoorAttractChanceArms) && DialogueBringNearbyEnemy(moveX, moveY, 10)) {
                    KinkyDungeonSendActionMessage(10, TextGet("KDDoorknobAttract" + ((armsbound) ? "" : "Arms")), "#ff5555", 2);
                    KinkyDungeonMakeNoise(armsbound ? 6 : 3, moveX, moveY);
                    open = true;
                }
                else {
                    KinkyDungeonSendActionMessage(10, TextGet("KDDoorknobFail" + (armsbound ? "" : "Arms")), "#ff5555", 2);
                    KinkyDungeonMakeNoise(armsbound ? 6 : 3, moveX, moveY);
                    if (!KinkyDungeonFlags.get("failUnfairFirst")) {
                        KinkyDungeonSetFlag("failUnfair", 5);
                        KinkyDungeonSetFlag("failUnfairFirst", 10);
                    }
                    if (KDToggles.Sound)
                        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Locked.ogg");
                }
            }
        }
        if (open) {
            KinkyDungeonMapSet(moveX, moveY, 'd');
            let faction = KinkyDungeonTilesGet(moveX + "," + moveY) && KinkyDungeonTilesGet(moveX + "," + moveY).Faction ? KinkyDungeonTilesGet(moveX + "," + moveY).Faction : undefined;
            if (faction) {
                KinkyDungeonAggroFaction(faction, true);
            }
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/DoorOpen.ogg");
        }
        return true;
    },
    'C': (moveX, moveY) => {
        let chestType = KinkyDungeonTilesGet(moveX + "," + moveY) && KinkyDungeonTilesGet(moveX + "," + moveY).Loot ? KinkyDungeonTilesGet(moveX + "," + moveY).Loot : "chest";
        let faction = KinkyDungeonTilesGet(moveX + "," + moveY) && KinkyDungeonTilesGet(moveX + "," + moveY).Faction ? KinkyDungeonTilesGet(moveX + "," + moveY).Faction : undefined;
        let noTrap = KinkyDungeonTilesGet(moveX + "," + moveY) && KinkyDungeonTilesGet(moveX + "," + moveY).NoTrap ? KinkyDungeonTilesGet(moveX + "," + moveY).NoTrap : false;
        let lootTrap = KinkyDungeonTilesGet(moveX + "," + moveY) && KinkyDungeonTilesGet(moveX + "," + moveY).lootTrap ? KinkyDungeonTilesGet(moveX + "," + moveY).lootTrap : undefined;
        let roll = KinkyDungeonTilesGet(moveX + "," + moveY) ? KinkyDungeonTilesGet(moveX + "," + moveY).Roll : KDRandom();
        if (faction && !KinkyDungeonChestConfirm) {
            KinkyDungeonChestConfirm = true;
            KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonChestFaction").replace("FACTION", TextGet("KinkyDungeonFaction" + faction)), "#ff0000", 2, true);
        }
        else {
            KinkyDungeonLoot(MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], chestType, roll, KinkyDungeonTilesGet(moveX + "," + moveY), undefined, noTrap);
            if (lootTrap) {
                KDTrigPanic();
                KDSpawnLootTrap(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, lootTrap.trap, lootTrap.mult, lootTrap.duration);
            }
            if (KDToggles.Sound)
                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/ChestOpen.ogg");
            KinkyDungeonMapSet(moveX, moveY, 'c');
            KDGameData.AlreadyOpened.push({ x: moveX, y: moveY });
            KinkyDungeonAggroAction('chest', { faction: faction });
        }
        return true;
    },
    'Y': (moveX, moveY) => {
        let chestType = KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint] == "lib" ? "shelf" : "rubble";
        KinkyDungeonLoot(MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], chestType);
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Coins.ogg");
        KinkyDungeonMapSet(moveX, moveY, 'X');
        KDGameData.AlreadyOpened.push({ x: moveX, y: moveY });
        return true;
    },
    'O': (moveX, moveY) => {
        if (KinkyDungeonIsPlayer())
            KinkyDungeonTakeOrb(1, moveX, moveY);
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
        KDGameData.AlreadyOpened.push({ x: moveX, y: moveY });
        return true;
    },
    'P': (moveX, moveY) => {
        if (KinkyDungeonIsPlayer()) {
            KDPerkConfirm = false;
            KinkyDungeonTakePerk(1, moveX, moveY);
        }
        if (KDToggles.Sound)
            AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
        return true;
    },
    '-': (moveX, moveY) => {
        KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonObjectChargerDestroyed"), "#999999", 1, true);
        return true;
    },
};
let KDEffectTileFunctionsStandalone = {
    "Inferno": (delta, tile) => {
        if (tile.duration > 4 && KDRandom() < 0.3 && !(tile.pauseDuration > 0)) {
            KDCreateAoEEffectTiles(tile.x, tile.y, {
                name: "Ember",
                duration: 1,
            }, 4, 1.5, undefined, 0.5);
        }
        return true;
    },
    "SlimeBurning": (delta, tile) => {
        if (tile.duration > 0 && !(tile.pauseDuration > 0)) {
            KDCreateEffectTile(tile.x, tile.y, {
                name: "Inferno",
                duration: 2,
            }, 1);
            if (KDRandom() < 0.3) {
                KDCreateAoEEffectTiles(tile.x, tile.y, {
                    name: "Ember",
                    duration: 1,
                }, 4, 1.5, undefined, 0.5);
            }
        }
        return true;
    },
    "Torch": (delta, tile) => {
        if (tile.duration > 9000) {
            tile.duration = 9999;
        }
        return true;
    },
    "TorchUnlit": (delta, tile) => {
        if (tile.duration > 9000) {
            tile.duration = 9999;
        }
        return true;
    },
    "Lantern": (delta, tile) => {
        if (tile.duration > 9000) {
            tile.duration = 9999;
        }
        return true;
    },
    "LanternUnlit": (delta, tile) => {
        if (tile.duration > 9000) {
            tile.duration = 9999;
        }
        return true;
    },
    "TorchOrb": (delta, tile) => {
        if (tile.duration > 9000) {
            tile.duration = 9999;
        }
        return true;
    },
};
function KDSlimeImmuneEntity(entity) {
    if (entity.player) {
        if (KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "glueDamageResist") >= 0.45)
            return true;
        for (let inv of KinkyDungeonAllRestraint()) {
            if (KDRestraint(inv).slimeWalk) {
                return true;
            }
        }
    }
    else
        return KDSlimeImmune(entity);
}
function KDSlimeWalker(entity) {
    var _a;
    if (KDSlimeImmuneEntity(entity))
        return true;
    else if (!entity.player && ((_a = entity.Enemy) === null || _a === void 0 ? void 0 : _a.tags.flying))
        return true;
    return false;
}
function KDSlimeImmune(enemy) {
    var _a, _b, _c, _d;
    return ((_a = enemy.Enemy) === null || _a === void 0 ? void 0 : _a.tags.slime) || ((_b = enemy.Enemy) === null || _b === void 0 ? void 0 : _b.tags.glueimmune) || ((_c = enemy.Enemy) === null || _c === void 0 ? void 0 : _c.tags.glueresist) || ((_d = enemy.Enemy) === null || _d === void 0 ? void 0 : _d.tags.slimewalk) || KDEntityBuffedStat(enemy, "glueDamageResist") >= 0.45;
}
let KDEffectTileFunctions = {
    "PressurePlateHold": (delta, entity, tile) => {
        KDCreateEffectTile(tile.x, tile.y, {
            name: "WireSparks",
            duration: 2,
        }, 0);
        return false;
    },
    "PressurePlate": (delta, entity, tile) => {
        let tags = KDEffectTileTags(tile.x, tile.y);
        if (!tags.ppactive) {
            KDCreateEffectTile(tile.x, tile.y, {
                name: "WireSparks",
                duration: 2,
            }, 0);
        }
        KDCreateEffectTile(tile.x, tile.y, {
            name: "PressurePlateActive",
            duration: 2,
        }, 0);
        return false;
    },
    "PressurePlateOneUse": (delta, entity, tile) => {
        KDCreateEffectTile(tile.x, tile.y, {
            name: "WireSparks",
            duration: 2,
        }, 0);
        tile.duration = 0;
        return false;
    },
    "SlimeBurning": (delta, entity, tile) => {
        if (!KDEntityHasBuff(entity, "Drenched")) {
            let slimeWalker = KDSlimeWalker(entity);
            if (!slimeWalker) {
                KinkyDungeonApplyBuffToEntity(entity, KDSlimed);
                return true;
            }
        }
        return false;
    },
    "Slime": (delta, entity, tile) => {
        if (tile.pauseDuration > 0) {
        }
        else if (!KDEntityHasBuff(entity, "Drenched")) {
            let slimeWalker = KDSlimeWalker(entity);
            if (!slimeWalker) {
                KinkyDungeonApplyBuffToEntity(entity, KDSlimed);
                return true;
            }
        }
        return false;
    },
    "Latex": (delta, entity, tile) => {
        if (tile.pauseDuration > 0) {
        }
        else {
            let result = false;
            if (!KDEntityHasBuff(entity, "Drenched")) {
                let slimeWalker = KDSlimeWalker(entity);
                if (!slimeWalker) {
                    KinkyDungeonApplyBuffToEntity(entity, KDSlimed);
                    result = true;
                }
            }
            if (result || KDEntityBuffedStat(entity, "SlimeProgress")) {
                if (entity.player) {
                    let latexData = {
                        cancelDamage: false,
                        dmg: KDLatexDmg * KDGetEnvironmentalDmg(),
                        type: "glue",
                    };
                    KinkyDungeonSendEvent("tickLatexPlayer", latexData);
                    if (!latexData.cancelDamage)
                        KinkyDungeonDealDamage({ damage: latexData.dmg * KDGetEnvironmentalDmg(), type: latexData.type });
                }
                else if (KDCanBind(entity)) {
                    let latexData = {
                        cancelDamage: entity.boundLevel > entity.Enemy.maxhp + KDLatexBind,
                        enemy: entity,
                        dmg: 0,
                        bind: KDLatexBind * KDGetEnvironmentalDmg(),
                        type: "glue",
                    };
                    KinkyDungeonSendEvent("tickLatex", latexData);
                    if (!latexData.cancelDamage) {
                        KinkyDungeonDamageEnemy(entity, {
                            type: "glue",
                            damage: 0,
                            bind: KDLatexBind * KDGetEnvironmentalDmg(),
                            flags: ["DoT"]
                        }, false, true, undefined, undefined, undefined, "Rage");
                        if (entity.boundLevel >= entity.Enemy.maxhp) {
                            KinkyDungeonApplyBuffToEntity(entity, KDEncased);
                        }
                    }
                }
                return true;
            }
        }
        return false;
    },
    "Ice": (delta, entity, tile) => {
        if ((!entity.player && !entity.Enemy.tags.ice && !entity.Enemy.tags.nofreeze) || (entity.player && !KDChillWalk(entity)))
            KinkyDungeonApplyBuffToEntity(entity, KDChilled);
        if (entity.player && KinkyDungeonPlayerBuffs.Slipping && !KinkyDungeonFlags.get("slipped")) {
            KDSlip({ x: KinkyDungeonPlayerEntity.x - KinkyDungeonPlayerEntity.lastx, y: KinkyDungeonPlayerEntity.y - KinkyDungeonPlayerEntity.lasty });
            KinkyDungeonSetFlag("slipped", 1);
        }
        return true;
    },
    "Water": (delta, entity, tile) => {
        if (tile.pauseSprite == tile.name + "Frozen") {
            if (entity.player && KinkyDungeonPlayerBuffs.Slipping && !KinkyDungeonFlags.get("slipped")) {
                KDSlip({ x: KinkyDungeonPlayerEntity.x - KinkyDungeonPlayerEntity.lastx, y: KinkyDungeonPlayerEntity.y - KinkyDungeonPlayerEntity.lasty });
                KinkyDungeonSetFlag("slipped", 1);
            }
        }
        else if (KDWettable(entity)) {
            KinkyDungeonApplyBuffToEntity(entity, KDDrenched);
            KinkyDungeonApplyBuffToEntity(entity, KDDrenched2);
            KinkyDungeonApplyBuffToEntity(entity, KDDrenched3);
        }
        return true;
    },
    "Inferno": (delta, entity, tile) => {
        if (entity.player) {
            KinkyDungeonDealDamage({
                type: "fire",
                damage: 1 * KDGetEnvironmentalDmg(),
                time: 0,
                bind: 0,
                flags: ["BurningDamage"]
            });
            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonInfernoBurn"), "#ff0000", 2);
        }
        else {
            KinkyDungeonDamageEnemy(entity, {
                type: "fire",
                damage: 1 * KDGetEnvironmentalDmg(),
                time: 0,
                bind: 0,
                flags: ["BurningDamage"]
            }, false, true, undefined, undefined, undefined);
        }
        if (KDEntityHasBuff(entity, "Drenched")) {
            KDEntityGetBuff(entity, "Drenched").duration = Math.max(0, KDEntityGetBuff(entity, "Drenched").duration - 4 * delta);
        }
        return true;
    },
};
let KDEffectTileCreateFunctionsCreator = {
    "Ropes": (newTile, existingTile) => {
        KDInferno(newTile, existingTile, 4);
        return true;
    },
    "Vines": (newTile, existingTile) => {
        KDInferno(newTile, existingTile, 6);
        return true;
    },
    "Ice": (newTile, existingTile) => {
        if (existingTile.tags.includes("freezeover")) {
            existingTile.pauseDuration = newTile.duration;
            existingTile.pauseSprite = existingTile.name + "Frozen";
        }
        else if (existingTile.tags.includes("hot")) {
            newTile.duration = 0;
        }
        return true;
    },
    "Slime": (newTile, existingTile) => {
        if (existingTile.tags.includes("ice")) {
            newTile.pauseDuration = newTile.duration;
            newTile.pauseSprite = newTile.name + "Frozen";
        }
        else if (existingTile.tags.includes("ignite")) {
            newTile.duration = 0;
            KDCreateEffectTile(newTile.x, newTile.y, {
                name: "SlimeBurning",
                duration: existingTile.duration / 2,
            }, 0);
        }
        return true;
    },
    "Latex": (newTile, existingTile) => {
        if (existingTile.tags.includes("slime")) {
            existingTile.duration = 0;
        }
        return true;
    },
    "Water": (newTile, existingTile) => {
        if (existingTile.tags.includes("ice")) {
            newTile.pauseDuration = newTile.duration;
            newTile.pauseSprite = newTile.name + "Frozen";
        }
        return true;
    },
    "Ember": (newTile, existingTile) => {
        if (existingTile.tags.includes("fire")) {
            newTile.pauseDuration = existingTile.duration;
            newTile.pauseSprite = newTile.name;
        }
        return true;
    },
    "Sparks": (newTile, existingTile) => {
        if (existingTile.tags.includes("conductive")) {
            let rt = KDEffectTileTags(existingTile.x + 1, existingTile.y);
            let lt = KDEffectTileTags(existingTile.x - 1, existingTile.y);
            let ut = KDEffectTileTags(existingTile.x, existingTile.y - 1);
            let dt = KDEffectTileTags(existingTile.x, existingTile.y + 1);
            let dmg = {
                type: "electric",
                damage: 2.0,
                time: 0,
                bind: 0,
                flags: ["EchoDamage"],
            };
            if (!rt.electric && rt.conductive) {
                KDCreateEffectTile(existingTile.x + 1, existingTile.y, {
                    name: "Sparks",
                    duration: 2,
                }, 2);
                KDDealEnvironmentalDamage(existingTile.x + 1, existingTile.y, 0.5, dmg, undefined);
            }
            if (!lt.electric && lt.conductive) {
                KDCreateEffectTile(existingTile.x - 1, existingTile.y, {
                    name: "Sparks",
                    duration: 2,
                }, 2);
                KDDealEnvironmentalDamage(existingTile.x - 1, existingTile.y, 0.5, dmg, undefined);
            }
            if (!dt.electric && dt.conductive) {
                KDCreateEffectTile(existingTile.x, existingTile.y + 1, {
                    name: "Sparks",
                    duration: 2,
                }, 2);
                KDDealEnvironmentalDamage(existingTile.x, existingTile.y + 1, 0.5, dmg, undefined);
            }
            if (!ut.electric && ut.conductive) {
                KDCreateEffectTile(existingTile.x, existingTile.y - 1, {
                    name: "Sparks",
                    duration: 2,
                }, 2);
                KDDealEnvironmentalDamage(existingTile.x, existingTile.y - 1, 0.5, dmg, undefined);
            }
        }
        return true;
    },
    "WireSparks": (newTile, existingTile) => {
        if (existingTile.tags.includes("wire")) {
            let mapTile = KinkyDungeonTilesGet(newTile.x + ',' + newTile.y);
            if (mapTile === null || mapTile === void 0 ? void 0 : mapTile.wireType) {
                if (KDActivateMapTile[mapTile.wireType](mapTile, newTile.x, newTile.y)) {
                    return true;
                }
            }
            let rt = KDEffectTileTags(existingTile.x + 1, existingTile.y);
            let lt = KDEffectTileTags(existingTile.x - 1, existingTile.y);
            let ut = KDEffectTileTags(existingTile.x, existingTile.y - 1);
            let dt = KDEffectTileTags(existingTile.x, existingTile.y + 1);
            if (!rt.signalFrame && rt.wire) {
                KDCreateEffectTile(existingTile.x + 1, existingTile.y, {
                    name: "WireSparksAct",
                    duration: 1,
                }, 0);
                KDCreateEffectTile(existingTile.x + 1, existingTile.y, {
                    name: "WireSparks",
                    duration: 2,
                }, 0);
            }
            if (!lt.signalFrame && lt.wire) {
                KDCreateEffectTile(existingTile.x - 1, existingTile.y, {
                    name: "WireSparksAct",
                    duration: 1,
                }, 0);
                KDCreateEffectTile(existingTile.x - 1, existingTile.y, {
                    name: "WireSparks",
                    duration: 2,
                }, 0);
            }
            if (!dt.signalFrame && dt.wire) {
                KDCreateEffectTile(existingTile.x, existingTile.y + 1, {
                    name: "WireSparksAct",
                    duration: 1,
                }, 0);
                KDCreateEffectTile(existingTile.x, existingTile.y + 1, {
                    name: "WireSparks",
                    duration: 2,
                }, 0);
            }
            if (!ut.signalFrame && ut.wire) {
                KDCreateEffectTile(existingTile.x, existingTile.y - 1, {
                    name: "WireSparksAct",
                    duration: 1,
                }, 0);
                KDCreateEffectTile(existingTile.x, existingTile.y - 1, {
                    name: "WireSparks",
                    duration: 2,
                }, 0);
            }
        }
        return true;
    },
};
let KDActivateMapTile = {
    "increment": (tile, x, y) => {
        if (!tile.count)
            tile.count = 0;
        tile.count += 1;
        return false;
    },
    "AutoDoor_Toggle": (tile, x, y) => {
        let entity = KinkyDungeonEntityAt(x, y);
        if (entity)
            return true;
        if (KinkyDungeonMapGet(x, y) == 'Z')
            KinkyDungeonMapSet(x, y, 'z');
        else
            KinkyDungeonMapSet(x, y, 'Z');
        return true;
    },
    "Conveyor_Toggle": (tile, x, y) => {
        if (tile.SwitchMode == "Off")
            tile.SwitchMode = "On";
        else
            tile.SwitchMode = "Off";
        return true;
    },
    "Conveyor_Switch": (tile, x, y) => {
        if (tile.DX)
            tile.DX *= -1;
        else if (tile.DY)
            tile.DY *= -1;
        return true;
    },
    "AutoDoor_HoldOpen": (tile, x, y) => {
        KinkyDungeonMapSet(x, y, 'z');
        return true;
    },
    "AutoDoor_HoldClosed": (tile, x, y) => {
        let entity = KinkyDungeonEntityAt(x, y);
        if (entity)
            return true;
        KinkyDungeonMapSet(x, y, 'Z');
        return true;
    },
    "AutoDoor_Open": (tile, x, y) => {
        KinkyDungeonMapSet(x, y, 'z');
        return true;
    },
    "AutoDoor_Close": (tile, x, y) => {
        let entity = KinkyDungeonEntityAt(x, y);
        if (entity)
            return true;
        KinkyDungeonMapSet(x, y, 'Z');
        return true;
    },
};
let KDEffectTileCreateFunctionsExisting = {
    "Ropes": (newTile, existingTile) => {
        KDInferno(existingTile, newTile, 4);
        return true;
    },
    "Vines": (newTile, existingTile) => {
        KDInferno(existingTile, newTile, 6);
        return true;
    },
    "TorchUnlit": (newTile, existingTile) => {
        if (newTile.tags.includes("fire") || newTile.tags.includes("ignite")) {
            existingTile.duration = 0;
            KDCreateEffectTile(existingTile.x, existingTile.y, {
                name: "Torch",
                duration: 9999,
            }, 0);
        }
        return true;
    },
    "Torch": (newTile, existingTile) => {
        if (newTile.tags.includes("freeze")) {
            existingTile.duration = 0;
            KDCreateEffectTile(existingTile.x, existingTile.y, {
                name: "TorchUnlit",
                duration: 9999,
            }, 0);
        }
        return true;
    },
    "Latex": (newTile, existingTile) => {
        if (newTile.tags.includes("slime")) {
            newTile.duration = 0;
        }
        return true;
    },
    "LanternUnlit": (newTile, existingTile) => {
        if (newTile.tags.includes("fire") || newTile.tags.includes("ignite")) {
            existingTile.duration = 0;
            KDCreateEffectTile(existingTile.x, existingTile.y, {
                name: "Lantern",
                duration: 9999,
            }, 0);
        }
        return true;
    },
    "SlimeBurning": (newTile, existingTile) => {
        if (newTile.tags.includes("ice") || newTile.tags.includes("water")) {
            existingTile.duration = 0;
            KDCreateEffectTile(existingTile.x, existingTile.y, {
                name: "Slime",
                duration: existingTile.duration * 2,
            }, 0);
        }
        return true;
    },
};
let KDEffectTileMoveOnFunctions = {
    "Cracked": (entity, tile, willing, dir, sprint) => {
        if (tile.pauseDuration > 0) {
        }
        else if (!entity.Enemy || (!entity.Enemy.tags.earth && !entity.Enemy.tags.unstoppable)) {
            KinkyDungeonApplyBuffToEntity(entity, KDUnsteady);
            if (entity.player) {
                KinkyDungeonApplyBuffToEntity(entity, KDUnsteady2);
                KinkyDungeonApplyBuffToEntity(entity, KDUnsteady3);
            }
            else if (!entity.Enemy || !entity.Enemy.tags.unflinching) {
                if (!entity.vulnerable)
                    entity.vulnerable = 1;
                else
                    entity.vulnerable = Math.max(entity.vulnerable, 1);
            }
        }
        return { cancelmove: false, returnvalue: false };
    },
    "Ice": (entity, tile, willing, dir, sprint) => {
        if (sprint && entity.player && willing && (dir.x || dir.y) && !KinkyDungeonFlags.get("slipped")) {
            KDSlip(dir);
            KinkyDungeonSetFlag("slipped", 1);
            return { cancelmove: true, returnvalue: true };
        }
        return { cancelmove: false, returnvalue: false };
    },
    "Water": (entity, tile, willing, dir, sprint) => {
        if (tile.pauseSprite == tile.name + "Frozen") {
            if (sprint && entity.player && willing && (dir.x || dir.y) && !KinkyDungeonFlags.get("slipped")) {
                KDSlip(dir);
                KinkyDungeonSetFlag("slipped", 1);
                return { cancelmove: true, returnvalue: true };
            }
        }
        return { cancelmove: false, returnvalue: false };
    },
};
let KDTorchExtinguishTypes = ["ice", "frost", "cold", "acid", "water", "stun", "glue"];
let KDSlimeExtinguishTypes = ["ice", "frost", "cold", "acid", "water"];
let KDIgnitionSources = ["fire", "electric"];
let KDEffectTileBulletFunctions = {
    "Ropes": (b, tile, d) => {
        KDIgnition(b, tile, d);
        return true;
    },
    "Vines": (b, tile, d) => {
        KDIgnition(b, tile, d);
        return true;
    },
    "SlimeBurning": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if (KDSlimeExtinguishTypes.includes(type)) {
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "Slime",
                    duration: tile.duration * 2,
                }, 0);
                tile.duration = 0;
            }
        }
        return true;
    },
    "Slime": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if ((KDIgnitionSources.includes(type)) && b.bullet.damage.damage > 0) {
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "SlimeBurning",
                    duration: tile.duration * 0.5,
                }, 0);
                tile.duration = 0;
            }
        }
        return true;
    },
    "Ember": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if (type == "stun" && b.bullet.damage.damage > 1) {
                let newT = KDCreateEffectTile(tile.x, tile.y, {
                    name: "Inferno",
                    duration: 5,
                }, 5);
                if (newT)
                    tile.pauseDuration = newT.duration;
            }
            else if ((type == "ice" || type == "frost" || type == "acid")) {
                tile.duration = 0;
                KDSmokePuff(tile.x, tile.y, 1.5, 0.1, true);
            }
        }
        return true;
    },
    "Torch": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if (KDTorchExtinguishTypes.includes(type)) {
                tile.duration = 0;
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "TorchUnlit",
                    duration: 9999,
                }, 0);
            }
        }
        return true;
    },
    "TorchUnlit": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if ((KDIgnitionSources.includes(type))) {
                tile.duration = 0;
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "Torch",
                    duration: 9999,
                }, 0);
            }
        }
        return true;
    },
    "Lantern": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if (KDTorchExtinguishTypes.includes(type)) {
                tile.duration = 0;
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "LanternUnlit",
                    duration: 9999,
                }, 0);
            }
        }
        return true;
    },
    "LanternUnlit": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if ((KDIgnitionSources.includes(type))) {
                tile.duration = 0;
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "Lantern",
                    duration: 9999,
                }, 0);
            }
        }
        return true;
    },
    "Ice": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if ((KDIgnitionSources.includes(type)) && b.bullet.damage.damage > 0) {
                tile.duration = 0;
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "Water",
                    duration: 2,
                }, 5);
            }
            else if ((type == "ice" || type == "frost") && tile.duration < 4 && tile.duration > 0) {
                tile.duration = 4;
            }
        }
        return true;
    },
    "Water": (b, tile, d) => {
        if (b.bullet.damage) {
            let type = b.bullet.damage.type;
            if ((type == "ice" || type == "frost")) {
                KDCreateEffectTile(tile.x, tile.y, {
                    name: "Ice",
                    duration: 3,
                }, 1);
            }
            else {
                if (type == "fire" && b.bullet.damage.damage > 0) {
                    tile.duration = 0;
                    KDSmokePuff(tile.x, tile.y, 1.5, 0.1, true);
                    KDCreateEffectTile(tile.x, tile.y, {
                        name: "Steam",
                        duration: 6,
                    }, 2);
                }
                if (type == "electric" && b.bullet.damage.damage > 0) {
                    KDCreateEffectTile(tile.x, tile.y, {
                        name: "Sparks",
                        duration: 3,
                    }, 1);
                }
            }
        }
        return true;
    },
};
let KDPathCache = new Map();
let KDPathCacheIgnoreLocks = new Map();
function KDUpdateDoorNavMap() {
    KDPathCache = new Map();
}
let KDPathfindingCacheHits = 0;
let KDPathfindingCacheFails = 0;
let KDPFTrim = 40;
function KinkyDungeonFindPath(startx, starty, endx, endy, blockEnemy, blockPlayer, ignoreLocks, Tiles, RequireLight, noDoors, needDoorMemory, Enemy, trimLongDistance) {
    let tileShort = Tiles;
    if (Tiles == KinkyDungeonMovableTilesSmartEnemy)
        tileShort = "TSE";
    else if (Tiles == KinkyDungeonMovableTilesEnemy)
        tileShort = "TE";
    else if (Tiles == KinkyDungeonGroundTiles)
        tileShort = "TG";
    let index = `${startx},${starty},${endx},${endy},${tileShort}`;
    if (!blockEnemy && !blockPlayer && !RequireLight && !noDoors && !needDoorMemory) {
        if (ignoreLocks) {
            if (KDPathCacheIgnoreLocks.has(index)) {
                KDPathfindingCacheHits++;
                return Object.assign([], KDPathCacheIgnoreLocks.get(index));
            }
        }
        else {
            if (KDPathCache.has(index)) {
                KDPathfindingCacheHits++;
                return Object.assign([], KDPathCache.get(index));
            }
        }
    }
    if (KDistChebyshev(startx - endx, starty - endy) < 1.5) {
        return [{ x: endx, y: endy }];
    }
    function heuristic(xx, yy, endxx, endyy) {
        return ((xx - endxx) * (xx - endxx) + (yy - endyy) * (yy - endyy)) ** 0.5;
    }
    let TilesTemp = Tiles;
    if (noDoors)
        TilesTemp = Tiles.replace("D", "");
    let start = { x: startx, y: starty, g: 0, f: 0, s: "" };
    let open = new Map();
    open.set(startx + "," + starty, start);
    let closed = new Map();
    let costBonus = 0;
    let MapTile = null;
    let moveCost = 1;
    let succ = new Map();
    while (open.size > 0) {
        if (trimLongDistance && open.size > KDPFTrim) {
            console.log("Quit pathfinding");
            return undefined;
        }
        let lowest = {};
        lowest = undefined;
        let lc = 1000000000;
        open.forEach(o => {
            if (o.f < lc) {
                lc = o.f;
                lowest = o;
            }
        });
        if (lowest) {
            let lowLoc = lowest.x + "," + lowest.y;
            moveCost = 1;
            succ = new Map();
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    if (x != 0 || y != 0) {
                        let xx = lowest.x + x;
                        let yy = lowest.y + y;
                        let tile = (xx == endx && yy == endy) ? "" : KinkyDungeonMapGet(xx, yy);
                        MapTile = KinkyDungeonTilesGet((xx) + "," + (yy));
                        let locIndex = `${lowLoc},${endx},${endy},${tileShort}`;
                        if (xx == endx && yy == endy) {
                            closed.set(lowLoc, lowest);
                            let newPath = KinkyDungeonGetPath(closed, lowest.x, lowest.y, endx, endy);
                            if (!blockEnemy && !blockPlayer && !RequireLight && !noDoors && !needDoorMemory) {
                                if (ignoreLocks) {
                                    if (!KDPathCacheIgnoreLocks.has(index))
                                        KDSetPathfindCache(KDPathCacheIgnoreLocks, newPath, endx, endy, tileShort, index);
                                }
                                else {
                                    if (!KDPathCache.has(index))
                                        KDSetPathfindCache(KDPathCache, newPath, endx, endy, tileShort, index);
                                }
                            }
                            KDPathfindingCacheFails++;
                            if (newPath.length > 0 && TilesTemp.includes(KinkyDungeonMapGet(newPath[0].x, newPath[0].y)))
                                return newPath;
                            else
                                return undefined;
                        }
                        else if (!blockEnemy && !blockPlayer && !RequireLight && !noDoors && !needDoorMemory
                            && ((ignoreLocks && KDPathCacheIgnoreLocks.has(locIndex)) || (!ignoreLocks && KDPathCache.has(locIndex)))) {
                            let newPath = [];
                            if (ignoreLocks) {
                                closed.set(lowLoc, lowest);
                                newPath = KinkyDungeonGetPath(closed, lowest.x, lowest.y);
                                let endPath = KDPathCacheIgnoreLocks.get(locIndex);
                                KDPathfindingCacheHits++;
                                newPath.push.apply(newPath, endPath);
                            }
                            else {
                                closed.set(lowLoc, lowest);
                                newPath = KinkyDungeonGetPath(closed, lowest.x, lowest.y);
                                let endPath = KDPathCache.get(locIndex);
                                KDPathfindingCacheHits++;
                                newPath.push.apply(newPath, endPath);
                            }
                            if (newPath.length > 0) {
                                if (ignoreLocks) {
                                    if (!KDPathCacheIgnoreLocks.has(index))
                                        KDSetPathfindCache(KDPathCacheIgnoreLocks, newPath, endx, endy, tileShort, index);
                                }
                                else {
                                    if (!KDPathCache.has(index))
                                        KDSetPathfindCache(KDPathCache, newPath, endx, endy, tileShort, index);
                                }
                                return newPath;
                            }
                            else
                                return undefined;
                        }
                        else if (TilesTemp.includes(tile) && (!RequireLight || KinkyDungeonVisionGet(xx, yy) > 0)
                            && (ignoreLocks || !MapTile || !MapTile.Lock)
                            && (!blockEnemy || KinkyDungeonNoEnemyExceptSub(xx, yy, false, Enemy))
                            && (!blockPlayer || KinkyDungeonPlayerEntity.x != xx || KinkyDungeonPlayerEntity.y != yy)
                            && (!needDoorMemory || tile != "d" || KDOpenDoorTiles.includes(KinkyDungeonTilesMemory[xx + "," + yy]))) {
                            costBonus = 0;
                            if (KinkyDungeonMapGet(xx, yy) == "D")
                                costBonus = 2;
                            else if (KinkyDungeonMapGet(xx, yy) == "d")
                                costBonus = 1;
                            else if (KinkyDungeonMapGet(xx, yy) == "g")
                                costBonus = 2;
                            else if (KinkyDungeonMapGet(xx, yy) == "L")
                                costBonus = 2;
                            costBonus = (MapTile && MapTile.Lock) ? costBonus + 2 : costBonus;
                            costBonus = (MapTile && MapTile.OffLimits) ? costBonus + 8 : costBonus;
                            succ.set(xx + "," + yy, { x: xx, y: yy,
                                g: moveCost + costBonus + lowest.g,
                                f: moveCost + costBonus + lowest.g + heuristic(xx, yy, endx, endy),
                                s: lowLoc });
                        }
                    }
                }
            }
            succ.forEach(s => {
                let q = s.x + "," + s.y;
                let openSucc = open.get(q);
                if (!openSucc || openSucc.f > s.f) {
                    let closedSucc = closed.get(q);
                    if (!closedSucc || closedSucc.f > s.f) {
                        open.set(q, s);
                    }
                }
            });
            open.delete(lowLoc);
            closed.set(lowLoc, lowest);
        }
        else {
            open.clear();
            console.log("Pathfinding error! Please report this!");
        }
    }
    return undefined;
}
function KinkyDungeonGetPath(closed, xx, yy, endx, endy) {
    let list = [];
    if (endx && endy)
        list.push({ x: endx, y: endy });
    let current = closed.get(xx + "," + yy);
    while (current) {
        if (current.s) {
            list.push({ x: current.x, y: current.y });
            current = closed.get(current.s);
        }
        else
            current = undefined;
    }
    return list.reverse();
}
function KDSetPathfindCache(PathMap, newPath, endx, endy, Tiles, Finalindex) {
    for (let i = 0; i < newPath.length - 1; i++) {
        let path = newPath.slice(i);
        let index = `${path[0].x},${path[0].y},${endx},${endy},${Tiles}`;
        PathMap.set(index, path.slice(1));
    }
    if (Finalindex)
        PathMap.set(Finalindex, newPath);
}
function KinkyDungeonSendBuffEvent(Event, data) {
    if (!KDMapHasEvent(KDEventMapBuff, Event))
        return;
    for (let buff of Object.values(KinkyDungeonPlayerBuffs)) {
        if (buff && buff.events) {
            for (let e of buff.events) {
                if (e.trigger == Event) {
                    KinkyDungeonHandleBuffEvent(Event, e, buff, KinkyDungeonPlayerEntity, data);
                }
            }
        }
    }
    for (let ent of KinkyDungeonEntities) {
        if (ent.buffs) {
            for (let buff of Object.values(ent.buffs)) {
                if (buff && buff.events) {
                    for (let e of buff.events) {
                        if (e.trigger == Event) {
                            KinkyDungeonHandleBuffEvent(Event, e, buff, ent, data);
                        }
                    }
                }
            }
        }
    }
}
function KinkyDungeonTickBuffs(list, delta, endFloor, entity) {
    for (const [key, value] of Object.entries(list)) {
        if (value) {
            if (value.endFloor && endFloor)
                KinkyDungeonExpireBuff(list, key);
            else if (value.endSleep && KDGameData.SleepTurns > 1)
                KinkyDungeonExpireBuff(list, key);
            else if (!value.duration || value.duration < 0)
                KinkyDungeonExpireBuff(list, key);
            else {
                if (value.type == "restore_mp")
                    KinkyDungeonChangeMana(value.power);
                if (value.type == "restore_wp")
                    KinkyDungeonChangeWill(value.power);
                if (value.type == "restore_sp")
                    KinkyDungeonChangeStamina(value.power);
                if (value.type == "restore_ap")
                    KinkyDungeonChangeDistraction(value.power, true);
                if (value.type == "SpellCastConstant" && value.spell && entity) {
                    KinkyDungeonCastSpell(entity.x, entity.y, KinkyDungeonFindSpell(value.spell, true), undefined, undefined, undefined);
                }
                if (value.type == "Flag") {
                    KinkyDungeonSetFlag(value.id, 1 + delta);
                }
                if (!(value.infinite))
                    value.duration -= delta;
            }
        }
    }
}
function KinkyDungeonTickBuffTag(list, tag, Amount = 1) {
    if (list)
        for (const [key, value] of Object.entries(list)) {
            if (value) {
                if (value.maxCount && value.tags.includes(tag)) {
                    if (!value.currentCount)
                        value.currentCount = 0;
                    value.currentCount += Amount;
                    if (value.currentCount >= value.maxCount)
                        KinkyDungeonExpireBuff(list, key);
                }
            }
        }
}
function KDEntityHasBuffTags(entity, tag) {
    let list = entity.player ? KinkyDungeonPlayerBuffs : entity.buffs;
    if (list) {
        for (const buff of Object.values(list)) {
            if (buff) {
                if (buff.tags && buff.tags.includes(tag))
                    return true;
            }
        }
    }
    return false;
}
function KDGetBuffsWithTag(entity, tag) {
    let ret = {};
    let list = entity.player ? KinkyDungeonPlayerBuffs : entity.buffs;
    if (list) {
        for (const [key, buff] of Object.entries(list)) {
            if (buff) {
                if (buff.tags && buff.tags.includes(tag))
                    ret[key] = buff;
            }
        }
    }
    return ret;
}
function KinkyDungeonRemoveBuffsWithTag(entity, tags) {
    let list = null;
    if (entity && entity.player) {
        list = KinkyDungeonPlayerBuffs;
    }
    else if (entity.buffs)
        list = entity.buffs;
    if (list)
        for (const [key, value] of Object.entries(list)) {
            if (value) {
                for (let t of tags)
                    if (value.tags && value.tags.includes(t)) {
                        KinkyDungeonExpireBuff(list, key);
                    }
            }
        }
}
function KinkyDungeonUpdateBuffs(delta, endFloor) {
    KinkyDungeonSendEvent("tickBuffs", { delta: delta });
    KinkyDungeonTickBuffs(KinkyDungeonPlayerBuffs, delta, endFloor, KinkyDungeonPlayerEntity);
    for (let enemy of KinkyDungeonEntities) {
        if (!enemy.buffs)
            enemy.buffs = {};
        KinkyDungeonTickBuffs(enemy.buffs, delta, endFloor, enemy);
    }
    for (let b of KinkyDungeonBullets) {
        if (b.bullet.spell && b.bullet.spell.buffs) {
            for (let buff of b.bullet.spell.buffs) {
                if (buff.player && buff.range >= Math.sqrt((KinkyDungeonPlayerEntity.x - b.x) * (KinkyDungeonPlayerEntity.x - b.x) + (KinkyDungeonPlayerEntity.y - b.y) * (KinkyDungeonPlayerEntity.y - b.y))) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, buff);
                }
                if (buff.enemies) {
                    for (let enemy of KinkyDungeonEntities) {
                        if ((KDHostile(enemy) || !buff.noAlly)
                            && (KDAllied(enemy) || !buff.onlyAlly)
                            && (!b.bullet.spell.filterTags || b.bullet.spell.filterTags.some((tag) => { return enemy.Enemy.tags[tag]; }))
                            && buff.range >= Math.sqrt((enemy.x - b.x) * (enemy.x - b.x) + (enemy.y - b.y) * (enemy.y - b.y))) {
                            KinkyDungeonApplyBuff(enemy.buffs, buff);
                        }
                    }
                }
            }
        }
    }
}
function KinkyDungeonGetBuffedStat(list, Stat, onlyPositiveDuration) {
    let stat = 0;
    if (list)
        for (let buff of Object.values(list)) {
            if (buff && buff.type == Stat && (!onlyPositiveDuration || buff.duration > 0)) {
                stat += buff.power;
            }
        }
    return stat;
}
function KinkyDungeonExpireBuff(list, key) {
    delete list[key];
}
function KinkyDungeonApplyBuffToEntity(entity, origbuff, changes) {
    if (entity && entity.player) {
        KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, origbuff, changes);
    }
    else if (entity) {
        if (!entity.buffs)
            entity.buffs = {};
        KinkyDungeonApplyBuff(entity.buffs, origbuff, changes);
    }
}
function KinkyDungeonApplyBuff(list, origbuff, changes) {
    if (!origbuff)
        return;
    let buff = {};
    Object.assign(buff, origbuff);
    if (changes)
        Object.assign(buff, changes);
    let id = buff.id ? buff.id : buff.name;
    if (list[id] && buff.cancelOnReapply) {
        KinkyDungeonExpireBuff(list, id);
    }
    else {
        if (!list[id] && buff.sfxApply)
            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + buff.sfxApply + ".ogg");
        if (!list[id] || (list[id].power > 0 && buff.power >= list[id].power) || (list[id].power < 0 && ((buff.power > 0 && buff.power >= list[id].power) || buff.power <= list[id].power)))
            list[id] = buff;
        if ((list[id].power && buff.power == list[id].power && buff.duration >= list[id].duration))
            list[id].duration = buff.duration;
        if (buff.tags)
            for (let tag of buff.tags) {
                if (tag == "darkness" && list == KinkyDungeonPlayerBuffs) {
                    KinkyDungeonBlindLevelBase = Math.max(KinkyDungeonBlindLevelBase, 1);
                }
                else if (tag == "heavydarkness" && list == KinkyDungeonPlayerBuffs) {
                    KinkyDungeonBlindLevelBase = Math.max(KinkyDungeonBlindLevelBase, 2);
                }
            }
    }
}
function KinkyDungeonGetbuff(list, Buff) {
    if (list && list[Buff])
        return list[Buff];
    else
        return null;
}
function KinkyDungeonHasBuff(list, Buff) {
    if (list && list[Buff])
        return true;
    else
        return false;
}
function KDEntityHasBuff(entity, buff) {
    if (entity.player) {
        return KinkyDungeonHasBuff(KinkyDungeonPlayerBuffs, buff);
    }
    else
        return KinkyDungeonHasBuff(entity.buffs, buff);
}
function KDEntityBuffedStat(entity, stat) {
    if (entity.player) {
        return KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, stat);
    }
    else
        return KinkyDungeonGetBuffedStat(entity.buffs, stat);
}
function KDEntityGetBuff(entity, buff) {
    if (entity.player) {
        return KinkyDungeonGetbuff(KinkyDungeonPlayerBuffs, buff);
    }
    else
        return KinkyDungeonGetbuff(entity.buffs, buff);
}
let KinkyDungeonAttackTwiceFlag = false;
let KinkyDungeonSlimeParts = [
    { group: "ItemHead", restraint: "SlimeHead", noUnmasked: true },
    { group: "ItemMouth", restraint: "SlimeMouth" },
    { group: "ItemArms", restraint: "SlimeArms" },
    { group: "ItemHands", restraint: "SlimeHands" },
    { group: "ItemLegs", restraint: "SlimeLegs" },
    { group: "ItemFeet", restraint: "SlimeFeet" },
    { group: "ItemBoots", restraint: "SlimeBoots" },
];
let KDAlertCD = 5;
let KDEventDataReset = {};
let KDEventDataBase = {
    SlimeLevel: 0,
    SlimeLevelStart: 0,
};
let KDEventData = Object.assign({}, KDEventDataBase);
function KDMapHasEvent(map, event) {
    return map[event] != undefined;
}
function KinkyDungeonSendEvent(Event, data, forceSpell) {
    KinkyDungeonSendMagicEvent(Event, data, forceSpell);
    KinkyDungeonSendWeaponEvent(Event, data);
    KinkyDungeonSendInventoryEvent(Event, data);
    KinkyDungeonSendBulletEvent(Event, data.bullet, data);
    KinkyDungeonSendBuffEvent(Event, data);
    KinkyDungeonSendOutfitEvent(Event, data);
    KinkyDungeonSendEnemyEvent(Event, data);
    KinkyDungeonHandleGenericEvent(Event, data);
}
function KinkyDungeonResetEventVariables() {
    KinkyDungeonHandleGenericEvent("resetEventVar", {});
}
function KinkyDungeonResetEventVariablesTick(delta) {
    KDEventDataReset = {};
    KinkyDungeonAttackTwiceFlag = false;
    KinkyDungeonHandleGenericEvent("resetEventVarTick", { delta: delta });
}
let KDEventMapInventory = {
    "postApply": {
        "ControlHarness": (e, item, data) => {
            var _a;
            let itemAdded = data.item;
            let itemtags = (_a = KDRestraint(itemAdded)) === null || _a === void 0 ? void 0 : _a.shrine;
            console.log(itemtags);
            if (itemtags === null || itemtags === void 0 ? void 0 : itemtags.includes("Cyber")) {
                for (let category of Object.values(KDControlHarnessCategories)) {
                    if (category.activateTags.some((tag) => { return itemtags.includes(tag); })) {
                        let restMap = new Map();
                        for (let tag of category.activateTags) {
                            for (let inv of KinkyDungeonGetRestraintsWithShrine(tag, false, true)) {
                                if (!restMap.has(inv)) {
                                    restMap.set(inv, true);
                                }
                            }
                        }
                        category.updateFunction(e, item, data, [...restMap.keys()]);
                        if (restMap.size == category.activateCount) {
                            category.activateFunction(e, item, data, [...restMap.keys()]);
                        }
                    }
                }
            }
        }
    },
    "calcOrgThresh": {
        "CurseSensitivity": (e, item, data) => {
            if (data.player == KinkyDungeonPlayerEntity) {
                data.threshold *= e.power;
            }
        }
    },
    "orgasm": {
        "CurseSubmission": (e, item, data) => {
            if (data.player == KinkyDungeonPlayerEntity) {
                KinkyDungeonChangeRep("Ghost", e.power);
                KinkyDungeonSendTextMessage(3, TextGet("KDSubmissionCurseApply")
                    .replace("RESTRAINTNAME", TextGet("Restraint" + item.name)), "#ceaaed", 10);
            }
        },
        "PunishEvent": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (e.msg && (e.always || !KDGameData.CurrentVibration))
                    KinkyDungeonSendTextMessage(1, TextGet(e.msg).replace("[RESTRAINTNAME]", TextGet("Restraint" + item.name)), "#aaaaaa", 1);
                KinkyDungeonSendEvent("punish", Object.assign({
                    item: item,
                    type: "orgasm",
                    kind: e.kind || "low",
                }, data));
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
    },
    "calcPlayChance": {
        "CurseAttraction": (e, item, data) => {
            if (data.enemy) {
                data.playChance += e.power;
                if (!data.enemy.playWithPlayer && data.enemy.playWithPlayerCD > 5) {
                    data.enemy.playWithPlayerCD = 5;
                }
            }
        }
    },
    "changeDistraction": {
        "multDistractionPos": (e, item, data) => {
            if (data.Amount > 0)
                data.Amount *= e.power;
        },
    },
    "changeWill": {
        "multWillPos": (e, item, data) => {
            if (data.Amount > 0)
                data.Amount *= e.power;
        },
    },
    "changeStamina": {
        "multStaminaPos": (e, item, data) => {
            if (data.Amount > 0)
                data.Amount *= e.power;
        },
    },
    "getLights": {
        "ItemLight": (e, item, data) => {
            data.lights.push({ brightness: e.power, x: KinkyDungeonPlayerEntity.x, y: KinkyDungeonPlayerEntity.y, color: string2hex(e.color) });
        },
    },
    "onWear": {
        "setSkinColor": (e, item, data) => {
            if (item == data.item) {
                data.color[0] = "#9A7F76";
                if (KinkyDungeonPlayer && KinkyDungeonPlayer.Appearance) {
                    let color = InventoryGet(KinkyDungeonPlayer, "BodyUpper").Color;
                    if (color == "Asian") {
                        data.color[0] = "#8B7B70";
                    }
                    else if (color == "Black") {
                        data.color[0] = "#684832";
                    }
                }
            }
        }
    },
    "afterDress": {
        "PrisonerJacket": (e, item, data) => {
            for (let A = 0; A < KinkyDungeonPlayer.Appearance.length; A++) {
                let asset = KinkyDungeonPlayer.Appearance[A].Asset;
                if (asset.Name == KDRestraint(item).Asset) {
                    KinkyDungeonPlayer.Appearance[A].Property = {
                        "Text": "PATIENT",
                        "Type": "ShortsAndStraps",
                        "Block": [
                            "ItemNipples",
                            "ItemNipplesPiercings",
                            "ItemTorso",
                            "ItemBreast",
                            "ItemHands",
                            "ItemVulva",
                            "ItemVulvaPiercings",
                            "ItemButt",
                            "ItemPelvis"
                        ],
                        "Hide": [
                            "Cloth",
                            "ClothLower",
                            "ItemNipplesPiercings",
                            "ItemVulva",
                            "ItemVulvaPiercings",
                            "ItemButt",
                            "Panties",
                            "Corset"
                        ],
                        "HideItemExclude": [
                            "ClothLowerJeans1",
                            "ClothLowerJeans2",
                            "ClothLowerLatexPants1",
                            "ClothLowerLeggings1",
                            "ClothLowerLeggings2",
                            "PantiesHarnessPanties1",
                            "PantiesHarnessPanties2"
                        ]
                    };
                }
            }
        },
    },
    "kill": {
        "MikoGhost": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (data.enemy && data.enemy.lifetime == undefined && data.enemy.playerdmg && !data.enemy.Enemy.tags.ghost && !data.enemy.Enemy.tags.construct) {
                    KinkyDungeonSummonEnemy(data.enemy.x, data.enemy.y, "MikoGhost", 1, 1.5, true);
                    KinkyDungeonSendTextMessage(5, TextGet("KDMikoCollarSummmon"), "purple", 2);
                }
            }
        },
        "DollmakerMask": (e, item, data) => {
            var _a;
            if ((_a = data.enemy) === null || _a === void 0 ? void 0 : _a.Enemy.tags.escapeddoll)
                KinkyDungeonSetFlag("DollmakerGrace", 70);
        },
    },
    "drawSGTooltip": {
        "curseInfo": (e, item, data) => {
            var _a;
            if (item == data.item || ((_a = KDRestraint(item)) === null || _a === void 0 ? void 0 : _a.Group) == data.group) {
                let pre = item == data.item ? "" : TextGet("Restraint" + item.name) + ": ";
                data.extraLines.push(pre + TextGet("curseInfo" + e.msg));
                data.extraLineColor.push(e.color);
            }
        },
    },
    "perksBonus": {
        "spellDamage": (e, item, data) => {
            KDDamageAmpPerksSpell += e.power;
        },
    },
    "calcBlind": {
        "DollmakerMask": (e, item, data) => {
            if (!KinkyDungeonFlags.get("DollmakerGrace")) {
                data.blindness = Math.max(data.blindness, 5);
                KinkyDungeonSendTextMessage(2, TextGet("KDDollmakerMaskDim"), "#ff5555", 2, true);
            }
        },
    },
    "draw": {
        "DollmakerMask": (e, item, data) => {
            let altType = KDGetAltType(MiniGameKinkyDungeonLevel);
            if (altType && altType.spawns === false)
                return;
            for (let enemy of KinkyDungeonEntities) {
                if (enemy.Enemy.tags.escapeddoll
                    && KDistChebyshev(KinkyDungeonPlayerEntity.x - enemy.x, KinkyDungeonPlayerEntity.y - enemy.y) < 12) {
                    KDDraw(kdcanvas, kdpixisprites, enemy.id + "_dolltarg", KinkyDungeonRootDirectory + "UI/DollmakerTarget.png", (enemy.visual_x - data.CamX - data.CamX_offset - 0.5) * KinkyDungeonGridSizeDisplay, (enemy.visual_y - data.CamY - data.CamY_offset - 0.5) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize * 2, KinkyDungeonSpriteSize * 2, undefined, {
                        zIndex: 10,
                    });
                }
            }
        },
    },
    "tick": {
        "DollmakerMask": (e, item, data) => {
            let altType = KDGetAltType(MiniGameKinkyDungeonLevel);
            if (altType && altType.spawns === false)
                return;
            if (KDRandom() < 0.1) {
                let count = 0;
                for (let en of KinkyDungeonEntities) {
                    if (en.Enemy.tags.escapeddoll)
                        count += 1;
                }
                if (count < 10) {
                    let point = KinkyDungeonGetRandomEnemyPoint(true, false, undefined, 6, 10);
                    if (point) {
                        DialogueCreateEnemy(point.x, point.y, "DollmakerTarget");
                    }
                }
            }
        },
        "RemoveOnBuffName": (e, item, data) => {
            if (KinkyDungeonPlayerBuffs[e.kind] && (!e.chance || KDRandom() < e.chance)) {
                item.curse = "";
                KinkyDungeonLock(item, "");
                KinkyDungeonSendTextMessage(5, TextGet("KDRemoveOnDmgType").replace("RESTRAINTNAME", TextGet("Restraint" + item.name)), "lightgreen", 2);
            }
        },
        "armorBuff": (e, item, data) => {
            KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: item.name + "Armor", type: "Armor", power: e.power, duration: 2, });
        },
        "spellWardBuff": (e, item, data) => {
            KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: item.name + "SpellResist", type: "SpellResist", power: e.power, duration: 2, });
        },
        "sneakBuff": (e, item, data) => {
            KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: item.name + "Sneak", type: "SlowDetection", power: e.power, duration: 2, });
        },
        "evasionBuff": (e, item, data) => {
            KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: item.name + "Evasion", type: "Evasion", power: e.power, duration: 2, });
        },
        "buff": (e, item, data) => {
            KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: item.name + e.buff, type: e.buff, power: e.power, duration: 2,
                tags: e.tags,
                currentCount: e.mult ? -1 : undefined,
                maxCount: e.mult, });
        },
        "restraintBlock": (e, item, data) => {
            KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: item.name + "Block", type: "RestraintBlock", power: e.power, duration: 2, });
        },
        "ShadowHandTether": (e, item, data) => {
            let enemy = (item.tx && item.ty) ? KinkyDungeonEnemyAt(item.tx, item.ty) : undefined;
            if (KinkyDungeonFlags.get("ShadowDommed") || (KDGameData.KinkyDungeonLeashedPlayer > 0 && KinkyDungeonLeashingEnemy() && enemy != KinkyDungeonLeashingEnemy())) {
                item.tx = undefined;
                item.ty = undefined;
            }
            else {
                if (item.tx && item.ty && (!enemy || (e.requiredTag && !enemy.Enemy.tags[e.requiredTag]))) {
                    item.tx = undefined;
                    item.ty = undefined;
                    return;
                }
                else {
                    for (enemy of KDNearbyEnemies(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, e.dist)) {
                        if (!e.requiredTag || enemy.Enemy.tags[e.requiredTag]) {
                            item.tx = enemy.x;
                            item.ty = enemy.y;
                        }
                    }
                }
            }
        },
        "Buff": (e, item, data) => {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                id: item.name,
                type: e.buffType,
                power: e.power,
                tags: e.tags,
                currentCount: e.mult ? -1 : undefined,
                maxCount: e.mult,
                duration: 2
            });
        },
        "PeriodicTeasing": (e, item, data) => {
            if (!data.delta)
                return;
            if (!e.chance || KDRandom() < e.chance) {
                if (!KDGameData.CurrentVibration && KDIsVibeCD(e.cooldown)) {
                    KinkyDungeonStartVibration(item.name, "normal", KDGetVibeLocation(item), e.power, e.time, undefined, undefined, undefined, undefined, e.edgeOnly);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
            }
        },
        "PeriodicDenial": (e, item, data) => {
            if (!data.delta)
                return;
            if (!e.chance || KDRandom() < e.chance) {
                if (!KDGameData.CurrentVibration && KDIsVibeCD(e.cooldown)) {
                    KinkyDungeonStartVibration(item.name, "normal", KDGetVibeLocation(item), e.power, e.time, undefined, 12, undefined, undefined, undefined, false, 0.1, 1.0);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
                else {
                    KinkyDungeonAddVibeModifier(item.name, "tease", KDRestraint(item).Group, 0, 9, e.power, false, true, false, false, true, 0.1, 1.0);
                }
            }
        },
        "AccuracyBuff": (e, item, data) => {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                id: item.name + e.type + e.trigger,
                type: "Accuracy",
                duration: 1,
                power: e.power
            });
        },
        "spellRange": (e, item, data) => {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                id: item.name + e.type + e.trigger,
                type: "spellRange",
                duration: 1,
                power: e.power
            });
        },
        "SneakBuff": (e, item, data) => {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                id: item.name + e.type + e.trigger,
                type: "Sneak",
                duration: 1,
                power: e.power
            });
        },
        "EvasionBuff": (e, item, data) => {
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                id: item.name + e.type + e.trigger,
                type: "Evasion",
                duration: 1,
                power: e.power
            });
        },
        "AllyHealingAura": (e, item, data) => {
            if (!data.delta)
                return;
            let healed = false;
            for (let enemy of KinkyDungeonEntities) {
                if (KDAllied(enemy) && KDistEuclidean(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) <= e.aoe) {
                    let origHP = enemy.hp;
                    enemy.hp = Math.min(enemy.hp + e.power, enemy.Enemy.maxhp);
                    if (enemy.hp - origHP > 0) {
                        KinkyDungeonSendFloater(enemy, `+${Math.round((enemy.hp - origHP) * 10)}`, "#44ff77", 3);
                        healed = true;
                    }
                }
            }
            if (healed) {
                if (e.energyCost)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        },
        "EnchantedAnkleCuffs2": (e, item, data) => {
            KinkyDungeonRemoveRestraint(KDRestraint(item).Group);
            KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName("EnchantedAnkleCuffs"), 0, true, undefined, false, undefined, undefined, undefined, item.faction);
        },
        "EnchantedAnkleCuffs": (e, item, data) => {
            if (KDGameData.AncientEnergyLevel <= 0.0000001) {
                KinkyDungeonRemoveRestraint(KDRestraint(item).Group);
                KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName("EnchantedAnkleCuffs2"), 0, true, undefined, false, undefined, undefined, undefined, item.faction);
            }
        },
        "RegenMana": (e, item, data) => {
            if (!e.limit || KinkyDungeonStatMana / KinkyDungeonStatManaMax < e.limit) {
                if (e.energyCost && KinkyDungeonStatMana < KinkyDungeonStatManaMax - 0.01)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                KinkyDungeonChangeMana(e.power);
            }
        },
        "RegenStamina": (e, item, data) => {
            if (!e.limit || KinkyDungeonStatStamina / KinkyDungeonStatStaminaMax < e.limit) {
                if (e.energyCost && KinkyDungeonStatStamina < KinkyDungeonStatStaminaMax - 0.01)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                KinkyDungeonChangeStamina(e.power);
            }
        },
        "ApplySlowLevelBuff": (e, item, data) => {
            if (item.type === Restraint) {
                if (KinkyDungeonPlayerBuffs[item.name + e.type + e.trigger])
                    delete KinkyDungeonPlayerBuffs[item.name + e.type + e.trigger];
                KinkyDungeonCalculateSlowLevel(0);
                if (KinkyDungeonSlowLevel > 0) {
                    if (e.energyCost)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                        id: item.name + e.type + e.trigger,
                        type: "SlowLevel",
                        duration: 2,
                        power: e.power
                    });
                }
            }
        },
        "AlertEnemies": (e, item, data) => {
            if (!data.delta)
                return;
            if (!e.chance || KDRandom() < e.chance) {
                KinkyDungeonAlert = Math.max(KinkyDungeonAlert, e.power);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonAlertEnemies").replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
        "iceDrain": (e, item, data) => {
            if (!data.delta)
                return;
            if (e.power) {
                KinkyDungeonChangeMana(e.power);
                KinkyDungeonChangeStamina(e.power);
                KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonIceDrain"), "lightblue", 2, true);
            }
        },
        "crystalDrain": (e, item, data) => {
            if (!data.delta)
                return;
            if (e.power) {
                KinkyDungeonChangeMana(e.power);
                KinkyDungeonChangeDistraction(-e.power * 3 * KDBuffResist(KinkyDungeonPlayerBuffs, "soul"), false, 0.1);
                KinkyDungeonSendTextMessage(1, TextGet("KinkyDungeonCrystalDrain"), "lightblue", 2, true);
            }
        },
        "tickleDrain": (e, item, data) => {
            if (!data.delta)
                return;
            if (e.power) {
                KinkyDungeonChangeDistraction(-e.power * KDBuffResist(KinkyDungeonPlayerBuffs, "tickle"), false, 0.01);
                KinkyDungeonSendTextMessage(0.5, TextGet("KinkyDungeonTickleDrain"), "lightblue", 2, true);
            }
        },
        "barrelDebuff": (e, item, data) => {
            if (!data.delta)
                return;
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Counterbarrel", type: "SlowDetection", duration: 1, power: -10, player: true, enemies: true, endSleep: true, tags: ["SlowDetection", "move", "cast"] });
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Counterbarrel3", type: "Sneak", duration: 1, power: -10, player: true, enemies: true, endSleep: true, tags: ["Sneak", "move", "cast"] });
        },
        "cageDebuff": (e, item, data) => {
            if (!data.delta)
                return;
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Countercage", type: "SlowDetection", duration: 1, power: -5, player: true, enemies: true, endSleep: true, tags: ["SlowDetection", "move", "cast"] });
            KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Countercage2", type: "Sneak", duration: 1, power: -10, player: true, enemies: true, endSleep: true, tags: ["Sneak", "move", "cast"] });
        },
        "callGuard": (e, item, data) => {
            if (!data.delta)
                return;
            if (!KinkyDungeonFlags.has("GuardCalled") && KDRandom() < 0.25) {
                KinkyDungeonSetFlag("GuardCalled", 35);
                console.log("Attempting to call guard");
                if (KinkyDungeonEntities.length < 400) {
                    console.log("Called guard");
                    KinkyDungeonCallGuard(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, true, true);
                }
            }
        },
        "callGuardFurniture": (e, item, data) => {
            if (!data.delta)
                return;
            if (!KinkyDungeonFlags.has("GuardCalled") && KDRandom() < (e.chance ? e.chance : 0.1)) {
                KinkyDungeonSetFlag("GuardCalled", 35);
                console.log("Attempting to call guard");
                if (KinkyDungeonEntities.length < 400 || KDGameData.CagedTime > KDMaxCageTime) {
                    console.log("Called guard");
                    let requireTags = null;
                    if (KinkyDungeonFlags.has("callGuardJailerOnly")) {
                        requireTags = ["jailer"];
                    }
                    let ee = KinkyDungeonCallGuard(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, true, true, requireTags);
                    if (ee) {
                        let point = KinkyDungeonGetRandomEnemyPoint(true);
                        if (point) {
                            ee.x = point.x;
                            ee.y = point.y;
                        }
                    }
                    if (ee && (KDGameData.PrisonerState == 'parole' || KDGameData.PrisonerState == 'jail')) {
                        ee.IntentAction = 'freeFurniture';
                        ee.playWithPlayer = 12;
                    }
                }
            }
            let guard = KinkyDungeonJailGuard();
            if (guard && !KinkyDungeonFlags.has("guardTP") && KDGameData.CagedTime > KDMaxCageTime && KDistChebyshev(guard.x - KinkyDungeonPlayerEntity.x, guard.y - KinkyDungeonPlayerEntity.y) > 4) {
                DialogueBringSpecific(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, guard);
                KinkyDungeonSetFlag("guardTP", 20);
            }
        },
        "slimeSpread": (e, item, data) => {
            if (!data.delta)
                return;
            let mult = 0.4 * Math.max(0.25, Math.min(2.0, KinkyDungeonMultiplicativeStat(KinkyDungeonGetBuffedStat(KinkyDungeonPlayerBuffs, "glueDamageResist"))));
            KDEventData.SlimeLevel = Math.max(KDEventData.SlimeLevel, KDEventData.SlimeLevelStart + e.power * mult);
            if (KDEventData.SlimeLevel >= 0.99999) {
                KDEventData.SlimeLevel = 0;
                KDEventData.SlimeLevelStart = -100;
                let slimedParts = [];
                let potentialSlimeParts = [];
                for (let inv of KinkyDungeonAllRestraint()) {
                    if (KDRestraint(inv).slimeLevel > 0) {
                        slimedParts.push({
                            name: KDRestraint(inv).name,
                            group: KDRestraint(inv).Group,
                            level: KDRestraint(inv).slimeLevel
                        });
                    }
                }
                for (let slime of slimedParts) {
                    let index = -1;
                    for (let i = 0; i < KinkyDungeonSlimeParts.length; i++)
                        if (KinkyDungeonSlimeParts[i].group === slime.group) {
                            index = i;
                            break;
                        }
                    if (index >= 0) {
                        let slime2 = undefined;
                        let slime3 = undefined;
                        if (index > 0) {
                            for (let s of potentialSlimeParts)
                                if (s.group === KinkyDungeonSlimeParts[index - 1].group && !(s.level > slime.level)) {
                                    slime2 = s;
                                    break;
                                }
                            if (!slime2 && (!KinkyDungeonStatsChoice.has("Unmasked") || !KinkyDungeonSlimeParts[index - 1].noUnmasked))
                                potentialSlimeParts.push({
                                    group: KinkyDungeonSlimeParts[index - 1].group,
                                    restraint: (e.restraint ? e.restraint : "") + KinkyDungeonSlimeParts[index - 1].restraint,
                                    level: slime.level
                                });
                        }
                        if (index < KinkyDungeonSlimeParts.length - 1) {
                            for (let s of potentialSlimeParts)
                                if (s.group === KinkyDungeonSlimeParts[index + 1].group && !(s.level > slime.level)) {
                                    slime3 = s;
                                    break;
                                }
                            if (!slime3 && (!KinkyDungeonStatsChoice.has("Unmasked") || !KinkyDungeonSlimeParts[index + 1].noUnmasked))
                                potentialSlimeParts.push({
                                    group: KinkyDungeonSlimeParts[index + 1].group,
                                    restraint: (e.restraint ? e.restraint : "") + KinkyDungeonSlimeParts[index + 1].restraint,
                                    level: slime.level
                                });
                        }
                    }
                }
                let slimed = false;
                if (potentialSlimeParts.length === 0) {
                    KDEventData.SlimeLevel = Math.min(KDEventData.SlimeLevel, 0.5);
                    KDEventData.SlimeLevelStart = Math.min(KDEventData.SlimeLevelStart, 0.5);
                }
                else
                    while (potentialSlimeParts.length > 0) {
                        let newSlime = potentialSlimeParts[Math.floor(KDRandom() * potentialSlimeParts.length)];
                        if (newSlime) {
                            let added = KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName(newSlime.restraint), 0, true);
                            if (added) {
                                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSlimeSpread"), "#ff44ff", 3);
                                potentialSlimeParts = [];
                                KDEventData.SlimeLevel = -100;
                                slimed = true;
                            }
                        }
                        potentialSlimeParts.splice(potentialSlimeParts.indexOf(newSlime), 1);
                    }
                if (!slimed && potentialSlimeParts.length === 0) {
                    let slime = slimedParts[Math.floor(KDRandom() * slimedParts.length)];
                    if (KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("Hard" + slime.name), 0, true)) {
                        KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonSlimeHarden"), "#ff44ff", 3);
                        let slimesuit = (e.restraint ? e.restraint : "") + "SlimeSuit";
                        if (KinkyDungeonCurrentDress !== slimesuit) {
                            KinkyDungeonSetDress(slimesuit, "");
                            KinkyDungeonDressPlayer();
                            KinkyDungeonSendTextMessage(6, TextGet("KinkyDungeonSlimeSpread"), "#ff44ff", 3);
                        }
                    }
                    KDEventData.SlimeLevel = -100;
                }
            }
        }
    },
    "remove": {
        "slimeStop": (e, item, data) => {
            if (data.item === item)
                KDEventData.SlimeLevel = 0;
        },
        "unlinkItem": (e, item, data) => {
            if (data.item === item && !data.add && !data.shrine) {
                console.log("Deprecated function");
                console.log(Event, e, item, data);
                console.trace();
            }
        },
    },
    "postRemoval": {
        "replaceItem": (e, item, data) => {
            if (data.item === item && !data.add && !data.shrine && e.list) {
                for (let restraint of e.list) {
                    KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName(restraint), e.power, true, e.lock, data.keep);
                }
            }
        },
        "RequireBaseArmCuffs": (e, item, data) => {
            if (data.item !== item && KDRestraint(item).Group) {
                let cuffsbase = false;
                for (let inv of KinkyDungeonAllRestraint()) {
                    if (KDRestraint(inv).shrine && (KDRestraint(inv).shrine.includes("ArmCuffsBase"))) {
                        cuffsbase = true;
                        break;
                    }
                    else if (inv.dynamicLink) {
                        let link = inv.dynamicLink;
                        for (let i = 0; i < 20; i++) {
                            if (link && KDRestraint(link).shrine && (KDRestraint(link).shrine.includes("ArmCuffsBase"))) {
                                cuffsbase = true;
                                break;
                            }
                            if (link.dynamicLink)
                                link = link.dynamicLink;
                            else
                                i = 200;
                        }
                    }
                }
                if (!cuffsbase) {
                    KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false, false);
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonRemoveCuffs"), "lightgreen", 2);
                }
            }
        },
        "RequireCollar": (e, item, data) => {
            if (data.item !== item && KDRestraint(item).Group) {
                let collar = false;
                for (let inv of KinkyDungeonAllRestraint()) {
                    if (KDRestraint(inv).shrine && (KDRestraint(inv).shrine.includes("Collars"))) {
                        collar = true;
                        break;
                    }
                }
                if (!collar) {
                    KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false, false);
                }
            }
        },
        "RequireBaseAnkleCuffs": (e, item, data) => {
            if (data.item !== item && KDRestraint(item).Group) {
                let cuffsbase = false;
                for (let inv of KinkyDungeonAllRestraint()) {
                    if (KDRestraint(inv).shrine && (KDRestraint(inv).shrine.includes("AnkleCuffsBase"))) {
                        cuffsbase = true;
                        break;
                    }
                    else if (inv.dynamicLink) {
                        let link = inv.dynamicLink;
                        for (let i = 0; i < 20; i++) {
                            if (link && KDRestraint(link).shrine && (KDRestraint(link).shrine.includes("AnkleCuffsBase"))) {
                                cuffsbase = true;
                                break;
                            }
                            if (link.dynamicLink)
                                link = link.dynamicLink;
                            else
                                i = 200;
                        }
                    }
                }
                if (!cuffsbase) {
                    KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false, false);
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonRemoveCuffs"), "lightgreen", 2);
                }
            }
        },
        "RequireBaseLegCuffs": (e, item, data) => {
            if (data.item !== item && KDRestraint(item).Group) {
                let cuffsbase = false;
                for (let inv of KinkyDungeonAllRestraint()) {
                    if (KDRestraint(inv).shrine && (KDRestraint(inv).shrine.includes("LegCuffsBase"))) {
                        cuffsbase = true;
                        break;
                    }
                    else if (inv.dynamicLink) {
                        let link = inv.dynamicLink;
                        for (let i = 0; i < 20; i++) {
                            if (link && KDRestraint(link).shrine && (KDRestraint(link).shrine.includes("LegCuffsBase"))) {
                                cuffsbase = true;
                                break;
                            }
                            if (link.dynamicLink)
                                link = link.dynamicLink;
                            else
                                i = 200;
                        }
                    }
                }
                if (!cuffsbase) {
                    KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false, false);
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonRemoveCuffs"), "lightgreen", 2);
                }
            }
        },
        "armbinderHarness": (e, item, data) => {
            if (data.item !== item && KDRestraint(item).Group) {
                let armbinder = false;
                for (let inv of KinkyDungeonAllRestraint()) {
                    if (KDRestraint(inv).shrine && (KDRestraint(inv).shrine.includes("Armbinders") || KDRestraint(inv).shrine.includes("Boxbinders"))) {
                        armbinder = true;
                        break;
                    }
                    else if (inv.dynamicLink) {
                        let link = inv.dynamicLink;
                        for (let i = 0; i < 10; i++) {
                            if (link && KDRestraint(link).shrine && (KDRestraint(link).shrine.includes("Armbinders") || KDRestraint(link).shrine.includes("Boxbinders"))) {
                                armbinder = true;
                                break;
                            }
                            if (link.dynamicLink)
                                link = link.dynamicLink;
                            else
                                i = 10;
                        }
                    }
                }
                if (!armbinder) {
                    KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false, false);
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonRemoveArmbinderHarness"), "lightgreen", 2);
                }
            }
        }
    },
    "hit": {
        "linkItem": (e, item, data) => {
            var _a;
            if ((data.attack && data.attack.includes("Bind") && (!data.enemy || data.enemy.Enemy.bound) && !data.attack.includes("Suicide"))) {
                let added = false;
                if (data.restraintsAdded) {
                    for (let r of data.restraintsAdded) {
                        if (r.name === item.name) {
                            added = true;
                            break;
                        }
                    }
                }
                if (!added) {
                    let subMult = 1;
                    let chance = e.chance ? e.chance : 1.0;
                    if (e.subMult !== undefined) {
                        let rep = (KinkyDungeonGoddessRep.Ghost + 50) / 100;
                        subMult = 1.0 + e.subMult * rep;
                    }
                    if (((_a = e.tags) === null || _a === void 0 ? void 0 : _a.includes("lowwill")) && KinkyDungeonStatWill < 0.1)
                        chance = 1.0;
                    if (item && KDRestraint(item).Link && (KDRandom() < chance * subMult) && (!e.noLeash || KDGameData.KinkyDungeonLeashedPlayer < 1)) {
                        let newRestraint = KinkyDungeonGetRestraintByName(KDRestraint(item).Link);
                        if (KDToggles.Sound && e.sfx)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                        KinkyDungeonAddRestraint(newRestraint, item.tightness, true, "", false, undefined, undefined, undefined, item.faction);
                    }
                }
            }
        }
    },
    "beforePlayerDamage": {
        "RemoveOnDmg": (e, item, data) => {
            let t = data.type;
            if (KDDamageEquivalencies[data.type])
                t = KDDamageEquivalencies[data.type];
            if (data.type && t == e.damage && data.dmg) {
                if (!e.power || data.dmg >= e.power) {
                    let count = getItemDataNumber(item, e.kind) || 0;
                    count = count + Math.max(data.dmg || 1, 1);
                    setItemDataNumber(item, e.kind, count);
                    if (!e.count || count >= e.count) {
                        item.curse = "";
                        KinkyDungeonLock(item, "");
                        KinkyDungeonSendTextMessage(5, TextGet("KDRemoveOnDmgType").replace("RESTRAINTNAME", TextGet("Restraint" + item.name)), "lightgreen", 2);
                    }
                    else {
                        KinkyDungeonSendTextMessage(5, TextGet("KDRemoveOnDmgTypePartial").replace("RESTRAINTNAME", TextGet("Restraint" + item.name)), "lightgreen", 2);
                    }
                }
            }
        },
        "linkItemOnDamageType": (e, item, data) => {
            if (data.type && data.type == e.damage && data.dmg) {
                let subMult = 1;
                let chance = e.chance ? e.chance : 1.0;
                if (item && KDRestraint(item).Link && KDRandom() < chance * subMult) {
                    let prereq = KDEventPrereq(e.requiredTag);
                    if (prereq) {
                        let newRestraint = KinkyDungeonGetRestraintByName(KDRestraint(item).Link);
                        if (KDToggles.Sound && e.sfx)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                        KinkyDungeonAddRestraint(newRestraint, item.tightness, true, "", false, undefined, undefined, undefined, item.faction);
                    }
                }
            }
        },
        "lockItemOnDamageType": (e, item, data) => {
            if (data.type && data.type == e.damage && data.dmg) {
                let subMult = 1;
                let chance = e.chance ? e.chance : 1.0;
                if (item && KinkyDungeonGetLockMult(e.lock) > KinkyDungeonGetLockMult(item.lock) && KDRandom() < chance * subMult) {
                    let prereq = KDEventPrereq(e.requiredTag);
                    if (prereq) {
                        KinkyDungeonLock(item, e.lock);
                    }
                }
            }
        },
    },
    "miss": {
        "EnergyCost": (e, item, data) => {
            if (e.energyCost && KinkyDungeonStatMana < KinkyDungeonStatManaMax - 0.01)
                KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
        }
    },
    "calcEvasion": {
        "HandsFree": (e, item, data) => {
            if (data.flags.KDEvasionHands) {
                data.flags.KDEvasionHands = false;
                if (data.cost && e.energyCost && KinkyDungeonStatMana < KinkyDungeonStatManaMax - 0.01)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        },
        "BlindFighting": (e, item, data) => {
            if (data.flags.KDEvasionSight) {
                data.flags.KDEvasionSight = false;
                if (data.cost && e.energyCost && KinkyDungeonStatMana < KinkyDungeonStatManaMax - 0.01)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        }
    },
    "beforePlayerAttack": {
        "BoostDamage": (e, item, data) => {
            data.buffdmg = Math.max(0, data.buffdmg + e.power);
            if (e.energyCost && KinkyDungeonStatMana < KinkyDungeonStatManaMax - 0.01)
                KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
        },
    },
    "beforeDamage": {
        "ModifyDamageFlat": (e, item, data) => {
            if (data.damage > 0) {
                if (!e.chance || KDRandom() < e.chance) {
                    data.damage = Math.max(data.damage + e.power, 0);
                    if (e.energyCost)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                }
            }
        },
    },
    "beforeDamageEnemy": {
        "MultiplyDamageStealth": (e, item, data) => {
            if (data.dmg > 0 && data.enemy && KDHostile(data.enemy) && !data.enemy.aware) {
                if (!e.chance || KDRandom() < e.chance) {
                    let dmg = Math.max(0, Math.min(data.enemy.hp, data.dmg));
                    if (e.energyCost && e.power > 1)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost * dmg * (e.power - 1));
                    data.dmg = Math.max(data.dmg * e.power, 0);
                }
            }
        },
        "AddDamageStealth": (e, item, data) => {
            if (data.dmg > 0 && data.enemy && KDHostile(data.enemy) && !data.enemy.aware) {
                if (!e.chance || KDRandom() < e.chance) {
                    if (e.energyCost && e.power > 1)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost * (e.power - 1));
                    data.dmg = Math.max(data.dmg + e.power, 0);
                }
            }
        },
        "MultiplyDamageStatus": (e, item, data) => {
            if (data.dmg > 0 && data.enemy && KDHostile(data.enemy) && (KinkyDungeonHasStatus(data.enemy))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let dmg = Math.max(0, Math.min(data.enemy.hp, data.dmg));
                    if (e.energyCost && e.power > 1)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost * dmg * (e.power - 1));
                    data.dmg = Math.max(data.dmg * e.power, 0);
                }
            }
        },
        "MultiplyDamageMagic": (e, item, data) => {
            if (data.dmg > 0 && data.incomingDamage && !KinkyDungeonMeleeDamageTypes.includes(data.incomingDamage.type)) {
                if (!e.chance || KDRandom() < e.chance) {
                    let dmg = Math.max(0, Math.min(data.enemy.hp, data.dmg));
                    if (e.energyCost && e.power > 1)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost * dmg * (e.power - 1));
                    data.dmg = Math.max(data.dmg * e.power, 0);
                }
            }
        }
    },
    "defeat": {
        "linkItem": (e, item, data) => {
            if (item && KDRestraint(item).Link && (KDRandom() < e.chance)) {
                let newRestraint = KinkyDungeonGetRestraintByName(KDRestraint(item).Link);
                KinkyDungeonAddRestraint(newRestraint, item.tightness, true, "", false, undefined, undefined, undefined, item.faction);
            }
        },
        "Kittify": (e, item, data) => {
            KinkyDungeonRemoveRestraint("ItemArms", false, false, true, false);
            KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName("KittyPetSuit"), 15, undefined, undefined, undefined, undefined, undefined, undefined, item.faction);
            let collared = InventoryGet(KinkyDungeonPlayer, "ItemNeck");
            if (collared != null) {
                KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName("BasicLeash"), 1, false, "Red", undefined, undefined, undefined, undefined, item.faction);
            }
        },
    },
    "struggle": {
        "crotchrope": (e, item, data) => {
            if (data.restraint && data.restraint.type === Restraint && KDRestraint(data.restraint).crotchrope && data.struggleType === "Struggle" && data.struggleType === "Remove") {
                KinkyDungeonChangeDistraction(1, false, 0.5);
                KinkyDungeonSendTextMessage(3, TextGet("KinkyDungeonCrotchRope").replace("RestraintName", TextGet("Restraint" + data.restraint.name)), "pink", 3);
            }
        },
        "VibeOnStruggle": (e, item, data) => {
            if ((!e.chance || KDRandom() < e.chance) && data.struggleType === "Struggle") {
                if (e.msg && (e.always || !KDGameData.CurrentVibration))
                    KinkyDungeonSendTextMessage(1, TextGet(e.msg).replace("[RESTRAINTNAME]", TextGet("Restraint" + item.name)), "#aaaaaa", 1);
                KinkyDungeonSendEvent("punish", Object.assign({
                    item: item,
                    type: "struggle",
                    kind: e.kind || "low",
                }, data));
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
        "celestialRopePunish": (e, item, data) => {
            if (data.restraint && item === data.restraint) {
                KinkyDungeonChangeDistraction(3);
                KinkyDungeonChangeMana(-1);
                KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind + 1, 2);
                for (let A = 0; A < KinkyDungeonPlayer.Appearance.length; A++) {
                    if (KinkyDungeonPlayer.Appearance[A].Asset.Group.Name === "Eyes" || KinkyDungeonPlayer.Appearance[A].Asset.Group.Name === "Eyes2") {
                        let property = KinkyDungeonPlayer.Appearance[A].Property;
                        if (!property || property.Expression !== "Surprised") {
                            KinkyDungeonPlayer.Appearance[A].Property = { Expression: "Surprised" };
                            KDRefresh = true;
                        }
                    }
                }
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonCelestialPunish" + Math.floor(KDRandom() * 3)), "#ff0000", 2);
            }
        },
        "crystalPunish": (e, item, data) => {
            if (data.restraint && item === data.restraint) {
                KinkyDungeonChangeDistraction(1, false, 0.1);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonCrystalPunish" + Math.floor(KDRandom() * 3)), "#ff0000", 2);
            }
        },
        "PunishPlayer": (e, item, data) => {
            if (data.restraint && item === data.restraint) {
                if (KDRandom() < e.chance || (KDGameData.WarningLevel > 2 && KDRandom() < e.warningchance)) {
                    if (e.stun && KDGameData.WarningLevel > 2) {
                        KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, e.stun);
                        KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    }
                    KDGameData.WarningLevel += 1;
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
                    KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer") + (KDGameData.WarningLevel > 2 ? "Harsh" : "")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
            }
        }
    },
    "beforeStruggleCalc": {
        "boostWater": (e, item, data) => {
            if (KinkyDungeonPlayerBuffs.Drenched && KinkyDungeonPlayerBuffs.Drenched.duration > 0) {
                data.escapeChance += e.power;
                let msg = e.msg ? e.msg : "KinkyDungeonDrenchedSlimeBuff";
                if (msg) {
                    KinkyDungeonSendTextMessage(5, TextGet(msg).replace("RestraintName", TextGet("Restraint" + data.restraint.name)), "lightgreen", 2);
                }
            }
        },
        "ShockForStruggle": (e, item, data) => {
            if (data.struggleType === "Struggle") {
                if (KDRandom() < e.chance || (KDGameData.WarningLevel > 2 && KDRandom() < e.warningchance) || data.group == "ItemNeck") {
                    if (e.stun && KDGameData.WarningLevel > 2) {
                        KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, e.stun);
                        KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    }
                    data.escapePenalty += e.bind ? e.bind : 0.1;
                    KDGameData.WarningLevel += 1;
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
                    KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer") + (KDGameData.WarningLevel > 2 ? "Harsh" : "")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
            }
        },
        "elbowCuffsBlock": (e, item, data) => {
            if (data.restraint && item != data.restraint && !(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && KDRestraint(data.restraint).shrine.includes("ArmCuffsBase")) {
                data.escapePenalty += e.power ? e.power : 1.0;
                KinkyDungeonSendTextMessage(10, TextGet("KDElbowCuffsBlock" + Math.floor(KDRandom() * 3)), "#ff0000", 2);
            }
        },
        "vibeStruggle": (e, item, data) => {
            if (KinkyDungeonHasCrotchRope && !KinkyDungeonPlayerTags.get("ChastityLower") && data.restraint && item == data.restraint && !(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && (KinkyDungeonIsHandsBound(false, false, 0.45) || KinkyDungeonIsArmsBound())) {
                data.escapePenalty += data.escapeChance;
                KinkyDungeonSendTextMessage(10, TextGet("KDCrotchRopeBlock" + Math.floor(KDRandom() * 3)), "#ff0000", 2);
            }
        },
        "struggleDebuff": (e, item, data) => {
            var _a, _b;
            if (e.StruggleType == data.struggleType && data.restraint && item != data.restraint && ((_b = (_a = KDRestraint(data.restraint)) === null || _a === void 0 ? void 0 : _a.shrine) === null || _b === void 0 ? void 0 : _b.includes(e.requiredTag))) {
                data.escapePenalty += e.power;
                if (e.msg)
                    KinkyDungeonSendTextMessage(2, TextGet(e.msg), "#ff5555", 2);
            }
        },
        "obsidianDebuff": (e, item, data) => {
            if (data.restraint && data.struggleType === "Struggle" && item != data.restraint && !(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && KDRestraint(data.restraint).shrine.includes("Obsidian")) {
                data.escapePenalty += e.power ? e.power : 0.075;
                KinkyDungeonSendTextMessage(5, TextGet("KDObsidianDebuff" + Math.floor(KDRandom() * 3)), "#8800aa", 2, true);
            }
        },
        "latexDebuff": (e, item, data) => {
            if (data.restraint && data.struggleType === "Struggle" && item != data.restraint && KDRestraint(data.restraint).shrine.includes("Latex")) {
                data.escapePenalty += e.power ? e.power : 0.075;
                KinkyDungeonSendTextMessage(5, TextGet("KDLatexDebuff" + Math.floor(KDRandom() * 3)), "#38a2c3", 2, true);
            }
        },
        "shadowBuff": (e, item, data) => {
            if (data.restraint && data.struggleType === "Struggle" && item == data.restraint) {
                let brightness = KinkyDungeonBrightnessGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
                if (brightness > 4) {
                    data.escapeChance += 0.1 * brightness;
                    KinkyDungeonSendTextMessage(7, TextGet("KDShadowBuff"), "#99ff99", 2, true);
                }
            }
        },
        "wristCuffsBlock": (e, item, data) => {
            if (data.restraint && item != data.restraint && !(KinkyDungeonHasGhostHelp() || KinkyDungeonHasAllyHelp()) && KDRestraint(data.restraint).shrine.includes("ArmCuffsBase")) {
                data.escapePenalty += e.power ? e.power : 0.075;
                KinkyDungeonSendTextMessage(5, TextGet("KDWristCuffsBlock" + Math.floor(KDRandom() * 3)), "#ff0000", 2);
            }
        },
    },
    "sprint": {
        "MotionSensitive": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (e.msg && (e.always || !KDGameData.CurrentVibration))
                    KinkyDungeonSendTextMessage(1, TextGet(e.msg).replace("[RESTRAINTNAME]", TextGet("Restraint" + item.name)), "#aaaaaa", 1);
                KinkyDungeonSendEvent("punish", Object.assign({
                    item: item,
                    type: "sprint",
                    kind: e.kind || "low",
                }, data));
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
    },
    "playerAttack": {
        "MotionSensitive": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (e.msg && (e.always || !KDGameData.CurrentVibration))
                    KinkyDungeonSendTextMessage(1, TextGet(e.msg).replace("[RESTRAINTNAME]", TextGet("Restraint" + item.name)), "#aaaaaa", 1);
                KinkyDungeonSendEvent("punish", Object.assign({
                    item: item,
                    type: "attack",
                    kind: e.kind || "low",
                }, data));
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
        "ShadowHeel": (e, item, data) => {
            if (data.targetX && data.targetY && !(data.enemy && data.enemy.Enemy && KDAllied(data.enemy))) {
                KinkyDungeonCastSpell(data.targetX, data.targetY, KinkyDungeonFindSpell("HeelShadowStrike", true), undefined, undefined, undefined);
                if (e.energyCost)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        },
        "AlertEnemies": (e, item, data) => {
            if (KDAlertCD < 1 && data.enemy && (!e.chance || KDRandom() < e.chance)) {
                KinkyDungeonAlert = Math.max(KinkyDungeonAlert, e.power);
                KDAlertCD = 5;
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonAlertEnemies").replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
        "PunishPlayer": (e, item, data) => {
            if (item.type === Restraint && data.targetX && data.targetY && data.enemy && !(data.enemy && data.enemy.Enemy && KDAllied(data.enemy)) && (!KinkyDungeonHiddenFactions.includes(KDGetFaction(data.enemy)) || KDGetFaction(data.enemy) == "Enemy")) {
                if (KDRandom() < e.chance || (KDGameData.WarningLevel > 2 && KDRandom() < e.warningchance)) {
                    if (e.stun && KDGameData.WarningLevel > 2) {
                        KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, e.stun);
                        KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    }
                    KDGameData.WarningLevel += 1;
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
                    KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer") + (KDGameData.WarningLevel > 2 ? "Harsh" : "")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
            }
        },
        "cursePunish": (e, item, data) => {
            if (item.type === Restraint && data.targetX && data.targetY && data.enemy && !(data.enemy && data.enemy.Enemy && KDAllied(data.enemy)) && (!KinkyDungeonHiddenFactions.includes(KDGetFaction(data.enemy)) || KDGetFaction(data.enemy) == "Enemy")) {
                if (!e.chance || KDRandom() < e.chance) {
                    if (e.stun) {
                        KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, e.stun);
                        KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    }
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
                    if (!data.cursePunish) {
                        KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                        if (e.sfx)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                    }
                    data.cursePunish = true;
                }
            }
        },
        "armorNoise": (e, item, data) => {
            if (item.type === Restraint && data.targetX && data.targetY && data.enemy && !data.armorNoise) {
                if (!e.chance || KDRandom() < e.chance) {
                    KinkyDungeonMakeNoise(e.dist, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
                    KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                    KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, `${TextGet("KDArmorNoise")}`, "#ffffff", 5);
                    data.armorNoise = true;
                }
            }
        },
    },
    "calcMiscast": {
        "ReduceMiscastFlat": (e, item, data) => {
            if (data.miscastChance > 0) {
                data.miscastChance -= e.power;
            }
        }
    },
    "remoteVibe": {
        "RemoteActivatedVibe": (e, item, data) => {
            if (!KDGameData.CurrentVibration) {
                KinkyDungeonStartVibration(item.name, "tease", KDGetVibeLocation(item), e.power, e.time, undefined, undefined, undefined, undefined, e.edgeOnly);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonStartVibeRemote").replace("EnemyName", TextGet("Name" + data.enemy)), "pink", 2);
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        }
    },
    "remotePunish": {
        "RemoteActivatedShock": (e, item, data) => {
            var _a;
            const enemy = data.enemy;
            if (!enemy || KDRandom() >= (((_a = enemy.Enemy.RemoteControl) === null || _a === void 0 ? void 0 : _a.punishRemoteChance) || 0.25) || KDEnemyHasFlag(enemy, "remoteShockCooldown") || (e.noLeash && KDGameData.KinkyDungeonLeashedPlayer >= 1)) {
                return;
            }
            KinkyDungeonSetEnemyFlag(enemy, "remoteShockCooldown", 7);
            if (e.stun) {
                KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, e.stun);
                KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
            }
            KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
            const msg = TextGet(e.msg ? e.msg : "KinkyDungeonRemoteShock")
                .replace("RestraintName", TextGet(`Restraint${item.name}`))
                .replace("EnemyName", TextGet(`Name${enemy.Enemy.name}`));
            KinkyDungeonSendTextMessage(5, msg, "#ff8800", 2);
            if (e.sfx)
                KinkyDungeonPlaySound(`${KinkyDungeonRootDirectory}/Audio/${e.sfx}.ogg`);
        },
        "RemoteLinkItem": (e, item, data) => {
            var _a;
            const enemy = data.enemy;
            if (KDRandom() >= (((_a = enemy.Enemy.RemoteControl) === null || _a === void 0 ? void 0 : _a.punishRemoteChance) || 0.1) || (e.noLeash && KDGameData.KinkyDungeonLeashedPlayer >= 1)) {
                return;
            }
            const newRestraint = KinkyDungeonGetRestraintByName(KDRestraint(item).Link);
            if (e.sfx)
                KinkyDungeonPlaySound(`${KinkyDungeonRootDirectory}/Audio/${e.sfx}.ogg`);
            KinkyDungeonAddRestraint(newRestraint, item.tightness, true, "", false, undefined, undefined, undefined, item.faction, undefined, undefined, undefined, false);
            if (e.enemyDialogue) {
                const dialogue = KinkyDungeonGetTextForEnemy(e.enemyDialogue, enemy);
                KinkyDungeonSendDialogue(enemy, dialogue, KDGetColor(enemy), 2, 4);
            }
            if (e.msg) {
                const msg = TextGet(e.msg)
                    .replace("RestraintName", TextGet(`Restraint${item.name}`))
                    .replace("EnemyName", TextGet(`Name${enemy.Enemy.name}`));
                KinkyDungeonSendTextMessage(5, msg, "#ff8800", 2);
            }
        }
    },
    "playerMove": {
        "removeOnMove": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (!e.prereq || KDCheckPrereq(KinkyDungeonPlayerEntity)) {
                    KinkyDungeonRemoveRestraint(KDRestraint(item).Group, false, false);
                }
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
    },
    "punish": {
        "PunishSelf": (e, item, data) => {
            if (item == data.item && (!e.kind || data.kind == e.kind) && (!e.requireTags || e.requireTags.includes(data.kind)) && (!e.filterTags || !e.filterTags.includes(data.kind))) {
                if (!e.chance || KDRandom() < e.chance) {
                    if (!KDGameData.CurrentVibration) {
                        KinkyDungeonStartVibration(item.name, "tease", KDGetVibeLocation(item), e.power, e.time, undefined, undefined, undefined, undefined, e.edgeOnly);
                    }
                    else {
                        KinkyDungeonAddVibeModifier(item.name, "reinforce", KDRestraint(item).Group, 1, e.time);
                    }
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
            }
        },
        "PunishShock": (e, item, data) => {
            if (item == data.item && (!e.kind || data.kind == e.kind) && (!e.requireTags || e.requireTags.includes(data.kind)) && (!e.filterTags || !e.filterTags.includes(data.kind))) {
                if (!e.chance || KDRandom() < e.chance) {
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
                    if (e.msg && (e.always || !KDGameData.CurrentVibration))
                        KinkyDungeonSendTextMessage(1, TextGet(e.msg).replace("[RESTRAINTNAME]", TextGet("Restraint" + item.name)), "#aaaaaa", 1);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
            }
        },
    },
    "playSelf": {
        "PunishEvent": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (e.msg && (e.always || !KDGameData.CurrentVibration))
                    KinkyDungeonSendTextMessage(1, TextGet(e.msg).replace("[RESTRAINTNAME]", TextGet("Restraint" + item.name)), "#aaaaaa", 1);
                KinkyDungeonSendEvent("punish", Object.assign({
                    item: item,
                    type: "playSelf",
                    kind: e.kind || "low",
                }, data));
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
    },
    "playerCast": {
        "MagicallySensitive": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (e.msg && (e.always || !KDGameData.CurrentVibration))
                    KinkyDungeonSendTextMessage(1, TextGet(e.msg).replace("[RESTRAINTNAME]", TextGet("Restraint" + item.name)), "#aaaaaa", 1);
                KinkyDungeonSendEvent("punish", Object.assign({
                    item: item,
                    type: "cast",
                    kind: e.kind || "low",
                }, data));
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
        "AlertEnemies": (e, item, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                KinkyDungeonAlert = Math.max(KinkyDungeonAlert, e.power);
                KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonAlertEnemies").replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
        "PunishPlayer": (e, item, data) => {
            if (data.spell && item.type === Restraint && (!e.punishComponent || (data.spell.components && data.spell.components.includes(e.punishComponent)))) {
                if (KDRandom() < e.chance || (KDGameData.WarningLevel > 2 && KDRandom() < e.warningchance)) {
                    if (e.stun && KDGameData.WarningLevel > 2) {
                        KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, e.stun);
                        KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    }
                    KDGameData.WarningLevel += 1;
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
                    KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer") + (KDGameData.WarningLevel > 2 ? "Harsh" : "")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                }
            }
        },
        "cursePunish": (e, item, data) => {
            if (data.spell && item.type === Restraint && (!e.punishComponent || (data.spell.components && data.spell.components.includes(e.punishComponent)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    if (e.stun) {
                        KinkyDungeonStatBlind = Math.max(KinkyDungeonStatBlind, e.stun);
                        KinkyDungeonMovePoints = Math.max(-1, KinkyDungeonMovePoints - 1);
                    }
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage });
                    if (!data.cursePunish) {
                        KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                        if (e.sfx)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                    }
                    data.cursePunish = true;
                }
            }
        },
        "armorNoise": (e, item, data) => {
            if (data.spell && item.type === Restraint && (!e.punishComponent || (data.spell.components && data.spell.components.includes(e.punishComponent))) && !data.armorNoise) {
                if (!e.chance || KDRandom() < e.chance) {
                    KinkyDungeonMakeNoise(e.dist, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
                    KinkyDungeonSendTextMessage(5, TextGet((e.msg ? e.msg : "KinkyDungeonPunishPlayer")).replace("RestraintName", TextGet("Restraint" + item.name)), "#ff8800", 2);
                    if (e.sfx)
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                    KinkyDungeonSendFloater(KinkyDungeonPlayerEntity, `${TextGet("KDArmorNoise")}`, "#ffffff", 5);
                    data.armorNoise = true;
                }
            }
        },
    }
};
function KinkyDungeonHandleInventoryEvent(Event, kinkyDungeonEvent, item, data) {
    if (Event === kinkyDungeonEvent.trigger && KDEventMapInventory[Event] && KDEventMapInventory[Event][kinkyDungeonEvent.type]) {
        KDEventMapInventory[Event][kinkyDungeonEvent.type](kinkyDungeonEvent, item, data);
    }
}
let KDEventMapBuff = {
    "beforeDamageEnemy": {
        "Conduction": (e, buff, entity, data) => {
            if (data.enemy == entity && (!data.flags || !data.flags.includes("EchoDamage")) && data.dmg > 0 && (!e.damage || e.damage == data.type)) {
                if (!e.chance || KDRandom() < e.chance) {
                    let maxSprites = 7;
                    let sprites = 0;
                    for (let enemy of KinkyDungeonEntities) {
                        if (enemy.buffs && enemy.buffs.Conduction && enemy != data.enemy && enemy.hp > 0 && KDistEuclidean(enemy.x - data.enemy.x, enemy.y - data.enemy.y) <= e.aoe) {
                            KinkyDungeonDamageEnemy(enemy, {
                                type: e.damage,
                                damage: data.dmg * e.power,
                                flags: ["EchoDamage"]
                            }, false, true, undefined, undefined, undefined, "Rage");
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Conduction.ogg");
                            let dist = KDistEuclidean(enemy.x - data.enemy.x, enemy.y - data.enemy.y);
                            let tx = enemy.x;
                            let ty = enemy.y;
                            if (dist > 0 && sprites < maxSprites)
                                for (let d = dist / 2.99; d < dist; d += dist / 2.99) {
                                    let xx = entity.x + d * (tx - entity.x);
                                    let yy = entity.y + d * (ty - entity.y);
                                    let newB = { born: 0, time: 1 + Math.round(KDRandom() * 1), x: Math.round(xx), y: Math.round(yy), vx: 0, vy: 0, xx: xx, yy: yy, spriteID: KinkyDungeonGetEnemyID() + "ElectricEffect" + CommonTime(),
                                        bullet: { faction: "Rage", spell: undefined, damage: undefined, lifetime: 2, passthrough: true, name: "ElectricEffect", width: 1, height: 1 } };
                                    KinkyDungeonBullets.push(newB);
                                    KinkyDungeonUpdateSingleBulletVisual(newB, false);
                                    sprites += 1;
                                }
                        }
                    }
                    if (KinkyDungeonPlayerBuffs.Conduction && KDistEuclidean(data.enemy.x - KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y - data.enemy.y) <= e.aoe) {
                        KinkyDungeonSendTextMessage(6, TextGet("KDConductionDamageTaken").replace("DAMAGEDEALT", "" + data.dmg * e.power), "#ff0000", 2);
                        KinkyDungeonDealDamage({
                            type: e.damage,
                            damage: data.dmg * e.power,
                            flags: ["EchoDamage"],
                        });
                        KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Conduction.ogg");
                        let dist = KDistEuclidean(KinkyDungeonPlayerEntity.x - data.enemy.x, KinkyDungeonPlayerEntity.y - data.enemy.y);
                        let tx = KinkyDungeonPlayerEntity.x;
                        let ty = KinkyDungeonPlayerEntity.y;
                        if (dist > 0)
                            for (let d = dist / 2.99; d < dist; d += dist / 2.99) {
                                let xx = entity.x + d * (tx - entity.x);
                                let yy = entity.y + d * (ty - entity.y);
                                let newB = { born: 0, time: 1 + Math.round(KDRandom() * 1), x: Math.round(xx), y: Math.round(yy), vx: 0, vy: 0, xx: xx, yy: yy, spriteID: KinkyDungeonGetEnemyID() + "ElectricEffect" + CommonTime(),
                                    bullet: { faction: "Rage", spell: undefined, damage: undefined, lifetime: 2, passthrough: true, name: "ElectricEffect", width: 1, height: 1 } };
                                KinkyDungeonBullets.push(newB);
                                KinkyDungeonUpdateSingleBulletVisual(newB, false);
                            }
                    }
                }
            }
        },
        "EchoDamage": (e, buff, entity, data) => {
            if (data.enemy == entity && (!data.flags || (!data.flags.includes("EchoDamage"))) && data.dmg > 0 && (!e.damageTrigger || data.type == e.damageTrigger)) {
                KinkyDungeonDamageEnemy(entity, {
                    type: e.damage,
                    damage: data.dmg * e.power,
                    flags: ["EchoDamage"]
                }, false, false, undefined, undefined, undefined, data.faction);
            }
        },
        "Volcanism": (e, buff, entity, data) => {
            if (data.enemy == entity && (!data.flags || (!data.flags.includes("VolcanicDamage") && !data.flags.includes("BurningDamage"))) && data.dmg > 0 && (data.type == "fire")) {
                KinkyDungeonCastSpell(data.enemy.x, data.enemy.y, KinkyDungeonFindSpell("VolcanicStrike", true), undefined, undefined, undefined, "Rock");
                data.enemy.hp = 0;
            }
        },
        "Flammable": (e, buff, entity, data) => {
            if ((!data.flags || !data.flags.includes("BurningDamage")) && !KDEntityHasBuff(entity, "Drenched") && data.dmg > 0 && (data.type == "fire")) {
                KinkyDungeonApplyBuffToEntity(entity, KDBurning);
            }
        },
    },
    "beforePlayerDamage": {
        "Flammable": (e, buff, entity, data) => {
            if ((!data.flags || !data.flags.includes("BurningDamage")) && !KDEntityHasBuff(entity, "Drenched") && data.dmg > 0 && (data.type == "fire")) {
                KinkyDungeonApplyBuffToEntity(entity, KDBurning);
            }
        },
        "Conduction": (e, buff, entity, data) => {
            if ((!data.flags || !data.flags.includes("EchoDamage")) && data.dmg > 0 && (!e.damage || e.damage == data.type)) {
                if (!e.chance || KDRandom() < e.chance) {
                    for (let enemy of KinkyDungeonEntities) {
                        if (enemy.buffs && enemy.buffs.Conduction && enemy.hp > 0 && KDistEuclidean(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) <= e.aoe) {
                            KinkyDungeonDamageEnemy(enemy, {
                                type: e.damage,
                                damage: data.dmg * e.power,
                                flags: ["EchoDamage"]
                            }, false, true, undefined, undefined, undefined, "Rage");
                            let dist = KDistEuclidean(enemy.x - entity.x, enemy.y - entity.y);
                            let tx = enemy.x;
                            let ty = enemy.y;
                            if (dist > 0)
                                for (let d = 0; d <= dist; d += dist / 3.01) {
                                    let xx = entity.x + d * (tx - entity.x);
                                    let yy = entity.y + d * (ty - entity.y);
                                    let newB = { born: 0, time: 1 + Math.round(KDRandom() * 1), x: Math.round(xx), y: Math.round(yy), vx: 0, vy: 0, xx: xx, yy: yy, spriteID: KinkyDungeonGetEnemyID() + "ElectricEffect" + CommonTime(),
                                        bullet: { faction: "Rage", spell: undefined, damage: undefined, lifetime: 2, passthrough: true, name: "ElectricEffect", width: 1, height: 1 } };
                                    KinkyDungeonBullets.push(newB);
                                    KinkyDungeonUpdateSingleBulletVisual(newB, false);
                                }
                        }
                    }
                }
            }
        },
        "EchoDamage": (e, buff, entity, data) => {
            if ((!data.flags || !data.flags.includes("EchoDamage")) && data.dmg > 0 && (!e.damageTrigger || e.damageTrigger == data.type)) {
                KinkyDungeonSendTextMessage(6, TextGet("KDBurningFanFlamesDamageTaken").replace("DAMAGEDEALT", "" + data.dmg * e.power), "#ff0000", 2);
                KinkyDungeonDealDamage({
                    type: e.damage,
                    damage: data.dmg * e.power,
                    flags: ["EchoDamage"],
                });
            }
        },
    },
    "beforeAttack": {
        "CounterattackDamage": (e, buff, entity, data) => {
            if (data.attacker && data.target == entity && (!(e.prereq == "hit") || (!data.missed && data.hit)) && (data.attacker.player || !data.target.player || KinkyDungeonAggressive(data.attacker))) {
                if (data.attacker.player) {
                    KinkyDungeonDealDamage({ damage: e.power, type: e.damage, bind: e.bind, time: e.time, bindType: e.bindType, });
                }
                else {
                    KinkyDungeonDamageEnemy(data.attacker, { damage: e.power, type: e.damage, bind: e.bind, bindType: e.bindType, time: e.time }, false, true, undefined, undefined, entity);
                }
                if (e.requiredTag)
                    KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, e.requiredTag, 1);
            }
        },
        "CounterattackSpell": (e, buff, entity, data) => {
            if (data.attacker && data.target == entity
                && (!(e.prereq == "hit") || (!data.missed && data.hit))
                && (!(e.prereq == "hit-hostile") || (!data.missed && data.hit && !data.attacker.playWithPlayer
                    && (data.attacker.player || !data.target.player || KinkyDungeonAggressive(data.attacker))))) {
                KinkyDungeonCastSpell(data.attacker.x, data.attacker.y, KinkyDungeonFindSpell(e.spell, true), undefined, undefined, undefined, entity.player ? "Player" : KDGetFaction(entity));
                if (e.requiredTag)
                    KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, e.requiredTag, 1);
            }
        },
    },
    "afterDamageEnemy": {
        "ShrineElements": (e, buff, entity, data) => {
            if (data.enemy && data.enemy.hp > 0.52 && KDHostile(data.enemy) && data.faction == "Player" && !KDEventDataReset.ShrineElements && ["fire", "ice", "frost", "electric", "gravity"].includes(data.type)) {
                KDEventDataReset.ShrineElements = true;
                KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, "shrineElements", 1);
                KinkyDungeonCastSpell(data.enemy.x, data.enemy.y, KinkyDungeonFindSpell(e.spell, true), undefined, undefined, undefined, "Player");
            }
        },
    },
    "playerAttack": {
        "ShadowStep": (e, buff, entity, data) => {
            if (data.enemy && KDHostile(data.enemy) && !KinkyDungeonPlayerBuffs.ShadowStep) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "ShadowStep", type: "SlowDetection", duration: e.time * 2, power: 0.667, player: true, enemies: true, endSleep: true, currentCount: -1, maxCount: 1, tags: ["SlowDetection", "hit", "cast"] });
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "ShadowStep2", type: "Sneak", duration: e.time, power: Math.min(20, e.time * 2), player: true, enemies: true, endSleep: true, currentCount: -1, maxCount: 1, tags: ["Sneak", "hit", "cast"] });
                if (e.requiredTag)
                    KinkyDungeonTickBuffTag(KinkyDungeonPlayerBuffs, e.requiredTag, 1);
            }
        },
        "ApplyDisarm": (e, buff, entity, data) => {
            if (data.enemy && data.enemy == entity && data.enemy.Enemy.bound && (!e.prereq || KDCheckPrereq(data.enemy, e.prereq))) {
                let time = e.time || 0;
                if (!time && entity.buffs)
                    time = KinkyDungeonGetBuffedStat(entity.buffs, "DisarmOnAttack");
                if (time > 0) {
                    KDDisarmEnemy(data.enemy, time);
                }
            }
        },
    },
    "calcMana": {
        "Tablet": (e, buff, entity, data) => {
            if (data.spell != KinkyDungeonTargetingSpellItem && data.spell.tags && data.spell.tags.includes(e.requiredTag) || (data.spell.school && data.spell.school.toLowerCase() == e.requiredTag)) {
                data.cost = Math.max(data.cost * e.power, 0);
            }
        },
        "AvatarFire": (e, buff, entity, data) => {
            if (data.spell.tags && data.spell.tags.includes("fire")) {
                data.cost = Math.max(data.cost - e.power, 0);
            }
        },
        "AvatarAir": (e, buff, entity, data) => {
            if (data.spell.tags && data.spell.tags.includes("air")) {
                data.cost = Math.max(data.cost - e.power, 0);
            }
        },
        "AvatarWater": (e, buff, entity, data) => {
            if (data.spell.tags && data.spell.tags.includes("water")) {
                data.cost = Math.max(data.cost - e.power, 0);
            }
        },
        "AvatarEarth": (e, buff, entity, data) => {
            if (data.spell.tags && data.spell.tags.includes("earth")) {
                data.cost = Math.max(data.cost - e.power, 0);
            }
        },
    },
    "tick": {
        "ShadowDommed": (e, buff, entity, data) => {
            if (buff.duration > 0) {
                if (entity.player) {
                    if (!KDIsPlayerTethered(KinkyDungeonPlayerEntity)) {
                        buff.duration = 0;
                    }
                    KinkyDungeonSetFlag("PlayerDommed", 2);
                }
            }
        },
        "BoundByFate": (e, buff, entity, data) => {
            if (buff.duration > 0) {
                if (entity.player) {
                    if (!KDEffectTileTags(entity.x, entity.y).fate) {
                        buff.duration = 0;
                        KinkyDungeonPlayerEffect(KinkyDungeonPlayerEntity, "soul", { name: "StarBondage", count: e.count, kind: e.kind, power: e.power });
                        KDRemoveAoEEffectTiles(entity.x, entity.y, ["fate"], 1.5);
                    }
                }
            }
        },
        "ApplyConduction": (e, buff, entity, data) => {
            let bb = Object.assign({}, KDConduction);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
        "ApplySlowed": (e, buff, entity, data) => {
            let bb = Object.assign({}, KDSlowed);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
        "ApplyVuln": (e, buff, entity, data) => {
            if (!entity.player) {
                if (!entity.vulnerable)
                    entity.vulnerable = 1;
            }
        },
        "ApplyAttackSlow": (e, buff, entity, data) => {
            let bb = Object.assign({}, KDAttackSlow);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
        "ApplySilence": (e, buff, entity, data) => {
            if (!buff.duration)
                return;
            if (!entity.player && entity.Enemy.bound) {
                if (!e.prereq || KDCheckPrereq(entity, e.prereq))
                    KDSilenceEnemy(entity, e.duration);
            }
        },
        "ApplyGlueVuln": (e, buff, entity, data) => {
            let bb = Object.assign({}, KDGlueVulnLow);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
        "RemoveDrench": (e, buff, entity, data) => {
            if (!KDWettable(entity)) {
                if (entity.player) {
                    delete KinkyDungeonPlayerBuffs.Drenched;
                    delete KinkyDungeonPlayerBuffs.Drenched2;
                    delete KinkyDungeonPlayerBuffs.Drenched3;
                }
                else {
                    delete entity.buffs.Drenched;
                    delete entity.buffs.Drenched2;
                    delete entity.buffs.Drenched3;
                }
            }
        },
        "RemoveConduction": (e, buff, entity, data) => {
            if (!KDConducting(entity)) {
                if (entity.player) {
                    delete KinkyDungeonPlayerBuffs.Conduction;
                }
                else {
                    delete entity.buffs.Conduction;
                }
            }
        },
        "RemoveSlimeWalk": (e, buff, entity, data) => {
            if (KDSlimeImmuneEntity(entity)) {
                if (entity.player) {
                    delete KinkyDungeonPlayerBuffs[buff.id];
                }
                else {
                    delete entity.buffs[buff.id];
                }
            }
        },
        "RemoveNoPlug": (e, buff, entity, data) => {
            if (!(KDEntityBuffedStat(entity, "Plug") > 0) && (!e.prereq || KDCheckPrereq(entity, e.prereq, e, data))) {
                if (entity.player) {
                    delete KinkyDungeonPlayerBuffs[buff.id];
                }
                else {
                    delete entity.buffs[buff.id];
                }
            }
        },
        "RemoveFree": (e, buff, entity, data) => {
            if (!(entity.boundLevel > 0) && (!e.prereq || KDCheckPrereq(entity, e.prereq, e, data))) {
                if (entity.player) {
                    delete KinkyDungeonPlayerBuffs[buff.id];
                }
                else {
                    delete entity.buffs[buff.id];
                }
            }
        },
        "RemoveFreeStrict": (e, buff, entity, data) => {
            if (!(entity.boundLevel > 0 || KinkyDungeonHasStatus(entity)) && (!e.prereq || KDCheckPrereq(entity, e.prereq, e, data))) {
                if (entity.player) {
                    delete KinkyDungeonPlayerBuffs[buff.id];
                }
                else {
                    delete entity.buffs[buff.id];
                }
            }
        },
        "Distract": (e, buff, entity, data) => {
            var _a;
            if (((_a = entity.Enemy) === null || _a === void 0 ? void 0 : _a.bound) && (!e.prereq || KDCheckPrereq(entity, e.prereq, e, data))) {
                if (!entity.distraction)
                    entity.distraction = data.delta * e.power;
                else
                    entity.distraction += data.delta * e.power;
            }
        },
        "RemoveBurning": (e, buff, entity, data) => {
            let drench = KDEntityGetBuff(entity, "Drenched");
            if (drench && drench.duration > data.delta) {
                if (entity.player) {
                    delete KinkyDungeonPlayerBuffs.Burning;
                }
                else {
                    delete entity.buffs.Burning;
                }
                drench.duration -= data.delta;
            }
        },
        "RemoveRestraint": (e, buff, entity, data) => {
            if (buff && buff.duration > data.delta && !entity.player) {
                if (!entity.Enemy.bound || entity.boundLevel <= 0.01)
                    delete entity.buffs[buff.id];
            }
        },
        "ElementalEffect": (e, buff, entity, data) => {
            if (buff.duration > 0) {
                if (entity.player) {
                    KinkyDungeonDealDamage({
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                        flags: ["BurningDamage"]
                    });
                }
                else {
                    KinkyDungeonDamageEnemy(entity, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                        flags: ["BurningDamage"]
                    }, false, true, undefined, undefined, undefined);
                }
            }
        },
    },
    "tickAfter": {
        "ApplyConduction": (e, buff, entity, data) => {
            if (!buff.duration)
                return;
            let bb = Object.assign({}, KDConduction);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
        "ApplySlowed": (e, buff, entity, data) => {
            if (!buff.duration)
                return;
            let bb = Object.assign({}, KDSlowed);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
        "ApplyVuln": (e, buff, entity, data) => {
            if (!entity.player) {
                if (!entity.vulnerable)
                    entity.vulnerable = 1;
            }
        },
        "ApplyAttackSlow": (e, buff, entity, data) => {
            if (!buff.duration)
                return;
            let bb = Object.assign({}, KDAttackSlow);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
        "ApplySilence": (e, buff, entity, data) => {
            if (!buff.duration)
                return;
            if (!entity.player && entity.Enemy.bound) {
                if (!e.prereq || KDCheckPrereq(entity, e.prereq))
                    KDSilenceEnemy(entity, e.duration);
            }
        },
        "ApplyGlueVuln": (e, buff, entity, data) => {
            if (!buff.duration)
                return;
            let bb = Object.assign({}, KDGlueVulnLow);
            if (e.duration)
                bb.duration = e.duration;
            if (e.power)
                bb.power = e.power;
            if (entity.player) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
            }
            else {
                if (!entity.buffs)
                    entity.buffs = {};
                KinkyDungeonApplyBuff(entity.buffs, bb);
            }
        },
    },
};
function KinkyDungeonHandleBuffEvent(Event, e, buff, entity, data) {
    if (Event === e.trigger && KDEventMapBuff[Event] && KDEventMapBuff[Event][e.type]) {
        KDEventMapBuff[Event][e.type](e, buff, entity, data);
    }
}
let KDEventMapOutfit = {
    "calcEvasion": {
        "AccuracyBuff": (e, outfit, data) => {
            if (data.enemy && data.enemy.Enemy && data.enemy.Enemy.tags[e.requiredTag]) {
                data.hitmult *= e.power;
            }
        },
    }
};
function KinkyDungeonHandleOutfitEvent(Event, e, outfit, data) {
    if (Event === e.trigger && KDEventMapOutfit[Event] && KDEventMapOutfit[Event][e.type]) {
        KDEventMapOutfit[Event][e.type](e, outfit, data);
    }
}
let KDEventMapSpell = {
    "calcComp": {
        "OneWithSlime": (e, spell, data) => {
            if (data.spell && data.spell.tags && data.failed.length > 0 && (data.spell.tags.includes("slime") || data.spell.tags.includes("latex"))) {
                let tiles = KDGetEffectTiles(data.x, data.y);
                for (let t of Object.values(tiles)) {
                    if (t.tags && (t.tags.includes("slime") || t.tags.includes("latex"))) {
                        data.failed = [];
                        return;
                    }
                }
            }
        },
    },
    "canSprint": {
        "Vault": (e, spell, data) => {
            if (!data.passThru) {
                let enemy = KinkyDungeonEntityAt(data.nextPosx, data.nextPosy);
                if (enemy && !(enemy === null || enemy === void 0 ? void 0 : enemy.player) && !KDIsImmobile(enemy)) {
                    data.passThru = true;
                }
            }
        },
    },
    "perkOrb": {
        "Cursed": (e, spell, data) => {
            if (data.perks && data.perks.includes("Cursed")) {
                for (let shrine in KinkyDungeonShrineBaseCosts) {
                    KinkyDungeonGoddessRep[shrine] = -50;
                }
            }
        },
    },
    "calcMaxStats": {
        "IronWill": (e, spell, data) => {
            if (KinkyDungeonStatWill >= 9.999)
                data.staminaRate += e.power;
        },
        "SteadfastGuard": (e, spell, data) => {
            if (!e.power || KinkyDungeonStatWill >= e.power)
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "SteadfastGuard",
                    type: "RestraintBlock",
                    power: (KinkyDungeonStatWill - (e.power || 0)) * e.mult,
                    duration: 2
                });
        },
        "IncreaseManaPool": (e, spell, data) => {
            KinkyDungeonStatManaPoolMax += e.power;
        },
    },
    "afterCalcMana": {
        "StaffUser1": (e, spell, data) => {
            if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.magic)
                data.cost = Math.max(data.cost * e.power, 0);
        },
    },
    "beforeMultMana": {
        "StaffUser3": (e, spell, data) => {
            if (data.spell && data.spell.upcastFrom)
                data.cost = data.cost * e.power;
        },
    },
    "calcMana": {
        "StaffUser2": (e, spell, data) => {
            if (data.spell && !data.spell.passive && data.spell.type != 'passive')
                data.cost = Math.max(data.cost - e.power, Math.min(data.cost, 1));
        },
    },
    "calcMiscast": {
        "DistractionCast": (e, spell, data) => {
            if (KinkyDungeonStatDistraction / KinkyDungeonStatDistractionMax > 0.99 || KinkyDungeonPlayerBuffs.DistractionCast)
                data.miscastChance -= 1.0;
        },
    },
    "playerCast": {
        "DistractionCast": (e, spell, data) => {
            if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.99 || KinkyDungeonPlayerBuffs.DistractionCast) {
                let tb = KinkyDungeonGetManaCost(data.spell) * 0.25;
                KinkyDungeonTeaseLevelBypass += tb;
                KDGameData.OrgasmStage = Math.max((KDGameData.OrgasmStage + Math.ceil(tb)) || tb, KinkyDungeonMaxOrgasmStage);
            }
        },
        "LightningRod": (e, spell, data) => {
            if (data.spell && data.spell.tags && data.spell.manacost > 0 && (data.spell.tags.includes("air") || data.spell.tags.includes("electric"))) {
                let bb = Object.assign({}, KDConduction);
                bb.duration = 4;
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "LightningRod", type: "electricDamageResist", aura: "#ffff00", power: e.power, player: true, duration: 4,
                });
            }
        },
        "LeatherBurst": (e, spell, data) => {
            if (data.spell && data.spell.tags && (data.spell.tags.includes("leather") && data.spell.tags.includes("burst"))) {
                let power = KDEntityBuffedStat(KinkyDungeonPlayerEntity, "LeatherBurst");
                if (power < e.power) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                        id: "LeatherBurst", type: "LeatherBurst", aura: "#ffffff", power: power + 1, player: true, duration: 1.1
                    });
                    if (power > 0)
                        data.delta = 0;
                }
                else {
                    KinkyDungeonExpireBuff(KinkyDungeonPlayerBuffs, "LeatherBurst");
                }
            }
        },
    },
    "calcEvasion": {
        "HandsFree": (e, spell, data) => {
            if (!data.IsSpell && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.flags.KDEvasionHands) {
                data.flags.KDEvasionHands = false;
            }
        },
    },
    "tick": {
        "DistractionCast": (e, spell, data) => {
            if (KinkyDungeonStatDistraction > KinkyDungeonStatDistractionMax * 0.99)
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "DistractionCast", type: "sfx", power: 1, duration: 4, sfxApply: "PowerMagic", aura: "#ff8888", aurasprite: "Heart"
                });
        },
        "Buff": (e, spell, data) => {
            if (KDCheckPrereq(null, e.prereq, e, data))
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: spell.name,
                    type: e.buffType,
                    power: e.power,
                    tags: e.tags,
                    currentCount: e.mult ? -1 : undefined,
                    maxCount: e.mult,
                    duration: 2
                });
        },
        "SlimeMimic": (e, spell, data) => {
            if (KinkyDungeonLastAction == "Wait"
                && (KinkyDungeonPlayerTags.get("Slime") || KinkyDungeonPlayerTags.get("SlimeHard"))
                && KinkyDungeonIsHandsBound(false, false, 0.15)
                && KinkyDungeonIsArmsBound(false, false)
                && KinkyDungeonSlowLevel > 0
                && KinkyDungeonGagTotal() > 0.25) {
                KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "SlimeMimic", aura: "#ff00ff", type: "SlowDetection", duration: 2, power: 24.0, player: true, enemies: true, endSleep: true, currentCount: -1, maxCount: 1, tags: ["SlowDetection", "move", "cast", "attack"] });
            }
        },
        "AccuracyBuff": (e, spell, data) => {
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell))) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: spell.name + e.type + e.trigger,
                    type: "Accuracy",
                    duration: 1,
                    power: e.power,
                });
            }
        },
        "Analyze": (e, spell, data) => {
            let activate = false;
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && !KinkyDungeonPlayerBuffs.Analyze) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Analyze", aura: "#ff5555", type: "MagicalSight", power: e.power, duration: e.time });
                activate = true;
            }
            if (KinkyDungeonPlayerBuffs.Analyze && KinkyDungeonPlayerBuffs.Analyze.duration > 1) {
            }
            else if (!activate) {
                KinkyDungeonDisableSpell("Analyze");
                KinkyDungeonExpireBuff(KinkyDungeonPlayerBuffs, "Analyze");
            }
        },
    },
    "calcStats": {
        "Blindness": (e, spell, data) => {
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell))) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: spell.name + e.type + e.trigger,
                    type: "Blindness",
                    duration: e.time ? e.time : 0,
                    power: -1
                });
            }
        },
    },
    "beforeMove": {
        "FleetFooted": (e, spell, data) => {
            if (!data.IsSpell && !KinkyDungeonNoMoveFlag && KinkyDungeonSlowLevel > 1 && KinkyDungeonHasStamina(1.1) && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell))) {
                let manacost = -KinkyDungeonGetManaCost(spell);
                e.prevSlowLevel = KinkyDungeonSlowLevel;
                KinkyDungeonSlowLevel = Math.max(0, KinkyDungeonSlowLevel - e.power);
                if (KinkyDungeonHasMana(1.5) && KinkyDungeonMovePoints < 0) {
                    KinkyDungeonMovePoints = 0;
                    manacost -= 1.5;
                    KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonFleetFootedIgnoreSlow"), "lightgreen", 2);
                }
                else
                    KinkyDungeonSendActionMessage(2, TextGet("KinkyDungeonFleetFooted"), "lightgreen", 2, false, true);
                KinkyDungeonChangeMana(manacost);
            }
        },
    },
    "afterMove": {
        "FleetFooted": (e, spell, data) => {
            if (e.prevSlowLevel && !data.IsSpell && KinkyDungeonSlowLevel < e.prevSlowLevel) {
                KinkyDungeonSlowLevel = e.prevSlowLevel;
                e.prevSlowLevel = undefined;
            }
        },
    },
    "beforeTrap": {
        "FleetFooted": (e, spell, data) => {
            if (data.flags.AllowTraps && !data.IsSpell && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell))) {
                if (KDRandom() < e.chance) {
                    KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                    data.flags.AllowTraps = false;
                    KinkyDungeonSendTextMessage(7, TextGet("KinkyDungeonFleetFootedIgnoreTrap"), "lightgreen", 2);
                }
                else {
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonFleetFootedIgnoreTrapFail"), "lightgreen", 2);
                }
            }
        },
    },
    "afterDamageEnemy": {
        "IcePrison": (e, spell, data) => {
            if (data.enemy && data.froze) {
                if ((!e.chance || KDRandom() < e.chance)) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: "ice",
                        damage: 0,
                        time: 0,
                        bind: data.froze + data.enemy.Enemy.maxhp * 0.1,
                        bindType: "Ice",
                    }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                    if (KDHelpless(data.enemy) && !(data.enemy.freeze > 300))
                        data.enemy.freeze = 300;
                }
            }
        },
    },
    "beforeDamageEnemy": {
        "MultiplyDamageStealth": (e, spell, data) => {
            if (data.dmg > 0 && data.enemy && KDHostile(data.enemy) && !data.enemy.aware && data.spell == spell) {
                if ((!e.humanOnly || data.enemy.Enemy.bound) && (!e.chance || KDRandom() < e.chance)) {
                    data.dmg = Math.max(data.dmg * e.power, 0);
                }
            }
        },
        "MakeVulnerable": (e, spell, data) => {
            if (data.enemy && data.spell == spell) {
                if ((!e.humanOnly || data.enemy.Enemy.bound) && (!e.chance || KDRandom() < e.chance) && !data.enemy.Enemy.tags.nonvulnerable) {
                    if (!data.enemy.vulnerable)
                        data.enemy.vulnerable = 0;
                    data.enemy.vulnerable = Math.max(0, e.time);
                }
            }
        },
        "TemperaturePlay": (e, spell, data) => {
            if (data.dmg > 0 && data.enemy && KDHostile(data.enemy) && ["fire", "frost", "ice"].includes(data.type)) {
                if ((!e.humanOnly || data.enemy.Enemy.bound) && (!e.chance || KDRandom() < e.chance)) {
                    let percent = Math.min(1, KDBoundEffects(data.enemy) / 4);
                    data.dmg = Math.max(data.dmg * (1 + e.power * percent), 0);
                }
            }
        },
        "Burning": (e, spell, data) => {
            if (data.enemy && (!data.flags || !data.flags.includes("BurningDamage")) && data.dmg > 0 && (!e.damage || e.damage == data.type)) {
                if ((!e.chance || KDRandom() < e.chance)) {
                    KinkyDungeonApplyBuffToEntity(data.enemy, KDBurning);
                }
            }
        },
    },
    "calcDamage": {
        "HandsFree": (e, spell, data) => {
            if (!data.IsSpell && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.flags.KDDamageHands) {
                data.flags.KDDamageHands = false;
            }
        },
    },
    "getWeapon": {
        "HandsFree": (e, spell, data) => {
            if (!data.IsSpell && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.flags && !data.flags.HandsFree) {
                data.flags.HandsFree = true;
            }
        },
    },
    "beforePlayerAttack": {
        "Shatter": (e, spell, data) => {
            if (KinkyDungeonPlayerDamage && (KinkyDungeonPlayerDamage.name == "IceBreaker") && data.enemy && data.enemy.freeze > 0 && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell))) {
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                KinkyDungeonCastSpell(data.enemy.x, data.enemy.y, KinkyDungeonFindSpell("ShatterStrike", true), undefined, undefined, undefined);
            }
        },
        "BoostDamage": (e, spell, data) => {
            if (data.eva && KinkyDungeonHasMana(e.cost != undefined ? e.cost : KinkyDungeonGetManaCost(spell)) && !data.miss && !data.disarm && data.targetX && data.targetY && data.enemy && KDHostile(data.enemy)) {
                if (KDCheckPrereq(null, e.prereq, e, data)) {
                    KinkyDungeonChangeMana(-(e.cost != undefined ? e.cost : KinkyDungeonGetManaCost(spell)));
                    data.buffdmg = Math.max(0, data.buffdmg + e.power);
                }
            }
        },
        "CritBoost": (e, spell, data) => {
            if (data.eva && !data.miss && !data.disarm && data.targetX && data.targetY && data.enemy && KDHostile(data.enemy)) {
                if (KDCheckPrereq(null, e.prereq, e, data)) {
                    let power = Math.max(0, Math.max((Math.max(KinkyDungeonPlayerDamage.chance || 0, KinkyDungeonGetEvasion()) - 1) * e.power));
                    data.buffdmg = Math.max(0, data.buffdmg + (KinkyDungeonPlayerDamage.dmg || 0) * power);
                }
            }
        },
    },
    "calcDisplayDamage": {
        "BoostDamage": (e, spell, data) => {
            if (KinkyDungeonHasMana(e.cost != undefined ? e.cost : KinkyDungeonGetManaCost(spell))) {
                if (KDCheckPrereq(null, e.prereq, e, data)) {
                    data.buffdmg = Math.max(0, data.buffdmg + e.power);
                }
            }
        },
        "CritBoost": (e, spell, data) => {
            if (KDCheckPrereq(null, e.prereq, e, data)) {
                let power = Math.max(0, Math.max(((KinkyDungeonPlayerDamage.chance || 0) - 1) * e.power));
                data.buffdmg = Math.max(0, data.buffdmg + (KinkyDungeonPlayerDamage.dmg || 0) * power);
            }
        },
    },
    "tickAfter": {
        "Frustration": (e, spell, data) => {
            for (let en of KinkyDungeonEntities) {
                if (en.Enemy.bound && en.buffs && KDEntityBuffedStat(en, "Chastity")) {
                    if (KDHelpless(en)) {
                        let Enemy = KinkyDungeonGetEnemyByName("PetChastity");
                        let doll = {
                            summoned: true,
                            faction: "Rage",
                            Enemy: Enemy,
                            id: KinkyDungeonGetEnemyID(),
                            x: en.x,
                            y: en.y,
                            hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp,
                            movePoints: 0,
                            attackPoints: 0
                        };
                        KDAddEntity(doll);
                        en.hp = 0;
                    }
                }
            }
        },
    },
    "playerAttack": {
        "FlameBlade": (e, spell, data) => {
            if (KinkyDungeonPlayerDamage && ((KinkyDungeonPlayerDamage.name && KinkyDungeonPlayerDamage.name != "Unarmed") || KinkyDungeonStatsChoice.get("Brawler")) && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.targetX && data.targetY && (data.enemy && KDHostile(data.enemy))) {
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                KinkyDungeonCastSpell(data.targetX, data.targetY, KinkyDungeonFindSpell("FlameStrike", true), undefined, undefined, undefined);
            }
        },
        "ElementalEffect": (e, spell, data) => {
            if (KinkyDungeonHasMana(e.cost != undefined ? e.cost : KinkyDungeonGetManaCost(spell)) && !data.miss && !data.disarm && data.targetX && data.targetY && data.enemy && KDHostile(data.enemy)) {
                KinkyDungeonChangeMana(-(e.cost != undefined ? e.cost : KinkyDungeonGetManaCost(spell)));
                KinkyDungeonDamageEnemy(data.enemy, {
                    type: e.damage,
                    damage: e.power,
                    time: e.time,
                    bind: e.bind,
                    bindType: e.bindType,
                }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
            }
        },
        "EffectTile": (e, spell, data) => {
            if (KinkyDungeonHasMana(e.cost != undefined ? e.cost : KinkyDungeonGetManaCost(spell)) && !data.miss && !data.disarm && data.targetX && data.targetY && data.enemy && KDHostile(data.enemy)) {
                KinkyDungeonChangeMana(-(e.cost != undefined ? e.cost : KinkyDungeonGetManaCost(spell)));
                KDCreateEffectTile(data.targetX, data.targetY, {
                    name: e.kind,
                    duration: e.duration,
                }, e.variance);
            }
        },
        "FloatingWeapon": (e, spell, data) => {
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.targetX && data.targetY && !(data.enemy && data.enemy.Enemy && KDAllied(data.enemy))) {
                let chanceWith = KinkyDungeonPlayerDamage.chance;
                let chanceWithout = KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon(true), true).chance;
                KinkyDungeonGetPlayerWeaponDamage(KinkyDungeonCanUseWeapon());
                if (KinkyDungeonPlayerDamage && KinkyDungeonPlayerDamage.name && chanceWithout < chanceWith)
                    KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
            }
        },
    },
    "beforeStruggleCalc": {
        "ModifyStruggle": (e, spell, data) => {
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.escapeChance != undefined && (!e.StruggleType || e.StruggleType == data.struggleType)) {
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                if (e.mult && data.escapeChance > 0)
                    data.escapeChance *= e.mult;
                if (e.power)
                    data.escapeChance += e.power;
                if (e.msg) {
                    KinkyDungeonSendTextMessage(10 * e.power, TextGet(e.msg), "lightgreen", 2);
                }
            }
        },
        "WillStruggle": (e, spell, data) => {
            if (data.escapeChance != undefined && (!e.StruggleType || e.StruggleType == data.struggleType)) {
                if (!e.power || KinkyDungeonStatWill > e.power) {
                    let boost = (KinkyDungeonStatWill - (e.power || 0)) * e.mult;
                    data.escapeChance += boost;
                    if (e.msg)
                        KinkyDungeonSendTextMessage(10 * boost, TextGet(e.msg).replace("AMOUNT", "" + Math.round(100 * boost)), "lightgreen", 2);
                }
            }
        },
    },
    "vision": {
        "TrueSight": (e, spell, data) => {
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.flags) {
                if (data.update)
                    KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell) * data.update);
                data.flags.SeeThroughWalls = Math.max(data.flags.SeeThroughWalls, 2);
            }
        },
    },
    "draw": {
        "EnemySense": (e, spell, data) => {
            let activate = false;
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && !KinkyDungeonPlayerBuffs.EnemySense) {
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell) * data.update);
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "EnemySense", type: "EnemySense", duration: 13 });
                activate = true;
            }
            if (KinkyDungeonPlayerBuffs.EnemySense && KinkyDungeonPlayerBuffs.EnemySense.duration > 1)
                for (let enemy of KinkyDungeonEntities) {
                    if (!KinkyDungeonVisionGet(enemy.x, enemy.y)
                        && Math.sqrt((KinkyDungeonPlayerEntity.x - enemy.x) * (KinkyDungeonPlayerEntity.x - enemy.x) + (KinkyDungeonPlayerEntity.y - enemy.y) * (KinkyDungeonPlayerEntity.y - enemy.y)) < e.dist) {
                        let color = "#882222";
                        if (enemy.Enemy.stealth > 0 || KDAmbushAI(enemy))
                            color = "#441111";
                        if (color == "#882222" || Math.sqrt((KinkyDungeonPlayerEntity.x - enemy.x) * (KinkyDungeonPlayerEntity.x - enemy.x) + (KinkyDungeonPlayerEntity.y - enemy.y) * (KinkyDungeonPlayerEntity.y - enemy.y)) < e.distStealth)
                            KDDraw(kdcanvas, kdpixisprites, enemy.id + "_sense", KinkyDungeonRootDirectory + "Aura.png", (enemy.visual_x - data.CamX - data.CamX_offset) * KinkyDungeonGridSizeDisplay, (enemy.visual_y - data.CamY - data.CamY_offset) * KinkyDungeonGridSizeDisplay, KinkyDungeonSpriteSize, KinkyDungeonSpriteSize, undefined, {
                                tint: string2hex(color),
                            });
                    }
                }
            else if (!activate) {
                KinkyDungeonDisableSpell("EnemySense");
                KinkyDungeonExpireBuff(KinkyDungeonPlayerBuffs, "EnemySense");
            }
        },
    },
    "getLights": {
        "Light": (e, spell, data) => {
            let activate = false;
            if (KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && !KinkyDungeonPlayerBuffs.Light) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, { id: "Light", type: "Light", duration: e.time, aura: "#ffffff" });
                activate = true;
                KinkyDungeonUpdateLightGrid = true;
            }
            if (KinkyDungeonPlayerBuffs.Light && KinkyDungeonPlayerBuffs.Light.duration > 1) {
                data.lights.push({ brightness: e.power, x: KinkyDungeonPlayerEntity.x, y: KinkyDungeonPlayerEntity.y, color: string2hex(e.color) });
            }
            else if (!activate) {
                KinkyDungeonDisableSpell("Light");
                KinkyDungeonExpireBuff(KinkyDungeonPlayerBuffs, "Light");
            }
        },
    },
    "toggleSpell": {
        "Light": (e, spell, data) => {
            var _a;
            if (((_a = data.spell) === null || _a === void 0 ? void 0 : _a.name) == (spell === null || spell === void 0 ? void 0 : spell.name)) {
                KinkyDungeonUpdateLightGrid = true;
                if (KinkyDungeonPlayerBuffs.Light && KinkyDungeonPlayerBuffs.Light.duration > 1) {
                    KinkyDungeonExpireBuff(KinkyDungeonPlayerBuffs, "Light");
                }
            }
        },
        "Analyze": (e, spell, data) => {
            var _a;
            if (((_a = data.spell) === null || _a === void 0 ? void 0 : _a.name) == (spell === null || spell === void 0 ? void 0 : spell.name)) {
                if (KinkyDungeonPlayerBuffs.Analyze && KinkyDungeonPlayerBuffs.Analyze.duration > 1) {
                    KinkyDungeonExpireBuff(KinkyDungeonPlayerBuffs, "Analyze");
                }
                KinkyDungeonAdvanceTime(0, true, true);
            }
        },
    },
    "enemyStatusEnd": {
        "Shatter": (e, spell, data) => {
            if (data.enemy && data.status == "freeze" && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.enemy.playerdmg && KDHostile(data.enemy) && KDistChebyshev(data.enemy.x - KinkyDungeonPlayerEntity.x, data.enemy.y - KinkyDungeonPlayerEntity.y) < 10) {
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                KinkyDungeonCastSpell(data.enemy.x, data.enemy.y, KinkyDungeonFindSpell("ShatterStrike", true), undefined, undefined, undefined);
            }
        }
    },
    "kill": {
        "Shatter": (e, spell, data) => {
            if (data.enemy && data.enemy.freeze > 0 && KinkyDungeonHasMana(KinkyDungeonGetManaCost(spell)) && data.enemy.playerdmg && KDHostile(data.enemy) && KDistChebyshev(data.enemy.x - KinkyDungeonPlayerEntity.x, data.enemy.y - KinkyDungeonPlayerEntity.y) < 10) {
                KinkyDungeonChangeMana(-KinkyDungeonGetManaCost(spell));
                KinkyDungeonCastSpell(data.enemy.x, data.enemy.y, KinkyDungeonFindSpell("ShatterStrike", true), undefined, undefined, undefined);
            }
        }
    },
};
function KinkyDungeonHandleMagicEvent(Event, e, spell, data) {
    if (Event === e.trigger && KDEventMapSpell[Event] && KDEventMapSpell[Event][e.type]) {
        KDEventMapSpell[Event][e.type](e, spell, data);
    }
}
let KDEventMapWeapon = {
    "beforePlayerDamage": {
        "StormBreakerCharge": (e, weapon, data) => {
            if (data.dmg > 0 && (!e.damageTrigger || e.damageTrigger == data.type)) {
                let turns = data.dmg * e.power;
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "StormCharge",
                    type: "StormCharge",
                    aura: e.color,
                    power: 1,
                    duration: Math.ceil(Math.min(30, turns)),
                });
            }
        },
    },
    "spellCast": {
        "BondageBustBoost": (e, weapon, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                if (data.spell && data.spell.name == "BondageBustBeam" && data.bulletfired) {
                    if (data.bulletfired.bullet && data.bulletfired.bullet.damage) {
                        let dmgMult = e.power;
                        let charge = KinkyDungeonPlayerBuffs[weapon.name + "Charge"] ? KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration : 0;
                        if (charge >= 9)
                            dmgMult *= 2;
                        data.bulletfired.bullet.damage.damage = data.bulletfired.bullet.damage.damage + dmgMult * charge;
                        KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration = 0;
                        if (e.energyCost)
                            KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost * charge);
                        if (e.sfx && charge > 9)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                    }
                }
            }
        },
    },
    "afterPlayerAttack": {
        "DoubleStrike": (e, weapon, data) => {
            if (!KinkyDungeonAttackTwiceFlag && (!e.chance || KDRandom() < e.chance)) {
                if (data.enemy && data.enemy.hp > 0 && !(KDHelpless(data.enemy) && data.enemy.hp < 0.6)) {
                    KinkyDungeonAttackTwiceFlag = true;
                    KinkyDungeonLaunchAttack(data.enemy, 1);
                    KinkyDungeonAttackTwiceFlag = false;
                    if (e.energyCost)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                }
            }
        },
        "ConvertBindingToDamage": (e, weapon, data) => {
            if ((!e.chance || KDRandom() < e.chance)) {
                if (data.enemy && data.enemy.hp > 0 && !(KDHelpless(data.enemy) && data.enemy.hp < 0.6) && data.enemy.boundLevel > 0) {
                    let bonus = Math.min(data.enemy.boundLevel, e.bind);
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: bonus * e.power,
                        time: e.time
                    }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    KDReduceBinding(data.enemy, bonus);
                    if (data.enemy.hp <= 0 && KDHelpless(data.enemy))
                        data.enemy.hp = 0.01;
                    if (e.energyCost)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                }
            }
        },
    },
    "getLights": {
        "WeaponLight": (e, spell, data) => {
            data.lights.push({ brightness: e.power, x: KinkyDungeonPlayerEntity.x, y: KinkyDungeonPlayerEntity.y, color: string2hex(e.color) });
        },
    },
    "tick": {
        "Charge": (e, weapon, data) => {
            if (KDGameData.AncientEnergyLevel > 0 && KinkyDungeonSlowMoveTurns < 1) {
                let currentCharge = KinkyDungeonPlayerBuffs[weapon.name + "Charge"] ? KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration : 0;
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: weapon.name + "Charge",
                    type: e.buffType,
                    aura: e.color,
                    power: 1,
                    duration: Math.min(e.power, currentCharge + 2),
                });
                if (KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration > e.power - 1) {
                    KinkyDungeonPlayerBuffs[weapon.name + "Charge"].aurasprite = undefined;
                }
                else {
                    KinkyDungeonPlayerBuffs[weapon.name + "Charge"].aurasprite = weapon.name;
                }
            }
        },
        "Patience": (e, weapon, data) => {
            if (KinkyDungeonSlowMoveTurns < 1) {
                let currentCharge = KinkyDungeonPlayerBuffs[weapon.name + "Charge"] ? KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration : 0;
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: weapon.name + "Charge",
                    type: e.buffType,
                    aura: e.color,
                    power: 1,
                    duration: Math.min(e.power, currentCharge + 2),
                });
                if (KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration > e.power - 1) {
                    KinkyDungeonPlayerBuffs[weapon.name + "Charge"].aura = e.color;
                }
                else {
                    KinkyDungeonPlayerBuffs[weapon.name + "Charge"].aura = "#888888";
                }
            }
        },
        "Buff": (e, weapon, data) => {
            if (KDCheckPrereq(null, e.prereq, e, data))
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: weapon.name,
                    type: e.buffType,
                    power: e.power,
                    tags: e.tags,
                    currentCount: e.mult ? -1 : undefined,
                    maxCount: e.mult,
                    duration: 2
                });
        },
        "BuffMulti": (e, weapon, data) => {
            if (KDCheckPrereq(null, e.prereq, e, data))
                for (let buff of e.buffTypes)
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                        id: weapon.name + buff,
                        type: buff,
                        power: e.power,
                        tags: e.tags,
                        currentCount: e.mult ? -1 : undefined,
                        maxCount: e.mult,
                        duration: 2
                    });
        },
        "AoEDamageFrozen": (e, weapon, data) => {
            let trigger = false;
            for (let enemy of KinkyDungeonEntities) {
                if (KDHostile(enemy) && enemy.freeze > 0 && (!e.chance || KDRandom() < e.chance) && enemy.hp > 0 && KDistEuclidean(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) <= e.aoe) {
                    KinkyDungeonDamageEnemy(enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time
                    }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                    trigger = true;
                }
            }
            if (trigger) {
                if (e.energyCost)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        },
        "AoEDamageBurning": (e, weapon, data) => {
            let trigger = false;
            for (let enemy of KinkyDungeonEntities) {
                if (KDHostile(enemy) && KDEntityHasBuff(enemy, "Burning") && (!e.chance || KDRandom() < e.chance) && enemy.hp > 0 && KDistEuclidean(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) <= e.aoe) {
                    KinkyDungeonDamageEnemy(enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        flags: ["BurningDamage"],
                    }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                    trigger = true;
                }
            }
            if (trigger) {
                if (e.energyCost)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        },
        "AoEDamage": (e, weapon, data) => {
            let trigger = false;
            for (let enemy of KinkyDungeonEntities) {
                if (KDHostile(enemy) && (!e.chance || KDRandom() < e.chance) && enemy.hp > 0 && KDistEuclidean(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) <= e.aoe) {
                    KinkyDungeonDamageEnemy(enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time
                    }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                    trigger = true;
                }
            }
            if (trigger) {
                if (e.energyCost)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        },
    },
    "beforePlayerAttack": {
        "KatanaBoost": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && data.Damage && data.Damage.damage) {
                if (data.enemy && data.enemy.hp > 0 && !KDHelpless(data.enemy)) {
                    if (!e.chance || KDRandom() < e.chance) {
                        let dmgMult = e.power;
                        let charge = KinkyDungeonPlayerBuffs[weapon.name + "Charge"] ? KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration : 0;
                        if (charge >= 9)
                            dmgMult *= 2;
                        data.Damage.damage = data.Damage.damage + dmgMult * charge;
                        if (KinkyDungeonPlayerBuffs[weapon.name + "Charge"])
                            KinkyDungeonPlayerBuffs[weapon.name + "Charge"].duration = 0;
                        if (e.energyCost)
                            KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost * charge);
                        if (e.sfx && charge > 9)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                    }
                }
            }
        },
        "DamageMultInShadow": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && data.Damage && data.Damage.damage) {
                if (data.enemy && data.enemy.hp > 0 && !KDHelpless(data.enemy)) {
                    if ((!e.chance || KDRandom() < e.chance) && (KinkyDungeonBrightnessGet(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y) <= 1.5 || KinkyDungeonBrightnessGet(data.enemy.x, data.enemy.y) <= 1.5)) {
                        let dmgMult = e.power;
                        data.Damage.damage = data.Damage.damage * dmgMult;
                        if (e.energyCost)
                            KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                        if (e.sfx)
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
                    }
                }
            }
        },
        "ChangeDamageUnaware": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy) && data.Damage && data.Damage.damage > 0 && !data.enemy.Enemy.tags.nobrain) {
                if ((!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (!data.enemy.aware) {
                        data.Damage.damage = e.power;
                        data.Damage.type = e.damage;
                        data.Damage.time = e.time;
                        data.Damage.bind = e.bind;
                    }
                }
            }
        },
        "ChangeDamageVulnerable": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy) && data.Damage && data.Damage.damage > 0 && !data.enemy.Enemy.tags.nonvulnerable) {
                if (data.enemy && (!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (data.enemy.vulnerable > 0) {
                        data.Damage.damage = e.power;
                        data.Damage.type = e.damage;
                        data.Damage.time = e.time;
                        data.Damage.bind = e.bind;
                    }
                }
            }
        },
    },
    "playerAttack": {
        "ElementalEffect": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm) {
                if (data.enemy && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0 && !KDHelpless(data.enemy)) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                }
            }
        },
        "StormBreakerDamage": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm) {
                let enemies = KDNearbyEnemies(data.enemy.x, data.enemy.y, e.aoe);
                for (let en of enemies) {
                    if (en && KDHostile(en) && (!e.chance || KDRandom() < e.chance) && en.hp > 0 && !KDHelpless(en) && KinkyDungeonPlayerBuffs.StormCharge) {
                        let mult = 0.2 * Math.min(5, KinkyDungeonPlayerBuffs.StormCharge.duration);
                        let damage = e.power * mult;
                        KinkyDungeonDamageEnemy(en, {
                            type: e.damage,
                            damage: damage,
                            time: e.time,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                        KDCreateEffectTile(en.x, en.y, {
                            name: "Sparks",
                            duration: 2,
                        }, 2);
                    }
                }
                if (e.sfx)
                    KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/" + e.sfx + ".ogg");
            }
        },
        "ApplyBuff": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm) {
                if (data.enemy && (!e.chance || KDRandom() < e.chance)) {
                    if (!data.enemy.buffs)
                        data.enemy.buffs = {};
                    KinkyDungeonApplyBuff(data.enemy.buffs, e.buff);
                }
            }
        },
        "Cleave": (e, weapon, data) => {
            if (data.enemy && !data.disarm) {
                for (let enemy of KinkyDungeonEntities) {
                    if (enemy != data.enemy && KDHostile(enemy) && !KDHelpless(data.enemy)) {
                        let dist = Math.max(Math.abs(enemy.x - KinkyDungeonPlayerEntity.x), Math.abs(enemy.y - KinkyDungeonPlayerEntity.y));
                        if (dist < 1.5 && KinkyDungeonEvasion(enemy) && Math.max(Math.abs(enemy.x - data.enemy.x), Math.abs(enemy.y - data.enemy.y))) {
                            KinkyDungeonDamageEnemy(enemy, {
                                type: e.damage,
                                damage: e.power,
                                time: e.time
                            }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                        }
                    }
                }
            }
        },
        "CastSpell": (e, weapon, data) => {
            if (data.enemy && !data.disarm && !KDHelpless(data.enemy)) {
                let spell = KinkyDungeonFindSpell(e.spell, true);
                KinkyDungeonCastSpell(data.enemy.x, data.enemy.y, spell, {
                    x: KinkyDungeonPlayerEntity.x,
                    y: KinkyDungeonPlayerEntity.y
                }, { x: data.enemy.x, y: data.enemy.y }, undefined);
                if (e.energyCost)
                    KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
            }
        },
        "Pierce": (e, weapon, data) => {
            if (data.enemy && !data.disarm) {
                let dist = e.dist ? e.dist : 1;
                for (let i = 1; i <= dist; i++) {
                    let xx = data.enemy.x + i * (data.enemy.x - KinkyDungeonPlayerEntity.x);
                    let yy = data.enemy.y + i * (data.enemy.y - KinkyDungeonPlayerEntity.y);
                    for (let enemy of KinkyDungeonEntities) {
                        if (enemy != data.enemy && KDHostile(enemy) && !KDHelpless(data.enemy)) {
                            if (KinkyDungeonEvasion(enemy) && enemy.x == xx && enemy.y == yy) {
                                KinkyDungeonDamageEnemy(enemy, {
                                    type: e.damage,
                                    damage: e.power
                                }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                            }
                        }
                    }
                }
            }
        },
        "DamageToTag": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy)) {
                if (data.enemy && data.enemy.Enemy.tags[e.requiredTag] && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                }
            }
        },
        "DamageToSummons": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy)) {
                if (data.enemy && data.enemy.lifetime > 0 && data.enemy.lifetime < 9999 && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                }
            }
        },
        "ElementalOnVulnerable": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy) && !data.enemy.Enemy.tags.nonvulnerable) {
                if (data.enemy && (!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (data.enemy.vulnerable > 0) {
                        KinkyDungeonDamageEnemy(data.enemy, {
                            type: e.damage,
                            damage: e.power,
                            time: e.time,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    }
                }
            }
        },
        "ElementalOnUnaware": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy) && !data.enemy.Enemy.tags.nobrain) {
                if (data.enemy && (!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (!data.enemy.aware) {
                        KinkyDungeonDamageEnemy(data.enemy, {
                            type: e.damage,
                            damage: e.power,
                            time: e.time,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    }
                }
            }
        },
        "ElementalDreamcatcher": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy)) {
                if (data.enemy && (!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (!data.enemy.aware && !data.enemy.Enemy.tags.nobrain) {
                        KinkyDungeonDamageEnemy(data.enemy, {
                            type: e.damage,
                            damage: e.power,
                            time: e.time,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    }
                    else if (data.enemy.vulnerable > 0 && !data.enemy.Enemy.tags.nonvulnerable) {
                        KinkyDungeonDamageEnemy(data.enemy, {
                            type: e.damage,
                            damage: e.power * 0.5,
                            time: e.time,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    }
                }
            }
        },
        "ElementalUnaware": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy) && !data.enemy.Enemy.tags.nobrain) {
                if (data.enemy && (!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (!data.enemy.aware) {
                        KinkyDungeonDamageEnemy(data.enemy, {
                            type: e.damage,
                            damage: e.power,
                            time: e.time,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    }
                }
            }
        },
        "ElementalVulnerable": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm && !KDHelpless(data.enemy) && !data.enemy.Enemy.tags.nonvulnerable) {
                if (data.enemy && (!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (data.enemy.vulnerable > 0) {
                        KinkyDungeonDamageEnemy(data.enemy, {
                            type: e.damage,
                            damage: e.power,
                            time: e.time,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    }
                }
            }
        },
        "Dreamcatcher": (e, weapon, data) => {
            if (data.enemy && !data.miss && !data.disarm) {
                if (data.enemy && (!e.requiredTag || data.enemy.Enemy.tags[e.requiredTag]) && (!e.chance || KDRandom() < e.chance) && data.enemy.hp > 0) {
                    if (!data.enemy.aware && !data.enemy.Enemy.tags.Temporary) {
                        let point = KinkyDungeonGetNearbyPoint(data.enemy.x, data.enemy.y, true, undefined, true);
                        if (point) {
                            let Enemy = KinkyDungeonGetEnemyByName("ShadowWarrior");
                            KDAddEntity({
                                summoned: true,
                                rage: Enemy.summonRage ? 9999 : undefined,
                                Enemy: Enemy,
                                id: KinkyDungeonGetEnemyID(),
                                x: point.x,
                                y: point.y,
                                hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp,
                                movePoints: 0,
                                attackPoints: 0,
                                lifetime: e.time,
                                maxlifetime: e.time,
                            });
                            if (e.energyCost)
                                KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                        }
                    }
                }
            }
        },
        "Knockback": (e, weapon, data) => {
            if (e.dist && data.enemy && data.targetX && data.targetY && !data.miss && !data.disarm && !KDHelpless(data.enemy)) {
                if (data.enemy.Enemy && !data.enemy.Enemy.tags.unflinching && !data.enemy.Enemy.tags.stunresist && !data.enemy.Enemy.tags.unstoppable && !data.enemy.Enemy.tags.noknockback && !KDIsImmobile(data.enemy)) {
                    let newX = data.targetX + Math.round(e.dist * (data.targetX - KinkyDungeonPlayerEntity.x));
                    let newY = data.targetY + Math.round(e.dist * (data.targetY - KinkyDungeonPlayerEntity.y));
                    if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(newX, newY)) && KinkyDungeonNoEnemy(newX, newY, true)
                        && (e.dist == 1 || KinkyDungeonCheckProjectileClearance(data.enemy.x, data.enemy.y, newX, newY))) {
                        KDMoveEntity(data.enemy, newX, newY, false);
                    }
                }
            }
        },
    },
    "beforeDamageEnemy": {
        "MultiplyTime": (e, weapon, data) => {
            if (data.time > 0 && (!e.damage || e.damage == data.type)) {
                if (!e.chance || KDRandom() < e.chance) {
                    data.time = Math.ceil(data.time * e.power);
                    if (e.energyCost)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                }
            }
        },
        "MultiplyDamageFrozen": (e, weapon, data) => {
            if (data.enemy && data.enemy.freeze > 0 && data.dmg > 0 && (!e.damage || e.damage == data.type)) {
                if (!e.chance || KDRandom() < e.chance) {
                    data.dmg = Math.ceil(data.dmg * e.power);
                    if (e.energyCost)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                }
            }
        },
        "EchoDamage": (e, weapon, data) => {
            if (data.enemy && (!data.flags || !data.flags.includes("EchoDamage")) && data.dmg > 0 && (!e.damage || e.damage == data.type)) {
                if (!e.chance || KDRandom() < e.chance) {
                    let trigger = false;
                    for (let enemy of KinkyDungeonEntities) {
                        if ((enemy.rage || (KDAllied(enemy) && KDAllied(data.enemy)) || (KDHostile(enemy) && KDHostile(data.enemy))) && enemy != data.enemy && !KDHelpless(enemy) && enemy.hp > 0 && KDistEuclidean(enemy.x - data.enemy.x, enemy.y - data.enemy.y) <= e.aoe) {
                            KinkyDungeonDamageEnemy(enemy, {
                                type: e.damage,
                                damage: e.power,
                                time: e.time,
                                flags: ["EchoDamage"]
                            }, false, true, undefined, undefined, KinkyDungeonPlayerEntity);
                            trigger = true;
                        }
                    }
                    if (trigger) {
                        if (e.energyCost)
                            KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                    }
                }
            }
        },
    },
    "capture": {
        "Dollmaker": (e, weapon, data) => {
            if (data.attacker && data.attacker.player && data.enemy && !KDAllied(data.enemy)) {
                if (!e.chance || KDRandom() < e.chance) {
                    let Enemy = KinkyDungeonGetEnemyByName("AllyDoll");
                    let doll = {
                        summoned: true,
                        rage: Enemy.summonRage ? 9999 : undefined,
                        Enemy: Enemy,
                        id: KinkyDungeonGetEnemyID(),
                        x: data.enemy.x,
                        y: data.enemy.y,
                        hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp,
                        movePoints: 0,
                        attackPoints: 0
                    };
                    let dollCount = KinkyDungeonEntities.filter((entity) => {
                        return entity.Enemy.name == "AllyDoll" && KDAllied(entity);
                    }).length;
                    if (dollCount > e.power) {
                        doll.faction = "Enemy";
                        doll.boundLevel = doll.hp * 11;
                        KinkyDungeonSendTextMessage(8, TextGet("KDDollmakerTooManyDolls"), "lightgreen", 2);
                    }
                    KDAddEntity(doll);
                    if (e.energyCost)
                        KDGameData.AncientEnergyLevel = Math.max(0, KDGameData.AncientEnergyLevel - e.energyCost);
                }
            }
        },
    },
    "afterDamageEnemy": {},
};
function KinkyDungeonHandleWeaponEvent(Event, e, weapon, data) {
    if (Event === e.trigger && KDEventMapWeapon[Event] && KDEventMapWeapon[Event][e.type]) {
        KDEventMapWeapon[Event][e.type](e, weapon, data);
    }
}
let KDEventMapBullet = {
    "beforeBulletHit": {
        "DropKnife": (e, b, data) => {
            let point = { x: b.x, y: b.y };
            if (!KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(point.x, point.y))) {
                if (b.vx || b.vy) {
                    let speed = KDistEuclidean(b.vx, b.vy);
                    if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(Math.round(b.x - b.vx / speed), Math.round(b.y - b.vy / speed)))) {
                        point = { x: Math.round(b.x - b.vx / speed), y: Math.round(b.y - b.vy / speed) };
                    }
                    else if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(Math.floor(b.x - b.vx / speed), Math.floor(b.y - b.vy / speed)))) {
                        point = { x: Math.floor(b.x - b.vx / speed), y: Math.floor(b.y - b.vy / speed) };
                    }
                    else {
                        point = { x: Math.ceil(b.x - b.vx / speed), y: Math.ceil(b.y - b.vy / speed) };
                    }
                }
            }
            KinkyDungeonDropItem({ name: "Knife" }, point, KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(point.x, point.y)), true, true);
        },
    },
    "bulletHitEnemy": {
        "Knockback": (e, b, data) => {
            if (b && data.enemy && !data.enemy.Enemy.tags.noknockback && !KDIsImmobile(data.enemy)) {
                let pushPower = KDPushModifier(e.power, data.enemy, false);
                if (pushPower > 0) {
                    let dist = e.dist;
                    if (pushPower > dist)
                        dist *= 2;
                    for (let i = 0; i < dist; i++) {
                        let newX = data.enemy.x + Math.round(1 * Math.sign(b.vx));
                        let newY = data.enemy.y + Math.round(1 * Math.sign(b.vy));
                        if (KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(newX, newY)) && KinkyDungeonNoEnemy(newX, newY, true)
                            && (e.dist == 1 || KinkyDungeonCheckProjectileClearance(data.enemy.x, data.enemy.y, newX, newY))) {
                            KDMoveEntity(data.enemy, newX, newY, false);
                        }
                    }
                }
            }
        },
        "GreaterRage": (e, b, data) => {
            if (b && data.enemy && !(data.enemy.Enemy.tags.soulimmune)) {
                let time = 300;
                if (data.enemy.Enemy.tags.soulresist)
                    time *= 0.5;
                else if (data.enemy.Enemy.tags.soulweakness)
                    time *= 2;
                else if (data.enemy.Enemy.tags.soulsevereweakness)
                    time *= 4;
                if (data.enemy.Enemy.tags.boss)
                    time *= 0.033;
                else if (data.enemy.Enemy.tags.miniboss)
                    time *= 0.1;
                if (time > 100)
                    time = 9999;
                if (!data.enemy.rage)
                    data.enemy.rage = time;
                else
                    data.enemy.rage = Math.max(data.enemy.rage, time);
                KDAddThought(data.enemy.id, "Play", 11, time);
            }
        },
        "ElementalOnSlowOrBind": (e, b, data) => {
            if (b && data.enemy && (KinkyDungeonIsSlowed(data.enemy) || data.enemy.bind > 0)) {
                KinkyDungeonDamageEnemy(data.enemy, {
                    type: e.damage,
                    damage: e.power,
                    time: e.time,
                    bind: e.bind,
                    bindType: e.bindType,
                }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
            }
        },
        "ApplyGenBuff": (e, b, data) => {
            if (b && data.enemy) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq))
                    KDApplyGenBuffs(data.enemy, e.buff, e.time);
            }
        },
        "PlugEnemy": (e, b, data) => {
            var _a;
            if (b && data.enemy) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq)) {
                    if (((_a = data.enemy.Enemy) === null || _a === void 0 ? void 0 : _a.bound) && (data.enemy.boundLevel > 0 || KDEntityGetBuff(data.enemy, "Chastity"))) {
                        KDPlugEnemy(data.enemy);
                    }
                }
            }
        },
        "LatexWall": (e, b, data) => {
            if (b && data.enemy) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq)) {
                    if (!KDEnemyHasFlag(data.enemy, "latexWall")) {
                        KinkyDungeonDamageEnemy(data.enemy, {
                            type: e.damage,
                            damage: e.power,
                            bind: e.bind,
                            bindType: e.bindType,
                        }, true, false, b.bullet.spell, b, undefined, b.delay, true);
                        KDBlindEnemy(data.enemy, e.time);
                        KinkyDungeonSetEnemyFlag(data.enemy, "latexWall", 21);
                    }
                }
            }
        },
        "EncaseBound": (e, b, data) => {
            if (b && data.enemy && data.enemy.Enemy) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq)) {
                    if (data.enemy.Enemy.bound && (data.enemy.boundLevel >= data.enemy.maxhp || KDHelpless(data.enemy))) {
                        KinkyDungeonApplyBuffToEntity(data.enemy, KDEncased);
                    }
                }
            }
        },
        "SilenceHumanoid": (e, b, data) => {
            if (b && data.enemy && data.enemy.Enemy.bound) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq))
                    KDSilenceEnemy(data.enemy, e.time);
            }
        },
        "BlindHumanoid": (e, b, data) => {
            if (b && data.enemy && data.enemy.Enemy.bound) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq))
                    KDBlindEnemy(data.enemy, e.time);
            }
        },
        "DisarmHumanoid": (e, b, data) => {
            if (b && data.enemy && data.enemy.Enemy.bound) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq))
                    KDDisarmEnemy(data.enemy, e.time);
            }
        },
        "DisarmDebuff": (e, b, data) => {
            if (b && data.enemy && data.enemy.Enemy.bound) {
                if (!e.prereq || KDCheckPrereq(data.enemy, e.prereq)) {
                    KinkyDungeonApplyBuffToEntity(data.enemy, KDRestraintDisarmLight);
                }
            }
        },
        "ElementalIfNotSilenced": (e, b, data) => {
            if (b && data.enemy) {
                if (!(data.enemy.silence > 0)) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
                }
            }
        },
        "ElementalIfNotBlinded": (e, b, data) => {
            if (b && data.enemy) {
                if (!(data.enemy.blind > 0)) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
                }
            }
        },
        "ElementalIfNotDisarmed": (e, b, data) => {
            if (b && data.enemy) {
                if (!(data.enemy.disarm > 0)) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
                }
            }
        },
        "ElementalIfNotSnared": (e, b, data) => {
            if (b && data.enemy) {
                if (!(data.enemy.bind > 0)) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
                }
            }
        },
        "ElementalIfHalfBound": (e, b, data) => {
            if (b && data.enemy) {
                if (KDBoundEffects(data.enemy) > 1) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power,
                        time: e.time,
                        bind: e.bind,
                        bindType: e.bindType,
                    }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
                }
            }
        },
        "Elemental": (e, b, data) => {
            if (b && data.enemy) {
                KinkyDungeonDamageEnemy(data.enemy, {
                    type: e.damage,
                    damage: e.power,
                    time: e.time,
                    bind: e.bind,
                    bindType: e.bindType,
                }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
            }
        },
        "BoundBonus": (e, b, data) => {
            if (b && data.enemy) {
                let mult = KDBoundEffects(data.enemy);
                if (mult > 0) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: e.damage,
                        damage: e.power ? e.power * mult : undefined,
                        time: e.time,
                        bind: e.bind ? e.bind * mult : undefined,
                        bindType: e.bindType,
                    }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
                }
            }
        },
        "ElementalOnSlowOrBindOrDrench": (e, b, data) => {
            if (b && data.enemy && (KinkyDungeonIsSlowed(data.enemy) || data.enemy.bind > 0 || (data.enemy.buffs && data.enemy.buffs.Drenched))) {
                KinkyDungeonDamageEnemy(data.enemy, {
                    type: e.damage,
                    damage: e.power,
                    time: e.time,
                    bind: e.bind,
                    bindType: e.bindType,
                }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
            }
        },
        "ElementalOnDrench": (e, b, data) => {
            if (b && data.enemy && (data.enemy.buffs && data.enemy.buffs.Drenched)) {
                KinkyDungeonDamageEnemy(data.enemy, {
                    type: e.damage,
                    damage: e.power,
                    time: e.time,
                    bind: e.bind,
                    bindType: e.bindType,
                }, true, (b.bullet.NoMsg || e.power == 0), b.bullet.spell, b, undefined, b.delay, true);
            }
        },
    },
    "bulletTick": {
        "ZoneOfPurity": (e, b, data) => {
            let enemies = KDNearbyEnemies(b.x, b.y, e.aoe);
            if (enemies.length > 0) {
                for (let en of enemies) {
                    if (en && en.Enemy.bound && en.boundLevel > e.power) {
                        KinkyDungeonApplyBuffToEntity(en, KDChastity);
                    }
                }
            }
            if (KDistChebyshev(KinkyDungeonPlayerEntity.x - b.x, KinkyDungeonPlayerEntity.y - b.y) <= e.aoe) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["magicBeltForced"] }, MiniGameKinkyDungeonLevel + 10, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd) {
                    KinkyDungeonSendActionMessage(3, TextGet("KDZoneOfPuritySelf"), "#88AAFF", 2);
                    KinkyDungeonAddRestraintIfWeaker(restraintAdd, 0, false, undefined, false, false, undefined, undefined);
                }
            }
        },
        "ZoneOfExcitement": (e, b, data) => {
            let enemies = KDNearbyEnemies(b.x, b.y, e.aoe);
            if (enemies.length > 0) {
                for (let en of enemies) {
                    if (en && en.Enemy.bound) {
                        KinkyDungeonApplyBuffToEntity(en, KDToy);
                    }
                }
            }
            if (KDistChebyshev(KinkyDungeonPlayerEntity.x - b.x, KinkyDungeonPlayerEntity.y - b.y) <= e.aoe) {
                let restraintAdd = KinkyDungeonGetRestraint({ tags: ["genericToys"] }, MiniGameKinkyDungeonLevel + 10, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                if (restraintAdd) {
                    KinkyDungeonSendActionMessage(3, TextGet("KDZoneOfExcitementSelf"), "#88AAFF", 2);
                    KinkyDungeonAddRestraintIfWeaker(restraintAdd, 0, false, undefined, false, false, undefined, undefined);
                }
            }
        },
        "CastSpellNearbyEnemy": (e, b, data) => {
            if (data.delta > 0) {
                let born = b.born ? 0 : 1;
                let enemies = KDNearbyEnemies(b.x + b.vx * data.delta * born, b.y + b.vy * data.delta * born, e.aoe).filter((enemy) => {
                    return (KDHostile(enemy) || (b.x == enemy.x && b.y == enemy.y && !KDAllied(enemy)));
                });
                if (e.player && KDistEuclidean(b.x + b.vx * data.delta * born, b.y + b.vy * data.delta * born) < e.aoe) {
                    enemies.push(KinkyDungeonPlayerEntity);
                }
                if (enemies.length > 0) {
                    let enemy = enemies[Math.floor(KDRandom() * enemies.length)];
                    KinkyDungeonCastSpell(enemy.x, enemy.y, KinkyDungeonFindSpell(e.spell, true), undefined, undefined, undefined, b.bullet.faction);
                }
            }
        },
    },
    "bulletAfterTick": {
        "RubberMissileHoming": (e, b, data) => {
            if (data.delta > 0 && b.bullet.targetX != undefined && b.bullet.targetY != undefined) {
                if (b.bullet.faction) {
                    let minDist = 1000;
                    let entity = null;
                    let playerDist = 1000;
                    if (KDFactionHostile(b.bullet.faction, "Player")) {
                        playerDist = KDistEuclidean(KinkyDungeonPlayerEntity.x - b.bullet.targetX, KinkyDungeonPlayerEntity.y - b.bullet.targetY);
                        if (playerDist <= e.dist) {
                            entity = KinkyDungeonPlayerEntity;
                            minDist = playerDist;
                        }
                    }
                    let enemies = KDNearbyEnemies(b.bullet.targetX, b.bullet.targetY, e.dist);
                    for (let en of enemies) {
                        if (!KDHelpless(en) && KDFactionHostile(b.bullet.faction, en)) {
                            playerDist = KDistEuclidean(en.x - b.bullet.targetX, en.y - b.bullet.targetY);
                            if (playerDist < minDist) {
                                entity = en;
                                minDist = playerDist;
                            }
                        }
                    }
                    if (entity) {
                        if (b.bullet.targetX > entity.x) {
                            b.bullet.targetX = Math.max(entity.x, b.bullet.targetX - data.delta * e.power);
                        }
                        else if (b.bullet.targetX < entity.x) {
                            b.bullet.targetX = Math.min(entity.x, b.bullet.targetX + data.delta * e.power);
                        }
                        if (b.bullet.targetY > entity.y) {
                            b.bullet.targetY = Math.max(entity.y, b.bullet.targetY - data.delta * e.power);
                        }
                        else if (b.bullet.targetX < entity.y) {
                            b.bullet.targetY = Math.min(entity.y, b.bullet.targetY + data.delta * e.power);
                        }
                    }
                }
                let speed = KDistEuclidean(b.vx, b.vy);
                let direction = Math.atan2(b.bullet.targetY - b.y, b.bullet.targetX - b.x);
                let vx = Math.cos(direction) * speed;
                let vy = Math.sin(direction) * speed;
                let vxx = b.vx;
                let vyy = b.vy;
                if (b.vx > vx)
                    vxx = Math.max(vx, b.vx - data.delta * e.power);
                else if (b.vx < vx)
                    vxx = Math.min(vx, b.vx + data.delta * e.power);
                if (b.vy > vy)
                    vyy = Math.max(vy, b.vy - data.delta * e.power);
                else if (b.vy < vy)
                    vyy = Math.min(vy, b.vy + data.delta * e.power);
                if (!e.limit || KDistEuclidean(vxx, vyy) >= e.limit) {
                    b.vx = vxx;
                    b.vy = vyy;
                }
                if (e.count) {
                    speed += e.count;
                }
                direction = Math.atan2(b.vy, b.vx);
                b.vx = Math.cos(direction) * speed;
                b.vy = Math.sin(direction) * speed;
            }
        },
    }
};
function KinkyDungeonHandleBulletEvent(Event, e, b, data) {
    if (Event === e.trigger && b.bullet && KDEventMapBullet[Event] && KDEventMapBullet[Event][e.type]) {
        KDEventMapBullet[Event][e.type](e, b, data);
    }
}
let KDEventMapEnemy = {
    "passout": {
        "delete": (e, enemy, data) => {
            if (!e.chance || KDRandom() < e.chance)
                enemy.hp = 0;
        }
    },
    "defeat": {
        "delete": (e, enemy, data) => {
            if (!e.chance || KDRandom() < e.chance)
                enemy.hp = 0;
        }
    },
    "calcManaPool": {
        "PetManaRegen": (e, enemy, data) => {
            if (KDAllied(enemy) && KDistChebyshev(enemy.x - data.player.x, enemy.y - data.player.y) < e.dist) {
                data.manaPoolRegen += e.power;
            }
        },
    },
    "tick": {
        "DisplayAura": (e, enemy, data) => {
            let enemies = KDNearbyEnemies(enemy.x, enemy.y, e.dist, enemy);
            for (let en of enemies) {
                KinkyDungeonApplyBuffToEntity(en, KDDollDebuff);
                KinkyDungeonApplyBuffToEntity(en, KDDollDebuff2);
            }
        },
        "suicideWhenBound": (e, enemy, data) => {
            if (KDHelpless(enemy)) {
                enemy.hp = 0;
            }
        },
    },
    "getLights": {
        "enemyTorch": (e, enemy, data) => {
            data.lights.push({ brightness: e.power, x: enemy.x, y: enemy.y, color: string2hex(e.color) });
        },
    },
    "beforeDamage": {
        "shadowEngulf": (e, enemy, data) => {
            if (data.enemy == enemy && data.target == KinkyDungeonPlayerEntity && data.restraintsAdded && data.restraintsAdded.length == 0 && !KinkyDungeonFlags.get("shadowEngulf")) {
                if (data.enemy == enemy && data.target == KinkyDungeonPlayerEntity && data.restraintsAdded && data.restraintsAdded.length == 0 && !KinkyDungeonFlags.get("shadowEngulf")) {
                    KDTripleBuffKill("ShadowEngulf", KinkyDungeonPlayerEntity, 9, (tt) => {
                        KinkyDungeonPassOut();
                    }, "Blindness");
                }
            }
        },
        "shadowDomme": (e, enemy, data) => {
            if (data.enemy == enemy && data.target == KinkyDungeonPlayerEntity && data.restraintsAdded && data.restraintsAdded.length == 0 && !KinkyDungeonFlags.get("shadowEngulf")) {
                KDTripleBuffKill("ShadowEngulf", KinkyDungeonPlayerEntity, 9, (tt) => {
                    KinkyDungeonPassOut(true);
                    KDBreakTether();
                    KinkyDungeonApplyBuffToEntity(KinkyDungeonPlayerEntity, { id: "ShadowDommed", type: "Flag", duration: 9999, power: 1, maxCount: 1, currentCount: 1, tags: ["attack", "cast"], events: [
                            { type: "ShadowDommed", trigger: "tick" },
                        ] });
                    if (!KinkyDungeonGetRestraintItem("ItemNeck")) {
                        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("ObsidianCollar"), 0, true, "Purple");
                    }
                    if (!KinkyDungeonGetRestraintItem("ItemNeckRestraints")) {
                        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("BasicLeash"), 0, true, "Purple");
                    }
                    KinkyDungeonAttachTetherToEntity(3.5, enemy);
                }, "Blindness");
            }
        },
    },
    "death": {
        "createEffectTile": (e, enemy, data) => {
            if (!e.chance || KDRandom() < e.chance) {
                let count = e.power ? e.power : 1;
                let rad = e.aoe ? e.aoe : 1.5;
                let minrad = e.dist;
                for (let i = 0; i < count; i++) {
                    let slots = [];
                    for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                        for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                            if (Math.sqrt(X * X + Y * Y) <= rad && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                                if ((enemy.x + X > 0 && enemy.y + Y > 0 && enemy.x + X < KinkyDungeonGridWidth && enemy.y + Y < KinkyDungeonGridHeight)
                                    && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(enemy.x + X, enemy.y + Y)))
                                    slots.push({ x: X, y: Y });
                            }
                        }
                    if (slots.length > 0) {
                        let slot = slots[Math.floor(KDRandom() * slots.length)];
                        if (slot) {
                            KDCreateEffectTile(enemy.x + slot.x, enemy.y + slot.y, {
                                name: e.kind,
                                duration: e.time,
                            }, e.variance);
                        }
                    }
                }
            }
        },
    },
    "spellCast": {
        "ropeKrakenSummonTentacle": (e, enemy, data) => {
            var _a;
            if (enemy == data.enemy && ((_a = data.spell) === null || _a === void 0 ? void 0 : _a.name) == "SummonRopeTentacle") {
                enemy.hp = Math.max(enemy.hp - enemy.Enemy.maxhp * KDMagicDefs.RopeKraken_TentacleCost, Math.min(enemy.hp, enemy.Enemy.maxhp * KDMagicDefs.RopeKraken_TentacleThreshold));
            }
        },
        "sarcoKrakenSummonTentacle": (e, enemy, data) => {
            var _a;
            if (enemy == data.enemy && ((_a = data.spell) === null || _a === void 0 ? void 0 : _a.name) == "SummonSarcoTentacle") {
                enemy.hp = Math.max(enemy.hp - enemy.Enemy.maxhp * KDMagicDefs.SarcoKraken_TentacleCost, Math.min(enemy.hp, enemy.Enemy.maxhp * KDMagicDefs.SarcoKraken_TentacleThreshold));
            }
        },
    },
    "afterDamageEnemy": {
        "bleedEffectTile": (e, enemy, data) => {
            if (data.dmg > 0 && enemy == data.enemy) {
                if (!e.chance || KDRandom() < e.chance) {
                    let count = e.power ? e.power : 1;
                    let rad = e.aoe ? e.aoe : 1.5;
                    let minrad = e.dist;
                    for (let i = 0; i < count; i++) {
                        let slots = [];
                        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                                if (Math.sqrt(X * X + Y * Y) <= rad && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                                    if ((enemy.x + X > 0 && enemy.y + Y > 0 && enemy.x + X < KinkyDungeonGridWidth && enemy.y + Y < KinkyDungeonGridHeight)
                                        && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(enemy.x + X, enemy.y + Y)))
                                        slots.push({ x: X, y: Y });
                                }
                            }
                        if (slots.length > 0) {
                            let slot = slots[Math.floor(KDRandom() * slots.length)];
                            if (slot) {
                                KDCreateEffectTile(enemy.x + slot.x, enemy.y + slot.y, {
                                    name: e.kind,
                                    duration: e.duration
                                }, e.time);
                            }
                        }
                    }
                }
            }
        },
    },
    "duringDamageEnemy": {
        "damageThreshold": (e, enemy, data) => {
            if (enemy == data.enemy && data.dmgDealt < e.power) {
                data.dmgDealt = 0;
            }
        },
    },
    "afterEnemyTick": {
        "ShopkeeperRescueAI": (e, enemy, data) => {
            if (data.delta && !KDHelpless(enemy) && !KinkyDungeonIsDisabled(enemy) && KDEnemyHasFlag(enemy, "RescuingPlayer")
                && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                KinkyDungeonSetEnemyFlag(enemy, "wander", 0);
                KinkyDungeonSetEnemyFlag(enemy, "failpath", 0);
                KinkyDungeonSetEnemyFlag(enemy, "genpath", 0);
                KinkyDungeonSetEnemyFlag(enemy, "longPath", 3);
                if (!e.chance || KDRandom() < e.chance) {
                    if (!KDIsPlayerTethered()) {
                        KinkyDungeonApplyBuffToEntity(enemy, KDEager);
                        enemy.gx = KinkyDungeonPlayerEntity.x;
                        enemy.gy = KinkyDungeonPlayerEntity.y;
                        if (KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 1.5) {
                            let newAdd = KinkyDungeonGetRestraint({ tags: ["leashing"] }, 0, 'grv');
                            if (newAdd) {
                                KinkyDungeonAddRestraintIfWeaker(newAdd, 0, true, undefined, false, false, undefined, "Prisoner");
                            }
                            if (KinkyDungeonAttachTetherToEntity(2.5, enemy)) {
                                KinkyDungeonSendTextMessage(9, TextGet("KDShopkeeperLeash"), "#ffffff", 4);
                            }
                        }
                    }
                    else {
                        KinkyDungeonSetEnemyFlag(enemy, "NoFollow", 3);
                        enemy.gx = KinkyDungeonStartPosition.x;
                        enemy.gy = KinkyDungeonStartPosition.y;
                        if (KDistChebyshev(enemy.x - KinkyDungeonStartPosition.x, enemy.y - KinkyDungeonStartPosition.y) < 1.5
                            && KDistChebyshev(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < 2.5) {
                            KinkyDungeonSendTextMessage(10, TextGet("KDShopkeeperTeleportToStart"), "#ffffff", 4);
                            KDGameData.RoomType = "ShopStart";
                            KDGameData.MapMod = "";
                            MiniGameKinkyDungeonLevel = Math.max(0, MiniGameKinkyDungeonLevel - 1);
                            let params = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]];
                            KinkyDungeonCreateMap(params, MiniGameKinkyDungeonLevel);
                            KDStartDialog("ShopkeeperTeleport", enemy.Enemy.name, true, "", enemy);
                        }
                    }
                }
            }
        },
        "dollmakerMissiles": (e, enemy, data) => {
            if (data.delta && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let player = KinkyDungeonPlayerEntity;
                    if (!KDHelpless(enemy) && !KDEnemyHasFlag(enemy, "dollmakerMissiles") && enemy.aware && KDHostile(enemy) && KDistEuclidean(enemy.x - player.x, enemy.y - player.y) > 2.5) {
                        let origins = [
                            { x: player.x + e.dist, y: player.y },
                            { x: player.x - e.dist, y: player.y },
                            { x: player.x, y: player.y + e.dist },
                            { x: player.x, y: player.y - e.dist },
                            { x: player.x + e.dist, y: player.y + e.dist },
                            { x: player.x + e.dist, y: player.y - e.dist },
                            { x: player.x - e.dist, y: player.y + e.dist },
                            { x: player.x - e.dist, y: player.y - e.dist },
                            { x: player.x + e.dist, y: player.y + e.dist / 2 },
                            { x: player.x + e.dist, y: player.y - e.dist / 2 },
                            { x: player.x - e.dist, y: player.y + e.dist / 2 },
                            { x: player.x - e.dist, y: player.y - e.dist / 2 },
                            { x: player.x + e.dist / 2, y: player.y + e.dist },
                            { x: player.x + e.dist / 2, y: player.y - e.dist },
                            { x: player.x - e.dist / 2, y: player.y + e.dist },
                            { x: player.x - e.dist / 2, y: player.y - e.dist },
                        ];
                        origins = origins.filter((origin) => {
                            return KinkyDungeonNoEnemy(origin.x, origin.y)
                                && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(origin.x, origin.y))
                                && KinkyDungeonCheckPath(origin.x, origin.y, player.x, player.y, true, false, 1);
                        });
                        let finalorigin = [];
                        for (let i = 0; i < e.count; i++) {
                            let index = Math.floor(KDRandom() * origins.length);
                            if (origins[index]) {
                                finalorigin.push(origins[index]);
                                origins.splice(index, 1);
                            }
                        }
                        for (let origin of finalorigin) {
                            let spell = KinkyDungeonFindSpell(e.kind, true);
                            let b = KinkyDungeonLaunchBullet(origin.x, origin.y, player.x, player.y, 0.5, { noSprite: spell.noSprite, faction: "Ambush", name: spell.name, block: spell.block, width: spell.size, height: spell.size, summon: spell.summon,
                                targetX: player.x, targetY: player.y, cast: Object.assign({}, spell.spellcast),
                                source: enemy.id, dot: spell.dot,
                                bulletColor: spell.bulletColor, bulletLight: spell.bulletLight,
                                bulletSpin: spell.bulletSpin,
                                effectTile: spell.effectTile, effectTileDurationMod: spell.effectTileDurationMod,
                                effectTileTrail: spell.effectTileTrail, effectTileDurationModTrail: spell.effectTileDurationModTrail, effectTileTrailAoE: spell.effectTileTrailAoE,
                                passthrough: spell.noTerrainHit, noEnemyCollision: spell.noEnemyCollision, alwaysCollideTags: spell.alwaysCollideTags, nonVolatile: spell.nonVolatile, noDoubleHit: spell.noDoubleHit,
                                pierceEnemies: spell.pierceEnemies, piercing: spell.piercing, events: spell.events,
                                lifetime: (spell.bulletLifetime ? spell.bulletLifetime : 1000), origin: { x: origin.x, y: origin.y }, range: spell.range, hit: spell.onhit,
                                damage: { evadeable: spell.evadeable, damage: spell.power, type: spell.damage, distract: spell.distract, distractEff: spell.distractEff, bindEff: spell.bindEff, bind: spell.bind, bindType: spell.bindType, boundBonus: spell.boundBonus, time: spell.time, flags: spell.damageFlags }, spell: spell }, false);
                            b.visual_x = origin.x;
                            b.visual_y = origin.y;
                            let dist = KDistEuclidean(player.x - origin.x, player.y - origin.y);
                            b.vy = 0.5 * (player.y - origin.y) / dist;
                            b.vx = 0.5 * (player.x - origin.x) / dist;
                        }
                        if (finalorigin.length > 0) {
                            KinkyDungeonPlaySound(KinkyDungeonRootDirectory + "Audio/Missile.ogg", enemy);
                            KinkyDungeonSetEnemyFlag(enemy, "dollmakerMissiles", e.time);
                        }
                    }
                }
            }
        },
        "nurseAura": (e, enemy, data) => {
            if (data.delta && KinkyDungeonCanCastSpells(enemy) && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let nearby = KDNearbyNeutrals(enemy.x, enemy.y, e.dist, enemy);
                    for (let en of nearby) {
                        if (en.hp > 0.52)
                            en.hp = Math.min(en.hp + e.power, en.Enemy.maxhp);
                    }
                }
            }
        },
        "shadowDebuff": (e, enemy, data) => {
            if (((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                let light = KinkyDungeonBrightnessGet(enemy.x, enemy.y);
                if (light >= 4.5) {
                    KinkyDungeonApplyBuffToEntity(enemy, { id: "ShadowDebuff1", aura: "#ff5555", type: "MoveSpeed", duration: 1, power: -0.7, tags: ["speed"] });
                    KinkyDungeonApplyBuffToEntity(enemy, { id: "ShadowDebuff2", aura: "#ff5555", type: "AttackSpeed", duration: 1, power: -0.5, tags: ["speed"] });
                }
                else if (light > 3) {
                    KinkyDungeonApplyBuffToEntity(enemy, { id: "ShadowDebuff1", aura: "#ff5555", type: "MoveSpeed", duration: 1, power: -0.4, tags: ["speed"] });
                }
            }
        },
        "shadowDommeRefresh": (e, enemy, data) => {
            if (KinkyDungeonFlags.get("ShadowDommed")) {
                KinkyDungeonSetEnemyFlag(enemy, "wander", 0);
            }
        },
        "wolfShieldDroneAura": (e, enemy, data) => {
            if (data.delta && KinkyDungeonCanCastSpells(enemy) && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let nearby = KDNearbyNeutrals(enemy.x, enemy.y, e.dist, enemy);
                    for (let en of nearby) {
                        if (en != enemy && en.hp > 0.52 && KDMatchTags(["nevermere", "wolfgirl", "alchemist", "dressmaker", "bountyhunter"], en)) {
                            KinkyDungeonApplyBuffToEntity(en, {
                                id: "WolfDroneArmor", aura: "#00ffff", type: "Armor", duration: 1.1, power: e.power, player: false, enemies: true, tags: ["defense", "armor"]
                            });
                            KinkyDungeonApplyBuffToEntity(en, {
                                id: "WolfDroneSpellResist", type: "SpellResist", duration: 1.1, power: e.power, player: false, enemies: true, tags: ["defense", "spellresist"]
                            });
                        }
                    }
                }
            }
        },
        "maidforceHeadAura": (e, enemy, data) => {
            if (data.delta && KinkyDungeonCanCastSpells(enemy) && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    if (enemy.aware && KinkyDungeonAggressive(enemy) && (KDPlayerIsStunned())) {
                        KinkyDungeonPlayerEffect(KinkyDungeonPlayerEntity, "charm", { name: "MaidChastity", power: 2, damage: "charm" });
                    }
                }
            }
        },
        "electrifyLocal": (e, enemy, data) => {
            if (data.delta && (enemy.aware || enemy.vp > 0.5) && (KDNearbyEnemies(enemy.x, enemy.y, 1.5, enemy).length > 0 || KinkyDungeonAggressive(enemy)) && KinkyDungeonCanCastSpells(enemy) && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let count = e.power ? e.power : 1;
                    let rad = e.aoe ? e.aoe : 1.5;
                    let minrad = 0.5;
                    for (let i = 0; i < count; i++) {
                        let slots = [];
                        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                                if (Math.sqrt(X * X + Y * Y) <= rad && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                                    if ((enemy.x + X > 0 && enemy.y + Y > 0 && enemy.x + X < KinkyDungeonGridWidth && enemy.y + Y < KinkyDungeonGridHeight)
                                        && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(enemy.x + X, enemy.y + Y)))
                                        slots.push({ x: X, y: Y });
                                }
                            }
                        if (slots.length > 0) {
                            let slot = slots[Math.floor(KDRandom() * slots.length)];
                            if (slot) {
                                KinkyDungeonCastSpell(enemy.x + slot.x, enemy.y + slot.y, KinkyDungeonFindSpell("WitchElectrify", true), enemy, undefined, undefined);
                            }
                        }
                    }
                }
            }
        },
        "createEffectTile": (e, enemy, data) => {
            if (data.delta && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let count = e.power ? e.power : 1;
                    let rad = e.aoe ? e.aoe : 1.5;
                    let minrad = e.dist;
                    for (let i = 0; i < count; i++) {
                        let slots = [];
                        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                                if (Math.sqrt(X * X + Y * Y) <= rad && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                                    if ((enemy.x + X > 0 && enemy.y + Y > 0 && enemy.x + X < KinkyDungeonGridWidth && enemy.y + Y < KinkyDungeonGridHeight)
                                        && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(enemy.x + X, enemy.y + Y)))
                                        slots.push({ x: X, y: Y });
                                }
                            }
                        if (slots.length > 0) {
                            let slot = slots[Math.floor(KDRandom() * slots.length)];
                            if (slot) {
                                KDCreateEffectTile(enemy.x + slot.x, enemy.y + slot.y, {
                                    name: e.kind,
                                }, e.time);
                            }
                        }
                    }
                }
            }
        },
        "createWater": (e, enemy, data) => {
            if (data.delta && !(enemy.freeze > 0) && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let count = e.power ? e.power : 1;
                    let rad = e.aoe ? e.aoe : 1.5;
                    let minrad = e.dist;
                    for (let i = 0; i < count; i++) {
                        let slots = [];
                        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                                if (Math.sqrt(X * X + Y * Y) <= rad && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                                    if ((enemy.x + X > 0 && enemy.y + Y > 0 && enemy.x + X < KinkyDungeonGridWidth && enemy.y + Y < KinkyDungeonGridHeight)
                                        && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(enemy.x + X, enemy.y + Y)))
                                        slots.push({ x: X, y: Y });
                                }
                            }
                        if (slots.length > 0) {
                            let slot = slots[Math.floor(KDRandom() * slots.length)];
                            if (slot) {
                                KDCreateEffectTile(enemy.x + slot.x, enemy.y + slot.y, {
                                    name: "Water",
                                    duration: 12,
                                }, 8);
                            }
                        }
                    }
                }
            }
        },
        "createIce": (e, enemy, data) => {
            if (data.delta && !(enemy.freeze > 0) && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                if (!e.chance || KDRandom() < e.chance) {
                    let count = e.power ? e.power : 1;
                    let rad = e.aoe ? e.aoe : 1.5;
                    let minrad = e.dist;
                    for (let i = 0; i < count; i++) {
                        let slots = [];
                        for (let X = -Math.ceil(rad); X <= Math.ceil(rad); X++)
                            for (let Y = -Math.ceil(rad); Y <= Math.ceil(rad); Y++) {
                                if (Math.sqrt(X * X + Y * Y) <= rad && (!minrad || Math.sqrt(X * X + Y * Y) >= minrad)) {
                                    if ((enemy.x + X > 0 && enemy.y + Y > 0 && enemy.x + X < KinkyDungeonGridWidth && enemy.y + Y < KinkyDungeonGridHeight)
                                        && KinkyDungeonMovableTilesEnemy.includes(KinkyDungeonMapGet(enemy.x + X, enemy.y + Y)))
                                        slots.push({ x: X, y: Y });
                                }
                            }
                        if (slots.length > 0) {
                            let slot = slots[Math.floor(KDRandom() * slots.length)];
                            if (slot) {
                                KDCreateEffectTile(enemy.x + slot.x, enemy.y + slot.y, {
                                    name: "Ice",
                                    duration: 6,
                                }, 4);
                            }
                        }
                    }
                }
            }
        },
        "ApplyConductionAoE": (e, enemy, data) => {
            if (data.delta > 0 && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                let bb = Object.assign({}, KDConduction);
                bb.duration = 1;
                let enemies = KDNearbyEnemies(enemy.x, enemy.y, e.aoe);
                for (let entity of enemies) {
                    if (!entity.buffs)
                        entity.buffs = {};
                    KinkyDungeonApplyBuff(entity.buffs, bb);
                }
                if (KDistEuclidean(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < e.aoe) {
                    KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, bb);
                }
            }
        },
        "CastSpellNearbyEnemy": (e, enemy, data) => {
            if (data.delta > 0 && ((data.allied && KDAllied(enemy)) || (!data.allied && !KDAllied(enemy)))) {
                let enemies = KDNearbyEnemies(enemy.x, enemy.y, e.aoe).filter((enemy2) => {
                    return (KDHostile(enemy2) || (enemy.x == enemy2.x && enemy.y == enemy2.y && KDFactionRelation(KDGetFaction(enemy2), KDGetFaction(enemy)) < 0.5));
                });
                if (e.player && KDistEuclidean(enemy.x - KinkyDungeonPlayerEntity.x, enemy.y - KinkyDungeonPlayerEntity.y) < e.aoe) {
                    enemies.push(KinkyDungeonPlayerEntity);
                }
                if (enemies.length > 0) {
                    let enemy2 = enemies[Math.floor(KDRandom() * enemies.length)];
                    KinkyDungeonCastSpell(enemy2.x, enemy2.y, KinkyDungeonFindSpell(e.spell, true), undefined, undefined, undefined, KDGetFaction(enemy));
                }
            }
        },
    },
};
function KinkyDungeonHandleEnemyEvent(Event, e, enemy, data) {
    if (Event === e.trigger && KDEventMapEnemy[Event] && KDEventMapEnemy[Event][e.type]) {
        KDEventMapEnemy[Event][e.type](e, enemy, data);
    }
}
let KDEventMapGeneric = {
    "calcEnemyTags": {
        "perkTags": (e, data) => {
            if (KinkyDungeonStatsChoice.get("TapePref"))
                data.tags.push("tapePref");
            else if (KinkyDungeonStatsChoice.get("TapeOptout"))
                data.tags.push("tapeOptout");
        }
    },
    "postMapgen": {
        "resetDollRoom": (e, data) => {
        }
    },
    "defeat": {
        "dollRoomRemove": (e, enemy, data) => {
            var _a;
            if (KDGameData.RoomType && ((_a = alts[KDGameData.RoomType].data) === null || _a === void 0 ? void 0 : _a.dollroom)) {
                for (let en of KinkyDungeonEntities) {
                    if (en.Enemy.tags.dollsmith) {
                        en.noDrop = true;
                        en.hp = 0;
                        KDClearItems(en);
                    }
                }
            }
        }
    },
    "beforeHandleStairs": {
        "resetDollRoom": (e, data) => {
            var _a;
            if (KDGameData.RoomType && ((_a = alts[KDGameData.RoomType].data) === null || _a === void 0 ? void 0 : _a.dollroom)) {
                KDGameData.DollRoomCount += 1;
                if (KDGameData.DollRoomCount >= 3) {
                    if (KinkyDungeonFlags.get("NoDollRoomBypass")) {
                        data.overrideProgression = true;
                        data.overrideRoomType = true;
                        data.mapMod = "";
                        KDGameData.RoomType = "";
                    }
                }
                else {
                    data.overrideRoomType = true;
                    data.overrideProgression = true;
                    data.mapMod = "";
                    KDGameData.RoomType = "DollRoom";
                }
            }
        }
    },
    "drawSGTooltip": {
        "goddessBonus": (e, data) => {
            var _a;
            if (data.item && ((_a = KDRestraint(data.item)) === null || _a === void 0 ? void 0 : _a.shrine)) {
                let bonus = KDGetItemGoddessBonus(data.item);
                if (bonus) {
                    data.extraLines.push(TextGet("KDGoddessStat_" + (bonus > 0 ? "Bonus" : "Penalty")) + Math.round(100 * bonus) + "%");
                    data.extraLineColor.push(KDGetPosNegColor(bonus));
                }
            }
        },
    },
    "playerMove": {
        "Conveyor": (e, data) => {
            for (let player of [KinkyDungeonPlayerEntity]) {
                if (KinkyDungeonMapGet(player.x, player.y) == 'V')
                    KDConveyor(1, player.x, player.y);
            }
        },
        "noisyTerrain": (e, data) => {
            if (data.sprint && !data.cancelmove) {
                let moves = [
                    { x: data.moveX, y: data.moveY, str: data.moveX + "," + data.moveY },
                ];
                for (let m of moves)
                    if (KinkyDungeonEffectTilesGet(m.str)) {
                        for (let tile of Object.values(KinkyDungeonEffectTilesGet(m.str))) {
                            if (tile.tags && tile.tags.includes("noisy")) {
                                KinkyDungeonMakeNoise(5, m.x, m.y);
                                KinkyDungeonSendTextMessage(3, TextGet("KDNoisyTerrain"), "#ff8800", 3, false, true);
                            }
                        }
                    }
            }
        },
    },
    "resetEventVar": {
        "resetVars": (e, data) => {
            KDEventData.SlimeLevel = 0;
        },
    },
    "resetEventVarTick": {
        "resetVars": (e, data) => {
            if (KDEventData.SlimeLevel < 0)
                KDEventData.SlimeLevel = 0;
            KDEventData.SlimeLevelStart = KDEventData.SlimeLevel;
            if (KDAlertCD > 0)
                KDAlertCD -= data.delta;
            if (KinkyDungeonLastTurnAction != "Attack" && KDGameData.WarningLevel > 0) {
                if (KDRandom() < 0.25)
                    KDGameData.WarningLevel -= data.delta;
                if (KDGameData.WarningLevel > 5)
                    KDGameData.WarningLevel = 5;
            }
        },
    },
    "postQuest": {
        "resetFlags": (e, data) => {
            KinkyDungeonSetFlag("slept", 0);
        },
        "lockStart": (e, data) => {
            for (let inv of KinkyDungeonAllRestraint()) {
                if (inv.lock && KDLocks[inv.lock] && KDLocks[inv.lock].levelStart) {
                    KDLocks[inv.lock].levelStart(inv);
                }
            }
        },
    },
    "tickFlags": {
        "TempFlagFloorTicks": (e, data) => {
            if (KDGameData.TempFlagFloorTicks)
                for (let f of Object.entries(KDGameData.TempFlagFloorTicks)) {
                    if (!KinkyDungeonFlags.get(f[0]))
                        delete KDGameData.TempFlagFloorTicks[f[0]];
                    else {
                        if (f[1] > data.delta)
                            KDGameData.TempFlagFloorTicks[f[0]] = KDGameData.TempFlagFloorTicks[f[0]] - data.delta;
                        else {
                            KinkyDungeonSetFlag(f[0], 0);
                            delete KDGameData.TempFlagFloorTicks[f[0]];
                        }
                    }
                }
        }
    },
    "playerAttack": {
        "GroundedInReality": (e, data) => {
            if (KinkyDungeonPlayerDamage && KinkyDungeonStatMana >= KinkyDungeonStatManaMax * 0.999 && KinkyDungeonStatsChoice.has("GroundedInReality")) {
                if (!data.miss && !data.disarm && data.targetX && data.targetY && data.enemy && KDHostile(data.enemy)) {
                    KinkyDungeonDamageEnemy(data.enemy, {
                        type: "electric",
                        damage: KinkyDungeonPlayerDamage.dmg * 0.3,
                    }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                }
            }
        },
    },
    "afterCalcMana": {
        "ImmovableObject": (e, data) => {
            if (KinkyDungeonStatWill >= KinkyDungeonStatWillMax * 0.90 && KinkyDungeonStatsChoice.has("ImmovableObject")) {
                if (data.spell && data.spell.tags && data.spell.tags.includes("buff") && data.spell.tags.includes("earth"))
                    data.cost = data.cost * 0.5;
            }
        },
    },
    "tick": {
        "DollRoomUpdate": (e, data) => {
            var _a, _b, _c;
            if (KDGameData.RoomType && ((_a = alts[KDGameData.RoomType].data) === null || _a === void 0 ? void 0 : _a.dollroom)) {
                if (((_b = KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y)) === null || _b === void 0 ? void 0 : _b.OffLimits)
                    && KDCanSpawnShopkeeper(true)
                    && KDRandom() < 0.1)
                    KDStartDialog("ShopkeeperRescue", "ShopkeeperRescue", true, "", undefined);
                let spawn = true;
                let eligible = false;
                for (let player of [KinkyDungeonPlayerEntity]) {
                    if (spawn && KDistEuclidean(player.x - KinkyDungeonStartPosition.x, player.y - KinkyDungeonStartPosition.y) < 10) {
                        spawn = false;
                    }
                    if (spawn && !eligible && !((_c = KinkyDungeonTilesGet(player.x + "," + player.y)) === null || _c === void 0 ? void 0 : _c.OffLimits)) {
                        eligible = true;
                    }
                }
                if (eligible && spawn && !KinkyDungeonFlags.get("spawnDollsmith")) {
                    let count = 0;
                    for (let en of KinkyDungeonEntities) {
                        if (en.Enemy.tags.dollsmith)
                            count += 1;
                    }
                    if (count < 5) {
                        KinkyDungeonSetFlag("spawnDollsmith", 15);
                        let en = DialogueCreateEnemy(KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y, "Dollsmith");
                        en.summoned = true;
                        en.noDrop = true;
                    }
                }
            }
        },
        "BurningDesire": (e, data) => {
            if (KinkyDungeonStatDistraction >= KinkyDungeonStatDistractionMax * 0.7 && KinkyDungeonStatsChoice.has("BurningDesire")) {
                let px = KinkyDungeonPlayerEntity.x - 1 + Math.round(2 * KDRandom());
                let py = KinkyDungeonPlayerEntity.y - 1 + Math.round(2 * KDRandom());
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(px, py)))
                    KDCreateEffectTile(px, py, {
                        name: "Ember",
                        duration: 4
                    }, 1);
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "BurningDesire",
                    type: "fireDamageBuff",
                    power: 0.4,
                    duration: 2
                });
            }
        },
        "Needs": (e, data) => {
            if (KinkyDungeonStatsChoice.get("Needs")) {
                if (data.delta > 0 && !(KDGameData.OrgasmStamina > 0)) {
                    if (KinkyDungeonStatDistractionLower < KinkyDungeonStatDistractionLowerCap * KinkyDungeonStatDistractionMax) {
                        KinkyDungeonStatDistractionLower = Math.min(KinkyDungeonStatDistractionLower + data.delta * 0.01, KinkyDungeonStatDistractionLowerCap * KinkyDungeonStatDistractionMax);
                    }
                }
            }
        },
        "LikeTheWind": (e, data) => {
            if (KinkyDungeonStatStamina >= KinkyDungeonStatStaminaMax * 0.95 && KinkyDungeonStatsChoice.has("LikeTheWind")) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "LikeTheWind",
                    type: "Evasion",
                    power: 0.3,
                    duration: 2
                });
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "LikeTheWind2",
                    type: "SlowLevel",
                    power: -1,
                    duration: 2
                });
            }
        },
        "ImmovableObject": (e, data) => {
            if (KinkyDungeonStatWill >= KinkyDungeonStatWillMax * 0.90 && KinkyDungeonStatsChoice.has("ImmovableObject")) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "ImmovableObject",
                    type: "RestraintBlock",
                    power: 15,
                    duration: 2
                });
            }
        },
        "LeastResistance": (e, data) => {
            if (KinkyDungeonStatWill < KinkyDungeonStatWillMax * 0.01 && KinkyDungeonStatsChoice.has("LeastResistance")) {
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "LeastResistance",
                    type: "Evasion",
                    power: 0.35,
                    duration: 2
                });
            }
        },
        "FrigidPersonality": (e, data) => {
            if (KinkyDungeonStatDistraction <= KinkyDungeonStatDistractionMax * 0.01 && KinkyDungeonStatsChoice.has("FrigidPersonality")) {
                let px = KinkyDungeonPlayerEntity.x - 1 + Math.round(2 * KDRandom());
                let py = KinkyDungeonPlayerEntity.y - 1 + Math.round(2 * KDRandom());
                if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(px, py)))
                    KDCreateEffectTile(px, py, {
                        name: "Ice",
                        duration: 4
                    }, 1);
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "FrigidPersonality",
                    type: "iceDamageBuff",
                    power: 0.1,
                    duration: 2
                });
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, {
                    id: "FrigidPersonality2",
                    type: "frostDamageBuff",
                    power: 0.1,
                    duration: 2
                });
                KinkyDungeonApplyBuff(KinkyDungeonPlayerBuffs, KDNoChillNoAura);
            }
        },
    },
    "playerCast": {
        "ArousingMagic": (e, data) => {
            if (KinkyDungeonStatsChoice.get("ArousingMagic")) {
                KinkyDungeonChangeDistraction(KinkyDungeonGetManaCost(data.spell), false, 0.1);
            }
        },
        "Clearheaded": (e, data) => {
            if (KinkyDungeonStatsChoice.get("Clearheaded")) {
                KinkyDungeonChangeDistraction(-KinkyDungeonGetManaCost(data.spell), false, 0.1);
            }
        },
    },
    "beforeDamage": {
        "LeastResistance": (e, data) => {
            if (KinkyDungeonStatWill < KinkyDungeonStatWillMax * 0.01 && KinkyDungeonStatsChoice.has("LeastResistance")) {
                if (data.attacker && data.target.player && data.bound && (data.attacker.player || !data.target.player || KinkyDungeonAggressive(data.attacker))) {
                    if (data.attacker.player) {
                        KinkyDungeonDealDamage({ damage: KinkyDungeonStatWillMax * 0.1, type: "acid" });
                    }
                    else {
                        KinkyDungeonDamageEnemy(data.attacker, { damage: KinkyDungeonStatWillMax * 0.20, type: "acid" }, false, false, undefined, undefined, KinkyDungeonPlayerEntity);
                    }
                }
            }
        },
    },
    "perksStruggleCalc": {
        "CursedLocks": (e, data) => {
            if (KinkyDungeonStatsChoice.get("CursedLocks") && data.struggleType == "Cut" && data.restraint.lock) {
                data.escapeChance = -100;
                if (data.Msg) {
                    KinkyDungeonSendTextMessage(10, TextGet("KDCursedLocks"), "#aa4488", 1.1);
                }
            }
        },
    },
};
function KinkyDungeonHandleGenericEvent(Event, data) {
    if (!KDMapHasEvent(KDEventMapGeneric, Event))
        return;
    if (KDEventMapGeneric[Event] && KDEventMapGeneric[Event]) {
        for (let e of Object.keys(KDEventMapGeneric[Event]))
            KDEventMapGeneric[Event][e](e, data);
    }
}
function KDEventPrereq(e, item, tags) {
    if (tags) {
        if (!tags.length) {
            tags = [tags];
        }
        for (let t of tags) {
            if (t == "locked") {
                return item.lock;
            }
        }
    }
    return true;
}
function KinkyDungeonAddTags(tags, Floor) {
    let security = (KinkyDungeonGoddessRep.Prisoner + 50);
    if (Floor % KDLevelsPerCheckpoint >= 2 || Floor % KDLevelsPerCheckpoint == 0 || KinkyDungeonDifficulty >= 20)
        tags.push("secondhalf");
    if (Floor % KDLevelsPerCheckpoint >= 3 || Floor % KDLevelsPerCheckpoint == 0 || KinkyDungeonDifficulty >= 40)
        tags.push("lastthird");
    let angeredGoddesses = [];
    let pleasedGoddessess = [];
    if (KinkyDungeonGoddessRep.Rope < KDANGER)
        angeredGoddesses.push({ tag: "ropeAnger", type: "rope" });
    if (KinkyDungeonGoddessRep.Rope < KDRAGE)
        angeredGoddesses.push({ tag: "ropeRage", type: "rope" });
    if (KinkyDungeonGoddessRep.Leather < KDANGER)
        angeredGoddesses.push({ tag: "leatherAnger", type: "leather" });
    if (KinkyDungeonGoddessRep.Leather < KDRAGE)
        angeredGoddesses.push({ tag: "leatherRage", type: "leather" });
    if (KinkyDungeonGoddessRep.Metal < KDANGER)
        angeredGoddesses.push({ tag: "metalAnger", type: "metal" });
    if (KinkyDungeonGoddessRep.Metal < KDRAGE)
        angeredGoddesses.push({ tag: "metalRage", type: "metal" });
    if (KinkyDungeonGoddessRep.Latex < KDANGER)
        angeredGoddesses.push({ tag: "latexAnger", type: "latex" });
    if (KinkyDungeonGoddessRep.Latex < KDRAGE)
        angeredGoddesses.push({ tag: "latexRage", type: "latex" });
    if (KinkyDungeonGoddessRep.Elements < KDANGER)
        angeredGoddesses.push({ tag: "elementsAnger", type: "elements" });
    if (KinkyDungeonGoddessRep.Elements < KDRAGE)
        angeredGoddesses.push({ tag: "elementsRage", type: "elements" });
    if (KinkyDungeonGoddessRep.Conjure < KDANGER)
        angeredGoddesses.push({ tag: "conjureAnger", type: "conjure" });
    if (KinkyDungeonGoddessRep.Conjure < KDRAGE)
        angeredGoddesses.push({ tag: "conjureRage", type: "conjure" });
    if (KinkyDungeonGoddessRep.Illusion < KDANGER)
        angeredGoddesses.push({ tag: "illusionAnger", type: "illusion" });
    if (KinkyDungeonGoddessRep.Illusion < KDRAGE)
        angeredGoddesses.push({ tag: "illusionRage", type: "illusion" });
    if (KinkyDungeonGoddessRep.Will < KDANGER)
        angeredGoddesses.push({ tag: "willAnger", type: "will" });
    if (KinkyDungeonGoddessRep.Will < KDRAGE)
        angeredGoddesses.push({ tag: "willRage", type: "will" });
    if (KinkyDungeonGoddessRep.Rope > KDPLEASED)
        pleasedGoddessess.push({ tag: "ropePleased", type: "rope" });
    if (KinkyDungeonGoddessRep.Rope > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "ropeFriendly", type: "rope" });
    if (KinkyDungeonGoddessRep.Leather > KDPLEASED)
        pleasedGoddessess.push({ tag: "leatherPleased", type: "leather" });
    if (KinkyDungeonGoddessRep.Leather > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "leatherFriendly", type: "leather" });
    if (KinkyDungeonGoddessRep.Metal > KDPLEASED)
        pleasedGoddessess.push({ tag: "metalPleased", type: "metal" });
    if (KinkyDungeonGoddessRep.Metal > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "metalFriendly", type: "metal" });
    if (KinkyDungeonGoddessRep.Latex > KDPLEASED)
        pleasedGoddessess.push({ tag: "latexPleased", type: "latex" });
    if (KinkyDungeonGoddessRep.Latex > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "latexFriendly", type: "latex" });
    if (KinkyDungeonGoddessRep.Elements > KDPLEASED)
        pleasedGoddessess.push({ tag: "elementsPleased", type: "elements" });
    if (KinkyDungeonGoddessRep.Elements > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "elementsFriendly", type: "elements" });
    if (KinkyDungeonGoddessRep.Conjure > KDPLEASED)
        pleasedGoddessess.push({ tag: "conjurePleased", type: "conjure" });
    if (KinkyDungeonGoddessRep.Conjure > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "conjureFriendly", type: "conjure" });
    if (KinkyDungeonGoddessRep.Illusion > KDPLEASED)
        pleasedGoddessess.push({ tag: "illusionPleased", type: "illusion" });
    if (KinkyDungeonGoddessRep.Illusion > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "illusionFriendly", type: "illusion" });
    if (KinkyDungeonGoddessRep.Will > KDPLEASED)
        pleasedGoddessess.push({ tag: "willPleased", type: "will" });
    if (KinkyDungeonGoddessRep.Will > KDFRIENDLY)
        pleasedGoddessess.push({ tag: "willFriendly", type: "will" });
    for (let pair of KDFactionRelations.get("Player").entries()) {
        if (pair[1] > 0.5) {
            tags.push(pair[0] + "Friendly");
        }
        else if (pair[1] < -0.5) {
            tags.push(pair[0] + "Enemy");
        }
        if (pair[1] > 0.75) {
            tags.push(pair[0] + "Allied");
        }
        else if (pair[1] < -0.75) {
            tags.push(pair[0] + "Wanted");
        }
        if (pair[1] > 0.9) {
            tags.push(pair[0] + "Loved");
        }
        else if (pair[1] < -0.9) {
            tags.push(pair[0] + "Hated");
        }
    }
    if (angeredGoddesses.length > 0) {
        let rage = false;
        for (let a of angeredGoddesses) {
            if (!rage && a.tag && a.tag.includes("Rage")) {
                rage = true;
                tags.push("goddessRage");
                break;
            }
        }
        for (let i = 0; i < 2; i++) {
            let tag = angeredGoddesses[Math.floor(angeredGoddesses.length * KDRandom())];
            if (tag && !tags.includes(tag.tag)) {
                for (let a of angeredGoddesses) {
                    if (a.type == tag.type) {
                        tags.push(a.tag);
                    }
                }
            }
        }
        tags.push("goddessAnger");
    }
    if (pleasedGoddessess.length > 0) {
        let rage = false;
        for (let a of pleasedGoddessess) {
            if (!rage && a.tag && a.tag.includes("Friend")) {
                rage = true;
                tags.push("goddessFriendly");
                break;
            }
        }
        for (let i = 0; i < 2; i++) {
            let tag = pleasedGoddessess[Math.floor(pleasedGoddessess.length * KDRandom())];
            if (tag && !tags.includes(tag.tag)) {
                for (let a of pleasedGoddessess) {
                    if (a.type == tag.type) {
                        tags.push(a.tag);
                    }
                }
            }
        }
        tags.push("goddessPleased");
    }
    let overrideTags = [];
    if (KinkyDungeonGoddessRep.Will < -45) {
        tags.push("plant");
        tags.push("beast");
    }
    if (KinkyDungeonGoddessRep.Metal < -45)
        tags.push("robot");
    if (KinkyDungeonGoddessRep.Leather < -45)
        tags.push("bandit");
    if (KinkyDungeonGoddessRep.Illusion < -45)
        tags.push("ghost");
    if (KinkyDungeonGoddessRep.Conjure < -45)
        tags.push("witch");
    if (KinkyDungeonGoddessRep.Conjure < -45)
        tags.push("book");
    if (KinkyDungeonGoddessRep.Elements < -45)
        tags.push("elemental");
    if (KinkyDungeonGoddessRep.Latex < -45)
        tags.push("slime");
    if (KinkyDungeonGoddessRep.Rope < -45)
        tags.push("construct");
    if (KinkyDungeonGoddessRep.Will >= 0) {
        tags.push("posWill");
    }
    if (KinkyDungeonGoddessRep.Metal >= 0)
        tags.push("posMetal");
    if (KinkyDungeonGoddessRep.Leather >= 0)
        tags.push("posLeather");
    if (KinkyDungeonGoddessRep.Illusion >= 0)
        tags.push("posIllusion");
    if (KinkyDungeonGoddessRep.Conjure >= 0)
        tags.push("posConjure");
    if (KinkyDungeonGoddessRep.Elements >= 0)
        tags.push("posElements");
    if (KinkyDungeonGoddessRep.Latex >= 0)
        tags.push("posLatex");
    if (KinkyDungeonGoddessRep.Rope >= 0)
        tags.push("posRope");
    if (security > 0)
        tags.push("jailbreak");
    if (security > 40)
        tags.push("highsecurity");
    let data = {
        tags: tags,
    };
    KinkyDungeonSendEvent("calcEnemyTags", data);
    return overrideTags;
}
let KDPerkToggleTags = [
    "NoNurse",
];
function KinkyDungeonGetEnemy(enemytags, Level, Index, Tile, requireTags, requireHostile, bonusTags, filterTags, requireSingleTag) {
    let enemyWeightTotal = 0;
    let enemyWeights = [];
    let tags = Object.assign([], enemytags);
    for (let t of KDPerkToggleTags) {
        if (KinkyDungeonStatsChoice.get(t)) {
            tags.push(t);
        }
    }
    for (let enemy of KinkyDungeonEnemies) {
        let effLevel = Level + 25 * KinkyDungeonNewGame;
        let weightMulti = 1.0;
        let weightBonus = 0;
        if (!KinkyDungeonStatsChoice.get("arousalMode") && enemy.arousalMode)
            weightMulti = 0;
        if (enemy.shrines) {
            for (let shrine of enemy.shrines) {
                if (KinkyDungeonGoddessRep[shrine]) {
                    let rep = KinkyDungeonGoddessRep[shrine];
                    if (rep > 0)
                        weightMulti *= Math.max(0, 1 - rep / 100);
                    else if (rep < 0) {
                        weightMulti = Math.max(weightMulti, Math.max(1, 1 - rep / 100));
                        weightBonus = Math.max(weightBonus, Math.min(10, -rep / 10));
                    }
                }
            }
        }
        let noOverride = ["boss", "miniboss", "elite", "minor"];
        let overrideFloor = false;
        for (let t of tags) {
            if (!enemy.noOverrideFloor && !noOverride.includes(t)) {
                if (enemy.tags[t]) {
                    overrideFloor = true;
                    weightMulti *= 1.25;
                }
            }
            else {
                if (enemy.outOfBoxWeightMult) {
                    weightMulti *= 1.25;
                }
                else {
                    weightMulti *= 0.1;
                }
            }
        }
        if (bonusTags)
            for (let t of Object.entries(bonusTags)) {
                if (enemy.tags[t[0]]) {
                    weightBonus += t[1].bonus;
                    weightMulti *= t[1].mult;
                }
            }
        if (effLevel >= enemy.minLevel && (!enemy.maxLevel || effLevel < enemy.maxLevel)
            && (!filterTags || !filterTags.some((tag) => { return enemy.tags[tag]; }))
            && (!requireHostile || !enemy.faction || KDFactionRelation("Player", enemy.faction) <= -0.5)
            && (overrideFloor || enemy.allFloors || !enemy.floors || enemy.floors[Index])
            && (KinkyDungeonGroundTiles.includes(Tile) || !enemy.tags.spawnFloorsOnly)) {
            let rt = true;
            let rst = false;
            if (requireTags)
                for (let t of requireTags) {
                    if (!enemy.tags[t]) {
                        rt = false;
                        break;
                    }
                }
            if (requireSingleTag)
                for (let t of requireSingleTag) {
                    if (enemy.tags[t]) {
                        rst = true;
                        break;
                    }
                }
            else
                rst = true;
            if (rt && rst) {
                enemyWeights.push({ enemy: enemy, weight: enemyWeightTotal });
                let weight = enemy.weight + weightBonus;
                if (enemy.terrainTags.increasingWeight)
                    weight += enemy.terrainTags.increasingWeight * Math.floor(Level / KDLevelsPerCheckpoint);
                if (!enemy.terrainTags.grate && tags.includes("grate"))
                    weight -= 1000;
                for (let tag of tags)
                    if (enemy.terrainTags[tag])
                        weight += enemy.terrainTags[tag];
                if (weight > 0)
                    enemyWeightTotal += Math.max(0, weight * weightMulti);
            }
        }
    }
    let selection = KDRandom() * enemyWeightTotal;
    for (let L = enemyWeights.length - 1; L >= 0; L--) {
        if (selection > enemyWeights[L].weight) {
            if (enemyWeights[L].enemy.name == "Mimic")
                console.log("Mimic says boo");
            return enemyWeights[L].enemy;
        }
    }
}
function KinkyDungeonGetEnemyByName(name) {
    return KinkyDungeonEnemies.find(element => element.name == name);
}
function KinkyDungeonCallGuard(x, y, noTransgress, normalDrops, requireTags) {
    var _a;
    let point = KinkyDungeonGetNearbyPoint(x, y, true, undefined, true, true);
    if (!point)
        point = KinkyDungeonGetRandomEnemyPoint(true);
    if (point) {
        if (!KinkyDungeonJailGuard()) {
            let jt = ((_a = KDGameData.GuardFaction) === null || _a === void 0 ? void 0 : _a.length) > 0 ? KinkyDungeonFactionTag[KDGameData.GuardFaction[Math.floor(KDRandom() * KDGameData.GuardFaction.length)]] : "guardCall";
            let Enemy = KinkyDungeonGetEnemy(["Guard", jt], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', requireTags ? requireTags : [jt, "jail"], true, undefined, ["gagged"]);
            if (!Enemy) {
                Enemy = KinkyDungeonGetEnemy(["Guard", jt], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', [jt, "jail"], false, undefined, ["gagged"]);
                if (!Enemy) {
                    jt = "guardCall";
                    Enemy = KinkyDungeonGetEnemy(["Guard", jt], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', [jt, "jail"], false);
                }
            }
            let guard = { summoned: true, noDrop: !normalDrops, Enemy: Enemy, id: KinkyDungeonGetEnemyID(),
                x: KinkyDungeonStartPosition.x, y: KinkyDungeonStartPosition.y, gx: point.x, gy: point.y,
                hp: (Enemy && Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0 };
            KinkyDungeonSetEnemyFlag(guard, "norep", -1);
            KDGameData.KinkyDungeonJailGuard = guard.id;
            KDAddEntity(guard);
            return guard;
        }
        else {
            KinkyDungeonJailGuard().gx = point.x;
            KinkyDungeonJailGuard().gy = point.y;
            KinkyDungeonJailGuard().gxx = point.x;
            KinkyDungeonJailGuard().gyy = point.y;
            if (KinkyDungeonFindPath(KinkyDungeonJailGuard().x, KinkyDungeonJailGuard().y, KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, true, false, true, KinkyDungeonMovableTilesSmartEnemy) < 15) {
                let p = KinkyDungeonGetRandomEnemyPoint(true, true, undefined, 20, 10);
                KinkyDungeonJailGuard().x = p.x;
                KinkyDungeonJailGuard().y = p.y;
            }
            return KinkyDungeonJailGuard();
        }
    }
    return null;
}
let KinkyDungeonTotalSleepTurns = 0;
let KinkyDungeonSearchTimer = 0;
let KinkyDungeonSearchTimerMin = 60;
let KinkyDungeonFirstSpawn = false;
let KinkyDungeonSearchStartAmount = 30;
let KinkyDungeonSearchHuntersAmount = 90;
let KinkyDungeonSearchEntranceAdjustAmount = 130;
let KinkyDungeonSearchEntranceChaseAmount = 160;
function KinkyDungeonHandleWanderingSpawns(delta) {
    if (KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel) && !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel).spawns)
        return;
    if (KDGameData.RoomType && KinkyDungeonAltFloor(KDGameData.RoomType) && !KinkyDungeonAltFloor(KDGameData.RoomType).spawns)
        return;
    let effLevel = MiniGameKinkyDungeonLevel + KinkyDungeonDifficulty;
    let HunterAdjust = KinkyDungeonDifficulty;
    let EntranceAdjust = KinkyDungeonDifficulty / 2;
    let BaseAdjust = KinkyDungeonDifficulty / 10;
    if (KinkyDungeonStatsChoice.get("SearchParty")) {
        BaseAdjust *= 1.2;
        BaseAdjust += KinkyDungeonSearchStartAmount;
        HunterAdjust += KinkyDungeonSearchHuntersAmount - 50;
        EntranceAdjust += KinkyDungeonSearchEntranceAdjustAmount - 30;
        effLevel += 12;
    }
    let sleepTurnsSpeedMult = 100;
    let sleepTurnsPerExtraSpawnLevel = 25;
    let baseChance = ((KDGameData.SleepTurns > 0 && (KinkyDungeonStatStamina > KinkyDungeonStatStaminaMax - 10 * KinkyDungeonStatStaminaRegenSleep || KDGameData.SleepTurns < 11)) ? 0.05 : 0.0005) * Math.sqrt(Math.max(1, effLevel)) * (1 + KinkyDungeonTotalSleepTurns / sleepTurnsSpeedMult);
    let Queue = [];
    if (KDGameData.RespawnQueue && KDGameData.RespawnQueue.length > 0) {
        let firstEnemy = KDGameData.RespawnQueue[Math.floor(KDRandom() * KDGameData.RespawnQueue.length)];
        for (let e of KDGameData.RespawnQueue) {
            if (KDFactionRelation(e.faction, firstEnemy.faction) >= 0.1) {
                Queue.push(e);
            }
        }
    }
    if (Queue.length > 0)
        baseChance = 0.07 * Math.sqrt(Math.max(1, effLevel));
    if (delta > 0 && KDRandom() < baseChance && KinkyDungeonSearchTimer > KinkyDungeonSearchTimerMin) {
        let hunters = false;
        let spawnLocation = KinkyDungeonStartPosition;
        let spawnPlayerExclusionRadius = 11;
        if ((KinkyDungeonTotalSleepTurns > KinkyDungeonSearchStartAmount - BaseAdjust || Queue.length > 0) && KinkyDungeonEntities.length < Math.min(100, (!KinkyDungeonAggressive()) ? (5 + effLevel / 15) : (20 + effLevel / KDLevelsPerCheckpoint))) {
            if (KinkyDungeonTotalSleepTurns > KinkyDungeonSearchHuntersAmount - HunterAdjust)
                hunters = true;
            if (((KinkyDungeonTotalSleepTurns > KinkyDungeonSearchEntranceAdjustAmount - EntranceAdjust || Queue.length > 0) && KDistChebyshev(KinkyDungeonPlayerEntity.x - KinkyDungeonEndPosition.x, KinkyDungeonPlayerEntity.y - KinkyDungeonEndPosition.y) > spawnPlayerExclusionRadius && KDRandom() < 0.5)
                || KDistChebyshev(KinkyDungeonPlayerEntity.x - KinkyDungeonStartPosition.x, KinkyDungeonPlayerEntity.y - KinkyDungeonStartPosition.y) < spawnPlayerExclusionRadius)
                spawnLocation = KinkyDungeonEndPosition;
            if (KinkyDungeonVisionGet(spawnLocation.x, spawnLocation.y) < 1 || KinkyDungeonSeeAll) {
                KinkyDungeonSearchTimer = 0;
                let count = 0;
                let maxCount = (2 + Math.min(5, Math.round(MiniGameKinkyDungeonLevel / 10))) * Math.sqrt(1 + KinkyDungeonTotalSleepTurns / sleepTurnsSpeedMult);
                if (KinkyDungeonStatsChoice.get("SearchParty")) {
                    maxCount *= 2;
                }
                let tags = [];
                KinkyDungeonAddTags(tags, MiniGameKinkyDungeonLevel);
                tags.push("boss");
                let miniboss = false;
                let requireTags = ["search"];
                if (hunters) {
                    requireTags = ["hunter"];
                    tags.push("secondhalf");
                    if (KinkyDungeonTotalSleepTurns > KinkyDungeonSearchEntranceChaseAmount)
                        tags.push("thirdhalf");
                }
                tags.push("bandit");
                let qq = Queue.length > 0 ? Queue[Math.floor(KDRandom() * Queue.length)] : null;
                let Enemy = qq ?
                    KinkyDungeonGetEnemyByName(qq.enemy)
                    : KinkyDungeonGetEnemy(tags, MiniGameKinkyDungeonLevel + KinkyDungeonDifficulty / 5 + Math.round(KinkyDungeonTotalSleepTurns / sleepTurnsPerExtraSpawnLevel), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], KinkyDungeonMapGet(spawnLocation.x, spawnLocation.y), requireTags, true);
                let EnemiesSummoned = [];
                KinkyDungeonMakeGhostDecision();
                while (Enemy && count < maxCount) {
                    let point = KinkyDungeonGetNearbyPoint(spawnLocation.x, spawnLocation.y, true);
                    if (point) {
                        let X = point.x;
                        let Y = point.y;
                        EnemiesSummoned.push(Enemy.name);
                        let e = { tracking: true, summoned: true, faction: qq ? qq.faction : undefined, Enemy: Enemy, id: KinkyDungeonGetEnemyID(), x: X, y: Y, hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0 };
                        KDAddEntity(e);
                        KinkyDungeonSetEnemyFlag(e, "NoFollow", -1);
                        let shop = KinkyDungeonGetShopForEnemy(e);
                        if (shop) {
                            KinkyDungeonSetEnemyFlag(e, "Shop", -1);
                            KinkyDungeonSetEnemyFlag(e, shop, -1);
                        }
                        if (Enemy.tags.minor)
                            count += 0.1;
                        else
                            count += 1;
                        if (Enemy.tags.boss) {
                            count += 3 * Math.max(1, 100 / (100 + KinkyDungeonDifficulty));
                            tags.push("boss");
                        }
                        else if (Enemy.tags.elite)
                            count += Math.max(1, 1000 / (2000 + 20 * KinkyDungeonDifficulty + KinkyDungeonTotalSleepTurns));
                        if (Enemy.tags.miniboss) {
                            if (!miniboss)
                                tags.push("boss");
                            miniboss = true;
                        }
                        KDGameData.RespawnQueue.splice(KDGameData.RespawnQueue.indexOf(qq), 1);
                        Queue.splice(Queue.indexOf(qq), 1);
                        if (Enemy.summon) {
                            for (let sum of Enemy.summon) {
                                if (!sum.chance || KDRandom() < sum.chance)
                                    KinkyDungeonSummonEnemy(X, Y, sum.enemy, sum.count, sum.range, sum.strict);
                            }
                        }
                    }
                    else
                        count += 0.1;
                    qq = Queue.length > 0 ? Queue[Math.floor(KDRandom() * Queue.length)] : null;
                    Enemy = qq ?
                        KinkyDungeonGetEnemyByName(qq.enemy)
                        : KinkyDungeonGetEnemy(tags, MiniGameKinkyDungeonLevel + effLevel / KDLevelsPerCheckpoint, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], KinkyDungeonMapGet(spawnLocation.x, spawnLocation.y), requireTags);
                }
                if (EnemiesSummoned.length > 0 && KinkyDungeonFirstSpawn) {
                    KinkyDungeonFirstSpawn = false;
                    KinkyDungeonSendTextMessage(4, TextGet("KinkyDungeonFirstSpawn"), "white", KDGameData.SleepTurns + 5);
                }
                if (KinkyDungeonTotalSleepTurns > KinkyDungeonSearchEntranceChaseAmount && !KinkyDungeonHuntDownPlayer && KDGameData.SleepTurns < 3) {
                    KinkyDungeonHuntDownPlayer = true;
                    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonHuntDownPlayer"), "#ff0000", KDGameData.SleepTurns + 10);
                }
                console.log(EnemiesSummoned);
            }
        }
    }
    else if (!(KDGameData.PrisonerState == 'jail'))
        KinkyDungeonSearchTimer += delta;
    if (!(KDGameData.HunterTimer > 0)) {
        if (KDGameData.HunterTimer == undefined)
            KDGameData.HunterTimer = HunterPulse;
        else {
            if (!KDGameData.Hunters)
                KDGameData.Hunters = [];
            let hunters = KDGameData.Hunters.map((id) => { return KinkyDungeonFindID(id); });
            let spawnLocation = { x: KinkyDungeonStartPosition.x, y: KinkyDungeonStartPosition.y };
            if (hunters.length > 0 || KDistChebyshev(spawnLocation.x - KinkyDungeonPlayerEntity.x, spawnLocation.y - KinkyDungeonPlayerEntity.y) < 10) {
                KDGameData.HunterTimer = Math.max(KDGameData.HunterTimer, HunterPulse);
            }
            else {
                let eToSpawn = [];
                KDGameData.Hunters = [];
                for (let e of eToSpawn) {
                    let point = KinkyDungeonGetNearbyPoint(spawnLocation.x, spawnLocation.y, true);
                    if (point) {
                        e.x = point.x;
                        e.y = point.y;
                        KDAddEntity(e);
                        KDGameData.Hunters.push(e.id);
                    }
                }
            }
        }
    }
    if (KDGameData.HunterTimer > 0)
        KDGameData.HunterTimer = Math.max(0, KDGameData.HunterTimer - delta);
}
let HunterPulse = 25;
let HunterSpawnTimer = 120;
let KDMaxCageTime = 100;
let KDJailFilters = ['jail'];
function KDAssignGuardAction(guard, xx, yy) {
    let eventWeightTotal = 0;
    let eventWeights = [];
    for (let event of Object.values(KDGuardActions)) {
        eventWeights.push({ event: event, weight: eventWeightTotal });
        eventWeightTotal += event.weight(guard, xx, yy);
    }
    let selection = KDRandom() * eventWeightTotal;
    for (let L = eventWeights.length - 1; L >= 0; L--) {
        if (selection > eventWeights[L].weight) {
            eventWeights[L].event.assign(guard, xx, yy);
            return;
        }
    }
}
function KDGetJailEvent(guard, xx, yy) {
    let eventWeightTotal = 0;
    let eventWeights = [];
    for (let event of Object.values(KDJailEvents)) {
        eventWeights.push({ event: event, weight: eventWeightTotal });
        eventWeightTotal += event.weight(guard, xx, yy);
    }
    let selection = KDRandom() * eventWeightTotal;
    for (let L = eventWeights.length - 1; L >= 0; L--) {
        if (selection > eventWeights[L].weight) {
            return eventWeights[L].event.trigger;
        }
    }
    return (g, x, y) => { };
}
function KinkyDungeonLoseJailKeys(Taken, boss, enemy) {
    if (KinkyDungeonFlags.has("BossUnlocked"))
        return;
    if (KDGameData.JailKey) {
        if (Taken) {
            KinkyDungeonSendActionMessage(7, TextGet("KinkyDungeonRemoveJailKey"), "#ff0000", 3);
            if (enemy) {
                if (!enemy.items)
                    enemy.items = [];
                if (!enemy.items.includes("Keyring"))
                    enemy.items.push("Keyring");
            }
        }
        KDGameData.JailKey = false;
    }
    if (boss) {
        KDGameData.JailKey = false;
        KinkyDungeonGroundItems = KinkyDungeonGroundItems.filter((item) => { return item.name != "Keyring"; });
    }
}
function KinkyDungeonUpdateJailKeys() {
    if (!KDGameData.JailKey) {
        let altRoom = KinkyDungeonAltFloor(KDGameData.RoomType);
        if ((!altRoom || !altRoom.nokeys) && (!KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel) || !KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel).nokeys)) {
            let keyCount = KinkyDungeonGroundItems.filter((item) => { return item.name == "Keyring"; }).length;
            for (let i = 0; i < 2 - keyCount; i++) {
                KinkyDungeonPlaceJailKeys();
            }
        }
    }
}
function KinkyDungeonAggroFaction(faction, noAllyRepPenalty) {
    let list = [];
    let list2 = [];
    for (let enemy of KinkyDungeonEntities) {
        if (enemy.Enemy.tags.peaceful)
            continue;
        let enemyfaction = KDGetFaction(enemy);
        if ((enemyfaction == faction || KDFactionRelation(enemyfaction, faction) > 0.4)) {
            let dist = KDistChebyshev(KinkyDungeonPlayerEntity.x - enemy.x, KinkyDungeonPlayerEntity.y - enemy.y);
            if (KinkyDungeonCheckLOS(enemy, KinkyDungeonPlayerEntity, dist, enemy.Enemy.visionRadius, false, true)) {
                list.push(enemy);
            }
        }
        else if (enemyfaction == "Player" && KDGetFactionOriginal(enemy) == faction) {
            let dist = KDistChebyshev(KinkyDungeonPlayerEntity.x - enemy.x, KinkyDungeonPlayerEntity.y - enemy.y);
            if (KinkyDungeonCheckLOS(enemy, KinkyDungeonPlayerEntity, dist, enemy.Enemy.visionRadius, false, true)) {
                list2.push(enemy);
            }
        }
    }
    if (faction) {
        let amount = 0.04;
        if (list.length > 0) {
            for (let e of list) {
                if (!e.allied) {
                    KDMakeHostile(e);
                }
            }
            KinkyDungeonChangeFactionRep(faction, -amount);
            return true;
        }
        else if (list2.length > 0 && !noAllyRepPenalty) {
            KinkyDungeonChangeFactionRep(faction, -amount);
            return false;
        }
    }
    return false;
}
function KinkyDungeonPlayerIsVisibleToJailers() {
    let list = [];
    for (let enemy of KinkyDungeonEntities) {
        if (KDHostile(enemy) && !(enemy.rage > 0) && (enemy.Enemy.tags.leashing || enemy.Enemy.tags.jail || enemy.Enemy.tags.jailer || enemy.Enemy.playLine)) {
            if (KinkyDungeonCheckLOS(enemy, KinkyDungeonPlayerEntity, KDistChebyshev(KinkyDungeonPlayerEntity.x - enemy.x, KinkyDungeonPlayerEntity.y - enemy.y), enemy.Enemy.visionRadius, false, true)) {
                list.push(enemy);
            }
        }
    }
    if (list.length > 0)
        return list[Math.floor(Math.random() * list.length)];
    return null;
}
function KinkyDungeonCanPlay(enemy) {
    var _a;
    return KDGameData.PrisonerState == 'parole' || (!KDHostile(enemy) && !KDAllied(enemy)) && (enemy.ambushtrigger || !KDAIType[KDGetAI(enemy)] || !KDAIType[KDGetAI(enemy)].ambush) && !((_a = enemy.Enemy.Behavior) === null || _a === void 0 ? void 0 : _a.noPlay);
}
function KinkyDungeonCheckRelease() {
    if (KDGameData.RoomType) {
        let altRoom = KinkyDungeonAltFloor(KDGameData.RoomType);
        if (altRoom && altRoom.noRelease)
            return altRoom.releaseOnLowSec ? (KinkyDungeonGoddessRep.Prisoner >= KDSecurityLevelHiSec ? -1 : 1) : -1;
    }
    let sub = KinkyDungeonGoddessRep.Ghost + 50;
    let security = KinkyDungeonGoddessRep.Prisoner + 50;
    if (sub == undefined || isNaN(sub))
        sub = 0;
    if (security == undefined || isNaN(security))
        security = 0;
    let turns = KDGameData.JailTurns - security;
    for (let i = 0; i < KDJailReleaseTurns.length; i++) {
        let condition = KDJailReleaseTurns[i];
        if (sub >= condition.minSub && turns >= condition.releaseTurns)
            return i;
    }
    return -1;
}
let KDMaxAlertTimer = 14;
let KDMaxAlertTimerAggro = 300;
function KinkyDungeonAggroAction(action, data) {
    let e = null;
    switch (action) {
        case 'attack':
            KinkyDungeonStartChase(data.enemy, "Attack");
            break;
        case 'magic':
            e = KinkyDungeonPlayerIsVisibleToJailers();
            if (e) {
                KinkyDungeonStartChase(e, "Spell");
            }
            break;
        case 'item':
            e = KinkyDungeonPlayerIsVisibleToJailers();
            if (e) {
                KinkyDungeonStartChase(e, "SpellItem");
            }
            break;
        case 'call':
            KinkyDungeonStartChase(data.enemy, "");
            break;
        case 'chest':
            e = KinkyDungeonPlayerIsVisibleToJailers();
            if (e) {
                KinkyDungeonStartChase(e, "Chest");
            }
            if (data.faction)
                KinkyDungeonAggroFaction(data.faction);
            break;
        case 'rubble':
            e = KinkyDungeonPlayerIsVisibleToJailers();
            if (e) {
                KinkyDungeonPlayExcuse(e, "Loot");
            }
            break;
        case 'shrine':
            e = KinkyDungeonPlayerIsVisibleToJailers();
            if (e) {
                KinkyDungeonStartChase(e, "Shrine");
            }
            break;
        case 'orb':
            e = KinkyDungeonPlayerIsVisibleToJailers();
            if (e) {
                KinkyDungeonStartChase(e, "Orb");
            }
            break;
        case 'struggle':
            if (data.enemy)
                KinkyDungeonPlayExcuse(data.enemy, "Struggle");
            break;
        case 'unrestrained':
            if (KDGameData.PrisonerState == "parole" && data.enemy)
                KinkyDungeonPlayExcuse(data.enemy, "Free");
            break;
        case 'jailbreak':
            if (KDGameData.PrisonerState == "jail") {
                KinkyDungeonStartChase(data.enemy, "Jailbreak");
            }
            break;
        case 'key':
            e = KinkyDungeonPlayerIsVisibleToJailers();
            if (e) {
                KinkyDungeonPlayExcuse(e, "Key");
            }
            break;
    }
}
let KDLocalChaseTypes = ["Refusal", "Attack", "Spell", "SpellItem", "Shrine", "Orb", "Chest"];
function KinkyDungeonStartChase(enemy, Type, faction, force) {
    if (!force && enemy && (!enemy.aware && !(enemy.vp > 0.5)))
        return;
    if ((!enemy && !KDLocalChaseTypes.includes(Type))) {
        if (KDGameData.PrisonerState == 'jail' || KDGameData.PrisonerState == 'parole') {
            KinkyDungeonChangeRep("Ghost", -10);
            KinkyDungeonChangeRep("Prisoner", 20);
            KDGameData.PrisonerState = "chase";
            KinkyDungeonInterruptSleep();
        }
        if (KDGameData.PrisonerState == 'jail' || KDGameData.PrisonerState == 'parole' || KDGameData.PrisonerState == 'chase')
            KDGameData.PrisonerState = "chase";
    }
    else if (KDLocalChaseTypes.includes(Type) && (enemy || faction)) {
        for (let e of KinkyDungeonEntities) {
            if (KDHostile(e) && KDFactionAllied(faction ? faction : KDGetFaction(enemy), e) && (!enemy || !enemy.Enemy.tags.peaceful) && KinkyDungeonCheckLOS(e, KinkyDungeonPlayerEntity, 7, 8, false, false)) {
                if (!e.hostile)
                    e.hostile = KDMaxAlertTimerAggro;
                else
                    KDMakeHostile(e);
                e.ceasefire = undefined;
            }
        }
    }
    if (Type && enemy && (enemy.Enemy.tags.jail || enemy.Enemy.tags.jailer || enemy.Enemy.playLine)) {
        let suff = enemy.Enemy.playLine ? enemy.Enemy.playLine + Type : Type;
        let index = (Type == "Attack" || Type == "Spell") ? ("" + Math.floor(Math.random() * 3)) : "";
        if (!enemy.dialogue || !enemy.dialogueDuration)
            KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJailChase" + suff + index).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 4, (!KDGameData.PrisonerState) ? 3 : 5);
    }
    if (enemy && KDFactionRelation(KDGetFaction(enemy), "Jail") > -0.1 && !enemy.Enemy.tags.peaceful) {
        if (!enemy.hostile)
            KDMakeHostile(enemy);
        else
            KDMakeHostile(enemy);
        enemy.ceasefire = undefined;
    }
}
function KinkyDungeonPlayExcuse(enemy, Type) {
    if (Type == "Free" && enemy && enemy.Enemy.noChaseUnrestrained) {
        return;
    }
    if (KinkyDungeonCanPlay(enemy) && !(enemy.playWithPlayer > 0) && enemy.aware && !(enemy.playWithPlayerCD > 0) && (enemy.Enemy.tags.jail || enemy.Enemy.tags.jailer || enemy.Enemy.playLine)) {
        enemy.playWithPlayer = 17;
        KDSetPlayCD(enemy, 1.5);
        KinkyDungeonSetEnemyFlag(enemy, "playstart", 3);
        if (Type == "Key") {
            enemy.playWithPlayer = 30;
            enemy.playWithPlayerCD = enemy.playWithPlayer;
        }
        let suff = enemy.Enemy.playLine ? enemy.Enemy.playLine + Type : Type;
        KinkyDungeonSendDialogue(enemy, TextGet("KinkyDungeonRemindJailPlay" + suff).replace("EnemyName", TextGet("Name" + enemy.Enemy.name)), KDGetColor(enemy), 4, 4);
    }
}
function KDSetPlayCD(enemy, mult, base = 10) {
    enemy.playWithPlayerCD = Math.max(enemy.playWithPlayerCD, base * mult + enemy.playWithPlayer * mult);
}
function KinkyDungeonGetJailRestraintForGroup(Group) {
    let cand = null;
    let candLevel = 0;
    for (let r of KDGetJailRestraints()) {
        let level = 0;
        if (KinkyDungeonGoddessRep.Prisoner)
            level = Math.max(0, KinkyDungeonGoddessRep.Prisoner + 50);
        if (!r.Level || level >= r.Level) {
            let candidate = KinkyDungeonGetRestraintByName(r.Name);
            if (candidate.Group == Group && (!candidate.nonbinding || cand == null)) {
                if (candLevel == 0 || r.Level > candLevel) {
                    cand = candidate;
                    candLevel = candidate.nonbinding ? 0 : r.Level;
                }
            }
        }
    }
    return cand;
}
function KinkyDungeonGetJailRestraintLevelFor(Name) {
    for (let r of KDGetJailRestraints()) {
        if (r.Name === Name) {
            return r.Level;
        }
    }
    return -1;
}
function KinkyDungeonInJail(filter) {
    return KinkyDungeonPlayerInCell(false, false, filter);
}
function KinkyDungeonPlaceJailKeys() {
    let jailKeyList = [];
    for (let X = 1; X < KinkyDungeonGridWidth; X += 1)
        for (let Y = 1; Y < KinkyDungeonGridHeight; Y += 1)
            if (KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(X, Y))
                && KDistChebyshev(X - KinkyDungeonPlayerEntity.x, Y - KinkyDungeonPlayerEntity.y) > 15
                && KDistChebyshev(X - KinkyDungeonEndPosition.x, Y - KinkyDungeonEndPosition.y) > 15
                && (!KinkyDungeonShortcutPosition || KDistChebyshev(X - KinkyDungeonShortcutPosition.x, Y - KinkyDungeonShortcutPosition.y) > 15)
                && (!KinkyDungeonTilesGet(X + "," + Y) || !KinkyDungeonTilesGet(X + "," + Y).OffLimits))
                jailKeyList.push({ x: X, y: Y });
    let i = 0;
    while (jailKeyList.length > 0) {
        let N = Math.floor(KDRandom() * jailKeyList.length);
        let slot = jailKeyList[N];
        if (KDGameData.KeyringLocations && i < KDGameData.KeyringLocations.length) {
            slot = KDGameData.KeyringLocations[Math.floor(KDRandom() * KDGameData.KeyringLocations.length)];
        }
        if (i < 1000 && !KinkyDungeonGroundItems.some((item) => { return item.name == "Keyring" && KDistChebyshev(item.x - slot.x, item.y - slot.y) < KinkyDungeonGridHeight / 3; })) {
            KinkyDungeonGroundItems.push({ x: slot.x, y: slot.y, name: "Keyring" });
        }
        i++;
        return true;
    }
}
function KinkyDungeonHandleJailSpawns(delta) {
    if (KDGameData.JailTurns)
        KDGameData.JailTurns += delta;
    else
        KDGameData.JailTurns = 1;
    if (KinkyDungeonInJail(KDJailFilters))
        KDGameData.JailRemoveRestraintsTimer += delta;
    let nearestJail = KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
    if (!nearestJail)
        return;
    let xx = nearestJail.x + KinkyDungeonJailLeashX;
    let yy = nearestJail.y;
    let playerInCell = (Math.abs(KinkyDungeonPlayerEntity.x - nearestJail.x) < KinkyDungeonJailLeashX - 1 && Math.abs(KinkyDungeonPlayerEntity.y - nearestJail.y) <= KinkyDungeonJailLeash);
    for (let enemy of KinkyDungeonEntities) {
        if (enemy.gxx == xx && enemy.gyy == yy && KDGetAI(enemy) == "guard") {
            enemy.AI = "hunt";
        }
    }
    if (KinkyDungeonInJail(KDJailFilters) && KDGameData.PrisonerState == "jail" && (KDGameData.KinkyDungeonGuardSpawnTimer <= 1 || KDGameData.SleepTurns == 3) && !KinkyDungeonJailGuard() && playerInCell) {
        KDGetJailEvent(KinkyDungeonJailGuard(), xx, yy)(KinkyDungeonJailGuard(), xx, yy);
    }
    else if (KDGameData.KinkyDungeonGuardSpawnTimer > 0 && KDGameData.SleepTurns < 1 && !KinkyDungeonAngel())
        KDGameData.KinkyDungeonGuardSpawnTimer -= delta;
    if (KinkyDungeonJailGuard() && KDGameData.KinkyDungeonGuardTimer > 0 && KDGameData.KinkyDungeonGuardTimerMax - KDGameData.KinkyDungeonGuardTimer > 6 && KDGameData.PrisonerState == 'jail') {
        if (KDGuardActions[KinkyDungeonJailGuard().CurrentAction] && KDGuardActions[KinkyDungeonJailGuard().CurrentAction].assignable && KDGuardActions[KinkyDungeonJailGuard().CurrentAction].assignable(KinkyDungeonJailGuard(), xx, yy)) {
            KDAssignGuardAction(KinkyDungeonJailGuard(), xx, yy);
        }
    }
    if (KinkyDungeonJailGuard()) {
        if (KDGuardActions[KinkyDungeonJailGuard().CurrentAction] && KDGuardActions[KinkyDungeonJailGuard().CurrentAction].handle) {
            KDGuardActions[KinkyDungeonJailGuard().CurrentAction].handle(KinkyDungeonJailGuard(), xx, yy, delta);
        }
        if (KDGameData.PrisonerState != 'jail') {
            KinkyDungeonJailGuard().CurrentAction = "jailWander";
        }
        KinkyDungeonJailGuard().gxx = KDGameData.PrisonerState == 'jail' && KDGameData.KinkyDungeonGuardTimer > 0 ? KinkyDungeonJailGuard().gx : xx;
        KinkyDungeonJailGuard().gyy = KDGameData.PrisonerState == 'jail' && KDGameData.KinkyDungeonGuardTimer > 0 ? KinkyDungeonJailGuard().gy : yy;
        if (KDGameData.KinkyDungeonGuardTimer > 0) {
            if (!KinkyDungeonFlags.has("notickguardtimer") && !KinkyDungeonAngel()) {
                KDGameData.KinkyDungeonGuardTimer -= 1;
                if (KDGameData.KinkyDungeonGuardTimer <= 0) {
                    KinkyDungeonJailGuard().gx = xx;
                    KinkyDungeonJailGuard().gy = yy;
                }
            }
        }
        else {
            if (KinkyDungeonJailGuard()
                && KinkyDungeonJailGuard().x == xx
                && KinkyDungeonJailGuard().y == yy
                && (!KinkyDungeonJailGuard().IntentAction || KinkyDungeonJailGuard().IntentAction.startsWith('jail'))
                && KDGameData.PrisonerState
                && !KinkyDungeonJailGuard().hostile
                && !KinkyDungeonFlags.has("notickguardtimer")
                && !KinkyDungeonFlags.has("nojailbreak")) {
                let g = KinkyDungeonJailGuard();
                KDClearItems(g);
                KDSpliceIndex(KinkyDungeonEntities.indexOf(KinkyDungeonJailGuard()), 1);
                if (KinkyDungeonTilesGet((xx - 1) + "," + yy) && KinkyDungeonTilesGet((xx - 1) + "," + yy).Type == "Door") {
                    KinkyDungeonMapSet(xx - 1, yy, 'D');
                    if (KDGameData.PrisonerState == 'jail')
                        KinkyDungeonTilesGet((xx - 1) + "," + yy).Lock = KinkyDungeonGenerateLock(true, MiniGameKinkyDungeonLevel);
                    if (KDGameData.PrisonerState == 'jail' && KinkyDungeonVisionGet(g.x, g.y))
                        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonGuardDisappear").replace("EnemyName", TextGet("Name" + g.Enemy.name)), "#ff0000", 6);
                    if (KinkyDungeonPlayerInCell(true))
                        KinkyDungeonChangeRep("Ghost", 1 + KDGameData.KinkyDungeonPrisonExtraGhostRep);
                    KDGameData.KinkyDungeonPrisonExtraGhostRep = 0;
                }
            }
            else if (!KinkyDungeonJailGuard().IntentAction || KinkyDungeonJailGuard().IntentAction.startsWith('jail')) {
                KinkyDungeonJailGuard().gx = xx;
                KinkyDungeonJailGuard().gy = yy;
            }
        }
    }
    if (!KDGameData.PrisonerState || KDGameData.PrisonerState == 'chase') {
        for (let T of Object.values(KinkyDungeonTiles)) {
            if (T.Lock && T.Type == "Door" && T.Jail)
                T.Lock = undefined;
        }
    }
    if (!KinkyDungeonJailGuard()) {
        KDGameData.KinkyDungeonGuardTimer = 0;
    }
    else {
        if (KDHelpless(KinkyDungeonJailGuard())) {
            KDGameData.KinkyDungeonJailGuard = 0;
        }
        if (KinkyDungeonJailGuard() && KDistChebyshev(KinkyDungeonJailGuard().x - KinkyDungeonPlayerEntity.x, KinkyDungeonJailGuard().y - KinkyDungeonPlayerEntity.y) > 10 && KDGameData.KinkyDungeonGuardTimer < 4) {
            KDGameData.KinkyDungeonJailGuard = 0;
        }
    }
    if (!KinkyDungeonEntities.includes(KinkyDungeonJailGuard())) {
        if (KDGameData.KinkyDungeonGuardSpawnTimer == 0 || KinkyDungeonJailGuard())
            KDGameData.KinkyDungeonGuardSpawnTimer = 14 + Math.floor(KDRandom() * (KDGameData.KinkyDungeonGuardSpawnTimerMax - KDGameData.KinkyDungeonGuardSpawnTimerMin));
        KDGameData.KinkyDungeonJailGuard = 0;
    }
}
function KinkyDungeonLockableItems() {
    let LockableGroups = [];
    for (let gr of KinkyDungeonStruggleGroupsBase) {
        let g = gr;
        if (gr == "ItemM") {
            g = "ItemMouth";
        }
        if (gr == "ItemH") {
            g = "ItemHead";
        }
        let currentItem = KinkyDungeonGetRestraintItem(g);
        if (currentItem && !currentItem.lock && KinkyDungeonIsLockable(KDRestraint(currentItem))) {
            LockableGroups.push(g);
        }
    }
    return LockableGroups;
}
function KinkyDungeonMissingJailUniform() {
    let MissingGroups = [];
    for (let gr of KinkyDungeonStruggleGroupsBase) {
        let g = gr;
        if (gr == "ItemM") {
            if (KinkyDungeonGetRestraintItem("ItemMouth2"))
                g = "ItemMouth3";
            else if (KinkyDungeonGetRestraintItem("ItemMouth"))
                g = "ItemMouth2";
            else
                g = "ItemMouth";
        }
        if (gr == "ItemH") {
            if (KinkyDungeonGetRestraintItem("ItemHood"))
                g = "ItemHood";
            else
                g = "ItemHood";
        }
        let rest = KinkyDungeonGetJailRestraintForGroup(g);
        let currentItem = KinkyDungeonGetRestraintItem(g);
        if (rest
            && (!currentItem || (KDCanAddRestraint(rest, KinkyDungeonStatsChoice.has("MagicHands") ? true : undefined, undefined, !KinkyDungeonStatsChoice.has("TightRestraints") ? true : undefined, undefined, KinkyDungeonStatsChoice.has("MagicHands") ? true : undefined, undefined, KinkyDungeonJailGuard())
                && (!currentItem.dynamicLink || !KDDynamicLinkList(currentItem, true).some((item) => { return rest.name == item.name; }))))
            && (KinkyDungeonStatsChoice.get("arousalMode") || !rest.arousalMode)
            && (KinkyDungeonStatsChoice.get("arousalModePlug") || rest.Group != "ItemButt")
            && (KinkyDungeonStatsChoice.get("arousalModePiercing") || !rest.piercing)) {
            MissingGroups.push(g);
        }
    }
    return MissingGroups;
}
function KinkyDungeonTooMuchRestraint() {
    let Groups = ["ItemArms", "ItemHands", "ItemHead", "ItemMouth", "ItemMouth2", "ItemMouth3", "ItemHood", "ItemLegs", "ItemFeet", "ItemHands"];
    for (let g of KinkyDungeonStruggleGroupsBase) {
        let rest = KinkyDungeonGetJailRestraintForGroup(g);
        if (rest && !Groups.includes(g))
            Groups.push(g);
    }
    let RemoveGroups = [];
    for (let g of Groups) {
        let rest = KinkyDungeonGetJailRestraintForGroup(g);
        let currentItem = KinkyDungeonGetRestraintItem(g);
        let cutoffpower = KinkyDungeonStatsChoice.get("KinkyPrison") ? -50 : 4;
        let lockMult = currentItem ? Math.max(1, KinkyDungeonGetLockMult(currentItem.lock) - 0.5) : (currentItem && KinkyDungeonIsLockable(KDRestraint(currentItem)) ? 0.4 : 1);
        if ((!rest && currentItem && KDRestraint(currentItem).power * lockMult <= Math.max(cutoffpower + 0.1, rest ? rest.power : cutoffpower))
            || (rest && currentItem && currentItem && rest.name != currentItem.name
                && (KDRestraint(currentItem).power < rest.power || KDRestraint(currentItem).power * lockMult <= Math.max(cutoffpower + 0.1, rest ? rest.power : cutoffpower)))) {
            if (!currentItem || (!currentItem.curse && !KDRestraint(currentItem).curse && !KDRestraint(currentItem).enchanted))
                RemoveGroups.push(g);
        }
    }
    return RemoveGroups;
}
function KinkyDungeonHandleLeashTour(xx, yy, type) {
    var _a;
    if (!KinkyDungeonJailGuard().RemainingJailLeashTourWaypoints && KinkyDungeonJailGuard().x === KinkyDungeonJailGuard().NextJailLeashTourWaypointX && KinkyDungeonJailGuard().y === KinkyDungeonJailGuard().NextJailLeashTourWaypointY) {
        let leashItemToRemove = KinkyDungeonGetRestraintItem("ItemNeckRestraints");
        if (leashItemToRemove) {
            KinkyDungeonRemoveRestraint("ItemNeckRestraints", false);
            let msg = TextGet("KinkyDungeonRemoveRestraints").replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name));
            msg = msg.replace("OldRestraintName", TextGet("Restraint" + leashItemToRemove.name));
            KinkyDungeonSendTextMessage(5, msg, "yellow", 1);
        }
        KDGameData.KinkyDungeonPrisonExtraGhostRep += 2;
        let entity = KinkyDungeonJailGuard() ? KinkyDungeonJailGuard() : KinkyDungeonPlayerEntity;
        let nearestJail = KinkyDungeonNearestJailPoint(entity.x, entity.y);
        let jailRadius = (nearestJail && nearestJail.radius) ? nearestJail.radius : 1.5;
        let playerInCell = nearestJail ? (Math.abs(KinkyDungeonPlayerEntity.x - nearestJail.x) < jailRadius - 1 && Math.abs(KinkyDungeonPlayerEntity.y - nearestJail.y) <= jailRadius)
            : null;
        if (!playerInCell) {
            let point = { x: nearestJail.x, y: nearestJail.y };
            if (point) {
                KDMovePlayer(point.x, point.y, false);
            }
        }
        if (((_a = KinkyDungeonJailGuard()) === null || _a === void 0 ? void 0 : _a.KinkyDungeonJailTourInfractions) < 1) {
            let item = "CookieJailer";
            KinkyDungeonSendDialogue(KinkyDungeonJailGuard(), TextGet("KinkyDungeonJailerReleaseGoodGirl").replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name)), "#ffff00", 4, 9);
            KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonJailerReleaseGoodGirlMsg")
                .replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name))
                .replace("ItemName", TextGet("KinkyDungeonInventoryItem" + item)), "#88ff88", 1);
            KinkyDungeonChangeConsumable(KinkyDungeonFindConsumable(item), 1);
        }
        let enemy = KinkyDungeonEnemyAt(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
        if (enemy)
            enemy.x += 1;
        KinkyDungeonJailGuard().CurrentAction = "jailWander";
        KDGameData.KinkyDungeonJailTourTimer = KDGameData.KinkyDungeonJailTourTimerMin + Math.floor((KDGameData.KinkyDungeonJailTourTimerMax - KDGameData.KinkyDungeonJailTourTimerMin) * KDRandom());
        KinkyDungeonJailGuard().gx = KinkyDungeonJailGuard().x;
        KinkyDungeonJailGuard().gy = KinkyDungeonJailGuard().y;
    }
    else {
        let playerDist = KDistChebyshev(KinkyDungeonJailGuard().x - KinkyDungeonPlayerEntity.x, KinkyDungeonJailGuard().y - KinkyDungeonPlayerEntity.y);
        let wearingLeash = KinkyDungeonIsWearingLeash();
        if (!wearingLeash) {
            let touchesPlayer = KinkyDungeonCheckLOS(KinkyDungeonJailGuard(), KinkyDungeonPlayerEntity, playerDist, 1.5, false, false);
            if (touchesPlayer) {
                if (!KinkyDungeonGetRestraintItem("ItemNeck")) {
                    let collar = KinkyDungeonGetRestraintByName("BasicCollar");
                    KinkyDungeonAddRestraintIfWeaker(collar, KinkyDungeonJailGuard().Enemy.power, true, "", undefined, undefined, undefined, KDGetFaction(KinkyDungeonJailGuard()), KinkyDungeonStatsChoice.has("MagicHands") ? true : undefined, undefined, KinkyDungeonJailGuard());
                    let msg = TextGet("KinkyDungeonAddRestraints").replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name));
                    msg = msg.replace("NewRestraintName", TextGet("Restraint" + collar.name));
                    KinkyDungeonSendTextMessage(5, msg, "yellow", 1);
                    KinkyDungeonJailGuard().NextJailLeashTourWaypointX = KinkyDungeonJailGuard().x;
                    KinkyDungeonJailGuard().NextJailLeashTourWaypointY = KinkyDungeonJailGuard().y;
                    KinkyDungeonJailGuard().gx = KinkyDungeonJailGuard().x;
                    KinkyDungeonJailGuard().gy = KinkyDungeonJailGuard().y;
                }
                else {
                    let leash = KinkyDungeonGetRestraintByName("BasicLeash");
                    KinkyDungeonAddRestraintIfWeaker(leash, KinkyDungeonJailGuard().Enemy.power, true, "", undefined, undefined, undefined, KDGetFaction(KinkyDungeonJailGuard()), KinkyDungeonStatsChoice.has("MagicHands") ? true : undefined, undefined, KinkyDungeonJailGuard());
                    let msg = TextGet("KinkyDungeonAddRestraints").replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name));
                    msg = msg.replace("NewRestraintName", TextGet("Restraint" + leash.name));
                    KinkyDungeonSendTextMessage(5, msg, "yellow", 1);
                    KinkyDungeonJailGuard().NextJailLeashTourWaypointX = KinkyDungeonJailGuard().x;
                    KinkyDungeonJailGuard().NextJailLeashTourWaypointY = KinkyDungeonJailGuard().y;
                    KinkyDungeonJailGuard().gx = KinkyDungeonJailGuard().x;
                    KinkyDungeonJailGuard().gy = KinkyDungeonJailGuard().y;
                }
                KinkyDungeonAttachTetherToEntity(2, KinkyDungeonJailGuard());
            }
            else {
                KinkyDungeonJailGuard().gx = KinkyDungeonPlayerEntity.x;
                KinkyDungeonJailGuard().gy = KinkyDungeonPlayerEntity.y;
            }
        }
        else if (!KinkyDungeonTetherLength()) {
            KinkyDungeonJailGuard().gx = KinkyDungeonPlayerEntity.x;
            KinkyDungeonJailGuard().gy = KinkyDungeonPlayerEntity.y;
            if (playerDist < 1.5) {
                KinkyDungeonAttachTetherToEntity(2, KinkyDungeonJailGuard());
            }
        }
        else if (KinkyDungeonJailGuard().RemainingJailLeashTourWaypoints > 0
            && (KDistChebyshev(KinkyDungeonJailGuard().x - KinkyDungeonJailGuard().NextJailLeashTourWaypointX, KinkyDungeonJailGuard().y - KinkyDungeonJailGuard().NextJailLeashTourWaypointY) < 2
                || (KDRandom() < 0.05 && KDistChebyshev(KinkyDungeonJailGuard().x - KinkyDungeonJailGuard().NextJailLeashTourWaypointX, KinkyDungeonJailGuard().y - KinkyDungeonJailGuard().NextJailLeashTourWaypointY) < 5)
                || KDRandom() < 0.01)) {
            KinkyDungeonJailGuard().RemainingJailLeashTourWaypoints--;
            if (KinkyDungeonJailGuard().NextJailLeashTourWaypointX > KinkyDungeonJailLeashX + 2) {
                if (KDRandom() < 0.5 && KinkyDungeonLastAction == "Move") {
                    let index = "0";
                    if (KinkyDungeonJailGuard().KinkyDungeonJailTourInfractions < 1) {
                        index = "" + Math.floor(KDRandom() * 6);
                    }
                    KinkyDungeonSendDialogue(KinkyDungeonJailGuard(), TextGet("KinkyDungeonJailerGoodGirl" + index).replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name)), "#ffff00", 4, 9);
                }
            }
            KinkyDungeonJailGuardGetLeashWaypoint(xx, yy, type);
        }
        else {
            let pullDist = 2.5;
            if (playerDist < 1.5) {
                KinkyDungeonAttachTetherToEntity(2, KinkyDungeonJailGuard());
            }
            if (playerDist > pullDist && KinkyDungeonSlowLevel < 2 && KinkyDungeonCheckProjectileClearance(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, KinkyDungeonJailGuard().x, KinkyDungeonJailGuard().y)) {
                let msg = TextGet("KinkyDungeonRemindJailTour" + KinkyDungeonJailGuard().KinkyDungeonJailTourInfractions).replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name));
                let msgPrev = TextGet("KinkyDungeonRemindJailTour" + Math.max(0, KinkyDungeonJailGuard().KinkyDungeonJailTourInfractions - 1)).replace("EnemyName", TextGet("Name" + KinkyDungeonJailGuard().Enemy.name));
                if (KinkyDungeonLastAction == "Move") {
                    KinkyDungeonSendDialogue(KinkyDungeonJailGuard(), msg, "#ffff00", 4, 7 + KinkyDungeonJailGuard().KinkyDungeonJailTourInfractions);
                    if (KinkyDungeonJailGuard().gx != KinkyDungeonPlayerEntity.x || KinkyDungeonJailGuard().gy != KinkyDungeonPlayerEntity.y && KinkyDungeonTextMessage != msgPrev) {
                        KinkyDungeonJailGuard().KinkyDungeonJailTourInfractions = Math.min(3, KinkyDungeonJailGuard().KinkyDungeonJailTourInfractions + 1);
                    }
                }
                if (KinkyDungeonJailGuard().KinkyDungeonJailTourInfractions == 3 && KinkyDungeonJailGuard().RemainingJailLeashTourWaypoints > 1)
                    KinkyDungeonJailGuard().RemainingJailLeashTourWaypoints = 1;
                KinkyDungeonJailGuard().gx = KinkyDungeonPlayerEntity.x;
                KinkyDungeonJailGuard().gy = KinkyDungeonPlayerEntity.y;
                KinkyDungeonUpdateTether(true, KinkyDungeonPlayerEntity);
            }
            else {
                KDGameData.KinkyDungeonLeashedPlayer = 2;
                KDGameData.KinkyDungeonLeashingEnemy = KinkyDungeonJailGuard().id;
                KinkyDungeonJailGuard().gx = KinkyDungeonJailGuard().NextJailLeashTourWaypointX;
                KinkyDungeonJailGuard().gy = KinkyDungeonJailGuard().NextJailLeashTourWaypointY;
                let guardPath = KinkyDungeonFindPath(KinkyDungeonJailGuard().x, KinkyDungeonJailGuard().y, KinkyDungeonJailGuard().gx, KinkyDungeonJailGuard().gy, false, false, true, KinkyDungeonMovableTilesEnemy);
                if (guardPath && guardPath.length > 0 && KDistChebyshev(guardPath[0].x - KinkyDungeonJailGuard().x, guardPath[0].y - KinkyDungeonJailGuard().y) < 1.5) {
                    if (guardPath[0].x === KinkyDungeonPlayerEntity.x && guardPath[0].y === KinkyDungeonPlayerEntity.y) {
                        KinkyDungeonTargetTile = null;
                        KinkyDungeonTargetTileLocation = "";
                        KDMovePlayer(KinkyDungeonJailGuard().x, KinkyDungeonJailGuard().y, false);
                        KinkyDungeonJailGuard().x = guardPath[0].x;
                        KinkyDungeonJailGuard().y = guardPath[0].y;
                    }
                    let enemy = KinkyDungeonEnemyAt(guardPath[0].x, guardPath[0].y);
                    if (enemy) {
                        KDMoveEntity(enemy, KinkyDungeonJailGuard().x, KinkyDungeonJailGuard().y, true, undefined, undefined, true);
                        KinkyDungeonJailGuard().x = guardPath[0].x;
                        KinkyDungeonJailGuard().y = guardPath[0].y;
                    }
                }
                else
                    KinkyDungeonJailGuardGetLeashWaypoint(xx, yy, type);
                KinkyDungeonUpdateTether(true, KinkyDungeonPlayerEntity);
            }
        }
    }
}
function KinkyDungeonJailGuardGetLeashWaypoint(xx, yy, type) {
    if (type == "transfer") {
        let nearestJail = KinkyDungeonRandomJailPoint(["jail"], [KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y)]);
        if (nearestJail) {
            KinkyDungeonJailGuard().NextJailLeashTourWaypointX = nearestJail.x;
            KinkyDungeonJailGuard().NextJailLeashTourWaypointY = nearestJail.y;
            KinkyDungeonJailGuard().gx = KinkyDungeonJailGuard().NextJailLeashTourWaypointX;
            KinkyDungeonJailGuard().gy = KinkyDungeonJailGuard().NextJailLeashTourWaypointY;
        }
    }
    else {
        if (KinkyDungeonJailGuard().RemainingJailLeashTourWaypoints === 0) {
            let nearestJail = KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
            KinkyDungeonJailGuard().NextJailLeashTourWaypointX = nearestJail.x;
            KinkyDungeonJailGuard().NextJailLeashTourWaypointY = nearestJail.y;
            KinkyDungeonJailGuard().gx = KinkyDungeonJailGuard().NextJailLeashTourWaypointX;
            KinkyDungeonJailGuard().gy = KinkyDungeonJailGuard().NextJailLeashTourWaypointY;
        }
        else {
            let randomPoint = KinkyDungeonJailGetLeashPoint(xx, yy, KinkyDungeonJailGuard());
            KinkyDungeonJailGuard().NextJailLeashTourWaypointX = randomPoint.x;
            KinkyDungeonJailGuard().NextJailLeashTourWaypointY = randomPoint.y;
            KinkyDungeonJailGuard().gx = KinkyDungeonJailGuard().NextJailLeashTourWaypointX;
            KinkyDungeonJailGuard().gy = KinkyDungeonJailGuard().NextJailLeashTourWaypointY;
        }
    }
}
function KinkyDungeonJailGetLeashPoint(xx, yy, enemy) {
    let randomPoint = { x: xx, y: yy };
    for (let i = 0; i < 40; ++i) {
        let candidatePoint = KinkyDungeonGetRandomEnemyPoint(true, false, enemy);
        if (candidatePoint) {
            let distanceFromCell = Math.sqrt((xx - candidatePoint.x) * (xx - candidatePoint.x) + (yy - candidatePoint.y) * (yy - candidatePoint.y));
            if (distanceFromCell > KinkyDungeonJailLeash * 2 && distanceFromCell < KinkyDungeonJailLeash * 6) {
                randomPoint = candidatePoint;
                break;
            }
        }
    }
    return randomPoint;
}
function KinkyDungeonPlayerInCell(any, qualified, filter) {
    var _a;
    if (!filter && ((_a = KinkyDungeonTilesGet(KinkyDungeonPlayerEntity.x + "," + KinkyDungeonPlayerEntity.y)) === null || _a === void 0 ? void 0 : _a.Jail)) {
        return true;
    }
    let nearestJail = KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, filter, any, qualified);
    if (!nearestJail || nearestJail.type != "jail")
        return false;
    return KDistChebyshev(KinkyDungeonPlayerEntity.x - nearestJail.x, KinkyDungeonPlayerEntity.y - nearestJail.y) < 2;
}
function KinkyDungeonPointInCell(x, y) {
    let nearestJail = KinkyDungeonNearestJailPoint(x, y);
    if (!nearestJail)
        return false;
    return KDistChebyshev(x - nearestJail.x, y - nearestJail.y) < 2;
}
function KinkyDungeonPassOut(noteleport) {
    KDDefeatedPlayerTick();
    KDBreakTether();
    KDGameData.KinkyDungeonLeashedPlayer = 0;
    KinkyDungeonBlindLevel = 6;
    KinkyDungeonStatBlind = 10;
    KinkyDungeonUpdateLightGrid = true;
    KDGameData.AlertTimer = 0;
    KinkyDungeonRemoveBuffsWithTag(KinkyDungeonPlayerEntity, ["passout"]);
    KinkyDungeonSendEvent("passout", {});
    KinkyDungeonStripInventory(false);
    KinkyDungeonSetDress("Bikini", "Bikini");
    KinkyDungeonDressPlayer();
    KinkyDungeonChangeStamina(-100);
    KinkyDungeonChangeMana(-100);
    KinkyDungeonChangeDistraction(-100);
    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonPassOut"), "#ff0000", 5);
    KinkyDungeonSendActionMessage(10, TextGet("KinkyDungeonPassOut2"), "#ff0000", 5);
    if (KDToggles.Sound)
        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/StoneDoor_Close.ogg");
    KDGameData.JailKey = false;
    KDResetAllAggro();
    KinkyDungeonSaveGame();
    if (!noteleport) {
        let point = KinkyDungeonGetRandomEnemyPoint(true, false, undefined);
        if (point) {
            KDMovePlayer(point.x, point.y, false);
        }
    }
    for (let e of KinkyDungeonEntities) {
        if (e.hostile < 9000)
            e.hostile = 0;
        if (e.vp > 0)
            e.vp = 0;
        if (e.aware)
            e.aware = false;
        if (e.maxlifetime && e.maxlifetime < 9000)
            e.lifetime = 0;
        KDExpireFlags(e);
    }
    KinkyDungeonLoseJailKeys();
    KinkyDungeonSlowMoveTurns = 10;
}
function KDGetJailDoor(x, y) {
    let point = KinkyDungeonNearestJailPoint(x, y);
    if (point) {
        x = point.x;
        y = point.y;
    }
    x += KinkyDungeonJailLeashX - 1;
    return { tile: KinkyDungeonTilesGet((x) + "," + y), x: x, y: y };
}
function KDDefeatedPlayerTick() {
    KinkyDungeonSetFlag("playerDefeated", 1);
}
function KDEnterDollTerminal(willing, cancelDialogue = true) {
    KinkyDungeonSetFlag("refusedShopkeeperRescue", 5);
    KDGameData.PrisonerState = 'jail';
    KDGameData.RoomType = "DollRoom";
    KDGameData.MapMod = "";
    if (cancelDialogue)
        KDGameData.CurrentDialog = "";
    let params = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]];
    KDGameData.DollRoomCount = 0;
    KinkyDungeonCreateMap(params, MiniGameKinkyDungeonLevel);
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv).removePrison && (!KinkyDungeonStatsChoice.get("KinkyPrison") || KDRestraint(inv).removeOnLeash || KDRestraint(inv).freeze || KDRestraint(inv).immobile)) {
            KinkyDungeonRemoveRestraint(KDRestraint(inv).Group, false);
        }
    }
    if (!willing) {
        let defeat_outfit = "DollSuit";
        if (KinkyDungeonPlayerTags.has("Cyber"))
            defeat_outfit = "CyberDoll";
        if (KinkyDungeonStatsChoice.has("KeepOutfit"))
            defeat_outfit = "Default";
        KinkyDungeonSetDress(defeat_outfit, defeat_outfit);
    }
    KinkyDungeonDressPlayer();
    if (KDToggles.Sound)
        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/StoneDoor_Close.ogg");
    KDGameData.JailKey = false;
    KDMovePlayer(Math.floor(KinkyDungeonGridWidth / 2), Math.floor(KinkyDungeonGridHeight / 2), false);
    KinkyDungeonLoseJailKeys();
    KDResetAllAggro();
    KinkyDungeonSaveGame();
}
function KinkyDungeonDefeat(PutInJail) {
    var _a, _b;
    KinkyDungeonInterruptSleep();
    if (KinkyDungeonTempWait)
        KDDisableAutoWait();
    KDDefeatedPlayerTick();
    KDBreakTether();
    KDGameData.CurrentDialog = "";
    KDGameData.CurrentDialogStage = "";
    KDGameData.KinkyDungeonLeashedPlayer = 0;
    if (KinkyDungeonFlags.get("JailIntro"))
        KinkyDungeonSetFlag("JailRepeat", -1);
    KinkyDungeonBlindLevel = 3;
    KinkyDungeonStatBlind = 3;
    KinkyDungeonUpdateLightGrid = true;
    if (!KDGameData.TimesJailed)
        KDGameData.TimesJailed = 1;
    else
        KDGameData.TimesJailed += 1;
    KDGameData.JailTurns = 0;
    KDGameData.PrisonerState = "jail";
    KDGameData.AlertTimer = 0;
    let nearestJail = KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
    if (!nearestJail) {
        nearestJail = Object.assign({ type: "jail", radius: 1 }, KinkyDungeonStartPosition);
    }
    KDSendStatus('jailed');
    KDSendEvent('jail');
    KDGameData.WarningLevel = 0;
    KDGameData.AncientEnergyLevel = 0;
    KDGameData.JailRemoveRestraintsTimer = 0;
    KinkyDungeonSendEvent("defeat", {});
    for (let inv of KinkyDungeonAllRestraint()) {
        if (KDRestraint(inv).removePrison && (!KinkyDungeonStatsChoice.get("KinkyPrison") || KDRestraint(inv).removeOnLeash || KDRestraint(inv).freeze)) {
            KinkyDungeonRemoveRestraint(KDRestraint(inv).Group, false);
        }
    }
    KDGameData.KinkyDungeonPrisonReduction = 0;
    KDGameData.KinkyDungeonGuardSpawnTimer = 4 + Math.floor(KDRandom() * (KDGameData.KinkyDungeonGuardSpawnTimerMax - KDGameData.KinkyDungeonGuardSpawnTimerMin));
    KDGameData.KinkyDungeonSpawnJailersMax = 2;
    if (KinkyDungeonGoddessRep.Prisoner)
        KDGameData.KinkyDungeonSpawnJailersMax += Math.round(6 * (KinkyDungeonGoddessRep.Prisoner + 50) / 100);
    KinkyDungeonStatBlind = 3;
    KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonLeashed"), "#ff0000", 3);
    if (!KinkyDungeonJailedOnce) {
        KinkyDungeonJailedOnce = true;
        KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonLeashed2"), "#ff0000", 3);
    }
    let params = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]];
    KDGameData.KinkyDungeonSpawnJailers = KDGameData.KinkyDungeonSpawnJailersMax;
    let defeat_outfit = params.defeat_outfit;
    let collar = KinkyDungeonGetRestraintItem("ItemNeck");
    if (collar && KDRestraint(collar)) {
        if (KDRestraint(collar).name == "DragonCollar")
            defeat_outfit = "Dragon";
        if (KDRestraint(collar).name == "MaidCollar")
            defeat_outfit = "Maid";
        if (KDRestraint(collar).name == "ExpCollar")
            defeat_outfit = "BlueSuitPrison";
        if (KDRestraint(collar).name == "WolfCollar")
            defeat_outfit = "Wolfgirl";
        if (KDRestraint(collar).name == "MithrilCollar")
            defeat_outfit = "Elven";
        if (KDRestraint(collar).name == "ObsidianCollar")
            defeat_outfit = "Obsidian";
    }
    if (KinkyDungeonStatsChoice.has("KeepOutfit"))
        defeat_outfit = "Default";
    KinkyDungeonSetDress(defeat_outfit, "JailUniform");
    KinkyDungeonDressPlayer();
    KinkyDungeonStripInventory(true);
    if (defeat_outfit != params.defeat_outfit) {
        if (!KinkyDungeonInventoryGet(defeat_outfit))
            KinkyDungeonInventoryAdd({ name: defeat_outfit, type: Outfit, id: KinkyDungeonGetItemID() });
    }
    else if (!KinkyDungeonInventoryGet("JailUniform"))
        KinkyDungeonInventoryAdd({ name: "JailUniform", type: Outfit, id: KinkyDungeonGetItemID() });
    KinkyDungeonDressPlayer();
    if (KDToggles.Sound)
        AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/StoneDoor_Close.ogg");
    KDGameData.JailKey = false;
    KinkyDungeonSaveGame();
    if (PutInJail) {
        KDGameData.RoomType = "Jail";
        KDGameData.MapMod = "";
        KinkyDungeonCreateMap(params, MiniGameKinkyDungeonLevel);
        KinkyDungeonSetFlag("LeashToPrison", 0);
        nearestJail = KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
    }
    KDMovePlayer(nearestJail.x + (((_a = nearestJail.direction) === null || _a === void 0 ? void 0 : _a.x) || 0), nearestJail.y + (((_b = nearestJail.direction) === null || _b === void 0 ? void 0 : _b.y) || 0), false);
    if (nearestJail.direction) {
        KinkyDungeonSetFlag("conveyed", 1);
    }
    if (nearestJail.restraint) {
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName(nearestJail.restraint), MiniGameKinkyDungeonLevel, false, undefined);
    }
    if (nearestJail.restrainttags) {
        let restraint = KinkyDungeonGetRestraint({ tags: nearestJail.restrainttags }, MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], false, undefined);
        if (restraint)
            KinkyDungeonAddRestraintIfWeaker(restraint, MiniGameKinkyDungeonLevel, false, undefined);
    }
    KinkyDungeonLoseJailKeys();
    let leash = KinkyDungeonGetRestraintItem("ItemNeckRestraints");
    if (leash && (leash.tx || leash.ty)) {
        leash.tx = undefined;
        leash.ty = undefined;
    }
    KDGameData.KinkyDungeonSpawnJailers = KDGameData.KinkyDungeonSpawnJailersMax - 1;
    for (let X = 1; X < KinkyDungeonGridWidth - 1; X++)
        for (let Y = 1; Y < KinkyDungeonGridHeight - 1; Y++) {
            let tile = KinkyDungeonTilesGet(X + "," + Y);
            if (tile && tile.Jail && tile.ReLock && (KinkyDungeonMapGet(X, Y) == 'd' || KinkyDungeonMapGet(X, Y) == 'D')) {
                KinkyDungeonMapSet(X, Y, 'D');
                if (tile && !tile.Lock) {
                    tile.Lock = "Red";
                    KDUpdateDoorNavMap();
                }
            }
        }
    KDKickEnemies(nearestJail);
    KDResetAllAggro();
}
function KDEnemyIsTemporary(enemy) {
    return enemy.Enemy.tags.temporary || (enemy.lifetime > 0);
}
function KDKickEnemies(nearestJail) {
    let enemies = [];
    for (let e of KinkyDungeonEntities) {
        if (!e.Enemy.tags.temporary) {
            if ((e.x == nearestJail.x && e.y == nearestJail.y) || (!e.Enemy.tags.prisoner && !e.Enemy.tags.peaceful && !KDEnemyHasFlag(e, "imprisoned"))) {
                if (KDistChebyshev(e.x - nearestJail.x, e.y - nearestJail.y) <= 4 || (e.aware || e.vp > 0.01 || e.aggro > 0)) {
                    let p = KinkyDungeonGetRandomEnemyPoint(true);
                    if (p) {
                        e.x = p.x;
                        e.y = p.y;
                        e.path = undefined;
                        e.gx = e.x;
                        e.gy = e.y;
                    }
                }
                if (e.boundLevel && e.boundLevel < 9000)
                    e.boundLevel = 0;
            }
            if (e.hostile < 9000)
                e.hostile = 0;
            KDExpireFlags(e);
            KDResetIntent(e, {});
            enemies.push(e);
        }
    }
    KinkyDungeonEntities = enemies;
    KDUpdateEnemyCache = true;
}
function KDResetAllIntents() {
    for (let e of KinkyDungeonEntities) {
        if (e.IntentAction && !KDIntentEvents[e.IntentAction].noMassReset)
            KDResetIntent(e);
    }
}
function KDResetAllAggro() {
    var _a;
    for (let e of KinkyDungeonEntities) {
        if (e.hostile && !((_a = KDIntentEvents[e.IntentAction]) === null || _a === void 0 ? void 0 : _a.noMassReset))
            e.hostile = 0;
    }
}
function KDKickEnemy(e) {
    if (!e.Enemy.tags.temporary) {
        if (!e.Enemy.tags.prisoner && !KDEnemyHasFlag(e, "imprisoned")) {
            let p = KinkyDungeonGetRandomEnemyPoint(true);
            if (p) {
                e.x = p.x;
                e.y = p.y;
                e.path = undefined;
                e.gx = e.x;
                e.gy = e.y;
            }
            if (e.boundLevel && e.boundLevel < 9000)
                e.boundLevel = 0;
        }
        if (e.hostile < 9000)
            e.hostile = 0;
        KDExpireFlags(e);
        KDResetIntent(e, {});
    }
    KDClearItems(e);
}
function KDKickEnemyLocal(e) {
    let point = KinkyDungeonGetNearbyPoint(e.x, e.y, true, undefined, true, true);
    if (point) {
        KDMoveEntity(e, point.x, point.y, false);
    }
}
function KinkyDungeonStripInventory(KeepPicks) {
    KinkyDungeonRedKeys = 0;
    KinkyDungeonBlueKeys = 0;
    KinkyDungeonLockpicks = KeepPicks ? (Math.min(Math.max(0, Math.round(3 * (1 - (KinkyDungeonGoddessRep.Prisoner + 50) / 100))), KinkyDungeonLockpicks)) : 0;
    let newInv = KinkyDungeonInventory.get(Restraint);
    let HasBound = false;
    let boundWeapons = [];
    if (HasBound) {
    }
    KinkyDungeonAddLostItems(KinkyDungeonFullInventory(), HasBound);
    KDInitInventory();
    KinkyDungeonInventory.set(Restraint, newInv);
    KinkyDungeonInventoryAddWeapon("Unarmed");
    KDSetWeapon(null, true);
    for (let b of boundWeapons) {
        KinkyDungeonInventoryAddWeapon(b);
    }
}
function KDExpireFlags(enemy) {
    if (enemy.flags) {
        for (let f of Object.entries(enemy.flags)) {
            if (f[1] > 0 && f[1] < 9000)
                enemy.flags[f[0]] = 0;
        }
    }
}
function KDGetJailRestraints(overrideTags, requireJail, requireParole) {
    let restraints = [];
    let guard = KinkyDungeonJailGuard();
    let tags = overrideTags ? overrideTags : [];
    if (!overrideTags) {
        if (!guard)
            tags.push("jailer");
        else {
            for (let t of Object.keys(KinkyDungeonJailGuard().Enemy.tags)) {
                if (KDJailOutfits[t] && (!requireJail || KDJailOutfits[t].jail) && (!requireParole || KDJailOutfits[t].parole))
                    tags.push(t);
            }
        }
    }
    let newtags = [];
    for (let t of tags) {
        newtags.push(t);
    }
    for (let t of tags) {
        let tag = KDJailOutfits[t];
        if (tag.overridelowerpriority) {
            let pri = tag.priority;
            for (let tt of newtags) {
                let tag2 = KDJailOutfits[tt];
                if (tag2.priority < pri)
                    newtags.splice(newtags.indexOf(tt), 1);
            }
        }
    }
    tags = newtags;
    for (let t of tags) {
        for (let r of KDJailOutfits[t].restraints) {
            restraints.push(r);
        }
    }
    return restraints;
}
let KDSetpieceAttempts = 10;
let KDSetPieces = [
    { Name: "Bedroom", tags: ["decorative", "urban"], Radius: 4 },
    { Name: "Graveyard", tags: ["decorative", "temple"], Radius: 5 },
    { Name: "Altar", tags: ["shrine", "temple"], Radius: 5 },
    { Name: "SmallAltar", tags: ["shrine", "temple", "endpoint"], Radius: 3, xPad: 1, yPad: 1, xPadEnd: 1, yPadEnd: 1 },
    { Name: "FuukaAltar", tags: ["boss", "temple"], Radius: 7, Max: 1 },
    { Name: "Storage", tags: ["loot", "urban", "endpoint"], Radius: 7 },
    { Name: "GuardedChest", tags: ["loot", "endpoint"], Radius: 3, xPad: 1, yPad: 1, xPadEnd: 1, yPadEnd: 1 },
    { Name: "BanditPrison", tags: ["rep", "endpoint"], Radius: 3, xPad: 1, yPad: 1, xPadEnd: 1, yPadEnd: 1 },
    { Name: "QuadCell", tags: ["decorative", "urban"], Radius: 7 },
    { Name: "PearlChest", tags: ["loot", "pearl"], Radius: 3, Prereqs: ["PearlEligible"], Max: 1, xPad: 1, yPad: 1, xPadEnd: 1, yPadEnd: 1 },
    { Name: "ShadowChest", tags: ["loot", "endpoint", "temple", "urban", "jungle", "cavern", "shadow"], Radius: 5, Max: 2 },
    { Name: "GuaranteedCell", tags: ["jail", "urban", "endpoint", "industrial", "temple", "factory", "cavern", "jungle"], Radius: 5, Max: 1, xPad: 2 },
    { Name: "ForbiddenChest", tags: ["loot", "temple", "urban", "endpoint"], Radius: 3, Max: 1, xPad: 1 },
    { Name: "ForbiddenHall", tags: ["loot", "temple", "open"], Radius: 7, Max: 1, xPad: 1 },
    { Name: "Cache", tags: ["loot", "urban", "endpoint"], Radius: 7, Max: 1, xPad: 2 },
    { Name: "ExtraCell", tags: ["jail", "urban", "endpoint"], Radius: 4, xPad: 2, yPad: 1, xPadEnd: 2, yPadEnd: 1 },
    { Name: "JungleLight", tags: ["natural", "light"], noPOI: true, Radius: 1, xPad: 1, yPad: 1, xPadEnd: 1, yPadEnd: 1 },
    { Name: "Fireflies", tags: ["natural", "light"], noPOI: true, Radius: 1, xPad: 1, yPad: 1, xPadEnd: 1, yPadEnd: 1 },
    { Name: "Magicflies", tags: ["temple", "light"], noPOI: true, Radius: 1, xPad: 1, yPad: 1, xPadEnd: 1, yPadEnd: 1 },
];
let KDCountSetpiece = new Map();
function KinkyDungeonPlaceSetPieces(POI, trapLocations, chestlist, shrinelist, chargerlist, spawnPoints, InJail, width, height) {
    KDCountSetpiece = new Map();
    let pieces = new Map();
    let Params = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]];
    let setpieces = [];
    let alt = !KDGameData.RoomType ? KinkyDungeonBossFloor(MiniGameKinkyDungeonLevel) : KinkyDungeonAltFloor(KDGameData.RoomType);
    let forcePOI = !alt || !alt.genType;
    if (!alt) {
        Object.assign(setpieces, Params.setpieces);
        setpieces.push({ Type: "GuaranteedCell", Weight: 100000 });
        for (let i of KDGameData.ChestsGenerated) {
            console.log(i);
        }
        if (!KDGameData.ChestsGenerated.includes("cache"))
            setpieces.push({ Type: "Cache", Weight: 100000 });
        let forbiddenChance = Params.forbiddenChance != undefined ? Params.forbiddenChance : 1;
        let greaterChance = Params.forbiddenGreaterChance != undefined ? Params.forbiddenGreaterChance : 0.5;
        if (KinkyDungeonStatsChoice.get("hardMode")) {
            setpieces.push({ Type: "ShadowChest", Weight: 10000 });
            forbiddenChance = 1;
            greaterChance = Math.max(greaterChance, 0.8);
        }
        if (KDRandom() < forbiddenChance) {
            if (KDRandom() < greaterChance) {
                if (!KDGameData.ChestsGenerated.includes("gold"))
                    setpieces.push({ Type: "ForbiddenHall", Weight: 100000 });
            }
            else {
                if (!KDGameData.ChestsGenerated.includes("lessergold"))
                    setpieces.push({ Type: "ForbiddenChest", Weight: 100000 });
            }
        }
    }
    else {
        for (let s of Object.entries(alt.setpieces)) {
            setpieces.push({ Type: s[0], Weight: s[1] });
        }
    }
    if (KDGameData.MapMod) {
        let mapmod = KDMapMods[KDGameData.MapMod];
        if (mapmod && mapmod.bonussetpieces) {
            for (let s of mapmod.bonussetpieces) {
                setpieces.push(s);
            }
        }
    }
    for (let p of KDSetPieces) {
        let prereqs = true;
        if (prereqs && p.Prereqs) {
            if (prereqs && p.Prereqs.includes("PearlEligible")) {
                let has = KDPearlRequirement();
                if (!has)
                    prereqs = false;
            }
        }
        if (prereqs)
            pieces.set(p.Name, p);
    }
    let pieceCount = width * height / 25;
    let count = 0;
    let fails = 0;
    while (count < pieceCount && fails < KDSetpieceAttempts) {
        let Piece = KinkyDungeonGetSetPiece(POI, setpieces, pieces);
        if (Piece && pieces.get(Piece) && KinkyDungeonGenerateSetpiece(POI, pieces.get(Piece), InJail, trapLocations, chestlist, shrinelist, chargerlist, spawnPoints, forcePOI && !pieces.get(Piece).noPOI, alt, Params).Pass) {
            count += 1;
            KDCountSetpiece.set(Piece, KDCountSetpiece.get(Piece) ? (KDCountSetpiece.get(Piece) + 1) : 1);
        }
        else
            fails += 1;
    }
}
function KDGetFavoredSetpieces(POI, setpieces) {
    let pieces = [];
    for (let p of POI) {
        if (p.used)
            continue;
        for (let f of p.favor) {
            if (!pieces.includes(f)) {
                pieces.push(f);
            }
        }
    }
    return setpieces.filter((p) => { return pieces.includes(p.Name); });
}
function KDGetFavoringSetpieces(Name, tags, POI, POIBlacklist) {
    let pois = [];
    for (let p of POI) {
        if (POIBlacklist && POIBlacklist.get(p))
            continue;
        if (p.used)
            continue;
        if (p.favor.includes(Name)) {
            pois.push(p);
        }
        else if (p.requireTags.length == 0 || p.requireTags.some((tag) => { return tags.includes(tag); })) {
            pois.push(p);
        }
    }
    return pois[Math.floor(KDRandom() * pois.length)];
}
function KinkyDungeonGetSetPiece(POI, setpieces, pieces) {
    let setpieces2 = KDGetFavoredSetpieces(POI, setpieces);
    if (setpieces2.length < 1 || KDRandom() < 0.1)
        setpieces2 = setpieces;
    if (setpieces2) {
        let pieceWeightTotal = 0;
        let pieceWeights = [];
        for (let piece of setpieces2) {
            if (pieces.has(piece.Type) && (!pieces.get(piece.Type).Max || !(KDCountSetpiece.get(piece.Type) >= pieces.get(piece.Type).Max))) {
                pieceWeights.push({ piece: piece, weight: pieceWeightTotal });
                pieceWeightTotal += piece.Weight;
            }
        }
        let selection = KDRandom() * pieceWeightTotal;
        for (let L = pieceWeights.length - 1; L >= 0; L--) {
            if (selection > pieceWeights[L].weight) {
                return pieceWeights[L].piece.Type;
            }
        }
    }
}
function KinkyDungeonGenerateSetpiece(POI, Piece, InJail, trapLocations, chestlist, shrinelist, chargerlist, spawnPoints, forcePOI, altType, MapParams) {
    let radius = Piece.Radius;
    let xPadStart = Piece.xPad || 5;
    let yPadStart = Piece.yPad || 2;
    let xPadEnd = Piece.xPadEnd || 2;
    let yPadEnd = Piece.yPadEnd || 2;
    if (InJail) {
        xPadStart = Math.max(xPadStart, KinkyDungeonJailLeashX + 2);
    }
    let cornerX = Math.ceil(xPadStart) + Math.floor(KDRandom() * (KinkyDungeonGridWidth - xPadStart - xPadEnd - radius - 1));
    let cornerY = Math.ceil(yPadStart) + Math.floor(KDRandom() * (KinkyDungeonGridHeight - yPadStart - yPadEnd - radius - 1));
    let favoringPOI = KDGetFavoringSetpieces(Piece.Name, Piece.tags ? Piece.tags : ["decorative"], POI);
    if (favoringPOI) {
        cornerX = favoringPOI.x - Math.floor(Piece.Radius / 2);
        cornerY = favoringPOI.y - Math.floor(Piece.Radius / 2);
    }
    let i = 0;
    let POIBlacklist = new Map();
    for (i = 0; i < 1000; i++) {
        let specialDist = KinkyDungeonGetClosestSpecialAreaDist(cornerX + Math.floor(radius / 2) - 1, cornerY + Math.floor(radius / 2));
        if (specialDist <= (forcePOI ? 0 : 1) + Math.ceil(radius / 2) || !(cornerX > Math.ceil(xPadStart) && cornerX < KinkyDungeonGridWidth - radius - xPadEnd && cornerY > Math.ceil(yPadStart) && cornerY < KinkyDungeonGridHeight - radius - yPadEnd)) {
            cornerY = Math.ceil(yPadStart) + Math.floor(KDRandom() * (KinkyDungeonGridHeight - yPadStart - yPadEnd - radius - 1));
            cornerX = Math.ceil(xPadStart) + Math.floor(KDRandom() * (KinkyDungeonGridWidth - xPadStart - radius - 1));
            if (i < 100 || i % 3 == 0 || forcePOI) {
                favoringPOI = KDGetFavoringSetpieces(Piece.Name, Piece.tags ? Piece.tags : ["decorative"], POI, POIBlacklist);
                if (favoringPOI) {
                    cornerX = favoringPOI.x - Math.floor(Piece.Radius / 2);
                    cornerY = favoringPOI.y - Math.floor(Piece.Radius / 2);
                    POIBlacklist.set(favoringPOI, true);
                }
            }
        }
        else
            break;
    }
    if (i > 990) {
        console.log("Could not place " + Piece.Name);
        return { Pass: false, Traps: trapLocations };
    }
    if (favoringPOI)
        favoringPOI.used = true;
    let skip = false;
    if (forcePOI && !favoringPOI) {
        skip = true;
    }
    if (!skip)
        switch (Piece.Name) {
            case "Bedroom":
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, true, false, 1, true);
                if (KDRandom() < 0.25) {
                    KinkyDungeonMapSet(cornerX + 2, cornerY + 3, 'D');
                    KinkyDungeonMapSet(cornerX + 2, cornerY + 1, 'c');
                    KinkyDungeonTilesSet("" + (cornerX + 2) + "," + (cornerY + 3), { Type: "Door", NoTrap: true, OffLimits: true });
                }
                else if (KDRandom() < 0.33) {
                    KinkyDungeonMapSet(cornerX + 2, cornerY, 'D');
                    KinkyDungeonMapSet(cornerX + 1, cornerY + 2, 'c');
                    KinkyDungeonTilesSet("" + (cornerX + 2) + "," + (cornerY), { Type: "Door", NoTrap: true, OffLimits: true });
                }
                else if (KDRandom() < 0.5) {
                    KinkyDungeonMapSet(cornerX + 3, cornerY + 2, 'D');
                    KinkyDungeonMapSet(cornerX + 2, cornerY + 1, 'c');
                    KinkyDungeonTilesSet("" + (cornerX + 3) + "," + (cornerY + 2), { Type: "Door", NoTrap: true, OffLimits: true });
                }
                else {
                    KinkyDungeonMapSet(cornerX, cornerY + 2, 'D');
                    KinkyDungeonMapSet(cornerX + 2, cornerY + 1, 'c');
                    KinkyDungeonTilesSet("" + (cornerX) + "," + (cornerY + 2), { Type: "Door", NoTrap: true, OffLimits: true });
                }
                KinkyDungeonMapSet(cornerX + 1, cornerY + 1, 'B');
                if (KinkyDungeonStatsChoice.has("Nowhere")) {
                    if (KDRandom() < 0.5)
                        KinkyDungeonTilesSet((cornerX + 1) + "," + (cornerY + 1), {
                            Type: "Trap",
                            Trap: "BedTrap",
                        });
                }
                if (KDRandom() < 0.15)
                    spawnPoints.push({ x: cornerX + 1, y: cornerY + 1, required: ["human"], AI: "guard" });
                break;
            case "Graveyard":
                {
                    KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 1, true);
                    KDCreateDoors(cornerX - 1, cornerY - 1, radius + 2, radius + 2);
                    let ghost = false;
                    for (let X = cornerX; X <= cornerX + radius - 1; X += 2) {
                        for (let Y = cornerY; Y < cornerY + radius; Y += 2) {
                            if (KDRandom() < 0.5)
                                KinkyDungeonMapSet(X, Y, 'X');
                            else if (KDRandom() < 0.33)
                                KinkyDungeonMapSet(X, Y, 'a');
                            else
                                KinkyDungeonMapSet(X, Y, '2');
                            if (!ghost && KDRandom() < 0.14) {
                                spawnPoints.push({ x: X, y: Y, required: ["ghost"], tags: ["ghost"], AI: "guard" });
                                ghost = true;
                            }
                        }
                    }
                }
                break;
            case "Altar":
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 1, false);
                KDCreateDoors(cornerX - 1, cornerY - 1, radius + 2, radius + 2);
                KinkyDungeonMapSet(cornerX, cornerY, 'X');
                KinkyDungeonMapSet(cornerX + radius - 1, cornerY, 'X');
                KinkyDungeonMapSet(cornerX, cornerY + radius - 1, 'X');
                KinkyDungeonMapSet(cornerX + radius - 1, cornerY + radius - 1, 'X');
                shrinelist.push({ x: cornerX + 2, y: cornerY + 2, priority: true });
                break;
            case "SmallAltar":
                if (!favoringPOI || KinkyDungeonBoringGet(cornerX + 1, cornerY + 1) < 3)
                    skip = true;
                else {
                    KinkyDungeonCreateRectangle(cornerX, cornerY, 2, 2, false, false, 0, false);
                    let xx = 1;
                    KinkyDungeonMapSet(cornerX + xx, cornerY + 1, 'a');
                    shrinelist.push({ x: cornerX + xx, y: cornerY + 1, priority: true });
                    if (KinkyDungeonMapGet(cornerX + xx, cornerY) == '1')
                        KinkyDungeonMapSet(cornerX + xx, cornerY, 'm');
                    if (KinkyDungeonMapGet(cornerX + xx, cornerY + 2) == '1')
                        KinkyDungeonMapSet(cornerX + xx, cornerY + 2, 'm');
                    if (KinkyDungeonMapGet(cornerX + xx - 1, cornerY) == '1')
                        KinkyDungeonMapSet(cornerX + xx - 1, cornerY, 'X');
                    if (KinkyDungeonMapGet(cornerX + xx - 1, cornerY + 1) == '1')
                        KinkyDungeonMapSet(cornerX + xx - 1, cornerY + 1, 'm');
                    if (KinkyDungeonMapGet(cornerX + xx - 1, cornerY + 2) == '1')
                        KinkyDungeonMapSet(cornerX + xx - 1, cornerY + 2, 'X');
                    if (KinkyDungeonMapGet(cornerX + xx + 1, cornerY) == '1')
                        KinkyDungeonMapSet(cornerX + xx + 1, cornerY, 'X');
                    if (KinkyDungeonMapGet(cornerX + xx + 1, cornerY + 1) == '1')
                        KinkyDungeonMapSet(cornerX + xx + 1, cornerY + 1, 'm');
                    if (KinkyDungeonMapGet(cornerX + xx + 1, cornerY + 2) == '1')
                        KinkyDungeonMapSet(cornerX + xx + 1, cornerY + 2, 'X');
                    KDCreateDoors(cornerX - 2 + xx, cornerY - 1, radius + 2, radius + 2);
                }
                break;
            case "FuukaAltar": {
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 1, false);
                KinkyDungeonMapSet(cornerX + 1, cornerY + 1, 'o');
                KinkyDungeonMapSet(cornerX + radius - 2, cornerY + 1, 'o');
                KinkyDungeonMapSet(cornerX + 1, cornerY + radius - 2, 'o');
                KinkyDungeonMapSet(cornerX + radius - 2, cornerY + radius - 2, 'o');
                KinkyDungeonMapSet(cornerX, cornerY + 3, 'o');
                KinkyDungeonMapSet(cornerX + 3, cornerY, 'o');
                KinkyDungeonMapSet(cornerX + 3, cornerY + radius - 1, 'o');
                KinkyDungeonMapSet(cornerX + radius - 1, cornerY + 3, 'o');
                let Enemy = KinkyDungeonGetEnemyByName("Fuuka1");
                let e = { tracking: true, Enemy: Enemy, id: KinkyDungeonGetEnemyID(), x: cornerX + 3, y: cornerY + 3, hp: (Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0 };
                KDAddEntity(e);
                KDStageBossGenerated = true;
                break;
            }
            case "PearlChest":
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 0, true);
                KinkyDungeonMapSet(cornerX, cornerY + 1, 'a');
                KinkyDungeonMapSet(cornerX + radius - 1, cornerY + 1, 'a');
                KinkyDungeonMapSet(cornerX + 1, cornerY + 1, 'C');
                KinkyDungeonTilesSet((cornerX + 1) + "," + (cornerY + 1), { Loot: "pearl", Roll: KDRandom() });
                break;
            case "ShadowChest":
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 0, false);
                KDCreateDoors(cornerX - 1, cornerY - 1, radius + 2, radius + 2);
                KinkyDungeonMapSet(cornerX, cornerY, 'o');
                KinkyDungeonMapSet(cornerX + radius - 1, cornerY, 'o');
                KinkyDungeonMapSet(cornerX, cornerY + radius - 1, 'o');
                KinkyDungeonMapSet(cornerX + radius - 1, cornerY + radius - 1, 'o');
                if (!Piece.Chance || KDRandom() < Piece.Chance) {
                    KinkyDungeonMapSet(cornerX + 2, cornerY + 2, 'C');
                    KinkyDungeonTilesSet((cornerX + 2) + "," + (cornerY + 2), {
                        Loot: "shadow", Roll: KDRandom(),
                        lootTrap: KDGenChestTrap(true, cornerX + 2, cornerY + 2, "shadow", undefined, false)
                    });
                    let chance = 0.75;
                    let chance2 = 0.25;
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 3, y: cornerY + 1 });
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 3, y: cornerY + 2 });
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 3, y: cornerY + 3 });
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 1, y: cornerY + 1 });
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 1, y: cornerY + 2 });
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 1, y: cornerY + 3 });
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 2, y: cornerY + 1 });
                    if (KDRandom() < chance)
                        trapLocations.push({ x: cornerX + 2, y: cornerY + 3 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 1, y: cornerY });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 2, y: cornerY });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 3, y: cornerY });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 1, y: cornerY + radius - 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 2, y: cornerY + radius - 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 3, y: cornerY + radius - 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX, y: cornerY + 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX, y: cornerY + 2 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX, y: cornerY + 3 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + radius - 1, y: cornerY + 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + radius - 1, y: cornerY + 2 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + radius - 1, y: cornerY + 3 });
                }
                else {
                    shrinelist.push({ x: cornerX + 2, y: cornerY + 2, priority: true });
                    let chance2 = 0.1;
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 1, y: cornerY });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 2, y: cornerY });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 3, y: cornerY });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 1, y: cornerY + radius - 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 2, y: cornerY + radius - 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + 3, y: cornerY + radius - 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX, y: cornerY + 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX, y: cornerY + 2 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX, y: cornerY + 3 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + radius - 1, y: cornerY + 1 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + radius - 1, y: cornerY + 2 });
                    if (KDRandom() < chance2)
                        trapLocations.push({ x: cornerX + radius - 1, y: cornerY + 3 });
                }
                break;
            case "GuaranteedCell": {
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, true, false, 1, true, true, true);
                KinkyDungeonMapSet(cornerX + 4, cornerY + 2, 'd');
                KinkyDungeonTilesSet("" + (cornerX + 4) + "," + (cornerY + 2), { Type: "Door", NoTrap: true, Jail: true, ReLock: true, OffLimits: true });
                KinkyDungeonPatrolPoints.push({ x: cornerX + 5, y: cornerY + 2 });
                let sidestyle = Math.floor(KDRandom() * 3);
                if (sidestyle == 0) {
                    KinkyDungeonMapSet(cornerX + 1 + Math.floor(KDRandom() * 3), cornerY, 'b');
                }
                else if (sidestyle == 1) {
                    KinkyDungeonMapSet(cornerX, cornerY + 1, 'b');
                    KinkyDungeonMapSet(cornerX, cornerY + 2, 'b');
                    KinkyDungeonMapSet(cornerX, cornerY + 3, 'b');
                }
                else {
                    KinkyDungeonMapSet(cornerX + 1, cornerY + 4, 'b');
                    KinkyDungeonMapSet(cornerX + 2, cornerY + 4, 'b');
                    KinkyDungeonMapSet(cornerX + 3, cornerY + 4, 'b');
                }
                KinkyDungeonMapSet(cornerX + 4, cornerY + 1, 'b');
                KinkyDungeonMapSet(cornerX + 4, cornerY + 3, 'b');
                KinkyDungeonMapSet(cornerX + 4, cornerY + 1, 'b');
                KinkyDungeonMapSet(cornerX + 2, cornerY + 2, 'B');
                if (KDRandom() < 0.0 + (KDGameData.RoomType == "Jail" ? 1.0 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 1, cornerY + 1);
                }
                if (KDRandom() < 0.5 + (KDGameData.RoomType == "Jail" ? 0.25 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 1, cornerY + 2);
                }
                if (KDRandom() < 0.5 + (KDGameData.RoomType == "Jail" ? 0.25 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 1, cornerY + 3);
                }
                KDGameData.JailPoints.push({ x: cornerX + 2, y: cornerY + 2, type: "jail", radius: 1 });
                KDTorch(cornerX + 2, cornerY, altType, MapParams);
                break;
            }
            case "ExtraCell": {
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, true, false, 1, true, true);
                KinkyDungeonMapSet(cornerX + 3, cornerY + 1, 'D');
                KinkyDungeonTilesSet("" + (cornerX + 3) + "," + (cornerY + 1), { Type: "Door", NoTrap: true, Jail: true, ReLock: true, OffLimits: true });
                KinkyDungeonMapSet(cornerX + 3, cornerY + 2, 'b');
                if (KDRandom() < 0.5) {
                    KinkyDungeonMapSet(cornerX, cornerY + 1, 'b');
                    KinkyDungeonMapSet(cornerX, cornerY + 2, 'b');
                }
                if (KDRandom() < 0.5) {
                    KinkyDungeonMapSet(cornerX + 1, cornerY, 'b');
                    KinkyDungeonMapSet(cornerX + 2, cornerY, 'b');
                }
                if (KDRandom() < 0.5) {
                    KinkyDungeonMapSet(cornerX + 1, cornerY + 3, 'b');
                    KinkyDungeonMapSet(cornerX + 2, cornerY + 3, 'b');
                }
                if (KDRandom() < 0.6 + (KDGameData.RoomType == "Jail" ? 0.35 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 1, cornerY + 2);
                }
                KinkyDungeonMapSet(cornerX + 1, cornerY + 1, 'B');
                KDTorch(cornerX + 1, cornerY, altType, MapParams);
                KDGameData.JailPoints.push({ x: cornerX + 1, y: cornerY + 1, type: "jail", radius: 1 });
                break;
            }
            case "JungleLight": {
                if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(cornerX, cornerY)))
                    skip = true;
                else {
                    KinkyDungeonMapSet(cornerX, cornerY, '2');
                    KinkyDungeonTilesSet((cornerX) + "," + (cornerY), { Light: 6, Skin: "LightRays" });
                }
                break;
            }
            case "Fireflies": {
                if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(cornerX, cornerY)))
                    skip = true;
                else
                    KinkyDungeonTilesSet((cornerX) + "," + (cornerY), { Light: 2, Skin: "Fireflies" });
                break;
            }
            case "Magicflies": {
                if (!KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(cornerX, cornerY)))
                    skip = true;
                else
                    KinkyDungeonTilesSet((cornerX) + "," + (cornerY), { Light: 2, Skin: "Magicflies" });
                break;
            }
            case "Storage": {
                let rad = radius - 2;
                KinkyDungeonCreateRectangle(cornerX + 1, cornerY + 1, rad, rad, true, false, 1, false);
                KinkyDungeonPatrolPoints.push({ x: cornerX + 1 + 2, y: cornerY + 1 + 2 });
                KinkyDungeonMapSet(cornerX + 1 + 2, cornerY + 1, KDRandom() < 0.5 ? 'D' : (KDRandom() < 0.5 ? 'g' : 'd'));
                KinkyDungeonTilesSet("" + (cornerX + 1 + 2) + "," + (cornerY + 1), { Type: "Door" });
                KinkyDungeonMapSet(cornerX + 1 + 2, cornerY + 1 + 4, KDRandom() < 0.5 ? 'D' : (KDRandom() < 0.5 ? 'g' : 'd'));
                KinkyDungeonTilesSet("" + (cornerX + 1 + 2) + "," + (cornerY + 1 + 4), { Type: "Door" });
                KinkyDungeonMapSet(cornerX + 1 + 1, cornerY + 1 + 1, KDRandom() < 0.6 ? 'L' : (KDRandom() < 0.5 ? 'c' : 'C'));
                if (KinkyDungeonMapGet(cornerX + 1 + 1, cornerY + 1 + 1) == 'C')
                    KinkyDungeonTilesSet((cornerX + 1 + 1) + "," + (cornerY + 1 + 1), { Loot: "storage", Roll: KDRandom() });
                KinkyDungeonMapSet(cornerX + 1 + 1, cornerY + 1 + 2, KDRandom() < 0.5 ? 'L' : (KDRandom() < 0.5 ? 'c' : 'C'));
                if (KinkyDungeonMapGet(cornerX + 1 + 1, cornerY + 1 + 2) == 'C')
                    KinkyDungeonTilesSet((cornerX + 1 + 1) + "," + (cornerY + 1 + 2), { Loot: "storage", Roll: KDRandom() });
                KinkyDungeonMapSet(cornerX + 1 + 1, cornerY + 1 + 3, KDRandom() < 0.7 ? 'L' : (KDRandom() < 0.5 ? 'c' : 'C'));
                if (KinkyDungeonMapGet(cornerX + 1 + 1, cornerY + 1 + 3) == 'C')
                    KinkyDungeonTilesSet((cornerX + 1 + 1) + "," + (cornerY + 1 + 3), { Loot: "storage", Roll: KDRandom() });
                KinkyDungeonMapSet(cornerX + 1 + 3, cornerY + 1 + 1, KDRandom() < 0.5 ? 'L' : (KDRandom() < 0.5 ? 'c' : 'C'));
                if (KinkyDungeonMapGet(cornerX + 1 + 3, cornerY + 1 + 1) == 'C')
                    KinkyDungeonTilesSet((cornerX + 1 + 3) + "," + (cornerY + 1 + 1), { Loot: "storage", Roll: KDRandom() });
                KinkyDungeonMapSet(cornerX + 1 + 3, cornerY + 1 + 2, KDRandom() < 0.75 ? 'L' : (KDRandom() < 0.5 ? 'c' : 'C'));
                if (KinkyDungeonMapGet(cornerX + 1 + 3, cornerY + 1 + 2) == 'C')
                    KinkyDungeonTilesSet((cornerX + 1 + 3) + "," + (cornerY + 1 + 2), { Loot: "storage", Roll: KDRandom() });
                KinkyDungeonMapSet(cornerX + 1 + 3, cornerY + 1 + 3, KDRandom() < 0.5 ? 'L' : (KDRandom() < 0.5 ? 'c' : 'C'));
                if (KinkyDungeonMapGet(cornerX + 1 + 3, cornerY + 1 + 3) == 'C')
                    KinkyDungeonTilesSet((cornerX + 1 + 3) + "," + (cornerY + 1 + 3), { Loot: "storage", Roll: KDRandom() });
                if (KDRandom() < 0.5) {
                    if (KDRandom() < 0.75)
                        spawnPoints.push({ x: cornerX + 1 + 2, y: cornerY + 1 + 3, required: ["beast"], AI: "guard" });
                    else if (KDRandom() < 0.5)
                        spawnPoints.push({ x: cornerX + 1 + 2, y: cornerY + 1 + 3, required: ["human"], AI: "guard" });
                    else
                        spawnPoints.push({ x: cornerX + 1 + 2, y: cornerY + 1 + 3, required: ["mold", "spawner"], tags: ["mold"], AI: "guard" });
                }
                break;
            }
            case "GuardedChest": {
                let chests = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].chestcount ? KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].chestcount : 6;
                if ((!favoringPOI && KDRandom() < 0.7) || KinkyDungeonBoringGet(cornerX + 1, cornerY + 1) < 3 || chestlist.length >= chests)
                    skip = true;
                else {
                    KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 0, false);
                    KDCreateDoors(cornerX - 1, cornerY - 1, radius + 2, radius + 2);
                    KDPlaceChest(cornerX, cornerY, radius, chestlist, spawnPoints);
                }
                break;
            }
            case "LargeGuardedChest": {
                let chests = KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].chestcount ? KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]].chestcount : 6;
                if ((!favoringPOI && KDRandom() < 0.7) || KinkyDungeonBoringGet(cornerX + 1, cornerY + 1) < 3 || chestlist.length >= chests)
                    skip = true;
                else {
                    KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 0, false);
                    KinkyDungeonCreateRectangle(cornerX, cornerY - 1, radius, 1, false, false, 0, false);
                    KinkyDungeonCreateRectangle(cornerX, cornerY + radius, radius, 1, false, false, 0, false);
                    KinkyDungeonCreateRectangle(cornerX - 1, cornerY, 1, radius, false, false, 0, false);
                    KinkyDungeonCreateRectangle(cornerX + radius, cornerY, 1, radius, false, false, 0, false);
                    KDCreateDoors(cornerX - 2, cornerY - 2, radius + 4, radius + 4);
                    KDPlaceChest(cornerX, cornerY, radius, chestlist, spawnPoints);
                }
                break;
            }
            case "BanditPrison": {
                if (KinkyDungeonBoringGet(cornerX + 1, cornerY + 1) < 3)
                    skip = true;
                else {
                    KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 0, false);
                    DialogueCreateEnemy(cornerX + 1, cornerY + 1, "PrisonerBandit");
                    spawnPoints.push({ x: cornerX, y: cornerY, required: ["bountyhunter"], tags: ["human"], AI: "guard" });
                    spawnPoints.push({ x: cornerX + 2, y: cornerY, required: ["bountyhunter"], tags: ["human"], AI: "guard" });
                    spawnPoints.push({ x: cornerX, y: cornerY + 2, required: ["bountyhunter"], tags: ["human"], AI: "guard" });
                    spawnPoints.push({ x: cornerX + 2, y: cornerY + 2, required: ["bountyhunter"], tags: ["human"], AI: "guard" });
                }
                break;
            }
            case "QuadCell": {
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 1, true);
                KinkyDungeonPatrolPoints.push({ x: cornerX + 3, y: cornerY + 3 });
                for (let X = cornerX; X < cornerX + radius; X++) {
                    KinkyDungeonMapSet(X, cornerY, '1');
                    KinkyDungeonMapSet(X, cornerY + 2, '1');
                    KinkyDungeonMapSet(X, cornerY + 4, '1');
                    KinkyDungeonMapSet(X, cornerY + 6, '1');
                }
                KinkyDungeonMapSet(cornerX, cornerY + 1, '1');
                KinkyDungeonMapSet(cornerX + 3, cornerY + 1, '1');
                KinkyDungeonMapSet(cornerX + 6, cornerY + 1, '1');
                KinkyDungeonMapSet(cornerX, cornerY + 5, '1');
                KinkyDungeonMapSet(cornerX + 3, cornerY + 5, '1');
                KinkyDungeonMapSet(cornerX + 6, cornerY + 5, '1');
                KinkyDungeonMapSet(cornerX + 2, cornerY + 2, 'b');
                KinkyDungeonMapSet(cornerX + 4, cornerY + 2, 'b');
                KinkyDungeonMapSet(cornerX + 2, cornerY + 4, 'b');
                KinkyDungeonMapSet(cornerX + 4, cornerY + 4, 'b');
                KinkyDungeonMapSet(cornerX + 2, cornerY + 1, 'B');
                KinkyDungeonMapSet(cornerX + 4, cornerY + 1, 'B');
                KinkyDungeonMapSet(cornerX + 2, cornerY + 5, 'B');
                KinkyDungeonMapSet(cornerX + 4, cornerY + 5, 'B');
                if (KinkyDungeonStatsChoice.has("Nowhere")) {
                    if (KDRandom() < 0.5)
                        KinkyDungeonTilesSet((cornerX + 2) + "," + (cornerY + 1), {
                            Type: "Trap",
                            Trap: "BedTrap",
                        });
                    if (KDRandom() < 0.5)
                        KinkyDungeonTilesSet((cornerX + 4) + "," + (cornerY + 1), {
                            Type: "Trap",
                            Trap: "BedTrap",
                        });
                    if (KDRandom() < 0.5)
                        KinkyDungeonTilesSet((cornerX + 2) + "," + (cornerY + 5), {
                            Type: "Trap",
                            Trap: "BedTrap",
                        });
                    if (KDRandom() < 0.5)
                        KinkyDungeonTilesSet((cornerX + 4) + "," + (cornerY + 5), {
                            Type: "Trap",
                            Trap: "BedTrap",
                        });
                }
                let l = KinkyDungeonMapGet(cornerX + 1, cornerY + 2) == 'D' ? "Red" : undefined;
                KinkyDungeonMapSet(cornerX + 1, cornerY + 2, KDRandom() < 0.75 ? 'D' : 'd');
                KinkyDungeonTilesSet("" + (cornerX + 1) + "," + (cornerY + 2), { Type: "Door", NoTrap: true, OffLimits: true, Lock: l });
                if (l && KDRandom() < 0.5)
                    spawnPoints.push({ x: cornerX + 2, y: cornerY + 1, required: ["human"], AI: "guard" });
                else if (l && KDRandom() < 0.6 + (KDGameData.RoomType == "Jail" ? 0.35 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 2, cornerY + 1);
                }
                l = KinkyDungeonMapGet(cornerX + 5, cornerY + 2) == 'D' ? "Red" : undefined;
                KinkyDungeonMapSet(cornerX + 5, cornerY + 2, KDRandom() < 0.75 ? 'D' : 'd');
                KinkyDungeonTilesSet("" + (cornerX + 5) + "," + (cornerY + 2), { Type: "Door", NoTrap: true, OffLimits: true, Lock: l });
                if (l && KDRandom() < 0.5)
                    spawnPoints.push({ x: cornerX + 4, y: cornerY + 1, required: ["human"], AI: "guard" });
                else if (l && KDRandom() < 0.6 + (KDGameData.RoomType == "Jail" ? 0.35 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 4, cornerY + 1);
                }
                l = KinkyDungeonMapGet(cornerX + 1, cornerY + 4) == 'D' ? "Red" : undefined;
                KinkyDungeonMapSet(cornerX + 1, cornerY + 4, KDRandom() < 0.75 ? 'D' : 'd');
                KinkyDungeonTilesSet("" + (cornerX + 1) + "," + (cornerY + 4), { Type: "Door", NoTrap: true, OffLimits: true, Lock: l });
                if (l && KDRandom() < 0.5)
                    spawnPoints.push({ x: cornerX + 2, y: cornerY + 5, required: ["human"], AI: "guard" });
                else if (l && KDRandom() < 0.6 + (KDGameData.RoomType == "Jail" ? 0.35 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 2, cornerY + 5);
                }
                l = KinkyDungeonMapGet(cornerX + 5, cornerY + 4) == 'D' ? "Red" : undefined;
                KinkyDungeonMapSet(cornerX + 5, cornerY + 4, KDRandom() < 0.75 ? 'D' : 'd');
                KinkyDungeonTilesSet("" + (cornerX + 5) + "," + (cornerY + 4), { Type: "Door", NoTrap: true, OffLimits: true, Lock: l });
                if (l && KDRandom() < 0.5)
                    spawnPoints.push({ x: cornerX + 4, y: cornerY + 5, required: ["human"], AI: "guard" });
                else if (l && KDRandom() < 0.6 + (KDGameData.RoomType == "Jail" ? 0.35 : 0)) {
                    SetpieceSpawnPrisoner(cornerX + 4, cornerY + 5);
                }
                break;
            }
            case "Cache": {
                let rad = radius - 2;
                KinkyDungeonCreateRectangle(cornerX + 1, cornerY + 1, rad, rad, true, false, 1, true);
                KinkyDungeonPatrolPoints.push({ x: cornerX, y: cornerY + 3 });
                KinkyDungeonMapSet(cornerX + 1 + Math.floor(rad / 2), cornerY + 1 + Math.floor(rad / 2), 'C');
                KinkyDungeonTilesSet((cornerX + 1 + Math.floor(rad / 2)) + "," + (cornerY + 1 + Math.floor(rad / 2)), { Loot: "cache", Faction: "Bandit", Roll: KDRandom() });
                KDTorch(cornerX + 1 + Math.floor(rad / 2), cornerY + 1, altType, MapParams);
                KinkyDungeonMapSet(cornerX + 1, cornerY + 1 + Math.floor(rad / 2) - 1, 'b');
                KinkyDungeonMapSet(cornerX + 1, cornerY + 1 + Math.floor(rad / 2) + 1, 'b');
                KinkyDungeonMapSet(cornerX + 1, cornerY + 1 + Math.floor(rad / 2), 'D');
                spawnPoints.push({ x: cornerX, y: cornerY + 1 + Math.floor(rad / 2) - 1, required: ["cacheguard"], tags: ["bandit"], AI: "guard" });
                spawnPoints.push({ x: cornerX, y: cornerY + 1 + Math.floor(rad / 2) + 1, required: ["cacheguard"], tags: ["bandit"], AI: "guard" });
                KinkyDungeonTilesSet((cornerX + 1) + "," + (cornerY + 1 + Math.floor(rad / 2)), { Type: "Door", Lock: "Red", OffLimits: true, ReLock: true });
                break;
            }
            case "ForbiddenHall": {
                KinkyDungeonCreateRectangle(cornerX + 1, cornerY, radius - 2, radius, true, false, 1, true);
                for (let X = cornerX + Math.floor(radius / 2) - 1; X <= cornerX + Math.floor(radius / 2) + 1; X++) {
                    for (let Y = cornerY + 1; Y < cornerY + radius - 1; Y++) {
                        if (!(X == cornerX + Math.floor(radius / 2) && Y == cornerY + 1) && !(X == cornerX + Math.floor(radius / 2) && Y == cornerY + radius - 2)) {
                            if (KDRandom() < 0.65) {
                                trapLocations.push({ x: X, y: Y });
                            }
                            else if (X != cornerX + Math.floor(radius / 2) && Y >= cornerY + 1) {
                                KinkyDungeonMapSet(X, Y, '2');
                            }
                        }
                    }
                }
                KinkyDungeonMapSet(cornerX + Math.floor(radius / 2), cornerY + 1, 'C');
                KinkyDungeonMapSet(cornerX + Math.floor(radius / 2) + 1, cornerY + radius - 1, '1');
                KinkyDungeonMapSet(cornerX + Math.floor(radius / 2) - 1, cornerY + radius - 1, '1');
                KinkyDungeonMapSet(cornerX + Math.floor(radius / 2), cornerY + radius - 1, '2');
                KinkyDungeonTilesSet((cornerX + Math.floor(radius / 2)) + "," + (cornerY + 1), { Loot: "gold", Faction: "AncientRobot", Roll: KDRandom() });
                KinkyDungeonMapSet(cornerX + Math.floor(radius / 2), cornerY + radius - 1, 'd');
                KinkyDungeonTilesSet((cornerX + Math.floor(radius / 2)) + "," + (cornerY + radius - 1), {
                    Type: "Door",
                    StepOffTrap: "DoorLock",
                    SpawnMult: 0.5,
                    Lifetime: 12,
                    StepOffTiles: [
                        (cornerX + Math.floor(radius / 2) - 1) + "," + (cornerY + radius - 2),
                        (cornerX + Math.floor(radius / 2)) + "," + (cornerY + radius - 2),
                        (cornerX + Math.floor(radius / 2)) + 1 + "," + (cornerY + radius - 2)
                    ]
                });
                console.log("Created forbidden hall");
                break;
            }
            case "ForbiddenChest": {
                KinkyDungeonCreateRectangle(cornerX, cornerY, radius, radius, false, false, 0, true);
                KinkyDungeonCreateRectangle(cornerX, cornerY - 1, radius, 1, false, false, 0, false);
                KinkyDungeonCreateRectangle(cornerX, cornerY + radius, radius, 1, false, false, 0, false);
                KinkyDungeonCreateRectangle(cornerX - 1, cornerY, 1, radius, false, false, 0, false);
                KinkyDungeonCreateRectangle(cornerX + radius, cornerY, 1, radius, false, false, 0, false);
                KDCreateDoors(cornerX - 2, cornerY - 2, radius + 4, radius + 4);
                KinkyDungeonPatrolPoints.push({ x: cornerX + 2, y: cornerY + 2 });
                for (let X = cornerX; X < cornerX + radius; X++) {
                    for (let Y = cornerY; Y < cornerY + radius; Y++) {
                        if (!(X == cornerX + 1 && Y == cornerY + 1)) {
                            trapLocations.push({ x: X, y: Y });
                        }
                    }
                }
                KinkyDungeonMapSet(cornerX + Math.floor(radius / 2), cornerY + Math.floor(radius / 2), 'C');
                KinkyDungeonTilesSet((cornerX + Math.floor(radius / 2)) + "," + (cornerY + Math.floor(radius / 2)), { Loot: "lessergold", Roll: KDRandom() });
                console.log("Created lesser gold chest");
                break;
            }
        }
    if (!skip)
        KinkyDungeonSpecialAreas.push({ x: cornerX + Math.floor(radius / 2), y: cornerY + Math.floor(radius / 2), radius: Math.ceil(radius / 2) });
    else if (favoringPOI)
        favoringPOI.used = false;
    if (TestMode) {
        console.log("Created " + Piece.Name);
    }
    return { Pass: true, Traps: trapLocations };
}
function KDUnblock(x, y) {
    let blocked = false;
    let blockTiles = "1X";
    let t = KinkyDungeonMapGet(x, y - 1);
    let tr = KinkyDungeonMapGet(x + 1, y - 1);
    let tl = KinkyDungeonMapGet(x - 1, y - 1);
    let r = KinkyDungeonMapGet(x + 1, y);
    let l = KinkyDungeonMapGet(x - 1, y);
    let b = KinkyDungeonMapGet(x, y - 1);
    let br = KinkyDungeonMapGet(x + 1, y + 1);
    let bl = KinkyDungeonMapGet(x - 1, y + 1);
    let m_t = KinkyDungeonMovableTilesSmartEnemy.includes(t);
    let m_tr = KinkyDungeonMovableTilesSmartEnemy.includes(tr);
    let m_tl = KinkyDungeonMovableTilesSmartEnemy.includes(tl);
    let m_r = KinkyDungeonMovableTilesSmartEnemy.includes(r);
    let m_l = KinkyDungeonMovableTilesSmartEnemy.includes(l);
    let m_b = KinkyDungeonMovableTilesSmartEnemy.includes(b);
    let m_br = KinkyDungeonMovableTilesSmartEnemy.includes(br);
    let m_bl = KinkyDungeonMovableTilesSmartEnemy.includes(bl);
    if (!blocked && m_t && m_b && !m_r && !m_l) {
        if (KDRandom() < 0.5 && blockTiles.includes(r)) {
            m_r = true;
            KinkyDungeonMapSet(x + 1, y, '2');
        }
        else if (blockTiles.includes(l)) {
            m_l = true;
            KinkyDungeonMapSet(x - 1, y, '2');
        }
        else
            blocked = true;
    }
    if (!blocked && m_r && m_l && !m_t && !m_b) {
        if (KDRandom() < 0.5 && blockTiles.includes(b)) {
            m_b = true;
            KinkyDungeonMapSet(x, y + 1, '2');
        }
        else if (blockTiles.includes(t)) {
            m_t = true;
            KinkyDungeonMapSet(x, y - 1, '2');
        }
        else
            blocked = true;
    }
    if (!blocked && m_tr && m_br && !m_r) {
        if (blockTiles.includes(r)) {
            m_r = true;
            KinkyDungeonMapSet(x + 1, y, '2');
        }
        else if (!m_t && !m_l && !m_b) {
            blocked = true;
        }
    }
    if (!blocked && m_tl && m_bl && !m_l) {
        if (blockTiles.includes(l)) {
            m_l = true;
            KinkyDungeonMapSet(x - 1, y, '2');
        }
        else if (!m_t && !m_r && !m_b) {
            blocked = true;
        }
    }
    if (!blocked && m_tl && m_tr && !m_t) {
        if (blockTiles.includes(t)) {
            m_t = true;
            KinkyDungeonMapSet(x, y - 1, '2');
        }
        else if (!m_l && !m_b && !m_r) {
            blocked = true;
        }
    }
    if (!blocked && m_bl && m_br && !m_b) {
        if (blockTiles.includes(b)) {
            m_b = true;
            KinkyDungeonMapSet(x, y + 1, '2');
        }
        else if (!m_l && !m_t && !m_r) {
            blocked = true;
        }
    }
    return !blocked;
}
function SetpieceSpawnPrisoner(x, y) {
    let Enemy = KinkyDungeonGetEnemy(["imprisonable",
        "ropeAnger", "ropeRage",
        "metalAnger", "metalRage",
        "latexAnger", "latexRage",
        "conjureAnger", "conjureRage",
        "elementsAnger", "elementsRage",
        "illusionAnger", "illusionRage",
        "leatherAnger", "leatherRage",
        "willAnger", "willRage"], MiniGameKinkyDungeonLevel * 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], KinkyDungeonMapGet(x, y), ["imprisonable"]);
    if (Enemy) {
        let e = DialogueCreateEnemy(x, y, Enemy.name);
        e.faction = "Prisoner";
        e.boundLevel = e.hp * 11;
        e.specialdialogue = "PrisonerJail";
        e.items = [];
        KinkyDungeonSetEnemyFlag(e, "noswap", -1);
        KinkyDungeonSetEnemyFlag(e, "imprisoned", -1);
        KDProcessCustomPatron(Enemy, e);
    }
}
function KDTorch(X, Y, altType, MapParams) {
    let torchreplace = (altType && altType.torchreplace) ? altType.torchreplace : (MapParams.torchreplace ? MapParams.torchreplace : null);
    KDCreateEffectTile(X, Y + 1, {
        name: torchreplace ? torchreplace.sprite : "Torch",
        duration: 9999,
    }, 0);
}
function KDChest(X, Y, loot = "chest", faction = "") {
    KinkyDungeonMapSet(X, Y, 'C');
    KinkyDungeonTilesSet((X) + "," + (Y), { Loot: loot, Faction: faction, Roll: KDRandom() });
}
function KDCreateDoors(Left, Top, Width, Height, openChance = 0, convertDoodads = true) {
    let doors = {};
    let rows = [Top, Top + Height - 1];
    for (let r of rows) {
        if (r > 0 && r < KinkyDungeonGridHeight - 1) {
            for (let x = Left; x < Left + Width - 3; x++) {
                if (x > 0 && x < KinkyDungeonGridWidth - 4
                    && (KinkyDungeonWallTiles.includes(KinkyDungeonMapGet(x, r)) || (convertDoodads && KinkyDungeonMapGet(x, r) == 'X'))
                    && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(x + 1, r))
                    && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(x + 2, r))
                    && (KinkyDungeonWallTiles.includes(KinkyDungeonMapGet(x + 3, r)) || (convertDoodads && KinkyDungeonMapGet(x + 3, r) == 'X'))) {
                    if ((KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x + 1, r - 1)) && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x + 1, r + 1)))
                        || (KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x + 2, r - 1)) && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(x + 2, r + 1)))) {
                        doors[(x + 1) + "," + r] = { x: x + 1, y: r };
                        doors[(x + 2) + "," + r] = { x: x + 2, y: r };
                    }
                }
            }
        }
    }
    let cols = [Left, Left + Width - 1];
    for (let c of cols) {
        if (c > 0 && c < KinkyDungeonGridWidth - 1) {
            for (let y = Top; y < Top + Height - 3; y++) {
                if (y > 0 && y < KinkyDungeonGridHeight - 4
                    && (KinkyDungeonWallTiles.includes(KinkyDungeonMapGet(c, y)) || (convertDoodads && KinkyDungeonMapGet(c, y) == 'X'))
                    && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(c, y + 1))
                    && KinkyDungeonGroundTiles.includes(KinkyDungeonMapGet(c, y + 2))
                    && (KinkyDungeonWallTiles.includes(KinkyDungeonMapGet(c, y + 3)) || (convertDoodads && KinkyDungeonMapGet(c, y + 3) == 'X'))) {
                    if ((KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(c - 1, y + 1)) && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(c + 1, y + 1)))
                        || (KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(c - 1, y + 2)) && KinkyDungeonMovableTiles.includes(KinkyDungeonMapGet(c + 1, y + 2)))) {
                        doors[c + "," + (y + 1)] = { x: c, y: y + 1 };
                        doors[c + "," + (y + 2)] = { x: c, y: y + 2 };
                    }
                }
            }
        }
    }
    for (let d of Object.values(doors)) {
        let tile = KDRandom() < openChance ? 'd' : 'D';
        KinkyDungeonMapSet(d.x, d.y, tile);
        KinkyDungeonTilesSet(d.x + "," + d.y, { Type: "Door", NoTrap: true });
    }
}
function KDPlaceChest(cornerX, cornerY, radius, chestlist, spawnPoints, NoAddToChestList) {
    let factionList = [
        { faction: "Bandit", tags: ["bandit"], rtags: ["bandit"], ftags: ["miniboss", "boss"] },
        { faction: "Dragon", tags: ["dragon"], rtags: ["dragon"], ftags: ["miniboss", "boss"] },
        { faction: "AncientRobot", tags: ["robot"], rtags: ["robot"], ftags: ["miniboss", "boss"] },
        { faction: "Maidforce", tags: ["maid"], rtags: ["maid"], ftags: ["miniboss", "boss"] },
        { faction: "Bountyhunter", tags: ["bountyhunter"], rtags: ["bountyhunter"], ftags: ["miniboss", "boss"] },
        { faction: "Dressmaker", tags: ["dressmaker"], rtags: ["dressmaker"], ftags: ["miniboss", "boss"] },
        { faction: "Witch", tags: ["witch", "apprentice", "skeleton"], rtags: ["witch", "apprentice", "skeleton"], ftags: ["miniboss", "boss"] },
        { faction: "Apprentice", tags: ["apprentice"], rtags: ["apprentice"], ftags: ["miniboss", "boss"] },
        { faction: "Nevermere", tags: ["nevermere"], rtags: ["nevermere"], ftags: ["miniboss", "boss"] },
        { faction: "Bast", tags: ["mummy"], rtags: ["mummy"], ftags: ["miniboss", "boss"] },
        { faction: "Elf", tags: ["elf"], rtags: ["elf"], ftags: ["miniboss", "boss"] },
        { faction: "Elemental", tags: ["elemental", "witch"], rtags: ["elemental", "witch"], ftags: ["miniboss", "boss"] },
        { faction: "Alchemist", tags: ["alchemist"], rtags: ["alchemist"], ftags: ["miniboss", "boss"] },
    ];
    let factionSelected = factionList[Math.floor(KDRandom() * factionList.length)];
    if (!NoAddToChestList) {
        chestlist.push({ x: cornerX + 1, y: cornerY + 1, priority: true, Faction: factionSelected.faction, NoTrap: true });
    }
    spawnPoints.push({ x: cornerX, y: cornerY, required: [factionSelected.rtags[Math.floor(KDRandom() * factionSelected.rtags.length)]], ftags: factionSelected.ftags, tags: factionSelected.tags, AI: "guard" });
    spawnPoints.push({ x: cornerX + 2, y: cornerY, required: [factionSelected.rtags[Math.floor(KDRandom() * factionSelected.rtags.length)]], ftags: factionSelected.ftags, tags: factionSelected.tags, AI: "guard" });
    spawnPoints.push({ x: cornerX, y: cornerY + 2, required: [factionSelected.rtags[Math.floor(KDRandom() * factionSelected.rtags.length)]], ftags: factionSelected.ftags, tags: factionSelected.tags, AI: "guard" });
    spawnPoints.push({ x: cornerX + 2, y: cornerY + 2, required: [factionSelected.rtags[Math.floor(KDRandom() * factionSelected.rtags.length)]], ftags: factionSelected.ftags, tags: factionSelected.tags, AI: "guard" });
    return factionSelected.faction;
}
let KDDialogueData = {
    CurrentDialogueIndex: 0,
};
function KDPersonalitySpread(Min, Avg, Max, Enemy) {
    return KDStrictPersonalities.includes((Enemy === null || Enemy === void 0 ? void 0 : Enemy.personality) || KDGameData.CurrentDialogMsgPersonality) ? Max :
        (!KDLoosePersonalities.includes((Enemy === null || Enemy === void 0 ? void 0 : Enemy.personality) || KDGameData.CurrentDialogMsgPersonality) ? Avg :
            Min);
}
function KinkyDungeonCanPutNewDialogue() {
    return !KDGameData.CurrentDialog && !KinkyDungeonFlags.get("NoDialogue");
}
function KDBasicCheck(PositiveReps, NegativeReps, Modifier = 0) {
    let value = Modifier;
    if (KinkyDungeonFlags.has("OfferRefused"))
        value -= 15;
    if (KinkyDungeonFlags.has("OfferRefusedLight"))
        value -= 15;
    if (KinkyDungeonStatWill < 10)
        value -= Math.max(0, 5 * (10 - KinkyDungeonStatWill));
    for (let rep of PositiveReps) {
        if (KinkyDungeonGoddessRep[rep] != undefined)
            value += 50 + KinkyDungeonGoddessRep[rep];
    }
    for (let rep of NegativeReps) {
        if (KinkyDungeonGoddessRep[rep] != undefined)
            value -= 50 + KinkyDungeonGoddessRep[rep];
    }
    return value;
}
function KDDialogueApplyPersonality(allowed) {
    if (allowed.includes(KDGameData.CurrentDialogMsgPersonality))
        KDGameData.CurrentDialogMsg = KDGameData.CurrentDialogMsg + KDGameData.CurrentDialogMsgPersonality;
}
function KDGetDialogue() {
    let dialogue = KDDialogue[KDGameData.CurrentDialog];
    if (KDGameData.CurrentDialogStage && (dialogue === null || dialogue === void 0 ? void 0 : dialogue.options)) {
        let stages = KDGameData.CurrentDialogStage.split("_");
        for (let i = 0; i < stages.length; i++) {
            if (dialogue.options[stages[i]])
                dialogue = dialogue.options[stages[i]];
            else {
                console.log("Error in dialogue " + KDGameData.CurrentDialog + ", stage = " + KDGameData.CurrentDialogStage);
                KDGameData.CurrentDialog = "";
                break;
            }
        }
    }
    return dialogue;
}
let KDMaxDialogue = 7;
let KDOptionOffset = 0;
function KDDrawDialogue() {
    KDDraw(kdcanvas, kdpixisprites, "dialogbg", KinkyDungeonRootDirectory + "DialogBackground.png", 500, 0, 1000, 1000, undefined, {
        zIndex: 111,
    });
    if (KDGameData.CurrentDialog && !(KinkyDungeonSlowMoveTurns > 0)) {
        KinkyDungeonDrawState = "Game";
        let dialogue = KDGetDialogue();
        if (dialogue.response && !KDGameData.CurrentDialogMsg)
            KDGameData.CurrentDialogMsg = dialogue.response;
        if (KDGameData.CurrentDialogMsg == "Default")
            KDGameData.CurrentDialogMsg = KDGameData.CurrentDialog + KDGameData.CurrentDialogStage;
        let text = TextGet("r" + KDGameData.CurrentDialogMsg).split("|");
        for (let i = 0; i < text.length; i++) {
            let tt = text[i];
            if (KDGameData.CurrentDialogMsgData) {
                for (let d of Object.entries(KDGameData.CurrentDialogMsgData)) {
                    tt = tt.replace(d[0], d[1]);
                }
            }
            DrawTextFitKD(tt.replace("SPEAKER", TextGet("Name" + KDGameData.CurrentDialogMsgSpeaker)), 1000, 300 + 50 * i - 25 * text.length, 900, "white", "black", undefined, undefined, 115);
        }
        if (dialogue.options) {
            let entries = Object.entries(dialogue.options);
            let II = 0;
            let gagged = KDDialogueGagged();
            for (let i = KDOptionOffset; i < entries.length && II < KDMaxDialogue; i++) {
                if ((!entries[i][1].prerequisiteFunction || entries[i][1].prerequisiteFunction(gagged, KinkyDungeonPlayerEntity))
                    && (!entries[i][1].gagRequired || gagged)
                    && (!entries[i][1].gagDisabled || !gagged)) {
                    let playertext = entries[i][1].playertext;
                    if (playertext == "Default")
                        playertext = KDGameData.CurrentDialog + KDGameData.CurrentDialogStage + "_" + entries[i][0];
                    if (entries[i][1].gag && KDDialogueGagged())
                        playertext = playertext + "Gag";
                    let tt = TextGet("d" + playertext);
                    if (KDGameData.CurrentDialogMsgData) {
                        for (let d of Object.entries(KDGameData.CurrentDialogMsgData)) {
                            tt = tt.replace(d[0], d[1]);
                        }
                    }
                    DrawButtonKDEx("dialogue" + II, (bdata) => {
                        KDOptionOffset = 0;
                        KDDialogueData.CurrentDialogueIndex = 0;
                        KDSendInput("dialogue", { dialogue: KDGameData.CurrentDialog, dialogueStage: KDGameData.CurrentDialogStage + ((KDGameData.CurrentDialogStage) ? "_" : "") + entries[i][0], click: true });
                        return true;
                    }, KinkyDungeonDialogueTimer < CommonTime(), 700, 450 + II * 60, 600, 50, tt, KinkyDungeonDialogueTimer < CommonTime() ? "#ffffff" : "#888888", undefined, undefined, undefined, undefined, KDDialogueData.CurrentDialogueIndex == II ? KDTextGray3 : undefined, undefined, undefined, {
                        zIndex: 122,
                    });
                    if (MouseIn(700, 450 + II * 60, 600, 50))
                        KDDialogueData.CurrentDialogueIndex = II;
                    II += 1;
                }
            }
            if (II >= KDMaxDialogue) {
                DrawButtonKDEx("dialogueUP", (bdata) => {
                    KDOptionOffset -= 1;
                    return true;
                }, KDOptionOffset > 0, 1350, 450, 90, 40, "", KDOptionOffset > 0 ? "white" : "#888888", KinkyDungeonRootDirectory + "Up.png", undefined, undefined, undefined, undefined, undefined, undefined, {
                    zIndex: 122,
                });
                DrawButtonKDEx("dialogueDOWN", (bdata) => {
                    KDOptionOffset += 1;
                    return true;
                }, KDOptionOffset + KDMaxDialogue < entries.length, 1350, 450 + (KDMaxDialogue - 1) * 60 + 10, 90, 40, "", KDOptionOffset + KDMaxDialogue < entries.length ? "white" : "#888888", KinkyDungeonRootDirectory + "Down.png", undefined, undefined, undefined, undefined, undefined, undefined, {
                    zIndex: 122,
                });
            }
            if (KDDialogueData.CurrentDialogueIndex < 0)
                KDDialogueData.CurrentDialogueIndex = 0;
            if (KDDialogueData.CurrentDialogueIndex >= II)
                KDDialogueData.CurrentDialogueIndex = II - 1;
        }
    }
    else if (!KDGameData.CurrentDialog) {
        KDGameData.CurrentDialogMsgData = {};
        KDGameData.CurrentDialogMsgValue = {};
    }
}
function KDIncreaseOfferFatigue(Amount) {
    if (!KDGameData.OfferFatigue) {
        KDGameData.OfferFatigue = 0;
    }
    KDGameData.OfferFatigue = Math.max(0, KDGameData.OfferFatigue + Amount);
    if (Amount > 0)
        KinkyDungeonSetFlag("OfferRefused", KDOfferCooldown * 2);
    if (Amount > 0)
        KinkyDungeonSetFlag("OfferRefusedLight", KDOfferCooldown * 5);
}
function KDEnemyHelpfulness(enemy) {
    if (!enemy.personality)
        return 1.0;
    if (KDStrictPersonalities.includes(enemy.personality))
        return 0.33;
    if (KDLoosePersonalities.includes(enemy.personality))
        return 1.75;
}
function KDGetSpeaker() {
    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
        return enemy;
    }
    return null;
}
function KDPleaseSpeaker(Amount) {
    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
        KDAddOpinion(enemy, Amount * 100);
        let faction = KDGetFactionOriginal(enemy);
        if (!KinkyDungeonHiddenFactions.includes(faction)) {
            KinkyDungeonChangeFactionRep(faction, Amount);
        }
    }
}
function KDAddOpinion(enemy, Amount) {
    if (!enemy)
        return;
    let a = Math.min(1000, Math.abs(Amount));
    while (a > 0) {
        enemy.opinion = Math.max((enemy.opinion || 0) + Math.min(10, a) * Math.min(10, a) / (Amount > 0 ? (Math.min(10, a) + (enemy.opinion || 0)) : -1), 0);
        a -= 10;
    }
}
function KDAllySpeaker(Turns, Follow) {
    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
        KDAddOpinion(enemy, Turns);
        if (!(enemy.hostile > 0)) {
            enemy.allied = Turns;
            if (Follow) {
                KinkyDungeonSetEnemyFlag(enemy, "NoFollow", 0);
            }
        }
    }
}
function KDAggroSpeaker(Turns = 300) {
    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
        if (!(enemy.hostile > 0)) {
            enemy.hostile = Turns;
        }
        else
            enemy.hostile = Math.max(enemy.hostile, Turns);
    }
}
function KDBasicDialogueSuccessChance(checkResult) {
    return Math.max(0, Math.min(1.0, checkResult / 100));
}
function KDAgilityDialogueSuccessChance(checkResult) {
    let evasion = KinkyDungeonPlayerEvasion();
    return Math.max(0, Math.min(1.0, (checkResult / 100 - (KDGameData.OfferFatigue ? KDGameData.OfferFatigue / 100 : 0) + 0.2 * Math.max(0, 3 - KinkyDungeonSlowLevel)) * evasion));
}
function KDOffensiveDialogueSuccessChance(checkResult) {
    let accuracy = KinkyDungeonGetEvasion();
    return Math.max(0, Math.min(1.0, (checkResult / 100 - (KDGameData.OfferFatigue ? KDGameData.OfferFatigue / 100 : 0)
        - 0.15 + 0.3 * Math.max(0, 3 - KinkyDungeonSlowLevel)) * accuracy));
}
let KinkyDungeonDialogueTimer = 0;
function KDStartDialog(Dialogue, Speaker, Click, Personality, enemy) {
    KinkyDungeonInterruptSleep();
    KDDisableAutoWait();
    KinkyDungeonDialogueTimer = CommonTime() + 700 + KinkyDungeonSlowMoveTurns * 200;
    KDOptionOffset = 0;
    KinkyDungeonFastMovePath = [];
    KinkyDungeonDrawState = "Game";
    KDDialogueData.CurrentDialogueIndex = 0;
    KDDoDialogue({ dialogue: Dialogue, dialogueStage: "", click: Click, speaker: Speaker, personality: Personality, enemy: enemy ? enemy.id : undefined });
}
function KDDoDialogue(data) {
    KDDelayedActionPrune(["Action", "Dialogue"]);
    if (!KDGameData.CurrentDialogMsgData)
        KDGameData.CurrentDialogMsgData = {};
    if (!KDGameData.CurrentDialogMsgValue)
        KDGameData.CurrentDialogMsgValue = {};
    KDGameData.CurrentDialog = data.dialogue;
    KDGameData.CurrentDialogStage = data.dialogueStage;
    if (data.speaker) {
        let oldSpeaker = KDGameData.CurrentDialogMsgSpeaker;
        KDGameData.CurrentDialogMsgSpeaker = data.speaker;
        if (KDGameData.CurrentDialogMsgSpeaker != oldSpeaker)
            KDGameData.CurrentDialogMsgPersonality = "";
    }
    if (data.enemy) {
        KDGameData.CurrentDialogMsgID = data.enemy;
    }
    if (data.personality)
        KDGameData.CurrentDialogMsgPersonality = data.personality;
    let dialogue = KDGetDialogue();
    if (dialogue.data)
        KDGameData.CurrentDialogMsgData = dialogue.data;
    if (dialogue.response)
        KDGameData.CurrentDialogMsg = dialogue.response;
    if (dialogue.response == "Default")
        KDGameData.CurrentDialogMsg = KDGameData.CurrentDialog + KDGameData.CurrentDialogStage;
    if (dialogue.personalities) {
        KDDialogueApplyPersonality(dialogue.personalities);
    }
    let abort = false;
    if (data.click) {
        let gagged = KDDialogueGagged();
        if (dialogue.gagFunction && gagged) {
            abort = dialogue.gagFunction(KinkyDungeonPlayerEntity);
        }
        else if (dialogue.clickFunction) {
            abort = dialogue.clickFunction(gagged, KinkyDungeonPlayerEntity);
        }
    }
    if (!abort) {
        if (dialogue.exitDialogue) {
            KDGameData.CurrentDialog = "";
            KDGameData.CurrentDialogStage = "";
        }
        else {
            let modded = false;
            if (dialogue.leadsTo != undefined) {
                KDGameData.CurrentDialog = dialogue.leadsTo;
                KDGameData.CurrentDialogStage = "";
                modded = true;
            }
            if (dialogue.leadsToStage != undefined) {
                KDGameData.CurrentDialogStage = dialogue.leadsToStage;
                modded = true;
            }
            if (modded && !dialogue.dontTouchText) {
                dialogue = KDGetDialogue();
                if (dialogue.response)
                    KDGameData.CurrentDialogMsg = dialogue.response;
                if (dialogue.response == "Default")
                    KDGameData.CurrentDialogMsg = KDGameData.CurrentDialog + KDGameData.CurrentDialogStage;
            }
        }
    }
}
function KDStartDialogInput(Dialogue, Speaker, Click, Personality, enemy) {
    KinkyDungeonInterruptSleep();
    KDDisableAutoWait();
    KinkyDungeonDialogueTimer = CommonTime() + 700 + KinkyDungeonSlowMoveTurns * 200;
    KDOptionOffset = 0;
    KinkyDungeonFastMovePath = [];
    KinkyDungeonDrawState = "Game";
    KDDialogueData.CurrentDialogueIndex = 0;
    KDSendInput("dialogue", { dialogue: Dialogue, dialogueStage: "", click: Click, speaker: Speaker, personality: Personality, enemy: enemy ? enemy.id : undefined });
}
function KDDialogueGagged() {
    let dialogue = KDGetDialogue();
    let threshold = dialogue.gagThreshold ? dialogue.gagThreshold : 0.01;
    if (KinkyDungeonGagTotal() >= threshold)
        return true;
    return false;
}
function KDHandleDialogue() {
    if (KDGameData.CurrentDialog && KinkyDungeonDialogueTimer < CommonTime()) {
        KinkyDungeonInterruptSleep();
        let dialogue = KDGetDialogue();
        if (dialogue.inventory)
            KinkyDungeonhandleQuickInv(true);
    }
    return false;
}
function DialogueCreateEnemy(x, y, Name) {
    if (KinkyDungeonEnemyAt(x, y))
        KDKickEnemy(KinkyDungeonEnemyAt(x, y));
    let Enemy = KinkyDungeonGetEnemyByName(Name);
    let e = { summoned: true, Enemy: Enemy, id: KinkyDungeonGetEnemyID(),
        x: x, y: y,
        hp: (Enemy && Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0 };
    KDAddEntity(e);
    return e;
}
function KDDialogueEnemy() {
    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
        return enemy;
    }
    return null;
}
function KDAllyDialogue(name, requireTags, requireSingleTag, excludeTags, weight) {
    let dialog = {
        response: "Default",
        options: {},
    };
    dialog.options.Leave = { playertext: "Leave", exitDialogue: true,
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                KinkyDungeonSetEnemyFlag(enemy, "NoShop", 9999);
            }
            return false;
        },
    };
    dialog.options.Attack = { playertext: name + "Attack", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (!enemy || (enemy.aware && !enemy.playWithPlayer))
                return true;
            return false;
        },
        options: {
            "Confirm": { playertext: name + "Attack_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        if (!enemy.Enemy.allied) {
                            KDMakeHostile(enemy);
                            let faction = KDGetFactionOriginal(enemy);
                            if (!KinkyDungeonHiddenFactions.includes(faction)) {
                                KinkyDungeonChangeRep("Ghost", -5);
                                KinkyDungeonChangeFactionRep(faction, -0.06);
                            }
                        }
                        else {
                            enemy.hp = 0;
                        }
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Leave": { playertext: name + "Attack_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    dialog.options.AttackPlay = { playertext: name + "AttackPlay", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.playWithPlayer)
                return true;
            return false;
        },
        options: {
            "Confirm": { playertext: name + "Attack_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        if (!enemy.Enemy.allied) {
                            KDMakeHostile(enemy);
                            let faction = KDGetFactionOriginal(enemy);
                            if (!KinkyDungeonHiddenFactions.includes(faction)) {
                                KinkyDungeonChangeRep("Ghost", -5);
                            }
                        }
                        else {
                            enemy.hp = 0;
                        }
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Leave": { playertext: name + "AttackPlay_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    dialog.options.AttackUnaware = { playertext: name + "AttackUnaware", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && (enemy.aware || enemy.playWithPlayer))
                return false;
            return true;
        },
        options: {
            "Confirm": { playertext: name + "AttackUnaware_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        if (!enemy.Enemy.allied) {
                            KDMakeHostile(enemy);
                            enemy.stun = Math.max(enemy.stun || 0, 1);
                            enemy.vulnerable = Math.max(enemy.vulnerable || 0, 1);
                        }
                        else {
                            enemy.hp = 0;
                        }
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Leave": { playertext: name + "AttackUnaware_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    dialog.options.StopFollowingMe = { playertext: name + "StopFollowingMe", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return KDAllied(enemy) && !KDEnemyHasFlag(enemy, "NoFollow");
            }
            return false;
        },
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                KinkyDungeonSetEnemyFlag(enemy, "NoFollow", 9999);
            }
            return false;
        },
        leadsToStage: "", dontTouchText: true,
    };
    dialog.options.FollowMe = { playertext: name + "FollowMe", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return KDAllied(enemy) && KDEnemyHasFlag(enemy, "NoFollow") && !KDEnemyHasFlag(enemy, "Shop");
            }
            return false;
        },
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                if (!KDEnemyHasFlag(enemy, "NoStay")
                    && (KDRandom() < (70 - KinkyDungeonGoddessRep.Ghost + KDGetModifiedOpinion(enemy) + (KinkyDungeonStatsChoice.get("Dominant") ? 50 : 0)) / 100 * 0.35 * KDEnemyHelpfulness(enemy) || enemy.Enemy.allied)) {
                    KinkyDungeonSetEnemyFlag(enemy, "NoFollow", 0);
                }
                else {
                    KDGameData.CurrentDialogMsg = name + "StayHere_Fail";
                    KinkyDungeonSetEnemyFlag(enemy, "NoStay", 100);
                }
            }
            return false;
        },
        leadsToStage: "", dontTouchText: true,
    };
    dialog.options.DontStayHere = { playertext: name + "DontStayHere", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return !KDHostile(enemy) && KDEnemyHasFlag(enemy, "StayHere");
            }
            return false;
        },
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                KinkyDungeonSetEnemyFlag(enemy, "StayHere", 0);
            }
            return false;
        },
        leadsToStage: "", dontTouchText: true,
    };
    dialog.options.StayHere = { playertext: name + "StayHere", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return !KDHostile(enemy) && !KDEnemyHasFlag(enemy, "StayHere") && !KDEnemyHasFlag(enemy, "Shop");
            }
            return false;
        },
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                if (!KDEnemyHasFlag(enemy, "NoStay") && (KDRandom() < (50 - KinkyDungeonGoddessRep.Ghost + KDGetModifiedOpinion(enemy) + (KinkyDungeonStatsChoice.get("Dominant") ? 50 : 0)) / 100 * KDEnemyHelpfulness(enemy) * (KDAllied(enemy) ? 4.0 : 0.25) || enemy.Enemy.allied)) {
                    KinkyDungeonSetEnemyFlag(enemy, "StayHere", -1);
                    enemy.gx = enemy.x;
                    enemy.gy = enemy.y;
                }
                else {
                    KDGameData.CurrentDialogMsg = name + "StayHere_Fail";
                    KinkyDungeonSetEnemyFlag(enemy, "NoStay", 100);
                }
            }
            return false;
        },
        leadsToStage: "", dontTouchText: true,
    };
    dialog.options.Aggressive = { playertext: name + "Aggressive", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return !KDHostile(enemy) && KDEnemyHasFlag(enemy, "Defensive");
            }
            return false;
        },
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                KinkyDungeonSetEnemyFlag(enemy, "Defensive", 0);
            }
            return false;
        },
        leadsToStage: "", dontTouchText: true,
    };
    dialog.options.Defensive = { playertext: name + "Defensive", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return !KDHostile(enemy) && !KDEnemyHasFlag(enemy, "Defensive") && !KDEnemyHasFlag(enemy, "Shop");
            }
            return false;
        },
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                KinkyDungeonSetEnemyFlag(enemy, "Defensive", -1);
            }
            return false;
        },
        leadsToStage: "", dontTouchText: true,
    };
    dialog.options.HelpMe = { playertext: name + "HelpMe", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return !KDHostile(enemy) && enemy.Enemy.bound && !enemy.Enemy.tags.nohelp && !KDHelpless(enemy)
                    && !KDEnemyHasFlag(enemy, "NoHelp") && !KDEnemyHasFlag(enemy, "HelpMe") && KinkyDungeonAllRestraint().length > 0;
            }
            return false;
        },
        options: {
            "Confirm": { playertext: name + "HelpMe_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        if (!KDEnemyHasFlag(enemy, "NoHelp")
                            && KDRandom() < (KDPersonalitySpread(125, 85, 25) - KinkyDungeonGoddessRep.Ghost + KDGetModifiedOpinion(enemy) + (KinkyDungeonStatsChoice.get("Dominant") ? 25 : 0)) / 100 * (KDPersonalitySpread(0.0, -0.25, -0.5) + (KDAllied(enemy) ? 2.0 : 1.0))) {
                            KinkyDungeonChangeRep("Ghost", 3);
                            KinkyDungeonSetEnemyFlag(enemy, "HelpMe", 30);
                            KinkyDungeonSetEnemyFlag(enemy, "wander", 30);
                        }
                        else {
                            KDGameData.CurrentDialogMsg = name + "HelpMe_Fail";
                            KinkyDungeonSetEnemyFlag(enemy, "NoHelp", 100);
                            KinkyDungeonSetEnemyFlag(enemy, "playLikely", 10);
                            KinkyDungeonChangeRep("Ghost", 1);
                        }
                    }
                    return false;
                },
                leadsToStage: "",
                dontTouchText: true,
            },
            "Leave": { playertext: name + "HelpMe_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    dialog.options.HelpMeCommandWord = { playertext: name + "HelpMeCommandWord", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker && enemy.Enemy.unlockCommandLevel > 0) {
                return !KDHostile(enemy) && enemy.Enemy.bound && !enemy.Enemy.tags.nohelp && !KDHelpless(enemy)
                    && !KDEnemyHasFlag(enemy, "NoHelpCommandWord") && !KDEnemyHasFlag(enemy, "commandword") && KinkyDungeonPlayerGetRestraintsWithLocks(KDMagicLocks).length > 0;
            }
            return false;
        },
        options: {
            "Confirm": { playertext: name + "HelpMeCommandWord_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    var _a;
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        if (!KDEnemyHasFlag(enemy, "NoHelpCommandWord")
                            && KDRandom() < (KDPersonalitySpread(125, 85, 25) - KinkyDungeonGoddessRep.Ghost + KDGetModifiedOpinion(enemy) + (KinkyDungeonStatsChoice.get("Dominant") ? 25 : 0)) / 100 * (KDPersonalitySpread(0.0, -0.25, -0.5) + (KDAllied(enemy) ? 2.0 : 1.0))) {
                            KinkyDungeonChangeRep("Ghost", 3);
                            if (KinkyDungeonPlayerGetRestraintsWithLocks(KDMagicLocks).length > 0) {
                                for (let r of KinkyDungeonPlayerGetRestraintsWithLocks(KDMagicLocks, true)) {
                                    KinkyDungeonLock(r, "");
                                }
                            }
                            const unlockSpell = KinkyDungeonFindSpell("EffectEnemyCM" + (((_a = enemy === null || enemy === void 0 ? void 0 : enemy.Enemy) === null || _a === void 0 ? void 0 : _a.unlockCommandLevel) || 1), true) || KinkyDungeonFindSpell("EffectEnemyCM1", true);
                            KinkyDungeonCastSpell(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y, unlockSpell, undefined, undefined, undefined);
                            if (KDToggles.Sound)
                                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Magic.ogg");
                            KinkyDungeonSetEnemyFlag(enemy, "commandword", enemy.Enemy.unlockCommandCD || 90);
                        }
                        else {
                            KDGameData.CurrentDialogMsg = name + "HelpMeCommandWord_Fail";
                            KinkyDungeonSetEnemyFlag(enemy, "NoHelpCommandWord", 100);
                            KinkyDungeonChangeRep("Ghost", 1);
                        }
                    }
                    return false;
                },
                leadsToStage: "",
                dontTouchText: true, },
            "Leave": { playertext: name + "HelpMeCommandWord_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    dialog.options.HelpMeKey = { playertext: name + "HelpMeKey", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return !KDHostile(enemy) && enemy.Enemy.bound && !enemy.Enemy.tags.nohelp && !KDHelpless(enemy)
                    && !KDEnemyHasFlag(enemy, "NoHelpKey") && enemy.items && enemy.items.includes("RedKey") && KinkyDungeonPlayerGetRestraintsWithLocks(KDKeyedLocks).length > 0;
            }
            return false;
        },
        options: {
            "Confirm": { playertext: name + "HelpMeKey_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        if (!KDEnemyHasFlag(enemy, "NoHelpKey")
                            && KDRandom() < (KDPersonalitySpread(125, 85, 25) - KinkyDungeonGoddessRep.Ghost + KDGetModifiedOpinion(enemy) + (KinkyDungeonStatsChoice.get("Dominant") ? 25 : 0)) / 100 * (KDPersonalitySpread(0.0, -0.25, -0.5) + (KDAllied(enemy) ? 2.0 : 1.0))) {
                            KinkyDungeonChangeRep("Ghost", 3);
                            KinkyDungeonRedKeys += 1;
                            if (KDToggles.Sound)
                                AudioPlayInstantSoundKD(KinkyDungeonRootDirectory + "Audio/Coins.ogg");
                            enemy.items.splice(enemy.items.indexOf("RedKey"), 1);
                        }
                        else {
                            KDGameData.CurrentDialogMsg = name + "HelpMeKey_Fail";
                            KinkyDungeonSetEnemyFlag(enemy, "NoHelpKey", 100);
                            KinkyDungeonChangeRep("Ghost", 1);
                        }
                    }
                    return false;
                },
                leadsToStage: "",
                dontTouchText: true,
            },
            "Leave": { playertext: name + "HelpMeKey_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    dialog.options.DontHelpMe = { playertext: name + "DontHelpMe", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return enemy.Enemy.bound && !enemy.Enemy.tags.nohelp && !KDEnemyHasFlag(enemy, "NoHelp") && KDEnemyHasFlag(enemy, "HelpMe") && KinkyDungeonAllRestraint().length > 0;
            }
            return false;
        },
        options: {
            "Confirm": { playertext: name + "DontHelpMe_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        KinkyDungeonSetEnemyFlag(enemy, "HelpMe", 0);
                        KinkyDungeonSetEnemyFlag(enemy, "wander", 0);
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Leave": { playertext: name + "DontHelpMe_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    dialog.options.Shop = { playertext: name + "Shop", response: "Default",
        prerequisiteFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                return KDEnemyHasFlag(enemy, "Shop");
            }
            return false;
        },
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                for (let shop of Object.values(KDShops)) {
                    if (KDEnemyHasFlag(enemy, shop.name)) {
                        KDStartDialog(shop.name, enemy.Enemy.name, true, enemy.personality, enemy);
                        return true;
                    }
                }
            }
        },
        exitDialogue: true,
    };
    KDAllyDialog[name] = { name: name, tags: requireTags, singletag: requireSingleTag, excludeTags: excludeTags, weight: weight };
    return dialog;
}
let KDPrisonRescues = {};
function KDPrisonerRescue(name, faction, enemytypes) {
    let dialogue = {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonInterruptSleep();
            let door = KDGetJailDoor(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
            if (door) {
                if (door.tile) {
                    door.tile.Lock = undefined;
                    KDUpdateDoorNavMap();
                }
                KinkyDungeonMapSet(door.x, door.y, 'd');
                let e = DialogueCreateEnemy(door.x, door.y, enemytypes[0]);
                e.allied = 9999;
                e.faction = "Player";
                KDGameData.CurrentDialogMsgSpeaker = e.Enemy.name;
                let reinforcementCount = Math.floor(1 + KDRandom() * (KDGameData.PriorJailbreaks ? (Math.min(5, KDGameData.PriorJailbreaks) + 1) : 1));
                KDGameData.PriorJailbreaks += 1;
                for (let i = 0; i < reinforcementCount; i++) {
                    let pp = KinkyDungeonGetNearbyPoint(door.x, door.y, true, undefined, undefined);
                    if (pp) {
                        let ee = DialogueCreateEnemy(pp.x, pp.y, enemytypes[1] || enemytypes[0]);
                        ee.allied = 9999;
                        ee.faction = "Player";
                    }
                }
            }
            KDGameData.KinkyDungeonGuardSpawnTimer = 50 + Math.floor(KDRandom() * 10);
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    };
    KDPrisonRescues[name] = {
        speaker: enemytypes[0],
        faction: faction,
    };
    return dialogue;
}
function KDRecruitDialogue(name, faction, outfitName, goddess, restraints, restraintscount, restraintsAngry, restraintscountAngry, requireTags, requireSingleTag, excludeTags, chance) {
    let recruit = {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag(name, -1, 1);
            return false;
        },
        options: {
            "Yes": { gag: true, playertext: "Default", response: "Default",
                options: {
                    "Yes": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            KDPleaseSpeaker(0.1);
                            KinkyDungeonChangeRep("Ghost", 2);
                            for (let i = 0; i < restraintscount; i++) {
                                let r = KinkyDungeonGetRestraint({ tags: restraints }, MiniGameKinkyDungeonLevel * 2 + KDGetOfferLevelMod(), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                                if (r)
                                    KinkyDungeonAddRestraintIfWeaker(r, 0, true);
                            }
                            let outfit = { name: outfitName, type: Outfit, id: KinkyDungeonGetItemID() };
                            if (!KinkyDungeonInventoryGet(outfitName))
                                KinkyDungeonInventoryAdd(outfit);
                            KinkyDungeonSetDress(outfitName, outfitName);
                            KinkyDungeonSetFlag("Recruit_" + name, -1);
                            KinkyDungeonSetFlag("Recruited", -1);
                            KDChangeFactionRelation("Player", faction, 0.4, true);
                            KDChangeFactionRelation("Player", faction, -0.2);
                            KinkyDungeonSlowMoveTurns = 3;
                            KinkyDungeonSleepTime = CommonTime() + 200;
                            KinkyDungeonSetFlag(name, -1, 1);
                            return false;
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } },
                    },
                    "No": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            let diff = KinkyDungeonStatsChoice.has("Dominant") ? 0 : 35;
                            if (KDBasicCheck([goddess], ["Ghost"]) <= diff) {
                                KDGameData.CurrentDialogStage = "Force";
                                KDGameData.CurrentDialogMsg = name + "ForceYes";
                                KDGameData.CurrentDialogMsgValue.Percent = KDAgilityDialogueSuccessChance(KDBasicCheck([goddess], ["Ghost"]));
                                KDGameData.CurrentDialogMsgData.PERCENT = `${Math.round(100 * KDGameData.CurrentDialogMsgValue.Percent)}%`;
                            }
                            KinkyDungeonChangeRep("Ghost", -1);
                            KinkyDungeonSetFlag(name, -1, 1);
                            return false;
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } },
                    },
                },
            },
            "No": { gag: true, playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    let diff = KinkyDungeonStatsChoice.has("Dominant") ? 0 : 45;
                    if (KDBasicCheck(["Metal"], ["Ghost"]) <= diff) {
                        KDGameData.CurrentDialogStage = "Force";
                        KDGameData.CurrentDialogMsg = "";
                        KDGameData.CurrentDialogMsgValue.Percent = KDAgilityDialogueSuccessChance(KDBasicCheck([goddess], ["Ghost"]));
                        KDGameData.CurrentDialogMsgData.PERCENT = `${Math.round(100 * KDGameData.CurrentDialogMsgValue.Percent)}%`;
                    }
                    KinkyDungeonChangeRep("Ghost", -1);
                    KinkyDungeonSetFlag(name, -1, 1);
                    return false;
                },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } },
            },
            "Force": { gag: true, playertext: "Default", response: "Default",
                prerequisiteFunction: (gagged, player) => { return false; },
                options: {
                    "Yes": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            KDPleaseSpeaker(0.08);
                            KinkyDungeonChangeRep("Ghost", 2);
                            for (let i = 0; i < restraintscount; i++) {
                                let r = KinkyDungeonGetRestraint({ tags: restraints }, MiniGameKinkyDungeonLevel * 2 + KDGetOfferLevelMod(), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                                if (r)
                                    KinkyDungeonAddRestraintIfWeaker(r, 0, true);
                            }
                            let outfit = { name: outfitName, type: Outfit, id: KinkyDungeonGetItemID() };
                            if (!KinkyDungeonInventoryGet(outfitName))
                                KinkyDungeonInventoryAdd(outfit);
                            KinkyDungeonSetDress(outfitName, outfitName);
                            KinkyDungeonSetFlag("Recruit_" + name, -1);
                            KinkyDungeonSetFlag("Recruited", -1);
                            KDChangeFactionRelation("Player", faction, 0.4, true);
                            KDChangeFactionRelation("Player", faction, -0.2);
                            KinkyDungeonSlowMoveTurns = 3;
                            KinkyDungeonSleepTime = CommonTime() + 200;
                            KinkyDungeonSetFlag(name, -1, 1);
                            return false;
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } }, },
                    "No": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            let percent = KDGameData.CurrentDialogMsgValue.Percent;
                            KinkyDungeonChangeRep("Ghost", -1);
                            if (KDRandom() > percent) {
                                KDIncreaseOfferFatigue(-20);
                                KDGameData.CurrentDialogMsg = name + "Force_Failure";
                                for (let i = 0; i < restraintscountAngry; i++) {
                                    let r = KinkyDungeonGetRestraint({ tags: restraintsAngry }, MiniGameKinkyDungeonLevel * 2 + KDGetOfferLevelMod(), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                                    if (r)
                                        KinkyDungeonAddRestraintIfWeaker(r, 0, true);
                                }
                                let outfit = { name: outfitName, type: Outfit, id: KinkyDungeonGetItemID() };
                                if (!KinkyDungeonInventoryGet(outfitName))
                                    KinkyDungeonInventoryAdd(outfit);
                                KinkyDungeonSetDress(outfitName, outfitName);
                                KinkyDungeonSlowMoveTurns = 3;
                                KinkyDungeonSleepTime = CommonTime() + 200;
                            }
                            else {
                                KDIncreaseOfferFatigue(10);
                                let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                                if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                                    KDMakeHostile(enemy);
                                    KinkyDungeonChangeRep(goddess, -2);
                                }
                            }
                            KinkyDungeonSetFlag(name, -1, 1);
                            return false;
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } }, },
                },
            },
        }
    };
    KDRecruitDialog[name] = { name: name, outfit: outfitName, tags: requireTags, singletag: requireSingleTag, excludeTags: excludeTags, chance: chance };
    KDDialogueTriggers[name] = KDRecruitTrigger(name, KDRecruitDialog[name]);
    return recruit;
}
let KDMaxSellItems = 6;
function KDShopDialogue(name, items, requireTags, requireSingleTag, chance) {
    let shop = {
        inventory: true,
        response: "Default",
        clickFunction: (gagged, player) => {
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                if (KinkyDungeonGetRestraintByName(item)) {
                    KDGameData.CurrentDialogMsgData["Item" + i] = TextGet("Restraint" + item);
                    let power = KinkyDungeonGetRestraintByName(item).power;
                    if (!power || power < 1)
                        power = 1;
                    KDGameData.CurrentDialogMsgValue["ItemCost" + i] = 5 * Math.round((10 + 2 * Math.pow(power, 1.5)) / 5);
                    KDGameData.CurrentDialogMsgData["ItemCost" + i] = "" + KDGameData.CurrentDialogMsgValue["ItemCost" + i];
                }
                else {
                    KDGameData.CurrentDialogMsgData["Item" + i] = TextGet("KinkyDungeonInventoryItem" + item);
                    KDGameData.CurrentDialogMsgValue["ItemCost" + i] = Math.round(KinkyDungeonItemCost(KinkyDungeonFindConsumable(item) ? KinkyDungeonFindConsumable(item) : KinkyDungeonFindWeapon(item), true, true) * 0.75);
                    KDGameData.CurrentDialogMsgData["ItemCost" + i] = "" + KDGameData.CurrentDialogMsgValue["ItemCost" + i];
                }
            }
            return false;
        },
        options: {},
    };
    shop.options.Leave = { playertext: "Leave", exitDialogue: true,
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                KinkyDungeonSetEnemyFlag(enemy, "NoShop", 9999);
                KinkyDungeonSetEnemyFlag(enemy, "NoTalk", 8);
            }
            return false;
        },
    };
    shop.options.Attack = { gag: true, playertext: "ItemShopAttack", response: "Default",
        options: {
            "Confirm": { playertext: "ItemShopAttack_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        KDMakeHostile(enemy);
                        KinkyDungeonChangeRep("Ghost", -5);
                        if (!KinkyDungeonHiddenFactions.includes(KDGetFactionOriginal(enemy)))
                            KinkyDungeonChangeFactionRep(KDGetFactionOriginal(enemy), -0.06);
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Leave": { playertext: "ItemShopAttack_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    for (let i = 0; i < items.length; i++) {
        let item = items[i];
        shop.options["Item" + i] = { playertext: "ItemShop" + i, response: name + item,
            prerequisiteFunction: (gagged, player) => {
                return KinkyDungeonInventoryGet(item) != undefined;
            },
            clickFunction: (gagged, player) => {
                let itemInv = KinkyDungeonInventoryGet(item);
                if (itemInv.type == Consumable)
                    KinkyDungeonChangeConsumable(KDConsumable(itemInv), -1);
                else
                    KinkyDungeonInventoryRemove(itemInv);
                let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                    let faction = KDGetFactionOriginal(enemy);
                    if (!KinkyDungeonHiddenFactions.includes(faction)) {
                        KinkyDungeonChangeFactionRep(faction, Math.max(0.0001, KDGameData.CurrentDialogMsgValue["ItemCost" + i] * 0.00005));
                    }
                }
                KinkyDungeonAddGold(KDGameData.CurrentDialogMsgValue["ItemCost" + i]);
                return false;
            },
            leadsToStage: "", dontTouchText: true,
        };
    }
    KDShops[name] = { name: name, tags: requireTags, singletag: requireSingleTag, chance: chance };
    return shop;
}
let KDOfferCooldown = 20;
function KDYesNoTemplate(setupFunction, yesFunction, noFunction, domFunction) {
    let dialogue = {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("BondageOffer", KDOfferCooldown);
            return false;
        },
        options: {
            "Yes": { gag: true, playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    return setupFunction(false);
                },
                options: {
                    "Yes": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            return yesFunction(false);
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } },
                    },
                    "No": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            return noFunction(false);
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } },
                    },
                    "Dominant": { gag: true, playertext: "OfferDominant", response: "OfferDominantSuccess",
                        clickFunction: (gagged, player) => {
                            return domFunction(false);
                        },
                        prerequisiteFunction: (gagged, player) => {
                            var _a, _b;
                            return ((_b = (_a = KDGetSpeaker()) === null || _a === void 0 ? void 0 : _a.Enemy) === null || _b === void 0 ? void 0 : _b.bound) != undefined;
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } }, },
                },
            },
            "No": { gag: true, playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    return setupFunction(true);
                },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } },
            },
            "Force": { gag: true, playertext: "Default", response: "Default",
                prerequisiteFunction: (gagged, player) => { return false; },
                options: {
                    "Yes": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            return yesFunction(true);
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } }, },
                    "No": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            return noFunction(true);
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } },
                    },
                    "Dominant": { gag: true, playertext: "OfferDominant", response: "OfferDominantSuccess",
                        clickFunction: (gagged, player) => {
                            return domFunction(true);
                        },
                        prerequisiteFunction: (gagged, player) => {
                            var _a, _b;
                            return ((_b = (_a = KDGetSpeaker()) === null || _a === void 0 ? void 0 : _a.Enemy) === null || _b === void 0 ? void 0 : _b.bound) != undefined;
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } }, },
                },
            },
        }
    };
    return dialogue;
}
function KDYesNoBasic(name, goddess, antigoddess, restraint, diffSpread, OffdiffSpread, count = 1, countAngry = 1, Lock = "Red", Ally = false, Flags = []) {
    return KDYesNoTemplate((refused) => {
        for (let f of Flags) {
            KinkyDungeonSetFlag(f.name, f.duration, f.floors);
        }
        let r = KinkyDungeonGetRestraint({ tags: restraint }, MiniGameKinkyDungeonLevel * 2 + KDGetOfferLevelMod(), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
        if (r) {
            KDGameData.CurrentDialogMsgData = {
                "Data_r": r.name,
                "RESTRAINT": TextGet("Restraint" + r.name),
            };
            KDGameData.CurrentDialogMsgValue.PercentOff =
                KDOffensiveDialogueSuccessChance(KDBasicCheck(goddess, [])
                    - (KDDialogueGagged() ? 60 : 40)
                    - (KinkyDungeonStatsChoice.get("Undeniable") ? 100 : 0)
                    - (KinkyDungeonStatsChoice.has("Dominant") ? 0 : 40)
                    - KDPersonalitySpread(OffdiffSpread[0], OffdiffSpread[1], KinkyDungeonStatsChoice.has("Dominant") ? OffdiffSpread[3] : OffdiffSpread[2]));
            KDGameData.CurrentDialogMsgData.OFFPERC = `${Math.round(100 * KDGameData.CurrentDialogMsgValue.PercentOff)}%`;
        }
        if (refused) {
            let diff = KinkyDungeonStatsChoice.has("Dominant") ? diffSpread[1] : diffSpread[0];
            if (KinkyDungeonStatsChoice.get("Undeniable"))
                diff += 140;
            if (KDBasicCheck(goddess, antigoddess) <= diff) {
                KDGameData.CurrentDialogStage = "Force";
                KDGameData.CurrentDialogMsg = name + "ForceYes";
                KDGameData.CurrentDialogMsgValue.Percent = KDAgilityDialogueSuccessChance(KDBasicCheck(goddess, antigoddess, KinkyDungeonStatsChoice.get("Undeniable") ? -70 : 0));
                KDGameData.CurrentDialogMsgData.PERCENT = `${Math.round(100 * KDGameData.CurrentDialogMsgValue.Percent)}%`;
            }
            else {
                KDIncreaseOfferFatigue(10);
            }
            KinkyDungeonChangeRep(antigoddess[0], -1);
            KDAddOpinion(KDGetSpeaker(), -10);
        }
        return false;
    }, (refused) => {
        KinkyDungeonChangeRep(goddess[0], 1);
        if (Ally)
            KDAllySpeaker(9999, true);
        else
            KDPleaseSpeaker(refused ? 0.004 : 0.005);
        KinkyDungeonChangeRep(antigoddess[0], refused ? 1 : 2);
        KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName(KDGameData.CurrentDialogMsgData.Data_r), 0, true, Lock);
        KDAddOffer(1);
        let num = count;
        if (num > 1) {
            let r = KinkyDungeonGetRestraint({ tags: restraint }, MiniGameKinkyDungeonLevel * 2 + KDGetOfferLevelMod(), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
            if (r)
                KinkyDungeonAddRestraintIfWeaker(r, 0, true, Lock);
        }
        return false;
    }, (refused) => {
        if (!refused) {
            let diff = KinkyDungeonStatsChoice.has("Dominant") ? diffSpread[3] : diffSpread[2];
            if (KinkyDungeonStatsChoice.get("Undeniable"))
                diff += 140;
            if (KDBasicCheck(goddess, antigoddess) <= diff) {
                KDGameData.CurrentDialogStage = "Force";
                KDGameData.CurrentDialogMsg = "";
                KDGameData.CurrentDialogMsgValue.Percent = KDAgilityDialogueSuccessChance(KDBasicCheck(goddess, antigoddess, KinkyDungeonStatsChoice.get("Undeniable") ? -70 : 0));
                KDGameData.CurrentDialogMsgData.PERCENT = `${Math.round(100 * KDGameData.CurrentDialogMsgValue.Percent)}%`;
            }
            else {
                KDIncreaseOfferFatigue(10);
            }
            KinkyDungeonChangeRep(antigoddess[0], -1);
            KDAddOpinion(KDGetSpeaker(), -5);
        }
        else {
            let percent = KDGameData.CurrentDialogMsgValue.Percent;
            KDAddOpinion(KDGetSpeaker(), -10);
            if (KDRandom() > percent) {
                KDIncreaseOfferFatigue(-20);
                KDGameData.CurrentDialogMsg = name + "Force_Failure";
                KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName(KDGameData.CurrentDialogMsgData.Data_r), 0, true, Lock || "Red");
                KDAddOffer(1);
                let num = refused ? countAngry : count;
                if (num > 1) {
                    let r = KinkyDungeonGetRestraint({ tags: restraint }, MiniGameKinkyDungeonLevel * 2 + KDGetOfferLevelMod(), KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]);
                    if (r)
                        KinkyDungeonAddRestraintIfWeaker(r, 0, true, Lock);
                }
            }
            else {
                KDIncreaseOfferFatigue(10);
            }
        }
        return false;
    }, (refused) => {
        let percent = KDGameData.CurrentDialogMsgValue.PercentOff;
        if (KDRandom() > percent) {
            KDIncreaseOfferFatigue(-20);
            KDGameData.CurrentDialogMsg = "OfferDominantFailure";
            KDAggroSpeaker(10);
            KDAddOpinion(KDGetSpeaker(), -20);
        }
        else {
            KDIncreaseOfferFatigue(10);
            KDAddOpinion(KDGetSpeaker(), 25);
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                enemy.playWithPlayer = 0;
                enemy.playWithPlayerCD = 999;
                let amount = 10;
                if (!enemy.boundLevel)
                    enemy.boundLevel = amount;
                else
                    enemy.boundLevel += amount;
            }
            KinkyDungeonChangeRep(antigoddess[0], -4);
        }
        return false;
    });
}
function KDSaleShop(name, items, requireTags, requireSingleTag, chance, markup) {
    if (!markup)
        markup = 1.0;
    let shop = {
        shop: true,
        response: "Default",
        clickFunction: (gagged, player) => {
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                if (KinkyDungeonGetRestraintByName(item)) {
                    KDGameData.CurrentDialogMsgData["Item" + i] = TextGet("Restraint" + item);
                    let power = KinkyDungeonGetRestraintByName(item).power;
                    if (!power || power < 1)
                        power = 1;
                    KDGameData.CurrentDialogMsgValue["ItemCost" + i] = 5 * Math.round((10 + 2 * Math.pow(power, 1.5)) / 5);
                    KDGameData.CurrentDialogMsgData["ItemCost" + i] = "" + KDGameData.CurrentDialogMsgValue["ItemCost" + i];
                }
                else {
                    KDGameData.CurrentDialogMsgData["Item" + i] = TextGet("KinkyDungeonInventoryItem" + item);
                    KDGameData.CurrentDialogMsgValue["ItemCost" + i] = Math.round(KinkyDungeonItemCost(KinkyDungeonFindConsumableOrBasic(item) ? KinkyDungeonFindConsumableOrBasic(item) : KinkyDungeonFindWeapon(item), true, true) * markup);
                    KDGameData.CurrentDialogMsgData["ItemCost" + i] = "" + KDGameData.CurrentDialogMsgValue["ItemCost" + i];
                }
            }
            return false;
        },
        options: {},
    };
    shop.options.Leave = { playertext: "Leave", exitDialogue: true,
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                KinkyDungeonSetEnemyFlag(enemy, "NoShop", 9999);
                KinkyDungeonSetEnemyFlag(enemy, "NoTalk", 8);
            }
            return false;
        },
    };
    shop.options.Attack = { gag: true, playertext: "ItemShopAttack", response: "Default",
        options: {
            "Confirm": { playertext: "ItemShopAttack_Confirm", response: "Default",
                clickFunction: (gagged, player) => {
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        KDMakeHostile(enemy);
                        KinkyDungeonChangeRep("Ghost", -5);
                        if (!KinkyDungeonHiddenFactions.includes(KDGetFactionOriginal(enemy)))
                            KinkyDungeonChangeFactionRep(KDGetFactionOriginal(enemy), -0.06);
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Leave": { playertext: "ItemShopAttack_Leave", response: "Default",
                leadsToStage: "",
            },
        }
    };
    for (let i = 0; i < items.length; i++) {
        let item = items[i];
        shop.options["Item" + i] = { playertext: "ItemShopBuy" + i, response: name + item,
            prerequisiteFunction: (gagged, player) => {
                return true;
            },
            clickFunction: (gagged, player) => {
                let buy = false;
                if (KinkyDungeonGold >= KDGameData.CurrentDialogMsgValue["ItemCost" + i]) {
                    buy = true;
                    if (KinkyDungeonGetRestraintByName(item)) {
                        let rest = KinkyDungeonGetRestraintByName(item);
                        let Rname = rest.inventoryAs || rest.name;
                        if (!KinkyDungeonInventoryGetLoose(Rname)) {
                            KinkyDungeonInventoryAdd({ name: Rname, type: LooseRestraint, events: rest.events, quantity: 1, id: KinkyDungeonGetItemID() });
                        }
                        else {
                            if (!KinkyDungeonInventoryGetLoose(Rname).quantity)
                                KinkyDungeonInventoryGetLoose(Rname).quantity = 0;
                            KinkyDungeonInventoryGetLoose(Rname).quantity += 1;
                        }
                    }
                    else if (KinkyDungeonFindBasic(item)) {
                        KDAddBasic(KinkyDungeonFindBasic(item));
                    }
                    else if (KinkyDungeonFindConsumable(item)) {
                        KinkyDungeonChangeConsumable(KinkyDungeonFindConsumable(item), 1);
                    }
                    else if (KinkyDungeonFindWeapon(item)) {
                        if (!KinkyDungeonInventoryGetWeapon(item)) {
                            KinkyDungeonInventoryAddWeapon(item);
                        }
                        else {
                            KDGameData.CurrentDialogMsg = name + "_AlreadyHave";
                            buy = false;
                        }
                    }
                }
                else {
                    KDGameData.CurrentDialogMsg = name + "_NoMoney";
                }
                if (buy) {
                    KinkyDungeonAddGold(-KDGameData.CurrentDialogMsgValue["ItemCost" + i]);
                    let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
                    if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                        let faction = KDGetFactionOriginal(enemy);
                        if (!KinkyDungeonHiddenFactions.includes(faction)) {
                            KinkyDungeonChangeFactionRep(faction, Math.max(0.0001, KDGameData.CurrentDialogMsgValue["ItemCost" + i] * 0.0001));
                        }
                    }
                }
                return false;
            },
            leadsToStage: "", dontTouchText: true,
        };
    }
    KDShops[name] = { name: name, tags: requireTags, singletag: requireSingleTag, chance: chance, items: items };
    return shop;
}
function DialogueBringNearbyEnemy(x, y, radius) {
    var _a;
    for (let e of KinkyDungeonEntities) {
        if (!KDHelpless(e) && KDistChebyshev(x - e.x, y - e.y) <= radius && KinkyDungeonAggressive(e) && !KDIsImmobile(e) && !e.Enemy.tags.temporary && (((_a = KDAIType[KDGetAI(e)]) === null || _a === void 0 ? void 0 : _a.ambush) || e.ambushtrigger)) {
            let point = KinkyDungeonNoEnemy(x, y, true) ? { x: x, y: y } : KinkyDungeonGetNearbyPoint(x, y, true);
            if (point) {
                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonDiscovered"), "#ff0000", 1);
                KDMoveEntity(e, point.x, point.y, true);
                return e;
            }
        }
    }
    return null;
}
function DialogueBringSpecific(x, y, enemy) {
    if (enemy) {
        let point = KinkyDungeonNoEnemy(x, y, true) ? { x: x, y: y } : KinkyDungeonGetNearbyPoint(x, y, true);
        if (point) {
            KDMoveEntity(enemy, point.x, point.y, true);
            return enemy;
        }
    }
    return null;
}
function KDIsSubmissiveEnough(enemy) {
    let diff = KDPersonalitySpread(20, -20, -51);
    if (KinkyDungeonGoddessRep.Ghost >= diff)
        return true;
    return false;
}
function KDGetModifiedOpinion(enemy) {
    let op = enemy.opinion || 0;
    op += 30 * KDFactionRelation("Player", KDGetFaction(enemy));
    if (KinkyDungeonStatsChoice.get("Dominant") && enemy.personality && KDLoosePersonalities.includes(enemy.personality))
        op += 12;
    if (KinkyDungeonStatsChoice.get("Oppression"))
        op -= 15;
    return op;
}
function KDAddOffer(Amount) {
    if (!KDGameData.OfferCount)
        KDGameData.OfferCount = 0;
    KDGameData.OfferCount += Amount;
}
function KDGetOfferLevelMod() {
    return Math.round(0.25 * (KDGameData.OfferCount || 0));
}
let KinkyDungeonMaxDialogueTriggerDist = 5.9;
let KDDialogueTriggers = {
    "WeaponStop": {
        dialogue: "WeaponFound",
        allowedPrisonStates: ["parole"],
        excludeTags: ["zombie", "skeleton"],
        playRequired: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        prerequisite: (enemy, dist, AIData) => {
            return (KinkyDungeonPlayerDamage
                && !KinkyDungeonPlayerDamage.unarmed
                && KinkyDungeonPlayerDamage.name
                && dist < 3.9
                && KDHostile(enemy)
                && KDRandom() < 0.25
                && !KinkyDungeonFlags.has("demand"));
        },
        weight: (enemy, dist) => {
            return KDStrictPersonalities.includes(enemy.personality) ? 10 : 1;
        },
    },
    "OfferDress": {
        dialogue: "OfferDress",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        requireTagsSingle: ["dressRestraints", "bindingDress"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["bindingDress"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.8 * Math.max(Math.abs(KinkyDungeonGoddessRep.Latex) / 100, Math.abs(KinkyDungeonGoddessRep.Conjure) / 100);
        },
    },
    "OfferKigu": {
        dialogue: "OfferKigu",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        requireTagsSingle: ["kiguRestraints"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["kiguRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.8 * Math.max(Math.abs(KinkyDungeonGoddessRep.Latex) / 100, Math.abs(KinkyDungeonGoddessRep.Conjure) / 100);
        },
    },
    "OfferArmor": {
        dialogue: "OfferArmor",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        requireTagsSingle: ["melee"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.1, ["shackleGag"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Metal) / 100, Math.abs(KinkyDungeonGoddessRep.Illusion) / 100);
        },
    },
    "OfferChain": {
        dialogue: "OfferChain",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        requireTagsSingle: ["chainRestraints", "witch"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["chainRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Metal) / 100, Math.abs(KinkyDungeonGoddessRep.Conjure) / 100);
        },
    },
    "OfferVine": {
        dialogue: "OfferVine",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom"],
        requireTagsSingle: ["vineRestraints"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["vineRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Rope) / 100, Math.abs(KinkyDungeonGoddessRep.Will) / 100);
        },
    },
    "OfferObsidian": {
        dialogue: "OfferObsidian",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom", "Sub"],
        requireTagsSingle: ["obsidianRestraints"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["obsidianRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Metal) / 100, Math.abs(KinkyDungeonGoddessRep.Elements) / 100);
        },
    },
    "OfferMaidRestraint": {
        dialogue: "OfferMaidRestraint",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        requireTagsSingle: ["maidRestraints"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["maidRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Latex) / 100, Math.abs(KinkyDungeonGoddessRep.Illusion) / 100);
        },
    },
    "OfferDragon": {
        dialogue: "OfferDragon",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom"],
        requireTagsSingle: ["dragonRestraints"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["dragonRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.abs(KinkyDungeonGoddessRep.Leather) / 100;
        },
    },
    "OfferComfy": {
        dialogue: "OfferComfy",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        requireTagsSingle: ["submissive"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["comfyRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Conjure) / 100, Math.abs(KinkyDungeonGoddessRep.Illusion) / 100);
        },
    },
    "OfferShackles": {
        dialogue: "OfferShackles",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom"],
        requireTagsSingle: ["shackleRestraints", "steelCuffs", "handcuffer"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["shackleRestraints", "steelCuffs"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Metal) / 100, Math.abs(KinkyDungeonGoddessRep.Prisoner) / 100);
        },
    },
    "OfferKitty": {
        dialogue: "OfferKitty",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom", "Sub"],
        requireTagsSingle: ["kittyRestraints"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["kittyRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Leather) / 100, Math.abs(KinkyDungeonGoddessRep.Will) / 100);
        },
    },
    "OfferMithrilRope": {
        dialogue: "OfferMithrilRope",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom", "Sub"],
        requireTagsSingle: ["mithrilRope", "mithrilRopeHogtie"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["mithrilRope", "mithrilRopeHogtie"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Rope) / 100, Math.abs(KinkyDungeonGoddessRep.Will) / 100);
        },
    },
    "OfferMithril": {
        dialogue: "OfferMithril",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom", "Sub"],
        requireTagsSingle: ["mithrilRestraints"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["mithrilRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Metal) / 100, Math.abs(KinkyDungeonGoddessRep.Ghost) / 100);
        },
    },
    "OfferWolfRestraint": {
        dialogue: "OfferWolfRestraint",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom"],
        requireTagsSingle: ["trainer"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["wolfRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Metal) / 100, Math.abs(KinkyDungeonGoddessRep.Will) / 100);
        },
    },
    "OfferSlime": {
        dialogue: "OfferSlime",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom"],
        requireTags: ["alchemist", "human"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["slimeRestraintsRandom"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Latex) / 100, Math.abs(KinkyDungeonGoddessRep.Will) / 100);
        },
    },
    "OfferScarf": {
        dialogue: "OfferScarf",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom", "Sub"],
        requireTagsSingle: ["scarfRestraints", "ropeAuxiliary"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["scarfRestraints"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.abs(KinkyDungeonGoddessRep.Rope) / 100;
        },
    },
    "OfferAutoTape": {
        dialogue: "OfferAutoTape",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Robot"],
        requireTags: ["robot", "autoTape"],
        excludeTags: ["zombie", "skeleton"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["autoTape"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.abs(KinkyDungeonGoddessRep.Metal + 50) / 100;
        },
    },
    "OfferHiTechCables": {
        dialogue: "OfferHiTechCables",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Robot"],
        requireTags: ["robot"],
        requireTagsSingle: ["hitechCables", "cableGag"],
        excludeTags: ["zombie", "skeleton"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["hitechCables", "cableGag"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.abs(KinkyDungeonGoddessRep.Metal + 50) / 100;
        },
    },
    "OfferIce": {
        dialogue: "OfferIce",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom"],
        requireTagsSingle: ["iceRestraints", "ice", "apprentice", "witch", "water"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["iceRestraints"]));
        },
        weight: (enemy, dist) => {
            return 0.5 + 0.1 * Math.max(Math.abs(KinkyDungeonGoddessRep.Elements) / 100, Math.abs(KinkyDungeonGoddessRep.Ghost) / 100);
        },
    },
    "OfferLatex": {
        dialogue: "OfferLatex",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        requireTagsSingle: ["latexRestraints", "latexRestraintsHeavy"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.25, ["latexRestraints", "latexRestraintsHeavy"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.max(Math.abs(KinkyDungeonGoddessRep.Latex) / 100, Math.abs(KinkyDungeonGoddessRep.Conjure) / 100);
        },
    },
    "OfferChastity": {
        dialogue: "OfferChastity",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Sub"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: true,
        prerequisite: (enemy, dist, AIData) => {
            return (dist < 1.5
                && KinkyDungeonStatsChoice.has("arousalMode")
                && !KinkyDungeonFlags.get("DangerFlag")
                && !KinkyDungeonFlags.get("BondageOffer")
                && !KinkyDungeonFlags.get("ChastityOffer")
                && !KinkyDungeonFlags.get("NoTalk")
                && KDRandom() < 0.05
                && KinkyDungeonGetRestraint({ tags: ["genericChastity"] }, MiniGameKinkyDungeonLevel * 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]) != undefined);
        },
        weight: (enemy, dist) => {
            return 1 + 0.8 * Math.max(Math.abs(KinkyDungeonGoddessRep.Metal) / 100, Math.abs(KinkyDungeonGoddessRep.Elements) / 100, Math.abs(KinkyDungeonGoddessRep.Illusion) / 100, Math.abs(KinkyDungeonGoddessRep.Ghost) / 100);
        },
    },
    "OfferRopes": {
        dialogue: "OfferRopes",
        allowedPrisonStates: ["parole", ""],
        allowedPersonalities: ["Dom"],
        requireTagsSingle: ["ropeRestraints", "ropeRestraints2", "ropeRestraintsWrist", "ropeRestraintsHogtie"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.5, ["ropeRestraints", "ropeRestraints", "ropeRestraintsWrist", "ropeRestraintsHogtie"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.4 * Math.abs(KinkyDungeonGoddessRep.Rope + 50) / 100;
        },
    },
    "OfferLeather": {
        dialogue: "OfferLeather",
        allowedPrisonStates: ["parole", ""],
        requireTagsSingle: ["leatherRestraints", "leatherRestraintsHeavy"],
        excludeTags: ["zombie", "skeleton", "robot"],
        playRequired: true,
        nonHostile: true,
        noCombat: true,
        noAlly: true,
        blockDuringPlaytime: false,
        onlyDuringPlay: true,
        allowPlayExceptionSub: true,
        prerequisite: (enemy, dist, AIData) => {
            return (KDDefaultPrereqs(enemy, AIData, dist, 1.5, 0.5, ["leatherRestraintsHeavy"]));
        },
        weight: (enemy, dist) => {
            return 1 + 0.5 * Math.abs(KinkyDungeonGoddessRep.Leather + 50) / 100;
        },
    },
    "PotionSell": KDShopTrigger("PotionSell"),
    "ElfCrystalSell": KDShopTrigger("ElfCrystalSell"),
    "NinjaSell": KDShopTrigger("NinjaSell"),
    "ScrollSell": KDShopTrigger("ScrollSell"),
    "GhostSell": KDShopTrigger("GhostSell"),
    "WolfgirlSell": KDShopTrigger("WolfgirlSell"),
    "Fuuka": KDBossTrigger("Fuuka", ["Fuuka1", "Fuuka2"]),
    "FuukaLose": KDBossLose("FuukaLose", ["Fuuka1", "Fuuka2"], ["mikoRestraints"]),
    "DollmakerLose1": KDBossLose("DollmakerLose", ["DollmakerBoss1"], ["controlharness", "dollmakerrestraints", "leashing"]),
    "DollmakerLose2": KDBossLose("DollmakerLose", ["DollmakerBoss2", "DollmakerBoss3"], ["controlharness", "cyberdollrestraints", "dollmakerrestraints"]),
    "Dollmaker": KDBossTrigger("Dollmaker", ["DollmakerBoss1", "DollmakerBoss2", "DollmakerBoss3"]),
};
function KDDefaultPrereqs(enemy, AIData, dist, maxdist, chance, restraintTags) {
    return dist < maxdist
        && !AIData.domMe
        && !KDEnemyHasFlag(enemy, "playstart")
        && !KinkyDungeonFlags.get("DangerFlag")
        && !KinkyDungeonFlags.get("BondageOffer")
        && !KinkyDungeonFlags.get("NoTalk")
        && (KinkyDungeonStatsChoice.get("Undeniable") || KDRandom() < chance)
        && (!restraintTags || KinkyDungeonGetRestraint({ tags: restraintTags }, MiniGameKinkyDungeonLevel * 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]) != undefined)
        && (KinkyDungeonStatsChoice.get("Undeniable") || !KDIsBrat(enemy));
}
function KDShopTrigger(name) {
    return {
        dialogue: name,
        allowedPrisonStates: ["parole", ""],
        nonHostile: true,
        noCombat: true,
        excludeTags: ["noshop"],
        blockDuringPlaytime: true,
        prerequisite: (enemy, dist, AIData) => {
            return (dist < 1.5
                && !KinkyDungeonFlags.get("NoTalk")
                && !(KDGameData.SleepTurns > 0)
                && KDEnemyHasFlag(enemy, name)
                && !KDEnemyHasFlag(enemy, "NoShop"));
        },
        weight: (enemy, dist) => {
            return 100;
        },
    };
}
function KDRecruitTrigger(name, dialogue) {
    if (dialogue)
        return {
            dialogue: name,
            allowedPrisonStates: ["parole", ""],
            requireTags: dialogue.tags,
            requireTagsSingle: dialogue.singletag,
            excludeTags: dialogue.excludeTags,
            playRequired: true,
            nonHostile: true,
            noCombat: true,
            blockDuringPlaytime: true,
            prerequisite: (enemy, dist, AIData) => {
                return (dist < 1.5
                    && !KinkyDungeonFlags.get("Recruited")
                    && !KinkyDungeonFlags.get("DangerFlag")
                    && !KinkyDungeonFlags.get(name)
                    && !KinkyDungeonFlags.get("NoTalk")
                    && KinkyDungeonCurrentDress != dialogue.outfit
                    && !enemy.faction
                    && !enemy.allied
                    && KDFactionRelation("Player", KDGetFactionOriginal(enemy)) > -0.1
                    && KDRandom() < dialogue.chance);
            },
            weight: (enemy, dist) => {
                return 10;
            },
        };
    return null;
}
function KDBossTrigger(name, enemyName) {
    return {
        dialogue: name,
        nonHostile: true,
        prerequisite: (enemy, dist, AIData) => {
            return (dist < 2.5
                && !KinkyDungeonFlags.get("NoTalk")
                && !(KDGameData.SleepTurns > 0)
                && enemyName.includes(enemy.Enemy.name)
                && !KinkyDungeonFlags.has("BossUnlocked")
                && !KinkyDungeonFlags.has("BossDialogue" + name));
        },
        weight: (enemy, dist) => {
            return 100;
        },
    };
}
function KDBossLose(name, enemyName, tags) {
    return {
        dialogue: name,
        prerequisite: (enemy, dist, AIData) => {
            return (dist < 1.5
                && !KinkyDungeonFlags.get("NoTalk")
                && !(KDGameData.SleepTurns > 0)
                && enemyName.includes(enemy.Enemy.name)
                && !KinkyDungeonFlags.has("BossUnlocked")
                && !KinkyDungeonHasWill(0.1)
                && (!tags || !KinkyDungeonGetRestraint({ tags: tags }, MiniGameKinkyDungeonLevel * 2, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint])));
        },
        weight: (enemy, dist) => {
            return 100;
        },
    };
}
function KinkyDungeonGetShopForEnemy(enemy, guaranteed) {
    if (enemy.Enemy.tags.noshop)
        return "";
    let shoplist = [];
    for (let s of Object.values(KDShops)) {
        let end = false;
        if (s.tags) {
            for (let t of s.tags) {
                if (!enemy.Enemy.tags[t]) {
                    end = true;
                    break;
                }
            }
        }
        let hasTag = !s.singletag;
        if (!end && s.singletag) {
            for (let t of s.singletag) {
                if (enemy.Enemy.tags[t]) {
                    hasTag = true;
                    break;
                }
            }
        }
        if (!hasTag)
            end = true;
        if (!end && (guaranteed || !s.chance || KDRandom() < s.chance))
            shoplist.push(s.name);
    }
    if (shoplist.length > 0)
        return shoplist[Math.floor(KDRandom() * shoplist.length)];
    return "";
}
let KDDialogueParams = {
    ShopkeeperFee: 900,
    ShopkeeperFeePerLevel: 100,
    ShopkeeperFeePunishThresh: 2500,
};
let KDResertNGTags = [
    "BossDialogueFuuka"
];
let KDShops = {};
let KDRecruitDialog = {};
let KDAllyDialog = {};
let KDSleepBedPercentage = 0.5;
let KDDialogue = {
    "GhostInfo": {
        response: "Default",
        options: {
            "Continue": {
                clickFunction: (gagged, player) => {
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                    return false;
                },
                playertext: "Default", exitDialogue: true,
            },
        },
    },
    "Tutorial1": {
        response: "Default",
        options: {
            "Continue": {
                clickFunction: (gagged, player) => {
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                    let zombie = DialogueCreateEnemy(KinkyDungeonStartPosition.x + 7, 3, "FastZombie");
                    zombie.AI = "guard";
                    zombie.gxx = KinkyDungeonStartPosition.x + 8;
                    zombie.gyy = KinkyDungeonGridHeight - 2;
                    return false;
                },
                playertext: "GhostInfo_Continue", exitDialogue: true,
            },
        },
    },
    "Tutorial2_mp3": {
        response: "Default",
        options: {
            "Continue": {
                clickFunction: (gagged, player) => {
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                    DialogueCreateEnemy(KinkyDungeonStartPosition.x + 22, 3, "FastZombie");
                    return false;
                },
                playertext: "GhostInfo_Continue", exitDialogue: true,
            },
        },
    },
    "Tutorial2_dp2": {
        response: "Default",
        options: {
            "Continue": {
                clickFunction: (gagged, player) => {
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                    DialogueCreateEnemy(KinkyDungeonStartPosition.x + 32, 4, "FastZombie");
                    return false;
                },
                playertext: "GhostInfo_Continue", exitDialogue: true,
            },
        },
    },
    "WeaponFound": {
        response: "WeaponFound",
        personalities: ["Robot"],
        options: {
            "Accept": { gag: true, playertext: "WeaponFoundAccept", response: "GoodGirl", personalities: ["Dom", "Sub", "Robot"],
                clickFunction: (gagged, player) => {
                    KinkyDungeonSendTextMessage(10, TextGet("KDWeaponConfiscated"), "#ff0000", 2);
                    let weapon = KinkyDungeonPlayerDamage.name;
                    if (weapon && weapon != "Unarmed") {
                        KinkyDungeonChangeRep("Ghost", 3);
                        let item = KinkyDungeonInventoryGetWeapon(weapon);
                        KDSetWeapon(null);
                        KinkyDungeonAddLostItems([item], false);
                        KinkyDungeonInventoryRemove(item);
                        KinkyDungeonSetFlag("demand", 4);
                    }
                    return false;
                },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } } },
            "Bluff": { playertext: "", response: "",
                prerequisiteFunction: (gagged, player) => { return false; },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } } },
            "Deny": { gag: true, playertext: "WeaponFoundDeny", response: "Punishment", personalities: ["Dom", "Sub", "Robot"],
                clickFunction: (gagged, player) => {
                    KinkyDungeonStartChase(undefined, "Refusal");
                    KDAggroSpeaker();
                    return false;
                },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } } },
            "Illusion": { gagDisabled: true, playertext: "WeaponFoundIllusion", response: "Disbelief", personalities: ["Dom", "Sub", "Robot"],
                prerequisiteFunction: (gagged, player) => { return KinkyDungeonGoddessRep.Illusion >= 51; },
                clickFunction: (gagged, player) => {
                    if (KDGameData.CurrentDialogMsgSpeaker == "MaidforceHead") {
                        KDGameData.CurrentDialogStage = "Deny";
                        KDGameData.CurrentDialogMsg = "HeadMaidExcuseMe";
                        KinkyDungeonStartChase(undefined, "Refusal");
                        KDAggroSpeaker();
                    }
                    else {
                        let diff = KDPersonalitySpread(40, 60, 80);
                        if (KDBasicCheck(["Illusion", "Ghost"], ["Prisoner"]) > diff) {
                            KDGameData.CurrentDialogStage = "Bluff";
                            KDGameData.CurrentDialogMsg = "Bluffed";
                            KinkyDungeonChangeRep("Ghost", -2);
                        }
                        KDDialogueApplyPersonality(["Dom", "Sub", "Robot"]);
                    }
                    return false;
                },
                options: { "Back": { playertext: "Pause", leadsToStage: "" } } },
            "Conjure": { gagDisabled: true, playertext: "WeaponFoundConjure", response: "Disbelief", personalities: ["Dom", "Sub", "Robot"],
                prerequisiteFunction: (gagged, player) => { return KinkyDungeonGoddessRep.Conjure >= 51; },
                clickFunction: (gagged, player) => {
                    let diff = KDPersonalitySpread(40, 60, 80);
                    if (KDBasicCheck(["Conjure", "Ghost"], ["Prisoner"]) > diff) {
                        KDGameData.CurrentDialogStage = "Bluff";
                        KDGameData.CurrentDialogMsg = "Bluffed";
                        KinkyDungeonChangeRep("Ghost", -2);
                    }
                    KDDialogueApplyPersonality(["Dom", "Sub", "Robot"]);
                    return false;
                },
                options: { "Back": { playertext: "Pause", leadsToStage: "" } } },
            "Elements": { gagDisabled: true, playertext: "WeaponFoundElements", response: "Disbelief", personalities: ["Dom", "Sub", "Robot"],
                prerequisiteFunction: (gagged, player) => { return KinkyDungeonGoddessRep.Elements >= 51; },
                clickFunction: (gagged, player) => {
                    let diff = KDPersonalitySpread(40, 60, 80);
                    if (KDBasicCheck(["Elements", "Ghost"], ["Prisoner"]) > diff) {
                        KDGameData.CurrentDialogStage = "Bluff";
                        KDGameData.CurrentDialogMsg = "Bluffed";
                        KinkyDungeonChangeRep("Ghost", -2);
                    }
                    KDDialogueApplyPersonality(["Dom", "Sub", "Robot"]);
                    return false;
                },
                options: { "Back": { playertext: "Pause", leadsToStage: "" } } },
            "Rope": { gagDisabled: true, playertext: "WeaponFoundRope", response: "Disbelief", personalities: ["Dom", "Sub", "Robot"],
                prerequisiteFunction: (gagged, player) => { return KinkyDungeonGoddessRep.Rope >= 51; },
                clickFunction: (gagged, player) => {
                    let diff = KDPersonalitySpread(40, 60, 80);
                    if (KDBasicCheck(["Rope", "Ghost"], ["Prisoner"]) > diff) {
                        KDGameData.CurrentDialogStage = "Bluff";
                        KDGameData.CurrentDialogMsg = "Bluffed";
                        KinkyDungeonChangeRep("Ghost", -2);
                    }
                    KDDialogueApplyPersonality(["Dom", "Sub", "Robot"]);
                    return false;
                },
                options: { "Back": { playertext: "Pause", leadsToStage: "" } } },
            "Leather": { gagDisabled: true, playertext: "WeaponFoundLeather", response: "Disbelief", personalities: ["Dom", "Sub", "Robot"],
                prerequisiteFunction: (gagged, player) => { return KinkyDungeonGoddessRep.Leather >= 51; },
                clickFunction: (gagged, player) => {
                    let diff = KDPersonalitySpread(40, 60, 80);
                    if (KDBasicCheck(["Leather", "Ghost"], ["Prisoner"]) > diff) {
                        KDGameData.CurrentDialogStage = "Bluff";
                        KDGameData.CurrentDialogMsg = "Bluffed";
                        KinkyDungeonChangeRep("Ghost", -2);
                    }
                    KDDialogueApplyPersonality(["Dom", "Sub", "Robot"]);
                    return false;
                },
                options: { "Back": { playertext: "Pause", leadsToStage: "" } } },
        }
    },
    "PrisonIntro": {
        response: "Default",
        options: {
            "NewLife": { playertext: "Default", response: "Default",
                options: {
                    "Pout": { playertext: "Default", response: "Default", options: { "Continue": { playertext: "Continue", leadsToStage: "Rules" } } },
                    "Brat": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonChangeRep("Ghost", -10);
                            KinkyDungeonChangeRep("Prisoner", 10);
                            return false;
                        },
                        options: { "Continue": { playertext: "Continue", leadsToStage: "Rules" } } },
                    "Sub": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonChangeRep("Ghost", 10);
                            return false;
                        },
                        options: { "Continue": { playertext: "Continue", leadsToStage: "Rules" } } },
                }
            },
            "Rules": { playertext: "Default", response: "Default",
                options: {
                    "Pout": { playertext: "Default", response: "Default", options: { "Continue": { playertext: "Continue", exitDialogue: true } } },
                    "Brat": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonChangeRep("Ghost", -10);
                            KinkyDungeonChangeRep("Prisoner", 10);
                            return false;
                        },
                        options: { "Continue": { playertext: "Continue", exitDialogue: true } } },
                    "Sub": { gag: true, playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonChangeRep("Ghost", 10);
                            return false;
                        },
                        options: { "Continue": { playertext: "Continue", exitDialogue: true } } },
                }
            },
        }
    },
    "PrisonRepeat": {
        response: "Default",
        options: {
            "Smile": { playertext: "Default", response: "Default",
                prerequisiteFunction: (gagged, player) => { return !(KinkyDungeonGetRestraintItem("ItemVulva")); },
                clickFunction: (gagged, player) => {
                    KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapBelt"), 0, true);
                    KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapPlug2"), 0, true);
                    KinkyDungeonChangeRep("Ghost", 3);
                    return false;
                },
                options: {
                    "Correct": { playertext: "Default", response: "Default", gagDisabled: true,
                        prerequisiteFunction: (gagged, player) => { return !(KinkyDungeonGetRestraintItem("ItemMouth") || KinkyDungeonGetRestraintItem("ItemMouth2") || KinkyDungeonGetRestraintItem("ItemMouth3")); },
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("TrapGag"), 0, true);
                            KinkyDungeonChangeRep("Ghost", -1);
                            return false;
                        },
                        options: {
                            "Leave": { playertext: "Leave", exitDialogue: true }
                        },
                    },
                    "Leave": { playertext: "Leave", exitDialogue: true }
                },
            },
            "Smile2": { playertext: "Default", response: "Default",
                prerequisiteFunction: (gagged, player) => { return KinkyDungeonGetRestraintItem("ItemVulva") != undefined; },
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeRep("Ghost", 5);
                    return false;
                },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } },
            },
            "Struggle": { playertext: "Default", response: "Default",
                prerequisiteFunction: (gagged, player) => { return KinkyDungeonGetRestraintItem("ItemArms") != undefined; },
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeRep("Prisoner", 3);
                    return false;
                },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } },
            },
            "Pout": { playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeRep("Ghost", -3);
                    return false;
                },
                options: { "Leave": { playertext: "Leave", exitDialogue: true } },
            },
            "Bribe": { playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    return KinkyDungeonGoddessRep.Prisoner >= -40 && KinkyDungeonGold >= 40;
                },
                options: {
                    "Accept": { playertext: "Default", response: "Default",
                        clickFunction: (gagged, player) => {
                            if (KinkyDungeonGoddessRep.Prisoner >= 49.5) {
                                KDGameData.CurrentDialogMsg = "PrisonRepeatBribeFail";
                                return false;
                            }
                            KinkyDungeonChangeRep("Prisoner", -Math.max(10, Math.min(100, KinkyDungeonGold * 0.25)));
                            KinkyDungeonGold = 0;
                            KinkyDungeonSetFlag("LeashToPrison", 0);
                            return false;
                        },
                        options: { "Leave": { playertext: "Leave", exitDialogue: true } },
                    },
                    "Leave": { playertext: "Leave", exitDialogue: true }
                },
            },
        }
    },
    "OfferDress": KDYesNoBasic("OfferDress", ["Rope"], ["Ghost"], ["bindingDress"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferArmor": KDYesNoBasic("OfferArmor", ["Metal"], ["Ghost"], ["shackleGag"], [60, -10, 75, -20], [-35, -10, 25, -5]),
    "OfferChain": KDYesNoBasic("OfferChain", ["Metal"], ["Ghost"], ["chainRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15], 2, 3),
    "OfferVine": KDYesNoBasic("OfferVine", ["Will"], ["Ghost"], ["vineRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15], 2, 3),
    "OfferObsidian": KDYesNoBasic("OfferObsidian", ["Elements"], ["Ghost"], ["obsidianRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15], 1, 2),
    "OfferMaidRestraint": KDYesNoBasic("OfferMaidRestraint", ["Illusion"], ["Ghost"], ["maidRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15], 1, 2),
    "OfferDragon": KDYesNoBasic("OfferDragon", ["Leather"], ["Ghost"], ["dragonRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15], 1, 2),
    "OfferComfy": KDYesNoBasic("OfferComfy", ["Conjure"], ["Ghost"], ["comfyRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferShackles": KDYesNoBasic("OfferShackles", ["Metal"], ["Ghost"], ["shackleRestraints", "steelCuffs"], [55, 0, 75, 0], [-25, 0, 40, 15], 1, 3),
    "OfferKitty": KDYesNoBasic("OfferKitty", ["Will"], ["Ghost"], ["kittyRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferMithril": KDYesNoBasic("OfferMithril", ["Metal"], ["Ghost"], ["mithrilRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferMithrilRope": KDYesNoBasic("OfferMithrilRope", ["Rope"], ["Ghost"], ["mithrilRope", "mithrilRopeHogtie"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferWolfRestraint": KDYesNoBasic("OfferWolfRestraint", ["Metal"], ["Ghost"], ["wolfRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferSlime": KDYesNoBasic("OfferSlime", ["Latex"], ["Ghost"], ["slimeRestraintsRandom"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferScarf": KDYesNoBasic("OfferScarf", ["Rope"], ["Ghost"], ["scarfRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferAutoTape": KDYesNoBasic("OfferAutoTape", ["Metal"], ["Ghost"], ["autoTape"], [55, 0, 75, 0], [-200, -200, -200, -200], 2, 3),
    "OfferHiTechCables": KDYesNoBasic("OfferHiTechCables", ["Metal"], ["Ghost"], ["hitechCables", "cableGag"], [55, 0, 75, 0], [-200, -200, -200, -200], 2, 3),
    "OfferIce": KDYesNoBasic("OfferIce", ["Elements"], ["Ghost"], ["iceRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15], 2, 3),
    "OfferLatex": KDYesNoBasic("OfferLatex", ["Latex"], ["Ghost"], ["latexRestraints", "latexRestraintsHeavy"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferKigu": KDYesNoBasic("OfferKigu", ["Conjure"], ["Ghost"], ["kiguRestraints"], [55, 0, 75, 0], [-25, 0, 40, 15]),
    "OfferLeather": KDYesNoBasic("OfferLeather", ["Leather"], ["Ghost"], ["armbinderSpell", "straitjacketSpell", "legbinderSpell", "harnessSpell", "gagSpell", "blindfoldSpell", "leathercuffsSpell"], [55, 0, 75, 0], [-25, 0, 40, 15], 1, 3),
    "OfferRopes": KDYesNoBasic("OfferRopes", ["Rope"], ["Ghost"], ["ropeRestraints", "ropeRestraints2", "ropeRestraintsHogtie", "ropeRestraintsWrist", "ropeAuxiliary"], [55, 0, 75, 0], [-25, 0, 40, 15], 3, 5, "Red"),
    "OfferChastity": KDYesNoBasic("OfferChastity", ["Metal"], ["Ghost"], ["genericChastity"], [55, 0, 75, 0], [-25, 0, 40, 15], 1, 1, "Gold", true, [{ name: "ChastityOffer", duration: 300 }]),
    "OfferWolfgirl": KDRecruitDialogue("OfferWolfgirl", "Nevermere", "Wolfgirl", "Metal", ["wolfGear"], 5, ["wolfGear", "wolfRestraints"], 8, ["wolfgirl", "trainer"], undefined, undefined, 0.5),
    "OfferMaid": KDRecruitDialogue("OfferMaid", "Maidforce", "Maid", "Illusion", ["maidVibeRestraints"], 5, ["maidVibeRestraints", "maidRestraints"], 13, ["maid"], undefined, ["submissive"], 0.5),
    "OfferBast": KDRecruitDialogue("OfferBast", "Bast", "Bast", "Will", ["kittyCollar"], 5, ["kittyRestraints"], 13, ["mummy"], undefined, ["submissive"], 0.5),
    "OfferDressmaker": KDRecruitDialogue("OfferDressmaker", "Dressmaker", "Bikini", "Rope", ["dressUniform"], 5, ["dressUniform", "dressRestraints"], 13, ["dressmaker"], undefined, ["submissive"], 0.5),
    "OfferBountyhunter": KDRecruitDialogue("OfferBountyhunter", "Bountyhunter", "Bountyhunter", "Illusion", [], 5, ["ropeRestraints", "ropeRestraints2", "ropeRestraintsHogtie", "ropeRestraintsWrist", "ropeAuxiliary"], 13, ["bountyhunter"], undefined, ["submissive"], 0.5),
    "OfferAncientRobot": KDRecruitDialogue("OfferAncientRobot", "AncientRobot", "Wolfgirl", "Metal", ["roboPrisoner"], 5, ["roboPrisoner", "roboAngry", "hitechCables"], 13, ["robot"], undefined, ["submissive"], 0.5),
    "OfferElf": KDRecruitDialogue("OfferElf", "Elf", "Elven", "Will", ["mithrilRestraints"], 5, ["mithrilRestraints", "mithrilRope"], 13, ["elf"], undefined, ["submissive"], 0.5),
    "OfferAlchemist": KDRecruitDialogue("OfferAlchemist", "Alchemist", "BlueSuit", "Latex", ["latexUniform"], 5, ["latexUniform", "latexRestraints"], 13, ["alchemist"], undefined, ["submissive"], 0.5),
    "OfferElemental": KDRecruitDialogue("OfferElemental", "Elemental", "Obsidian", "Elements", ["obsidianCuffs"], 5, ["obsidianRestraints"], 13, ["elemental"], undefined, ["submissive"], 0.5),
    "OfferDragonheart": KDRecruitDialogue("OfferDragonheart", "Dragon", "Default", "Leather", [], 5, ["dragonRestraints"], 13, ["dragon"], undefined, ["submissive"], 0.5),
    "OfferApprentice": KDRecruitDialogue("OfferApprentice", "Apprentice", "Default", "Conjure", [], 5, ["ropeRestraints", "ropeRestraints2", "ropeRestraintsHogtie", "ropeRestraintsWrist", "ropeAuxiliary"], 13, ["apprentice"], undefined, ["submissive", "wizard"], 0.5),
    "OfferBandit": KDRecruitDialogue("OfferBandit", "Bandit", "Default", "Leather", [], 5, ["leatherRestraints", "leatherRestraintsHeavy"], 13, ["bandit"], undefined, ["submissive"], 0.5),
    "AngelHelp": {
        response: "Default",
        inventory: true,
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("AngelHelp", 55);
            return false;
        },
        options: {
            "Knife": {
                playertext: "Default", response: "AngelHelpKnife",
                prerequisiteFunction: (gagged, player) => {
                    return !KinkyDungeonFlags.get("AngelHelped") && !KinkyDungeonInventoryGet("Knife");
                },
                clickFunction: (gagged, player) => {
                    KinkyDungeonInventoryAddWeapon("Knife");
                    KinkyDungeonSetFlag("AngelHelped", 5);
                    return false;
                },
                leadsToStage: "", dontTouchText: true,
            },
            "Pick": {
                playertext: "Default", response: "AngelHelpPick",
                prerequisiteFunction: (gagged, player) => {
                    return !KinkyDungeonFlags.get("AngelHelped");
                },
                clickFunction: (gagged, player) => {
                    KinkyDungeonLockpicks += 3;
                    KinkyDungeonSetFlag("AngelHelped", 5);
                    return false;
                },
                leadsToStage: "", dontTouchText: true,
            },
            "BlueKey": {
                playertext: "Default", response: "AngelHelpBlueKey",
                prerequisiteFunction: (gagged, player) => {
                    return !KinkyDungeonFlags.get("AngelHelped");
                },
                clickFunction: (gagged, player) => {
                    KinkyDungeonBlueKeys += 1;
                    KinkyDungeonSetFlag("AngelHelped", 5);
                    return false;
                },
                leadsToStage: "", dontTouchText: true,
            },
            "Leave": { playertext: "Leave", exitDialogue: true },
        }
    },
    "DressmakerQuest": {
        response: "Default",
        inventory: true,
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Help": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDAddQuest("DressmakerQuest");
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Complete": {
                playertext: "Default", response: "Default",
                gag: true,
                clickFunction: (gagged, player) => {
                    let items = KinkyDungeonGetRestraintsWithShrine("BindingDress", true, true);
                    let item = items.length > 0 ? items.reduce((prev, current) => (KDRestraint(prev).power * KinkyDungeonGetLockMult(prev.lock) > KDRestraint(current).power * KinkyDungeonGetLockMult(current.lock)) ? prev : current) : null;
                    let power = item ? KDRestraint(item).power : 5;
                    if (KDFactionRelation("Player", "Dressmaker") < 0.25)
                        KinkyDungeonChangeFactionRep("Dressmaker", 0.002 * power);
                    else
                        KinkyDungeonChangeFactionRep("Dressmaker", 0.0007 * power);
                    KDRemoveQuest("DressmakerQuest");
                    KDSpliceIndex(KinkyDungeonEntities.indexOf(KDDialogueEnemy()), 1);
                    return false;
                },
                prerequisiteFunction: (gagged, player) => {
                    return KinkyDungeonPlayerTags.has("BindingDress");
                },
                options: {
                    "Question": {
                        playertext: "Default", response: "Default",
                        gag: true,
                        clickFunction: (gagged, player) => {
                            if (KinkyDungeonStatsChoice.has("Dominant")) {
                                KinkyDungeonRemoveRestraintsWithShrine("BindingDress");
                                KDGameData.CurrentDialogMsg = "DressmakerQuestComplete_QuestionSuccess";
                            }
                            return false;
                        },
                        options: {
                            "Leave": {
                                playertext: "Leave", response: "Default",
                                exitDialogue: true,
                            },
                        }
                    },
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "ApprenticeQuest": {
        response: "Default",
        inventory: true,
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Help": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDAddQuest("ApprenticeQuest");
                    return false;
                },
                prerequisiteFunction: (gagged, player) => {
                    return !KDHasQuest("ApprenticeQuest");
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "CompleteLegs": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDRemoveQuest("ApprenticeQuest");
                    KDSpliceIndex(KinkyDungeonEntities.indexOf(KDDialogueEnemy()), 1);
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollLegs, -1);
                    if (KDFactionRelation("Player", "Apprentice") < 0.25)
                        KinkyDungeonChangeFactionRep("Apprentice", 0.015);
                    else
                        KinkyDungeonChangeFactionRep("Apprentice", 0.005);
                    return false;
                },
                prerequisiteFunction: (gagged, player) => {
                    return KDHasQuest("ApprenticeQuest") && KinkyDungeonInventoryGet("ScrollLegs") != undefined;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "CompleteArms": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDRemoveQuest("ApprenticeQuest");
                    KDSpliceIndex(KinkyDungeonEntities.indexOf(KDDialogueEnemy()), 1);
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollArms, -1);
                    if (KDFactionRelation("Player", "Apprentice") < 0.25)
                        KinkyDungeonChangeFactionRep("Apprentice", 0.015);
                    else
                        KinkyDungeonChangeFactionRep("Apprentice", 0.005);
                    return false;
                },
                prerequisiteFunction: (gagged, player) => {
                    return KDHasQuest("ApprenticeQuest") && KinkyDungeonInventoryGet("ScrollArms") != undefined;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "CompleteVerbal": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDRemoveQuest("ApprenticeQuest");
                    KDSpliceIndex(KinkyDungeonEntities.indexOf(KDDialogueEnemy()), 1);
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollVerbal, -1);
                    if (KDFactionRelation("Player", "Apprentice") < 0.25)
                        KinkyDungeonChangeFactionRep("Apprentice", 0.015);
                    else
                        KinkyDungeonChangeFactionRep("Apprentice", 0.005);
                    return false;
                },
                prerequisiteFunction: (gagged, player) => {
                    return KDHasQuest("ApprenticeQuest") && KinkyDungeonInventoryGet("ScrollVerbal") != undefined;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "CompletePurity": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDRemoveQuest("ApprenticeQuest");
                    KDSpliceIndex(KinkyDungeonEntities.indexOf(KDDialogueEnemy()), 1);
                    KinkyDungeonChangeConsumable(KinkyDungeonConsumables.ScrollPurity, -1);
                    if (KDFactionRelation("Player", "Apprentice") < 0.25)
                        KinkyDungeonChangeFactionRep("Apprentice", 0.015);
                    else
                        KinkyDungeonChangeFactionRep("Apprentice", 0.005);
                    return false;
                },
                prerequisiteFunction: (gagged, player) => {
                    return KDHasQuest("ApprenticeQuest") && KinkyDungeonInventoryGet("ScrollPurity") != undefined;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "DragonheartQuest": {
        response: "Default",
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Help": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDAddQuest("DragonheartQuest");
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "MaidforceQuest": {
        response: "Default",
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Help": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDAddQuest("MaidforceQuest");
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "JailerHiSec": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("LeashToPrison", -1);
            return false;
        },
        options: {
            "Submit": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonDefeat(true);
                    return true;
                },
                exitDialogue: true,
            },
            "Resist": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    if (KDDialogueEnemy() && !KDDialogueEnemy().hostile) {
                        KDDialogueEnemy().hostile = 300;
                    }
                    KinkyDungeonStartChase(undefined, "Jailbreak");
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "Bed": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("nobed", 8);
            return false;
        },
        options: {
            "Sleep": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonSetFlag("slept", -1);
                    KDGameData.SleepTurns = KinkyDungeonSleepTurnsMax;
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "TableFood": {
        response: "Default",
        clickFunction: (gagged, player) => {
            if (KinkyDungeonTargetTile) {
                let tile = KinkyDungeonTilesGet(KinkyDungeonTargetTileLocation);
                if (tile) {
                    KDGameData.CurrentDialogMsgData = {
                        AMOUNT: "" + 10 * (tile.Amount || 1),
                        ARTICLE: "a",
                        FOODNAME: TextGet(KinkyDungeonTargetTile.Food),
                        FOODMSG: TextGet("KinkyDungeonFood" + KinkyDungeonTargetTile.Food),
                    };
                }
            }
            return false;
        },
        options: {
            "Eat": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    let tile = KinkyDungeonTilesGet(KinkyDungeonTargetTileLocation);
                    if (tile && tile.Type == "Food") {
                        let gagTotal = KinkyDungeonGagTotal();
                        if (gagTotal > 0) {
                            KDGameData.CurrentDialogMsg = "TableFoodEatFail";
                        }
                        else {
                            let Willmulti = Math.max(KinkyDungeonStatWillMax / KDMaxStatStart);
                            let amount = tile.Amount ? tile.Amount : 1.0;
                            KinkyDungeonChangeWill(amount * Willmulti);
                            KinkyDungeonAdvanceTime(1);
                            tile.Food = "Plate";
                            tile.Eaten = true;
                        }
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        clickFunction: (gagged, player) => {
                            KinkyDungeonTargetTile = null;
                            KinkyDungeonTargetTileLocation = "";
                            return false;
                        },
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Leave": {
                clickFunction: (gagged, player) => {
                    KinkyDungeonTargetTile = null;
                    KinkyDungeonTargetTileLocation = "";
                    return false;
                },
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "Button": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("nobutton", 3);
            return false;
        },
        options: {
            "Press": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDCreateEffectTile(player.x, player.y, {
                        name: "WireSparks",
                        duration: 2,
                    }, 0);
                    KinkyDungeonAdvanceTime(1, true, true);
                    return false;
                },
                exitDialogue: true,
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "LeylineMap": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("nodollterm", 4);
            return false;
        },
        options: {
            "Leave": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonSpells.push(KinkyDungeonFindSpell("ManaPoolUp"));
                    KinkyDungeonUpdateStats(0);
                    return false;
                },
                exitDialogue: true,
            },
            "Cancel": {
                playertext: "Default", response: "Default",
                options: {
                    "Leave": {
                        playertext: "Default", response: "Default",
                        exitDialogue: true,
                        clickFunction: (gagged, player) => {
                            KinkyDungeonSpells.push(KinkyDungeonFindSpell("ManaPoolUp"));
                            KinkyDungeonUpdateStats(0);
                            return false;
                        },
                    },
                    "Cancel": {
                        playertext: "Default", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "DollTerminal_Step": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("nodollterm", 4);
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Enter": {
                playertext: "Default", response: "Default",
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                    "Enter": {
                        playertext: "Default", response: "Default",
                        options: {
                            "Leave": {
                                playertext: "Leave", response: "Default",
                                clickFunction: (gagged, player) => {
                                    KDEnterDollTerminal(true);
                                    return false;
                                },
                                exitDialogue: true,
                            },
                        }
                    },
                }
            },
        }
    },
    "DollTerminal_Forced": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("nodollterm", 4);
            KDGameData.CurrentDialogMsgValue = {
                Percent: Math.max(0, 0.25 * KinkyDungeonSlowLevel),
            };
            KDGameData.CurrentDialogMsgData = {
                RESISTCHANCE: "" + Math.max(0, Math.round(100 - KDGameData.CurrentDialogMsgValue.Percent * 100)),
            };
            return false;
        },
        options: {
            "Resist": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    if (KDRandom() < KDGameData.CurrentDialogMsgValue.Percent) {
                        KDGameData.CurrentDialogMsg = "DollTerminal_ForcedForced";
                        KDGameData.CurrentDialogStage = "Forced";
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Enter": {
                playertext: "Default", response: "Default",
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        clickFunction: (gagged, player) => {
                            KDEnterDollTerminal(true);
                            return false;
                        },
                        exitDialogue: true,
                    },
                }
            },
            "Forced": {
                prerequisiteFunction: (gagged, player) => { return false; },
                playertext: "Default", response: "Default",
                options: {
                    "Leave": {
                        clickFunction: (gagged, player) => {
                            KDEnterDollTerminal(false);
                            return false;
                        },
                        playertext: "DollTerminal_Forced_Submit", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "Leyline": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("noleyline", 8);
            return false;
        },
        options: {
            "Use": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeMana(0, false, 100, false, false);
                    if (KDTile() && KDTile().Leyline) {
                        KinkyDungeonMapSet(player.x, player.y, '0');
                        KDTileDelete();
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "BanditQuest": {
        response: "Default",
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Help": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDAddQuest("BanditPrisoner");
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "PrisonerRescueBountyhunter": KDPrisonerRescue("PrisonerRescueBountyhunter", "Bountyhunter", ["Nawashi", "Ninja"]),
    "PrisonerRescue": KDPrisonerRescue("PrisonerRescue", "Bandit", ["Bandit", "Bandit"]),
    "PrisonerRescueAlchemist": KDPrisonerRescue("PrisonerRescueAlchemist", "Alchemist", ["Alkahestor", "Alchemist"]),
    "PrisonerRescueNevermere": KDPrisonerRescue("PrisonerRescueNevermere", "Nevermere", ["Wolfgirl", "WolfgirlPet"]),
    "PrisonerRescueApprentice": KDPrisonerRescue("PrisonerRescueApprentice", "Apprentice", ["Apprentice2", "Apprentice"]),
    "PrisonerRescueDressmaker": KDPrisonerRescue("PrisonerRescueDressmaker", "Dressmaker", ["Librarian", "Dressmaker"]),
    "PrisonerRescueWitch": KDPrisonerRescue("PrisonerRescueWitch", "Witch", ["WitchIce", "Apprentice"]),
    "PrisonerRescueElemental": KDPrisonerRescue("PrisonerRescueElemental", "Elemental", ["ElementalAir", "ElementalFire"]),
    "PrisonerRescueDragon": KDPrisonerRescue("PrisonerRescueDragon", "Dragon", ["DragonShield", "Dragon"]),
    "PrisonerRescueMaid": KDPrisonerRescue("PrisonerRescueMaid", "Maidforce", ["MaidforceStalker", "Maidforce"]),
    "PrisonerRescueBast": KDPrisonerRescue("PrisonerRescueBast", "Bast", ["Cleric", "MeleeCleric"]),
    "PrisonerRescueElf": KDPrisonerRescue("PrisonerRescueElf", "Elf", ["Elf", "ElfRanger"]),
    "PrisonerRescueAncientRobot": KDPrisonerRescue("PrisonerRescueAncientRobot", "AncientRobot", ["CaptureBot", "Drone"]),
    "ShopkeeperRescue": {
        response: "Default",
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Accept": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KDGameData.PrisonerState = "";
                    KinkyDungeonInterruptSleep();
                    let doorTile = KDGetJailDoor(player.x, player.y);
                    let door = doorTile;
                    if (door) {
                        if (doorTile.tile) {
                            doorTile.tile.Lock = undefined;
                            KDUpdateDoorNavMap();
                        }
                        KinkyDungeonMapSet(door.x, door.y, 'd');
                    }
                    else
                        door = KinkyDungeonGetNearbyPoint(player.x, player.y, true);
                    if (!door) {
                        door = { x: player.x, y: player.y };
                    }
                    KinkyDungeonEntities = [];
                    KDGameData.RespawnQueue = [];
                    KDUpdateEnemyCache = true;
                    let e = DialogueCreateEnemy(door.x, door.y, "ShopkeeperRescue");
                    e.allied = 9999;
                    e.faction = "Player";
                    KDGameData.CurrentDialogMsgSpeaker = e.Enemy.name;
                    KinkyDungeonSetEnemyFlag(e, "RescuingPlayer", -1);
                    KDGameData.KinkyDungeonGuardSpawnTimer = 100;
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Refuse": {
                playertext: "Default", response: "Default",
                gag: true,
                clickFunction: (gagged, player) => {
                    KinkyDungeonSetFlag("refusedShopkeeperRescue", 100);
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "ShopkeeperRescueChatter": {
        response: "Default",
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Treasure": {
                playertext: "Default", response: "Default", gagDisabled: true,
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Cost": {
                playertext: "Default", response: "Default", gagDisabled: true,
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "ShopkeeperTeleport": {
        response: "Default",
        clickFunction: (gagged, player) => {
            if (!KDGameData.ShopkeeperFee)
                KDGameData.ShopkeeperFee = 0;
            KDGameData.ShopkeeperFee += KDDialogueParams.ShopkeeperFee + Math.max(0, KDDialogueParams.ShopkeeperFeePerLevel * MiniGameKinkyDungeonLevel);
            KDGameData.CurrentDialogMsgValue = {
                "RESCUECOST": KDGameData.ShopkeeperFee,
            };
            KDGameData.CurrentDialogMsgData = {
                "RESCUECOST": "" + KDGameData.ShopkeeperFee,
            };
            return false;
        },
        options: {
            "Pay": {
                playertext: "Default", response: "Default", gag: true,
                prerequisiteFunction: (gagged, player) => {
                    return KinkyDungeonGold >= KDGameData.ShopkeeperFee;
                },
                clickFunction: (gagged, player) => {
                    KinkyDungeonGold -= KDGameData.ShopkeeperFee;
                    KDGameData.ShopkeeperFee = 0;
                    KinkyDungeonRemoveRestraintsWithShrine("Rope", undefined, true, false, true);
                    KinkyDungeonRemoveRestraintsWithShrine("Leather", undefined, true, false, true);
                    KinkyDungeonRemoveRestraintsWithShrine("Metal", undefined, true, false, true);
                    KinkyDungeonRemoveRestraintsWithShrine("Latex", undefined, true, false, true);
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Tab": {
                prerequisiteFunction: (gagged, player) => {
                    return !KDGameData.CurrentDialogMsgData.Please;
                },
                playertext: "Default", response: "Default", gag: true,
                clickFunction: (gagged, player) => {
                    var _a, _b, _c, _d;
                    if (KinkyDungeonGold >= KDDialogueParams.ShopkeeperFee + Math.max(0, KDDialogueParams.ShopkeeperFeePerLevel * MiniGameKinkyDungeonLevel)) {
                        KDGameData.CurrentDialogMsg = "ShopkeeperTeleportTabNo";
                        KDGameData.CurrentDialogStage = "";
                        KDGameData.CurrentDialogMsgData.Please = "true";
                        return false;
                    }
                    else {
                        if (!KDGameData.CurrentDialogMsgData)
                            KDGameData.CurrentDialogMsgData = {};
                        KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Armor = (_a = KinkyDungeonGetRestraint({ tags: ['basicCurse', 'shopCurse'] }, 10, 'grv', true, undefined, undefined, undefined, false)) === null || _a === void 0 ? void 0 : _a.name;
                        KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Restraint = (_b = KDChooseRestraintFromListGroupPri(KDGetRestraintsEligible({ tags: ['trap', 'shopRestraint'] }, 10, 'grv', true, undefined, undefined, undefined, false), KDRestraintGroupProgressiveOrderFun)) === null || _b === void 0 ? void 0 : _b.name;
                        KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Collar = (_c = KinkyDungeonGetRestraint({ tags: ['shopCollar'] }, 10, 'grv', true, undefined, undefined, undefined, false)) === null || _c === void 0 ? void 0 : _c.name;
                        KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Catsuit = (_d = KinkyDungeonGetRestraint({ tags: ['shopCatsuit'] }, 10, 'grv', true, undefined, undefined, undefined, false)) === null || _d === void 0 ? void 0 : _d.name;
                        if (KDGameData.ShopkeeperFee < KDDialogueParams.ShopkeeperFeePunishThresh || !(KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Armor
                            || KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Restraint
                            || KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Collar
                            || KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Catsuit
                            || KinkyDungeonGold > KDGameData.ShopkeeperFee)) {
                            if (KinkyDungeonPlayerTags.get("Metal") || KinkyDungeonPlayerTags.get("Leather") || KinkyDungeonPlayerTags.get("Rope") || KinkyDungeonPlayerTags.get("Latex")) {
                                KDGameData.CurrentDialogMsg = "ShopkeeperTeleportTabYesRestrained";
                            }
                            else
                                KDGameData.CurrentDialogMsg = "ShopkeeperTeleportTabYes";
                        }
                        else {
                            KDGameData.CurrentDialogStage = "Debt";
                            KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt";
                        }
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "TabRetry": {
                prerequisiteFunction: (gagged, player) => {
                    return KDGameData.CurrentDialogMsgData.Please != undefined;
                },
                playertext: "Default", response: "Default", gag: true,
                clickFunction: (gagged, player) => {
                    var _a, _b, _c, _d;
                    if (!KDGameData.CurrentDialogMsgData)
                        KDGameData.CurrentDialogMsgData = {};
                    KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Armor = (_a = KinkyDungeonGetRestraint({ tags: ['basicCurse', 'shopCurse'] }, 10, 'grv', true, undefined, undefined, undefined, false)) === null || _a === void 0 ? void 0 : _a.name;
                    KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Restraint = (_b = KDChooseRestraintFromListGroupPri(KDGetRestraintsEligible({ tags: ['trap', 'shopRestraint'] }, 10, 'grv', true, undefined, undefined, undefined, false), KDRestraintGroupProgressiveOrderFun)) === null || _b === void 0 ? void 0 : _b.name;
                    KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Collar = (_c = KinkyDungeonGetRestraint({ tags: ['shopCollar'] }, 10, 'grv', true, undefined, undefined, undefined, false)) === null || _c === void 0 ? void 0 : _c.name;
                    KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Catsuit = (_d = KinkyDungeonGetRestraint({ tags: ['shopCatsuit'] }, 10, 'grv', true, undefined, undefined, undefined, false)) === null || _d === void 0 ? void 0 : _d.name;
                    if (KDGameData.ShopkeeperFee < KDDialogueParams.ShopkeeperFeePunishThresh || !(KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Armor
                        || KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Restraint
                        || KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Collar
                        || KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Catsuit
                        || KinkyDungeonGold > KDGameData.ShopkeeperFee)) {
                        if (KinkyDungeonPlayerTags.get("Metal") || KinkyDungeonPlayerTags.get("Leather") || KinkyDungeonPlayerTags.get("Rope") || KinkyDungeonPlayerTags.get("Latex")) {
                            KDGameData.CurrentDialogMsg = "ShopkeeperTeleportTabRetryRestrained";
                        }
                        else
                            KDGameData.CurrentDialogMsg = "ShopkeeperTeleportTabRetry";
                    }
                    else {
                        KDGameData.CurrentDialogStage = "Debt";
                        KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt";
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Debt": {
                prerequisiteFunction: (gagged, player) => {
                    return false;
                },
                playertext: "Default", response: "Default", gag: true,
                clickFunction: (gagged, player) => {
                    return false;
                },
                options: {
                    "Armor": {
                        playertext: "Default", response: "Default",
                        prerequisiteFunction: (gagged, player) => {
                            var _a;
                            return ((_a = KDGameData.CurrentDialogMsgData) === null || _a === void 0 ? void 0 : _a.RESTRAINTNAME_Armor) != undefined;
                        },
                        clickFunction: (gagged, player) => {
                            KDGameData.CurrentDialogMsgData.RESTRAINTNAME = TextGet("Restraint" + KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Armor);
                            return false;
                        },
                        options: {
                            "Yes": {
                                playertext: "ShopkeeperTeleportDebt_Yes", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    if (KDRandom() > (KDBasicArmorWeight_Cursed) / (KDBasicArmorWeight_Cursed + KDBasicArmorWeight)) {
                                        KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt_Armor_YesUncursed";
                                    }
                                    else {
                                        KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName(KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Armor), 0, true, "", true, false, false, undefined, "Shopkeeper", false, undefined, CommonRandomItemFromList("", KDCurseUnlockList.Basic));
                                        KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt_Armor_YesCursed";
                                    }
                                    return false;
                                },
                                options: {
                                    "Leave": {
                                        playertext: "Leave", response: "Default",
                                        exitDialogue: true,
                                    },
                                }
                            },
                            "No": {
                                playertext: "ShopkeeperTeleportDebt_No", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    KDGameData.CurrentDialogStage = "Debt";
                                    KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt";
                                    return true;
                                }
                            },
                        }
                    },
                    "Restraint": {
                        playertext: "Default", response: "Default",
                        prerequisiteFunction: (gagged, player) => {
                            var _a;
                            return ((_a = KDGameData.CurrentDialogMsgData) === null || _a === void 0 ? void 0 : _a.RESTRAINTNAME_Restraint) != undefined;
                        },
                        clickFunction: (gagged, player) => {
                            KDGameData.CurrentDialogMsgData.RESTRAINTNAME = TextGet("Restraint" + KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Restraint);
                            return false;
                        },
                        options: {
                            "Yes": {
                                playertext: "ShopkeeperTeleportDebt_Yes", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName(KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Restraint), 0, true, "", true, false, false, undefined, "Shopkeeper", false, undefined, CommonRandomItemFromList("", KDCurseUnlockList.Basic));
                                    return false;
                                },
                                options: {
                                    "Leave": {
                                        playertext: "Leave", response: "Default",
                                        exitDialogue: true,
                                    },
                                }
                            },
                            "No": {
                                playertext: "ShopkeeperTeleportDebt_No", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    KDGameData.CurrentDialogStage = "Debt";
                                    KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt";
                                    return true;
                                }
                            },
                        }
                    },
                    "Collar": {
                        playertext: "Default", response: "Default",
                        prerequisiteFunction: (gagged, player) => {
                            var _a;
                            return ((_a = KDGameData.CurrentDialogMsgData) === null || _a === void 0 ? void 0 : _a.RESTRAINTNAME_Collar) != undefined;
                        },
                        clickFunction: (gagged, player) => {
                            KDGameData.CurrentDialogMsgData.RESTRAINTNAME = TextGet("Restraint" + KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Collar);
                            return false;
                        },
                        options: {
                            "Yes": {
                                playertext: "ShopkeeperTeleportDebt_Yes", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName(KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Collar), 0, true, "", true, false, false, undefined, "Shopkeeper", false, undefined, CommonRandomItemFromList("", KDCurseUnlockList.Basic));
                                    return false;
                                },
                                options: {
                                    "Leave": {
                                        playertext: "Leave", response: "Default",
                                        exitDialogue: true,
                                    },
                                }
                            },
                            "No": {
                                playertext: "ShopkeeperTeleportDebt_No", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    KDGameData.CurrentDialogStage = "Debt";
                                    KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt";
                                    return true;
                                }
                            },
                        }
                    },
                    "Catsuit": {
                        playertext: "Default", response: "Default",
                        prerequisiteFunction: (gagged, player) => {
                            var _a;
                            return ((_a = KDGameData.CurrentDialogMsgData) === null || _a === void 0 ? void 0 : _a.RESTRAINTNAME_Catsuit) != undefined;
                        },
                        clickFunction: (gagged, player) => {
                            KDGameData.CurrentDialogMsgData.RESTRAINTNAME = TextGet("Restraint" + KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Catsuit);
                            return false;
                        },
                        options: {
                            "Yes": {
                                playertext: "ShopkeeperTeleportDebt_Yes", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    KinkyDungeonAddRestraint(KinkyDungeonGetRestraintByName(KDGameData.CurrentDialogMsgData.RESTRAINTNAME_Catsuit), 0, true, "", true, false, false, undefined, "Shopkeeper", false, undefined, CommonRandomItemFromList("", KDCurseUnlockList.Basic));
                                    return false;
                                },
                                options: {
                                    "Leave": {
                                        playertext: "Leave", response: "Default",
                                        exitDialogue: true,
                                    },
                                }
                            },
                            "No": {
                                playertext: "ShopkeeperTeleportDebt_No", response: "Default", gag: true,
                                clickFunction: (gagged, player) => {
                                    KDGameData.CurrentDialogStage = "Debt";
                                    KDGameData.CurrentDialogMsg = "ShopkeeperTeleportDebt";
                                    return true;
                                }
                            },
                        }
                    },
                    "Pay": {
                        playertext: "Default", response: "Default",
                        prerequisiteFunction: (gagged, player) => {
                            return KinkyDungeonGold >= KDGameData.ShopkeeperFee;
                        },
                        clickFunction: (gagged, player) => {
                            KinkyDungeonGold -= KDGameData.ShopkeeperFee;
                            KDGameData.ShopkeeperFee = 0;
                            KinkyDungeonRemoveRestraintsWithShrine("Rope", undefined, true, false, true);
                            KinkyDungeonRemoveRestraintsWithShrine("Leather", undefined, true, false, true);
                            KinkyDungeonRemoveRestraintsWithShrine("Metal", undefined, true, false, true);
                            KinkyDungeonRemoveRestraintsWithShrine("Latex", undefined, true, false, true);
                            return false;
                        },
                        options: {
                            "Leave": {
                                playertext: "Leave", response: "Default",
                                exitDialogue: true,
                            },
                        }
                    },
                }
            },
        }
    },
    "ShopkeeperStart": {
        response: "Default",
        clickFunction: (gagged, player) => {
            if (!KDGameData.ShopkeeperFee)
                KDGameData.ShopkeeperFee = 0;
            KDGameData.CurrentDialogMsgValue = {
                "RESCUECOST": KDGameData.ShopkeeperFee || (KDDialogueParams.ShopkeeperFee + Math.max(0, KDDialogueParams.ShopkeeperFeePerLevel * MiniGameKinkyDungeonLevel)),
            };
            KDGameData.CurrentDialogMsgData = {
                "RESCUECOST": "" + (KDGameData.ShopkeeperFee || (KDDialogueParams.ShopkeeperFee + Math.max(0, KDDialogueParams.ShopkeeperFeePerLevel * MiniGameKinkyDungeonLevel))),
            };
            return false;
        },
        options: {
            "Danger": {
                playertext: "Default", response: "Default",
                gagDisabled: true,
                options: {
                    "Return": {
                        playertext: "Return", response: "Default",
                        leadsToStage: "",
                    },
                }
            },
            "Fee": {
                playertext: "Default", response: "Default",
                gagDisabled: true,
                options: {
                    "Return": {
                        playertext: "Return", response: "Default",
                        leadsToStage: "",
                    },
                }
            },
            "Shop": {
                playertext: "Default", response: "Default",
                gagDisabled: true,
                options: {
                    "Return": {
                        playertext: "Return", response: "Default",
                        leadsToStage: "",
                    },
                }
            },
            "Gag": {
                playertext: "Default", response: "Default",
                gagRequired: true,
                options: {
                    "Return": {
                        playertext: "Return", response: "Default",
                        leadsToStage: "",
                    },
                }
            },
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "BlacksmithShop": KDSaleShop("BlacksmithShop", ["Lockpick", "Knife", "Sword", "Axe", "Spear", "TrapCuffs"], [], ["blacksmith"], 0.4, 1.5),
    "PrisonerBandit": {
        response: "Default",
        personalities: ["Sub"],
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Help": {
                playertext: "Default", response: "Default",
                personalities: ["Sub"],
                clickFunction: (gagged, player) => {
                    if (KDDialogueEnemy()) {
                        let e = KDDialogueEnemy();
                        KDSpliceIndex(KinkyDungeonEntities.indexOf(KDDialogueEnemy()), 1);
                        let created = DialogueCreateEnemy(e.x, e.y, "Bandit");
                        created.allied = 9999;
                        created.personality = e.personality;
                        if (KDFactionRelation("Player", "Bandit") < -0.5) {
                            for (let enemy of KinkyDungeonEntities) {
                                if (enemy.Enemy.tags.bandit) {
                                    if (enemy.hostile && enemy.hostile < 9000) {
                                        enemy.hostile = 0;
                                    }
                                    enemy.ceasefire = 300;
                                }
                            }
                        }
                        KinkyDungeonAggroFaction("Bountyhunter");
                        if (KDFactionRelation("Player", "Bandit") < 0.25)
                            KinkyDungeonChangeFactionRep("Bandit", 0.015);
                        else
                            KinkyDungeonChangeFactionRep("Bandit", 0.005);
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Tighten": {
                playertext: "Default", response: "Default",
                personalities: ["Sub"],
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "PrisonerJail": {
        response: "Default",
        clickFunction: (gagged, player) => {
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
            "Unlock": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    if (KinkyDungeonRedKeys > 0) {
                        if (KinkyDungeonCanUseKey() || !KinkyDungeonIsArmsBound()) {
                            if (KDDialogueEnemy()) {
                                let e = KDDialogueEnemy();
                                e.boundLevel = 0;
                                KinkyDungeonSetEnemyFlag(e, "imprisoned", 0);
                                e.allied = 9999;
                                e.specialdialogue = undefined;
                                KinkyDungeonAggroFaction("Jail");
                                let faction = e.Enemy.faction ? e.Enemy.faction : "Enemy";
                                e.faction = "Player";
                                if (!KinkyDungeonHiddenFactions.includes(faction) && !(KDGameData.MapFaction == faction)) {
                                    if (KDFactionRelation("Player", faction) < 0.25)
                                        KinkyDungeonChangeFactionRep(faction, 0.005);
                                    else
                                        KinkyDungeonChangeFactionRep(faction, 0.0025);
                                }
                                KinkyDungeonRedKeys -= 1;
                                if (KinkyDungeonIsHandsBound(false, true, 0.2)) {
                                    DialogueBringNearbyEnemy(player.x, player.y, 8);
                                    KDGameData.CurrentDialogMsg = "PrisonerJailUnlockSlow";
                                }
                                else {
                                    KDGameData.CurrentDialogMsg = "PrisonerJailUnlock";
                                    if (e.Enemy.tags.gagged) {
                                        KDGameData.CurrentDialogMsg = KDGameData.CurrentDialogMsg + "Gagged";
                                    }
                                }
                            }
                        }
                        else {
                            KDGameData.CurrentDialogStage = "";
                            KDGameData.CurrentDialogMsg = "PrisonerJailUnlockHandsBound";
                        }
                    }
                    else {
                        KDGameData.CurrentDialogStage = "";
                        KDGameData.CurrentDialogMsg = "PrisonerJailNoKeys";
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Pick": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    if (KinkyDungeonLockpicks > 0) {
                        if (!KinkyDungeonIsHandsBound(false, true, 0.45)) {
                            if (KDDialogueEnemy()) {
                                let e = KDDialogueEnemy();
                                e.boundLevel = 0;
                                KinkyDungeonSetEnemyFlag(e, "imprisoned", 0);
                                e.allied = 9999;
                                e.specialdialogue = undefined;
                                KinkyDungeonAggroFaction("Jail");
                                let faction = e.Enemy.faction ? e.Enemy.faction : "Enemy";
                                e.faction = "Player";
                                if (!KinkyDungeonHiddenFactions.includes(faction) && !(KDGameData.MapFaction == faction)) {
                                    if (KDFactionRelation("Player", faction) < 0.25)
                                        KinkyDungeonChangeFactionRep(faction, 0.005);
                                    else
                                        KinkyDungeonChangeFactionRep(faction, 0.0025);
                                }
                                KDGameData.CurrentDialogMsg = "PrisonerJailPick";
                                if (e.Enemy.tags.gagged) {
                                    KDGameData.CurrentDialogMsg = KDGameData.CurrentDialogMsg + "Gagged";
                                }
                                DialogueBringNearbyEnemy(player.x, player.y, 8);
                            }
                        }
                        else {
                            KDGameData.CurrentDialogStage = "";
                            KDGameData.CurrentDialogMsg = "PrisonerJailPickHandsBound";
                        }
                    }
                    else {
                        KDGameData.CurrentDialogStage = "";
                        KDGameData.CurrentDialogMsg = "PrisonerJailNoPick";
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "Fuuka": {
        response: "Default",
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                enemy.hostile = 9999;
                enemy.aware = true;
                enemy.vp = 2;
                enemy.AI = 'hunt';
                KinkyDungeonSetFlag("BossDialogueFuuka", -1, 1);
            }
            return false;
        },
        options: {
            "Aggressive": { gag: true,
                playertext: "Default", response: "Default",
                options: {
                    "Question": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Brat": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Proceed": {
                                        playertext: "Default", response: "Default",
                                        leadsToStage: "PostIntro",
                                    }
                                }
                            },
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Proceed": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        leadsToStage: "PostIntro",
                    },
                    "ProceedGag": { gagRequired: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Brat": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": { gag: true,
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                            "Proceed2": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                }
            },
            "Defensive": { gag: true,
                playertext: "Default", response: "Default",
                options: {
                    "Question": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Question": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Question": {
                                        playertext: "Default", response: "Default",
                                        options: {
                                            "Question": {
                                                playertext: "Default", response: "Default",
                                                options: {
                                                    "Question": {
                                                        playertext: "Default", response: "Default",
                                                        options: {
                                                            "Question": {
                                                                playertext: "Default", response: "Default",
                                                                options: {
                                                                    "Proceed": {
                                                                        playertext: "FuukaDefensive_Question_Question_Proceed", response: "Default",
                                                                        leadsToStage: "PostIntro",
                                                                    }
                                                                }
                                                            },
                                                            "Question2": {
                                                                playertext: "Default", response: "Default",
                                                                options: {
                                                                    "Proceed": {
                                                                        playertext: "FuukaDefensive_Question_Question_Proceed", response: "Default",
                                                                        leadsToStage: "PostIntro",
                                                                    }
                                                                }
                                                            },
                                                            "Proceed": {
                                                                playertext: "FuukaDefensive_Question_Question_Proceed", response: "Default",
                                                                leadsToStage: "PostIntro",
                                                            }
                                                        }
                                                    },
                                                    "Proceed": {
                                                        playertext: "FuukaDefensive_Question_Question_Proceed", response: "Default",
                                                        leadsToStage: "PostIntro",
                                                    }
                                                }
                                            },
                                            "Proceed": {
                                                playertext: "FuukaDefensive_Question_Question_Proceed", response: "Default",
                                                leadsToStage: "PostIntro",
                                            }
                                        }
                                    },
                                    "Proceed": {
                                        playertext: "FuukaDefensive_Question_Question_Proceed", response: "Default",
                                        leadsToStage: "PostIntro",
                                    }
                                }
                            },
                            "Proceed": {
                                playertext: "FuukaDefensive_Question_Question_Proceed", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Proceed": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        leadsToStage: "PostIntro",
                    },
                    "ProceedGag": { gagRequired: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Brat": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": { gag: true,
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                            "Proceed2": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                }
            },
            "Brat": { gag: true,
                playertext: "Default", response: "Default",
                options: {
                    "Question": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Question": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Proceed": {
                                        playertext: "Default", response: "Default",
                                        leadsToStage: "PostIntro",
                                    }
                                }
                            },
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Proceed": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        leadsToStage: "PostIntro",
                    },
                    "ProceedGag": { gagRequired: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Brat": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": { gag: true,
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                            "Proceed2": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                }
            },
            "Dom": { gag: true,
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeRep("Ghost", -2);
                    return false;
                },
                options: {
                    "Question": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Question": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Proceed": {
                                        playertext: "Default", response: "Default",
                                        leadsToStage: "PostIntro",
                                    }
                                }
                            },
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Proceed": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        leadsToStage: "PostIntro",
                    },
                    "ProceedGag": { gagRequired: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Brat": { gag: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": { gag: true,
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                            "Proceed2": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                }
            },
            "Sub": { gag: true,
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeRep("Ghost", 2);
                    return false;
                },
                options: {
                    "Question": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Question": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Proceed": {
                                        playertext: "Default", response: "Default",
                                        leadsToStage: "PostIntro",
                                    }
                                }
                            },
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Proceed": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        leadsToStage: "PostIntro",
                    },
                    "ProceedGag": { gagRequired: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                    "Brat": { gag: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": { gag: true,
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                            "Proceed2": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "PostIntro",
                            },
                        }
                    },
                }
            },
            "Attack": { playertext: "Default", exitDialogue: true },
            "PostIntro": {
                prerequisiteFunction: (gagged, player) => { return false; },
                playertext: "Default", response: "Default",
                options: {
                    "Zombie": {
                        gagDisabled: true,
                        playertext: "Default", response: "Default",
                        leadsToStage: "Defensive_Question",
                    },
                    "Brat": { gag: true,
                        playertext: "Default", response: "FuukaPostIntro_Brat",
                        leadsToStage: "Fight",
                    },
                    "Dom": { gag: true,
                        playertext: "Default", response: "FuukaPostIntro_Dom",
                        leadsToStage: "Fight",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonChangeRep("Ghost", -2);
                            return false;
                        }
                    },
                    "Sub": { gag: true,
                        playertext: "Default", response: "FuukaPostIntro_Sub",
                        leadsToStage: "Fight",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonChangeRep("Ghost", 2);
                            return false;
                        }
                    },
                    "Normal": { gag: true,
                        playertext: "Default", response: "FuukaPostIntro_Normal",
                        leadsToStage: "Fight",
                    },
                }
            },
            "Fight": {
                prerequisiteFunction: (gagged, player) => { return false; },
                playertext: "Default", dontTouchText: true,
                options: {
                    "Fight1": { gag: true,
                        playertext: "Default", exitDialogue: true,
                    },
                    "Fight2": { gag: true,
                        playertext: "Default", exitDialogue: true,
                    },
                    "Fight3": { gag: true,
                        playertext: "Default", exitDialogue: true,
                    },
                }
            }
        }
    },
    "Dollmaker": {
        response: "Default",
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                enemy.hostile = 9999;
                enemy.aware = true;
                enemy.vp = 2;
                enemy.AI = 'hunt';
                KinkyDungeonSetFlag("BossDialogueDollmaker", -1, 1);
            }
            return false;
        },
        options: {
            "Ask": {
                playertext: "Default", response: "Default", gag: true,
                options: {
                    "Proceed": {
                        playertext: "Default", response: "Default", gag: true,
                        leadsToStage: "Fight",
                    },
                    "Staff": {
                        prerequisiteFunction: (gagged, player) => {
                            return (KinkyDungeonPlayerDamage === null || KinkyDungeonPlayerDamage === void 0 ? void 0 : KinkyDungeonPlayerDamage.name) == "StaffDoll";
                        },
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "Fight",
                            },
                        }
                    }
                }
            },
            "Assume": {
                playertext: "Default", response: "Default", gagDisabled: true,
                options: {
                    "Happy": {
                        playertext: "Default", response: "Default",
                        leadsToStage: "Fight",
                    },
                    "Proceed": {
                        playertext: "Default", response: "Default",
                        leadsToStage: "Fight",
                    },
                    "Staff": {
                        prerequisiteFunction: (gagged, player) => {
                            return (KinkyDungeonPlayerDamage === null || KinkyDungeonPlayerDamage === void 0 ? void 0 : KinkyDungeonPlayerDamage.name) == "StaffDoll";
                        },
                        playertext: "Default", response: "Default",
                        options: {
                            "Proceed": {
                                playertext: "Default", response: "Default",
                                leadsToStage: "Fight",
                            },
                        }
                    }
                }
            },
            "Fight": {
                prerequisiteFunction: (gagged, player) => { return false; },
                playertext: "Default", response: "Default",
                options: {
                    "Wait": { gagDisabled: true,
                        playertext: "Default", response: "Default",
                        options: {
                            "Dismiss": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Proceed": {
                                        playertext: "Default", exitDialogue: true,
                                    },
                                }
                            },
                            "Press": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Proceed": {
                                        playertext: "Default", exitDialogue: true,
                                    },
                                }
                            },
                            "Press2": {
                                playertext: "Default", response: "Default",
                                options: {
                                    "Proceed": {
                                        playertext: "Default", exitDialogue: true,
                                    },
                                }
                            },
                            "Proceed": {
                                playertext: "Default", exitDialogue: true,
                            },
                        }
                    },
                    "Fight1": { gag: true,
                        playertext: "Default", exitDialogue: true,
                    },
                    "Fight2": { gag: true,
                        playertext: "Default", exitDialogue: true,
                    },
                    "Fight3": { gag: true,
                        playertext: "Default", exitDialogue: true,
                    },
                }
            },
            "Attack": { playertext: "Default", exitDialogue: true },
        }
    },
    "DollmakerStage2": {
        response: "Default",
        clickFunction: (gagged, player) => {
            let point = KinkyDungeonGetNearbyPoint(KinkyDungeonStartPosition.x + 10, KinkyDungeonStartPosition.y - 5, true, undefined, true);
            if (!point) {
                point = { x: KinkyDungeonStartPosition.x + 10, y: KinkyDungeonStartPosition.y - 7 };
            }
            let e = DialogueCreateEnemy(point.x, point.y, "DollmakerBoss2");
            e.hostile = 300;
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "DollmakerStage3": {
        response: "Default",
        clickFunction: (gagged, player) => {
            for (let en of KinkyDungeonEntities) {
                if (en.Enemy.tags.dolldoor)
                    en.hp = 0;
            }
            let point = KinkyDungeonGetNearbyPoint(player.x, player.y, true);
            if (!point) {
                point = KinkyDungeonGetRandomEnemyPoint(false, false, null);
            }
            let e = DialogueCreateEnemy(point.x, point.y, "DollmakerBoss3");
            e.hostile = 300;
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "DollmakerWin": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("BossUnlocked", -1);
            KinkyDungeonSetFlag("SpawnMap", -1);
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                clickFunction: (gagged, player) => {
                    if (KinkyDungeonIsPlayer()) {
                        KDUnlockPerk("DollmakerVisor");
                        KDUnlockPerk("StartCyberDoll");
                        KDUnlockPerk("CommonCyber");
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Accept": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("DollmakerVisor"), 0, true);
                    KinkyDungeonAddGold(1000);
                    if (KinkyDungeonIsPlayer()) {
                        KDUnlockPerk("DollmakerVisor");
                        KDUnlockPerk("StartCyberDoll");
                        KDUnlockPerk("CommonCyber");
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Accept2": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("DollmakerMask"), 0, true);
                    KinkyDungeonAddGold(1000);
                    if (KinkyDungeonIsPlayer()) {
                        KDUnlockPerk("DollmakerVisor");
                        KDUnlockPerk("StartCyberDoll");
                        KDUnlockPerk("CommonCyber");
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Gag": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeRep("Ghost", -5);
                    if (KinkyDungeonIsPlayer()) {
                        KDUnlockPerk("DollmakerVisor");
                        KDUnlockPerk("StartCyberDoll");
                        KDUnlockPerk("CommonCyber");
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "DollmakerLose": {
        response: "Default",
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                enemy.hostile = 0;
                enemy.ceasefire = 4;
                KinkyDungeonSetFlag("BossUnlocked", -1);
                KinkyDungeonSetFlag("NoDollRoomBypass", 0);
            }
            return false;
        },
        options: {
            "Accept": { gag: true,
                playertext: "Default", response: "Default",
                options: {
                    "Continue1": {
                        playertext: "DollmakerLose_Continue1", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("DollmakerVisor"), 0, true);
                            return false;
                        },
                    },
                    "Continue2": {
                        playertext: "DollmakerLose_Continue2", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("DollmakerMask"), 0, true);
                            return false;
                        },
                    },
                    "Continue3": {
                        playertext: "DollmakerLose_Continue3", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName(KDRandom() < 0.5 ? "DollmakerVisor" : "DollmakerMask"), 0, true);
                            return false;
                        },
                    },
                }
            },
            "Deny": { gag: true,
                playertext: "Default", response: "Default",
                options: {
                    "Continue1": {
                        playertext: "DollmakerLose_Continue1", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("DollmakerVisor"), 0, true);
                            return false;
                        },
                    },
                    "Continue2": {
                        playertext: "DollmakerLose_Continue2", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("DollmakerMask"), 0, true);
                            return false;
                        },
                    },
                    "Continue3": {
                        playertext: "DollmakerLose_Continue3", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName(KDRandom() < 0.5 ? "DollmakerVisor" : "DollmakerMask"), 0, true);
                            return false;
                        },
                    },
                }
            },
            "Finish": {
                prerequisiteFunction: (gagged, player) => { return false; },
                playertext: "Default", response: "DollmakerLoseFinish",
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            }
        }
    },
    "FuukaLose": {
        response: "Default",
        clickFunction: (gagged, player) => {
            let enemy = KinkyDungeonFindID(KDGameData.CurrentDialogMsgID);
            if (enemy && enemy.Enemy.name == KDGameData.CurrentDialogMsgSpeaker) {
                enemy.hostile = 0;
                enemy.ceasefire = 4;
                KinkyDungeonSetFlag("BossUnlocked", -1);
            }
            return false;
        },
        options: {
            "Accept": { gag: true,
                playertext: "Default", response: "Default",
                options: {
                    "Continue1": {
                        playertext: "FuukaLose_Continue1", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true);
                            return false;
                        },
                    },
                    "Continue2": {
                        playertext: "FuukaLose_Continue2", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true);
                            return false;
                        },
                    },
                    "Continue3": {
                        playertext: "FuukaLose_Continue3", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true);
                            return false;
                        },
                    },
                }
            },
            "Deny": { gag: true,
                playertext: "Default", response: "Default",
                options: {
                    "Continue1": {
                        playertext: "FuukaLose_Continue1", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true);
                            return false;
                        },
                    },
                    "Continue2": {
                        playertext: "FuukaLose_Continue2", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true);
                            return false;
                        },
                    },
                    "Continue3": {
                        playertext: "FuukaLose_Continue3", response: "Default",
                        leadsToStage: "Finish",
                        clickFunction: (gagged, player) => {
                            KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true);
                            return false;
                        },
                    },
                }
            },
            "Finish": {
                prerequisiteFunction: (gagged, player) => { return false; },
                playertext: "Default", response: "FuukaLoseFinish",
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            }
        }
    },
    "FuukaStage2": {
        response: "Default",
        clickFunction: (gagged, player) => {
            let point = KinkyDungeonGetNearbyPoint(player.x, player.y, true);
            if (!point) {
                point = KinkyDungeonGetRandomEnemyPoint(false, false, null);
            }
            let e = DialogueCreateEnemy(point.x, point.y, "Fuuka2");
            e.hostile = 300;
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                exitDialogue: true,
            },
        }
    },
    "FuukaWin": {
        response: "Default",
        clickFunction: (gagged, player) => {
            KinkyDungeonSetFlag("BossUnlocked", -1);
            KinkyDungeonSetFlag("SpawnMap", -1);
            return false;
        },
        options: {
            "Leave": {
                playertext: "Leave", response: "Default",
                clickFunction: (gagged, player) => {
                    if (KinkyDungeonIsPlayer()) {
                        KDUnlockPerk("FuukaCollar");
                        KDUnlockPerk("CommonFuuka");
                    }
                    return false;
                },
                exitDialogue: true,
            },
            "Accept": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonAddRestraintIfWeaker(KinkyDungeonGetRestraintByName("MikoCollar"), 0, true);
                    KinkyDungeonAddGold(1000);
                    if (KinkyDungeonIsPlayer()) {
                        KDUnlockPerk("FuukaCollar");
                        KDUnlockPerk("CommonFuuka");
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
            "Gag": {
                playertext: "Default", response: "Default",
                clickFunction: (gagged, player) => {
                    KinkyDungeonChangeRep("Ghost", -5);
                    if (KinkyDungeonIsPlayer()) {
                        KDUnlockPerk("FuukaCollar");
                        KDUnlockPerk("CommonFuuka");
                    }
                    return false;
                },
                options: {
                    "Leave": {
                        playertext: "Leave", response: "Default",
                        exitDialogue: true,
                    },
                }
            },
        }
    },
    "PotionSell": KDShopDialogue("PotionSell", ["PotionFrigid", "PotionStamina", "PotionMana", "PotionInvisibility"], [], ["witch", "apprentice", "alchemist", "human", "dragon"], 0.2),
    "ElfCrystalSell": KDShopDialogue("ElfCrystalSell", ["PotionMana", "ElfCrystal", "EarthRune", "WaterRune", "IceRune"], [], ["elf"], 0.25),
    "ScrollSell": KDShopDialogue("ScrollSell", ["ScrollArms", "ScrollVerbal", "ScrollLegs", "ScrollPurity"], [], ["witch", "apprentice", "elf", "wizard", "dressmaker"], 0.15),
    "WolfgirlSell": KDShopDialogue("WolfgirlSell", ["MistressKey", "AncientPowerSource", "AncientPowerSourceSpent", "EnchantedGrinder"], [], ["trainer", "alchemist", "human"], 0.2),
    "NinjaSell": KDShopDialogue("NinjaSell", ["SmokeBomb", "Bola", "Bomb", "PotionInvisibility"], [], ["ninja", "bountyhunter"], 0.2),
    "GhostSell": KDShopDialogue("GhostSell", ["Ectoplasm", "PotionInvisibility", "ElfCrystal"], [], ["alchemist", "witch", "apprentice", "dressmaker", "dragon"], 0.1),
    "GenericAlly": KDAllyDialogue("GenericAlly", [], [], [], 1),
};
function KinkyDungeonAggressive(enemy) {
    if (enemy && enemy.hostile > 0)
        return true;
    if (!KDGameData.PrisonerState || KDGameData.PrisonerState == "chase")
        return KDHostile(enemy);
    if (enemy && KDFactionRelation(KDGetFaction(enemy), "Jail") < -0.4)
        return KDHostile(enemy);
    if (enemy && KDFactionRelation(KDGetFaction(enemy), "Jail") < -0.1 && KDGameData.PrisonerState != 'jail' && (KDGameData.PrisonerState != 'parole' || !KinkyDungeonPlayerInCell(true, true)))
        return KDHostile(enemy);
    return false;
}
function KDAllied(enemy) {
    return !(enemy.rage > 0) && !(enemy.hostile > 0) && KDFactionAllied("Player", enemy);
}
function KDHostile(enemy, enemy2) {
    if (enemy == enemy2)
        return false;
    return (enemy.rage > 0) ||
        (!(!enemy2 && enemy.ceasefire > 0)
            && ((!enemy2
                && (KDFactionHostile("Player", enemy) || enemy.hostile > 0)
                || (enemy2 && ((KDGetFaction(enemy2) == "Player" && enemy.hostile > 0) || KDFactionHostile(KDGetFaction(enemy), enemy2))))));
}
function KDGetFaction(enemy) {
    if (!enemy)
        return undefined;
    if (enemy.player)
        return "Player";
    let E = enemy.Enemy;
    if (enemy.rage > 0)
        return "Rage";
    if (enemy.faction)
        return enemy.faction;
    if ((E && E.allied) || ((enemy.allied || (E && E.faction && KDFactionAllied("Player", E.faction) && !KDEnemyHasFlag(enemy, "NoFollow"))) && !enemy.faction && !KDEnemyHasFlag(enemy, "Shop")))
        return "Player";
    if (E && E.faction)
        return E.faction;
    return "Enemy";
}
function KDGetFactionOriginal(enemy) {
    let E = enemy.Enemy;
    if (enemy.faction)
        return enemy.faction;
    if (E && E.faction)
        return E.faction;
    return "Enemy";
}
function KDFactionHostile(a, b) {
    if (a == "Player" && b && !(typeof b === "string") && b.hostile > 0)
        return true;
    if (!(typeof b === "string") && b.rage > 0)
        return true;
    if (a == "Player" && !(typeof b === "string") && b.allied > 0)
        return false;
    if (!(typeof b === "string"))
        b = KDGetFaction(b);
    if (a == "Rage" || b == "Rage")
        return true;
    if (a == "Player" && b == "Enemy")
        return true;
    if (b == "Player" && a == "Enemy")
        return true;
    if (KDFactionRelation(a, b) <= -0.5)
        return true;
    if (a == b)
        return false;
    return false;
}
function KDFactionAllied(a, b, threshold = 0.7) {
    if (a == "Player" && b && !(typeof b === "string") && b.hostile > 0)
        return false;
    if (!(typeof b === "string") && b.rage > 0)
        return false;
    if (a == "Player" && !(typeof b === "string") && b.allied > 0)
        return true;
    if (!(typeof b === "string"))
        b = KDGetFaction(b);
    if (a == "Rage" || b == "Rage")
        return false;
    if (a == "Player" && b == "Player")
        return true;
    if (b == "Enemy" && a == "Enemy")
        return true;
    if (KDFactionRelation(a, !(typeof b === "string") ? KDGetFaction(b) : b) >= threshold)
        return true;
    if (a == b)
        return true;
    return false;
}
function KDFactionFavorable(a, b) {
    return KDFactionAllied(a, b, 0.099);
}
let KinkyDungeonFactionColors = {
    "Jail": ["#8A120C"],
    "Slime": ["#9B49BD", "#9B49BD"],
    "Dressmaker": ["#6B48E0", "#F8BD01"],
    "Alchemist": ["#4c6885", "#7bef41"],
    "Elf": ["#63ab3f", "#F8BD01"],
    "Bountyhunter": ["#252525", "#bfbfbf"],
    "AncientRobot": ["#444444", "#4fa4b8"],
    "Dollsmith": ["#444444", "#b1062a", "#ff5277"],
    "Mushy": ["#bfbfbf", "#92c1e8"],
    "Apprentice": ["#686f99", "#ff5277"],
    "Witch": ["#222222", "#8359b3"],
};
let KinkyDungeonHiddenFactions = [
    "Plant",
    "Natural",
    "Player",
    "Enemy",
    "Jail",
    "Prisoner",
    "Beast",
    "Slime",
    "Mold",
    "KinkyConstruct",
    "Boss",
    "Ambush",
    "Rage",
    "Ghost",
    "Trap",
    "Rebel",
    "Rock",
    "Delinquent",
    "Wolfhunter",
    "Chase",
    "Mushy",
    "Witch",
];
let KDFactionSecurityMod = {
    Dressmaker: {
        level_magic: 1,
        level_key: 1,
    },
    Witch: {
        level_magic: 1,
        level_key: 1,
    },
    Elemental: {
        level_magic: 2,
    },
    Mushy: {
        level_magic: 1,
        level_tech: 0,
    },
    Apprentice: {
        level_magic: 0,
        level_key: -1,
    },
    Elf: {
        level_magic: 1,
        level_key: 1,
    },
    Bast: {
        level_magic: 1,
    },
    AncientRobot: {
        level_tech: 2,
        level_key: 1,
    },
    Nevermere: {
        level_tech: 1,
        level_key: 1,
    },
    Maidforce: {
        level_tech: 0,
        level_magic: -1,
        level_key: 1,
    },
    Alchemist: {
        level_tech: 1,
        level_magic: -1,
    },
    Bountyhunter: {
        level_tech: 0,
        level_key: 2,
    },
};
let KDBaseSecurity = {
    level_key: 0,
};
let KDPiousFactions = {
    "Angel": 1.0,
};
let KinkyDungeonTooltipFactions = [
    "Rebel",
    "Ambush",
    "Delinquent",
    "Wolfhunter",
    "Rock",
    "Rage",
];
let KinkyDungeonFactionTag = {
    Bountyhunter: "bountyhunter",
    Bandit: "bandit",
    Alchemist: "alchemist",
    Nevermere: "nevermere",
    Apprentice: "apprentice",
    Dressmaker: "dressmaker",
    Elemental: "elemental",
    Dragon: "dragon",
    Maidforce: "maid",
    Bast: "mummy",
    Elf: "elf",
    AncientRobot: "robot",
};
let KinkyDungeonFactionRelationsBase = {
    "Player": {
        Enemy: -1.0,
        Jail: -1.0,
        Prisoner: 0.1,
        KinkyConstruct: -0.9,
        Plant: -0.9,
        Slime: -1.0,
        Mold: -1.0,
        Beast: -0.6,
        Bountyhunter: -0.3,
        Bandit: -0.7,
        Alchemist: -0.2,
        Nevermere: -0.1,
        Apprentice: 0.2,
        Dressmaker: -0.4,
        Witch: -0.8,
        Elemental: -0.6,
        Dragon: 0.1,
        Maidforce: -0.1,
        Bast: -0.6,
        Elf: -0.3,
        Mushy: -0.6,
        AncientRobot: -0.4,
        Angel: 0.1,
        Demon: -0.25,
    },
    "Angel": {
        Demon: -1.0,
        Ghost: -0.7,
        Elemental: 0.15,
        Dragon: 0.05,
        AncientRobot: -0.25,
        Nevermere: -0.1,
        Enemy: 0.1,
    },
    "Natural": {
        Player: -1,
        Jail: -1,
    },
    "Ghost": {
        Player: -1.0,
        Jail: -0.25,
    },
    "Rock": {
        Player: -1.0,
    },
    "Rebel": {
        Jail: -0.1,
    },
    "Demon": {
        Elf: -1.0,
        Bast: -1.0,
        Witch: 0.25,
        Bountyhunter: -0.5,
        Bandit: -0.5,
        Alchemist: -0.5,
        Nevermere: -0.5,
        Apprentice: -0.5,
        Dressmaker: -0.5,
        Elemental: -0.1,
        Dragon: -1.0,
        Maidforce: -0.5,
        Mushy: -0.5,
        AncientRobot: -0.45,
    },
    "Enemy": {
        KinkyConstruct: .1,
        Dragon: .1,
        Bountyhunter: .1,
        Bandit: .1,
        Alchemist: .1,
        Nevermere: .1,
        Apprentice: .1,
        Dressmaker: .1,
        Witch: .1,
        Elemental: .1,
        Maidforce: .1,
        Bast: .1,
        Elf: .1,
        Mushy: .1,
        AncientRobot: .1,
    },
    "Delinquent": {
        Player: -1,
        Maidforce: -1,
        Chase: -1,
    },
    "Wolfhunter": {
        Player: -1,
        Nevermere: -1,
        Chase: -1,
    },
    "Trap": {
        Enemy: 1.0,
        Jail: 1.0,
        Prisoner: 1,
        KinkyConstruct: 1,
        Plant: 1,
        Slime: 1,
        Mold: 1,
        Beast: 1,
        Bountyhunter: 1,
        Bandit: 1,
        Alchemist: 1,
        Nevermere: 1,
        Apprentice: 1,
        Dressmaker: 1,
        Witch: 1,
        Elemental: 1,
        Dragon: 1,
        Maidforce: 1,
        Bast: 1,
        Elf: 1,
        Mushy: 1,
        AncientRobot: 1,
        Angel: 1,
        Demon: 1,
        Chase: -1,
    },
    "Boss": {
        Chase: -1,
    },
    "Chase": {},
    "Ambush": {
        Player: -1.0,
        Jail: -0.25,
        Chase: -1,
    },
    "Prisoner": {},
    "Jail": {},
    "Slime": {
        Jail: -0.25,
        Bountyhunter: -0.5,
        Bandit: -0.6,
        Alchemist: -0.8,
        Nevermere: -0.55,
        Apprentice: -0.55,
        Dressmaker: -0.4,
        Witch: 0.4,
        Elemental: -0.4,
        Dragon: -1.0,
        Maidforce: -1.0,
        Bast: -0.1,
        Elf: -0.1,
        Mushy: 0.1,
        AncientRobot: -1.0,
    },
    "Mold": {
        Jail: -0.25,
        Enemy: -0.5,
        Bountyhunter: -0.5,
        Bandit: -0.6,
        Alchemist: -0.8,
        Nevermere: -0.55,
        Apprentice: -0.55,
        Dressmaker: -0.5,
        Witch: -0.5,
        Elemental: -0.5,
        Dragon: -1.0,
        Maidforce: -1.0,
        Bast: -0.5,
        Elf: -0.5,
        Mushy: -0.5,
        AncientRobot: -1.0,
    },
    "Beast": {
        Jail: -0.25,
        Bountyhunter: -0.4,
        Bandit: -0.4,
        Alchemist: -0.4,
        Nevermere: -0.4,
        Apprentice: -0.4,
        Dressmaker: -0.4,
        Witch: -0.1,
        Elemental: -0.4,
        Dragon: -1.0,
        Maidforce: -0.4,
        Mushy: -0.4,
        AncientRobot: -1.0,
    },
    "KinkyConstruct": {
        Jail: -0.25,
        Apprentice: -0.55,
        Witch: 0.4,
        Dressmaker: 0.4,
        Dragon: -1.0,
    },
    "Plant": {
        Jail: -0.25,
    },
    "Nevermere": {
        "Alchemist": 1.0,
        "Bast": -0.55,
        "Mushy": -0.4,
        "Bandit": 0.3,
        "Apprentice": 0.15,
        "AncientRobot": -0.51,
    },
    "Alchemist": {
        "Bandit": 0.15,
        "AncientRobot": -0.55,
        "Dressmaker": -0.25,
    },
    "Bountyhunter": {
        "Jail": 0.8,
        "Dragon": 0.4,
        "Bandit": -0.55,
        "Maidforce": -0.15,
        "Witch": -0.4,
        "Dressmaker": 0.5,
        "Nevermere": 0.75,
    },
    "Elf": {
        "Mushy": 1.0,
        "Beast": 1.0,
    },
    "Bast": {
        "Elf": -1.0,
        "Witch": -0.4,
        "Beast": 0.55,
    },
    "Bandit": {
        "Mushy": -0.6,
    },
    "Elemental": {
        "KinkyConstruct": 0.55,
        "Dressmaker": 0.35,
        "Witch": 0.15,
        "Bandit": -0.15,
        "Elf": 0.5,
        "Bast": -0.35,
        "Dragon": -0.5,
        "AncientRobot": -0.15,
    },
    "AncientRobot": {
        "Bast": 0.55,
        "Elf": -0.6,
    },
    "Dragon": {
        "Jail": 1.0,
        "Apprentice": 0.4,
        "Bandit": -0.6,
        "Witch": -0.4,
        "Alchemist": -0.15,
        "Beast": -1.0,
        "Mushy": 0.15,
    },
    "Mushy": {
        "Alchemist": -0.55,
        "Elemental": 0.25,
    },
    "Witch": {
        "Elf": -1.0,
    },
    "Dressmaker": {
        "Witch": 0.15,
        "Nevermere": 0.8,
        "Bandit": -0.5,
        "Dragon": -0.5,
    },
    "Apprentice": {
        "Jail": 1.0,
        "Elf": 0.75,
    },
    "Maidforce": {
        "Alchemist": 0.55,
        "Jail": 0.55,
        "Dragon": 0.55,
        "Apprentice": 0.55,
        "Bandit": -0.6,
        "Witch": -0.4,
    },
};
let KinkyDungeonFactionRelations = Object.assign({}, KinkyDungeonFactionRelationsBase);
function KDFactionRelation(a, b) {
    if (a == "Rage" || b == "Rage")
        return -1.0;
    if (a == b)
        return 1.0;
    if (KDFactionRelations.get(a) && KDFactionRelations.get(a).get(b)) {
        return KDFactionRelations.get(a).get(b);
    }
    return 0.0;
}
let KDFactionRelations = new Map();
function KDInitFactions(Reset) {
    if (Reset) {
        KinkyDungeonFactionRelations = Object.assign({}, KinkyDungeonFactionRelationsBase);
        for (let relation of Object.entries(KinkyDungeonFactionRelationsBase)) {
            KinkyDungeonFactionRelations[relation[0]] = Object.assign({}, KinkyDungeonFactionRelationsBase[relation[0]]);
        }
    }
    for (let f of Object.keys(KinkyDungeonFactionRelationsBase)) {
        if (!KinkyDungeonFactionRelations[f]) {
            KinkyDungeonFactionRelations[f] = Object.assign(KinkyDungeonFactionRelationsBase[f]);
        }
    }
    KDFactionRelations = new Map();
    for (let f1 of Object.entries(KinkyDungeonFactionRelationsBase)) {
        let fmap = new Map();
        KDFactionRelations.set(f1[0], fmap);
    }
    for (let f1 of Object.entries(KinkyDungeonFactionRelations)) {
        let fmap = KDFactionRelations.get(f1[0]);
        for (let f2 of Object.entries(f1[1])) {
            fmap.set(f2[0], f2[1]);
            if (!KDFactionRelations.get(f2[0])) {
                console.log("Could not find faction " + f2[0]);
            }
            KDFactionRelations.get(f2[0]).set(f1[0], f2[1]);
        }
    }
}
function KDSetFactionRelation(a, b, relation) {
    if (a == "Rage" || b == "Rage")
        return;
    if (KinkyDungeonFactionRelations[a])
        KinkyDungeonFactionRelations[a][b] = Math.max(-1, Math.min(1, relation));
    if (KinkyDungeonFactionRelations[b])
        KinkyDungeonFactionRelations[b][a] = Math.max(-1, Math.min(1, relation));
    KDInitFactions();
}
function KDChangeFactionRelation(a, b, amount, AffectRivals) {
    if (a == "Rage" || b == "Rage")
        return;
    if (!KinkyDungeonFactionRelations[a])
        KinkyDungeonFactionRelations[a] = KinkyDungeonFactionRelationsBase[a] || 0;
    if (!KinkyDungeonFactionRelations[b])
        KinkyDungeonFactionRelations[b] = KinkyDungeonFactionRelationsBase[b] || 0;
    let amountSetTo = 0;
    let amountSet = false;
    if (KinkyDungeonFactionRelations[a]) {
        if (!KinkyDungeonFactionRelations[a][b] && KinkyDungeonFactionRelations[b][a])
            KinkyDungeonFactionRelations[a][b] = KinkyDungeonFactionRelations[b][a];
        else if (!KinkyDungeonFactionRelations[a][b])
            KinkyDungeonFactionRelations[a][b] = 0;
        amountSetTo = Math.max(-1, Math.min(1, KinkyDungeonFactionRelations[a][b] + amount));
        KinkyDungeonFactionRelations[a][b] = amountSetTo;
        amountSet = true;
    }
    if (KinkyDungeonFactionRelations[b]) {
        if (!KinkyDungeonFactionRelations[b][a] && KinkyDungeonFactionRelations[a][b])
            KinkyDungeonFactionRelations[b][a] = KinkyDungeonFactionRelations[a][b];
        else if (!KinkyDungeonFactionRelations[b][a])
            KinkyDungeonFactionRelations[b][a] = 0;
        KinkyDungeonFactionRelations[b][a] = amountSet ? amountSetTo : Math.max(-1, Math.min(1, KinkyDungeonFactionRelations[b][a] + amount));
    }
    if (AffectRivals && a == "Player") {
        for (let faction of Object.keys(KinkyDungeonFactionRelations)) {
            if (!KinkyDungeonHiddenFactions.includes(faction) && faction != a && faction != b) {
                let relation = KDFactionRelation(b, faction);
                KDChangeFactionRelation("Player", faction, amount * relation);
            }
        }
    }
    KDInitFactions();
}
let Ally = "ally";
let Sub = "sub";
let Enemy = "enemy";
let Jailer = "jail";
let KDMistress = {
    "Adventurer": {
        name: "Adventurer",
        alignment: Ally,
    }
};
let KDJailEvents = {
    "spawnGuard": {
        weight: (guard, xx, yy) => {
            return 70;
        },
        trigger: (g, xx, yy) => {
            var _a;
            if (KinkyDungeonFlags.get("slept") == -1) {
                KinkyDungeonSetFlag("slept", 0);
                KinkyDungeonSetFlag("slept", 150);
            }
            let jt = ((_a = KDGameData.JailFaction) === null || _a === void 0 ? void 0 : _a.length) > 0 ? KinkyDungeonFactionTag[[KDGameData.JailFaction[Math.floor(KDRandom() * KDGameData.JailFaction.length)]]] : "jailer";
            let Enemy = KinkyDungeonGetEnemy(["jailGuard", jt], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', [jt, "jailer"], false, undefined, ["gagged"]);
            if (!Enemy) {
                Enemy = KinkyDungeonGetEnemy(["jailGuard", jt], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', [jt, "jailer"], false, undefined, ["gagged"]);
                if (!Enemy) {
                    jt = "genericJailer";
                    Enemy = KinkyDungeonGetEnemy(["jailGuard", jt], MiniGameKinkyDungeonLevel, KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint], '0', [jt, "jailer"]);
                }
            }
            let guard = { summoned: true, Enemy: Enemy, id: KinkyDungeonGetEnemyID(),
                x: xx, y: yy, gx: xx - 2, gy: yy, CurrentAction: "jailWander", keys: true, AI: "guard",
                hp: (Enemy && Enemy.startinghp) ? Enemy.startinghp : Enemy.maxhp, movePoints: 0, attackPoints: 0 };
            if (!KinkyDungeonFlags.get("JailIntro")) {
                KinkyDungeonSetFlag("JailIntro", -1);
                KDStartDialog("PrisonIntro", guard.Enemy.name, true, "");
            }
            else if (KinkyDungeonFlags.get("JailRepeat")) {
                KinkyDungeonSetFlag("JailRepeat", 0);
                KDStartDialog("PrisonRepeat", guard.Enemy.name, true, "");
            }
            if (KinkyDungeonTilesGet((xx - 1) + "," + yy) && KinkyDungeonTilesGet((xx - 1) + "," + yy).Type == "Door") {
                KinkyDungeonTilesGet((xx - 1) + "," + yy).Lock = undefined;
            }
            KDGameData.KinkyDungeonJailGuard = guard.id;
            if (KinkyDungeonEnemyAt(guard.x, guard.y))
                KDKickEnemy(KinkyDungeonEnemyAt(guard.x, guard.y));
            KDAddEntity(guard);
            if (KinkyDungeonVisionGet(guard.x, guard.y))
                KinkyDungeonSendTextMessage(10, TextGet("KinkyDungeonGuardAppear").replace("EnemyName", TextGet("Name" + guard.Enemy.name)), "white", 6);
            KDGameData.KinkyDungeonGuardTimer = KDGameData.KinkyDungeonGuardTimerMax;
            KDGameData.KinkyDungeonGuardSpawnTimer = KDGameData.KinkyDungeonGuardSpawnTimerMin + Math.floor(KDRandom() * (KDGameData.KinkyDungeonGuardSpawnTimerMax - KDGameData.KinkyDungeonGuardSpawnTimerMin));
        },
    },
    "spawnRescue": {
        weight: (guard, xx, yy) => {
            return KDCanSpawnShopkeeper() ? 100 : 0;
        },
        trigger: (g, xx, yy) => {
            KDStartDialog("ShopkeeperRescue", "ShopkeeperRescue", true, "", undefined);
        },
    },
};
for (let rescue of Object.entries(KDPrisonRescues)) {
    KDJailEvents[rescue[0]] = {
        weight: (guard, xx, yy) => {
            if (guard)
                return 0;
            if (KinkyDungeonStatsChoice.get("norescueMode"))
                return 0;
            if (KDGameData.JailTurns <= 70 || KDFactionRelation("Player", rescue[1].faction) < 0.09)
                return 0;
            return 100 * Math.min(0.05, Math.max(0.1, 0.35 * KDFactionRelation("Player", rescue[1].faction)) - 0.005 * (KDGameData.PriorJailbreaks ? (KDGameData.PriorJailbreaks - (KDGameData.PriorJailbreaksDecay || 0)) : 0));
        },
        trigger: (guard, xx, yy) => {
            KDStartDialog(rescue[0], rescue[1].speaker, true, "", undefined);
        },
    };
}
function KDCanSpawnShopkeeper(override) {
    return (KinkyDungeonStatsChoice.get("easyMode") && (override || (KinkyDungeonFlags.get("JailIntro") && !KinkyDungeonFlags.get("JailRepeat"))) && !KinkyDungeonFlags.get("refusedShopkeeperRescue") && !KDIsPlayerTethered(KinkyDungeonPlayerEntity));
}
let KDGuardActions = {
    "jailWander": {
        weight: (guard, xx, yy) => {
            return 100;
        },
        assignable: (guard, xx, yy) => {
            return KDistChebyshev(guard.gx - guard.x, guard.gy - guard.y) < 1.5;
        },
        assign: (guard, xx, yy) => {
        },
        handle: (guard, xx, yy) => {
            if (KDRandom() < 0.2) {
                guard.gx = xx - 2;
                if (KDRandom() < 0.5)
                    guard.gy = yy + Math.round(KDRandom() * KinkyDungeonJailLeash * 2 - KinkyDungeonJailLeash);
                else
                    guard.gy = KinkyDungeonPlayerEntity.y;
            }
            KDGameData.GuardApplyTime = 0;
        },
    },
    "release": {
        weight: (guard, xx, yy) => {
            let missingJailUniform = KinkyDungeonMissingJailUniform();
            return (KinkyDungeonCheckRelease() >= 0 && KinkyDungeonLockableItems().length == 0 && missingJailUniform.length < 1) ? 1000 : 0;
        },
        assign: (guard, xx, yy) => {
            var _a;
            KinkyDungeonInterruptSleep();
            if (KinkyDungeonGoddessRep.Prisoner >= KDSecurityLevelHiSec && KDGameData.RoomType != "Jail" && (!(((_a = KDGameData.JailFaction) === null || _a === void 0 ? void 0 : _a.length) > 0) || KDFactionRelation("Player", KDGameData.JailFaction[0]) < 0.4)) {
                KDStartDialog("JailerHiSec", guard.Enemy.name, true, "", guard);
            }
            else {
                KinkyDungeonSendDialogue(guard, TextGet("KinkyDungeonRemindJailRelease" + KinkyDungeonCheckRelease()).replace("EnemyName", TextGet("Name" + guard.Enemy.name)), "#ffff00", 4, 8);
                KDGameData.PrisonerState = 'parole';
                guard.CurrentAction = "jailWander";
                for (let T of Object.values(KinkyDungeonTiles)) {
                    if (T.Lock && T.Jail)
                        T.Lock = undefined;
                    if (T.Type == "Lock")
                        T.Type = undefined;
                }
            }
        },
        handle: (guard, xx, yy) => {
        },
    },
    "jailTease": {
        weight: (guard, xx, yy) => {
            return 10 + (KinkyDungeonGoddessRep.Ghost + 50);
        },
        assign: (guard, xx, yy) => {
            guard.CurrentAction = "jailTease";
        },
        handle: (guard, xx, yy, delta) => {
            let playerHasVibrator = Array.from(KinkyDungeonAllRestraint()).some(i => KDRestraint(i).allowRemote);
            guard.gx = guard.x;
            guard.gy = guard.y;
            if (playerHasVibrator) {
                let extraCharge = Math.round(2 + (KinkyDungeonGoddessRep.Ghost + 50) * KDRandom() * 0.15);
                KinkyDungeonSendEvent("remoteVibe", { enemy: guard.Enemy.name, power: extraCharge, overcharge: true, noSound: false });
            }
            else if (guard.Enemy.dmgType === "grope" || guard.Enemy.dmgType === "tickle") {
                let touchesPlayer = KinkyDungeonCheckLOS(KinkyDungeonJailGuard(), KinkyDungeonPlayerEntity, KDistChebyshev(guard.x - KinkyDungeonPlayerEntity.x, guard.y - KinkyDungeonPlayerEntity.y), 1.5, false, false);
                if (touchesPlayer) {
                    let dmg = KinkyDungeonDealDamage({ damage: guard.Enemy.power * 0.1, type: guard.Enemy.dmgType }, undefined, undefined, true);
                    if (dmg && dmg.string)
                        KinkyDungeonSendTextMessage(5, TextGet("Attack" + guard.Enemy.name).replace("DamageTaken", dmg.string), "yellow", 3);
                }
                else {
                    guard.gx = KinkyDungeonPlayerEntity.x;
                    guard.gy = KinkyDungeonPlayerEntity.y;
                }
            }
            if (KDRandom() < 0.02 || (KinkyDungeonStatStamina < 10 && KDRandom() < 0.1))
                guard.CurrentAction = "jailWander";
        }
    },
    "bindings": {
        weight: (guard, xx, yy) => {
            let missingJailUniform = KinkyDungeonMissingJailUniform();
            let tooMuchRestraint = KinkyDungeonTooMuchRestraint();
            let lockableRestraint = KinkyDungeonLockableItems();
            return (lockableRestraint.length > 0
                || missingJailUniform.length > 0
                || (tooMuchRestraint.length > 0 && KDGameData.JailRemoveRestraintsTimer > KinkyDungeonJailRemoveRestraintsTimerMin)) ? (100 + (missingJailUniform.length > 0 ? 100 : 0)) : 0;
        },
        assign: (guard, xx, yy) => {
            let missingJailUniform = KinkyDungeonMissingJailUniform();
            let tooMuchRestraint = KinkyDungeonTooMuchRestraint();
            let lockableRestraint = KinkyDungeonLockableItems();
            if (missingJailUniform.length > 0 || KDRandom() < 0.2) {
                if (tooMuchRestraint.length > 0 && (KDRandom() < 0.5 || missingJailUniform.length < 1) && KDGameData.JailRemoveRestraintsTimer > KinkyDungeonJailRemoveRestraintsTimerMin) {
                    let group = "";
                    if (tooMuchRestraint.includes("ItemMouth3"))
                        group = "ItemMouth3";
                    else if (tooMuchRestraint.includes("ItemMouth2"))
                        group = "ItemMouth2";
                    else if (tooMuchRestraint.includes("ItemMouth"))
                        group = "ItemMouth";
                    else
                        group = tooMuchRestraint[Math.floor(tooMuchRestraint.length * KDRandom())];
                    if (group) {
                        guard.CurrentAction = "jailRemoveRestraints";
                        guard.CurrentRestraintSwapGroup = group;
                    }
                    KinkyDungeonSendDialogue(guard, TextGet("KinkyDungeonJailerRemove").replace("EnemyName", TextGet("Name" + guard.Enemy.name)), "#ffff00", 4, 3);
                }
                else if (missingJailUniform.length > 0) {
                    let group = "";
                    if (missingJailUniform.includes("ItemMouth3"))
                        group = "ItemMouth3";
                    else if (missingJailUniform.includes("ItemMouth2"))
                        group = "ItemMouth2";
                    else if (missingJailUniform.includes("ItemMouth"))
                        group = "ItemMouth";
                    else
                        group = missingJailUniform[Math.floor(missingJailUniform.length * KDRandom())];
                    if (group) {
                        guard.CurrentAction = "jailAddRestraints";
                        guard.CurrentRestraintSwapGroup = group;
                    }
                    KinkyDungeonSendDialogue(guard, TextGet("KinkyDungeonJailerAdd").replace("EnemyName", TextGet("Name" + guard.Enemy.name)), "#ffff00", 4, 3);
                }
            }
            else if (lockableRestraint.length > 0) {
                let group = "";
                if (lockableRestraint.includes("ItemMouth3"))
                    group = "ItemMouth3";
                else if (lockableRestraint.includes("ItemMouth2"))
                    group = "ItemMouth2";
                else if (lockableRestraint.includes("ItemMouth"))
                    group = "ItemMouth";
                else
                    group = lockableRestraint[Math.floor(lockableRestraint.length * KDRandom())];
                if (group) {
                    guard.CurrentAction = "jailLockRestraints";
                    guard.CurrentRestraintSwapGroup = group;
                }
                KinkyDungeonSendDialogue(guard, TextGet("KinkyDungeonJailerLock").replace("EnemyName", TextGet("Name" + guard.Enemy.name)), "#ffff00", 4, 3);
            }
        },
        handle: (guard, xx, yy, delta) => {
        },
    },
    "jailRemoveRestraints": {
        weight: (guard, xx, yy) => {
            return 0;
        },
        assign: (guard, xx, yy) => {
        },
        handle: (guard, xx, yy, delta) => {
            let applyTime = 2;
            let playerDist = Math.sqrt((guard.x - KinkyDungeonPlayerEntity.x) * (guard.x - KinkyDungeonPlayerEntity.x) + (guard.y - KinkyDungeonPlayerEntity.y) * (guard.y - KinkyDungeonPlayerEntity.y));
            let touchesPlayer = KinkyDungeonCheckLOS(guard, KinkyDungeonPlayerEntity, playerDist, 1.5, false, false);
            if (touchesPlayer) {
                KDGameData.KinkyDungeonGuardTimer = Math.max(KDGameData.KinkyDungeonGuardTimer, 2);
                let oldRestraintItem = KinkyDungeonGetRestraintItem(guard.CurrentRestraintSwapGroup);
                if (KDGameData.GuardApplyTime > applyTime) {
                    if (oldRestraintItem && KDRestraint(oldRestraintItem) && !KDRestraint(oldRestraintItem).noJailRemove) {
                        KinkyDungeonRemoveRestraint(KDRestraint(oldRestraintItem).Group, false, false, false);
                        let msg = TextGet("KinkyDungeonRemoveRestraints")
                            .replace("EnemyName", TextGet("Name" + guard.Enemy.name));
                        if (oldRestraintItem)
                            msg = msg.replace("OldRestraintName", TextGet("Restraint" + oldRestraintItem.name));
                        KinkyDungeonSendTextMessage(5, msg, "yellow", 1);
                    }
                    guard.CurrentAction = "jailWander";
                    guard.gx = guard.x;
                    guard.gy = guard.y;
                    KDGameData.GuardApplyTime = 0;
                }
                else if (oldRestraintItem) {
                    KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonJailerStartRemoving")
                        .replace("EnemyName", TextGet("Name" + guard.Enemy.name))
                        .replace("RestraintName", TextGet("Restraint" + oldRestraintItem.name)), "yellow", 2, true);
                    KDGameData.GuardApplyTime += delta;
                }
                else {
                    guard.CurrentAction = "jailWander";
                    guard.gx = guard.x;
                    guard.gy = guard.y;
                    KDGameData.GuardApplyTime = 0;
                }
            }
            else {
                KDGameData.KinkyDungeonGuardTimer = Math.max(KDGameData.KinkyDungeonGuardTimer, 2);
                KDGameData.GuardApplyTime = 0;
                guard.gx = KinkyDungeonPlayerEntity.x;
                guard.gy = KinkyDungeonPlayerEntity.y;
            }
        },
    },
    "jailAddRestraints": {
        weight: (guard, xx, yy) => {
            return 0;
        },
        assign: (guard, xx, yy) => {
        },
        handle: (guard, xx, yy, delta) => {
            let applyTime = 2;
            let playerDist = Math.sqrt((guard.x - KinkyDungeonPlayerEntity.x) * (guard.x - KinkyDungeonPlayerEntity.x) + (guard.y - KinkyDungeonPlayerEntity.y) * (guard.y - KinkyDungeonPlayerEntity.y));
            let touchesPlayer = KinkyDungeonCheckLOS(guard, KinkyDungeonPlayerEntity, playerDist, 1.5, false, false);
            if (touchesPlayer) {
                KDGameData.KinkyDungeonGuardTimer = Math.max(KDGameData.KinkyDungeonGuardTimer, 7);
                let newRestraint = KinkyDungeonGetJailRestraintForGroup(guard.CurrentRestraintSwapGroup);
                if (KDGameData.GuardApplyTime > applyTime) {
                    if (newRestraint) {
                        let oldRestraintItem = KinkyDungeonGetRestraintItem(guard.CurrentRestraintSwapGroup);
                        let added = KinkyDungeonAddRestraintIfWeaker(newRestraint, 0, true, undefined, undefined, undefined, undefined, KDGetFaction(KinkyDungeonJailGuard()), KinkyDungeonStatsChoice.has("MagicHands") ? true : undefined, undefined, KinkyDungeonJailGuard());
                        if (added) {
                            let restraintModification = oldRestraintItem ? "ChangeRestraints" : "AddRestraints";
                            let msg = TextGet("KinkyDungeon" + restraintModification).replace("EnemyName", TextGet("Name" + guard.Enemy.name));
                            if (oldRestraintItem)
                                msg = msg.replace("OldRestraintName", TextGet("Restraint" + oldRestraintItem.name));
                            msg = msg.replace("NewRestraintName", TextGet("Restraint" + newRestraint.name));
                            KinkyDungeonSendTextMessage(5, msg, "yellow", 1);
                        }
                        else
                            KinkyDungeonSendTextMessage(5, TextGet("KinkyDungeonJailerCheck"), "yellow", 3, true);
                    }
                    guard.CurrentAction = "jailWander";
                    guard.gx = guard.x;
                    guard.gy = guard.y;
                    KDGameData.GuardApplyTime = 0;
                }
                else if (newRestraint) {
                    KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonJailerStartAdding")
                        .replace("RestraintName", TextGet("Restraint" + newRestraint.name))
                        .replace("EnemyName", TextGet("Name" + guard.Enemy.name)), "yellow", 2, true);
                    KDGameData.GuardApplyTime += delta;
                }
            }
            else {
                KDGameData.KinkyDungeonGuardTimer = Math.max(KDGameData.KinkyDungeonGuardTimer, 7);
                KDGameData.GuardApplyTime = 0;
                guard.gx = KinkyDungeonPlayerEntity.x;
                guard.gy = KinkyDungeonPlayerEntity.y;
            }
        },
    },
    "jailLockRestraints": {
        weight: (guard, xx, yy) => {
            return 0;
        },
        assign: (guard, xx, yy) => {
        },
        handle: (guard, xx, yy, delta) => {
            let applyTime = 2;
            let playerDist = Math.sqrt((guard.x - KinkyDungeonPlayerEntity.x) * (guard.x - KinkyDungeonPlayerEntity.x) + (guard.y - KinkyDungeonPlayerEntity.y) * (guard.y - KinkyDungeonPlayerEntity.y));
            let touchesPlayer = KinkyDungeonCheckLOS(guard, KinkyDungeonPlayerEntity, playerDist, 1.5, false, false);
            if (touchesPlayer) {
                KDGameData.KinkyDungeonGuardTimer = Math.max(KDGameData.KinkyDungeonGuardTimer, 2);
                let oldRestraintItem = KinkyDungeonGetRestraintItem(guard.CurrentRestraintSwapGroup);
                if (KDGameData.GuardApplyTime > applyTime) {
                    if (oldRestraintItem && !oldRestraintItem.lock && KinkyDungeonIsLockable(KDRestraint(oldRestraintItem))) {
                        let lock = KinkyDungeonGenerateLock(true, MiniGameKinkyDungeonLevel, false);
                        KinkyDungeonLock(oldRestraintItem, lock);
                        let msg = TextGet("KinkyDungeonJailerFinishLocking")
                            .replace("EnemyName", TextGet("Name" + guard.Enemy.name))
                            .replace("RestraintName", TextGet("Restraint" + oldRestraintItem.name))
                            .replace("LockType", TextGet("Kinky" + lock + "Lock"));
                        KinkyDungeonSendTextMessage(5, msg, "yellow", 1);
                    }
                    guard.CurrentAction = "jailWander";
                    guard.gx = guard.x;
                    guard.gy = guard.y;
                    KDGameData.GuardApplyTime = 0;
                }
                else if (oldRestraintItem) {
                    KinkyDungeonSendActionMessage(4, TextGet("KinkyDungeonJailerStartLocking")
                        .replace("EnemyName", TextGet("Name" + guard.Enemy.name))
                        .replace("RestraintName", TextGet("Restraint" + oldRestraintItem.name)), "yellow", 2, true);
                    KDGameData.GuardApplyTime += delta;
                }
                else {
                    guard.CurrentAction = "jailWander";
                    guard.gx = guard.x;
                    guard.gy = guard.y;
                    KDGameData.GuardApplyTime = 0;
                }
            }
            else {
                KDGameData.KinkyDungeonGuardTimer = Math.max(KDGameData.KinkyDungeonGuardTimer, 2);
                KDGameData.GuardApplyTime = 0;
                guard.gx = KinkyDungeonPlayerEntity.x;
                guard.gy = KinkyDungeonPlayerEntity.y;
            }
        },
    },
    "jailLeashTour": {
        weight: (guard, xx, yy) => {
            KDGameData.KinkyDungeonJailTourTimer = 0;
            return (KDGameData.SleepTurns < 1 && KDGameData.KinkyDungeonJailTourTimer < 1 && KinkyDungeonGoddessRep.Ghost >= -45) ? (5 + Math.max(0, (50 + KinkyDungeonGoddessRep.Ghost) / 5)) : 0;
        },
        assign: (guard, xx, yy) => {
            guard.RemainingJailLeashTourWaypoints = 2 + Math.ceil(KDRandom() * 4);
            guard.CurrentAction = "jailLeashTour";
            guard.KinkyDungeonJailTourInfractions = 0;
            KinkyDungeonInterruptSleep();
            let msg = TextGet("KinkyDungeonRemindJailTourStart").replace("EnemyName", TextGet("Name" + guard.Enemy.name));
            KinkyDungeonSendDialogue(guard, msg, "#ffff00", 4, 9);
        },
        handle: (guard, xx, yy, delta) => {
            if (KDGameData.KinkyDungeonJailTourTimer > 0) {
                KDGameData.KinkyDungeonJailTourTimer = Math.max(0, KDGameData.KinkyDungeonJailTourTimer - delta);
            }
            KinkyDungeonSetFlag("nojailbreak", 2);
            KinkyDungeonSetFlag("noclosedoors", 2);
            KinkyDungeonSetFlag("notickguardtimer", 7);
            KinkyDungeonHandleLeashTour(xx, yy, "tour");
        },
    },
    "jailLeashTransfer": {
        weight: (guard, xx, yy) => {
            KDGameData.KinkyDungeonJailTourTimer = 0;
            return (KDGameData.JailTurns > 30 && KinkyDungeonRandomJailPoint(["jail"], [KinkyDungeonNearestJailPoint(KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y)])) ? 5 : 0;
        },
        assign: (guard, xx, yy) => {
            guard.RemainingJailLeashTourWaypoints = 1;
            guard.CurrentAction = "jailLeashTransfer";
            guard.KinkyDungeonJailTourInfractions = 0;
            KinkyDungeonInterruptSleep();
            let msg = TextGet("KinkyDungeonRemindJailTourStartCell").replace("EnemyName", TextGet("Name" + guard.Enemy.name));
            KinkyDungeonSendDialogue(guard, msg, "#ffff00", 4, 9);
        },
        handle: (guard, xx, yy, delta) => {
            if (KDGameData.KinkyDungeonJailTourTimer > 0) {
                KDGameData.KinkyDungeonJailTourTimer = Math.max(0, KDGameData.KinkyDungeonJailTourTimer - delta);
            }
            KinkyDungeonSetFlag("nojailbreak", 2);
            KinkyDungeonSetFlag("noclosedoors", 2);
            KinkyDungeonSetFlag("notickguardtimer", 7);
            KinkyDungeonHandleLeashTour(xx, yy, "transfer");
        },
    },
};
let KinkyDungeonJailRemoveRestraintsTimerMin = 90;
let KinkyDungeonJailedOnce = false;
let KDJailReleaseTurns = [
    { minSub: 0, releaseTurns: 250 },
    { minSub: 5, releaseTurns: 140 },
    { minSub: 40, releaseTurns: 80 },
    { minSub: 90, releaseTurns: 40 },
];
let KDSecurityLevelHiSec = 0;
let KDJailOutfits = {
    "jailer": {
        overridelowerpriority: false,
        priority: -1,
        jail: true,
        parole: false,
        restraints: [
            { Name: "Stuffing", Level: 20 },
            { Name: "TrapGag", Level: 20 },
            { Name: "HighsecBallGag", Level: 50 },
            { Name: "FeetShackles", Level: 5 },
            { Name: "HighsecShackles", Level: 40 },
            { Name: "LegShackles", Level: 15 },
            { Name: "HighsecLegbinder", Level: 35 },
            { Name: "WristShackles", Level: 0 },
            { Name: "TrapArmbinder", Level: 40 },
            { Name: "HighsecArmbinder", Level: 70 },
            { Name: "PrisonBelt", Level: 30 },
            { Name: "TrapPlug", Level: 30 },
            { Name: "TrapPlug2", Level: 45 },
            { Name: "TrapPlug3", Level: 60 },
            { Name: "TrapPlug4", Level: 75 },
            { Name: "TrapPlug5", Level: 90 },
            { Name: "TrapBlindfold", Level: 90 },
            { Name: "TrapBoots", Level: 60 },
        ],
    },
    "ropeRestraints": {
        overridelowerpriority: false,
        priority: 1,
        jail: true,
        parole: true,
        restraints: [
            { Name: "RopeSnakeCuffs", Level: 0 },
            { Name: "RopeSnakeArmsWrist", Level: 0 },
            { Name: "RopeSnakeFeet", Level: 20 },
            { Name: "RopeSnakeCrotch", Level: 10 },
            { Name: "RopeSnakeLegs", Level: 30 },
            { Name: "RopeSnakeHogtie", Level: 100 },
        ],
    },
    "latexRestraints": {
        overridelowerpriority: false,
        priority: 1,
        jail: true,
        parole: false,
        restraints: [
            { Name: "LatexBoots", Level: 40 },
            { Name: "LatexBallGag", Level: 0 },
            { Name: "LatexCorset", Level: 65 },
            { Name: "LatexLegbinder", Level: 80 },
            { Name: "LatexArmbinder", Level: 30 },
            { Name: "LatexStraitjacket", Level: 60 },
            { Name: "LatexCatsuit", Level: 100 },
        ],
    },
    "wolfRestraints": {
        overridelowerpriority: true,
        priority: 2,
        jail: true,
        parole: false,
        restraints: [
            { Name: "WolfCuffs", Level: 0 },
            { Name: "WolfArmbinder", Level: 30 },
            { Name: "WolfAnkleCuffs", Level: 10 },
            { Name: "WolfHarness", Level: 20 },
            { Name: "ControlHarness", Level: 80 },
            { Name: "WolfBallGag", Level: 30 },
            { Name: "WolfCollar", Level: 0 },
            { Name: "WolfPanties", Level: 60 },
        ],
    },
    "expRestraints": {
        overridelowerpriority: true,
        priority: 2,
        jail: true,
        parole: false,
        restraints: [
            { Name: "ExpArmbinder", Level: 0 },
            { Name: "ExpArmbinderHarness", Level: 60 },
            { Name: "ExpAnkleCuffs", Level: 30 },
            { Name: "LatexBallGag", Level: 5 },
            { Name: "ExpCollar", Level: 40 },
            { Name: "ExpBoots", Level: 50 },
        ],
    },
    "dragonRestraints": {
        overridelowerpriority: true,
        priority: 2,
        jail: true,
        parole: false,
        restraints: [
            { Name: "ScaleArmCuffs", Level: 0 },
            { Name: "DragonStraps", Level: 20 },
            { Name: "DragonLegCuffs", Level: 60 },
            { Name: "DragonAnkleCuffs", Level: 10 },
            { Name: "DragonBoots", Level: 90 },
            { Name: "DragonBallGag", Level: 30 },
            { Name: "DragonMuzzleGag", Level: 60 },
            { Name: "DragonCollar", Level: 0 },
        ],
    },
    "kittyRestraints": {
        overridelowerpriority: false,
        priority: 2,
        jail: true,
        parole: true,
        restraints: [
            { Name: "KittyPaws", Level: 0 },
            { Name: "KittyGag", Level: 10 },
            { Name: "KittyMuzzle", Level: 45 },
            { Name: "KittyBlindfold", Level: 60 },
            { Name: "KittySuit", Level: 80 },
            { Name: "KittyPetSuit", Level: 100 },
        ],
    },
    "obsidianRestraints": {
        overridelowerpriority: false,
        priority: 2,
        jail: true,
        parole: false,
        restraints: [
            { Name: "ObsidianArmCuffs", Level: 0 },
            { Name: "ObsidianLegCuffs", Level: 60 },
            { Name: "ObsidianAnkleCuffs", Level: 10 },
            { Name: "ObsidianGag", Level: 30 },
            { Name: "ObsidianCollar", Level: 0 },
        ],
    },
    "leatherRestraints": {
        overridelowerpriority: false,
        priority: 1,
        jail: true,
        parole: true,
        restraints: [
            { Name: "LeatherArmCuffs", Level: 5 },
            { Name: "SturdyLeatherBeltsArms", Level: 30 },
            { Name: "SturdyLeatherBeltsLegs", Level: 80 },
            { Name: "SturdyLeatherBeltsFeet", Level: 60 },
            { Name: "TrapArmbinder", Level: 50 },
            { Name: "TrapMittens", Level: 0 },
            { Name: "TrapGag", Level: 10 },
            { Name: "PanelGag", Level: 20 },
            { Name: "TrapHarness", Level: 40 },
        ],
    },
    "dressRestraints": {
        overridelowerpriority: false,
        priority: 1,
        jail: true,
        parole: true,
        restraints: [
            { Name: "BindingDress", Level: 0 },
            { Name: "NippleClamps", Level: 60 },
            { Name: "DressBra", Level: 60 },
        ],
    },
};
function KDRunTests() {
    KDDebug = true;
    if (KDTestMapGen(100, [0, 6, 12, 18,], [0, 1, 2, 3, 11,])
        && KDTestFullRunthrough(3, true, true)) {
        console.log("All tests passed!");
    }
    KDDebug = false;
}
function KDTestMapGen(count, Ranges, Checkpoints) {
    for (let Checkpoint of Checkpoints) {
        MiniGameKinkyDungeonCheckpoint = Checkpoint;
        for (let FloorRange of Ranges)
            for (let f = FloorRange; f < FloorRange + KDLevelsPerCheckpoint; f++) {
                console.log(`Testing floor ${f}`);
                MiniGameKinkyDungeonLevel = f;
                for (let i = 0; i < count; i++) {
                    if (i % (count / KDLevelsPerCheckpoint) == 0)
                        console.log(`Testing iteration ${i} on floor ${MiniGameKinkyDungeonLevel}`);
                    KinkyDungeonCreateMap(KinkyDungeonMapParams[KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint]], f, true);
                    let accessible = KinkyDungeonIsAccessible(KinkyDungeonStartPosition.x, KinkyDungeonStartPosition.y);
                    if (!accessible) {
                        console.log(`Error, stairs are inaccessible on iteration ${i}`);
                        return false;
                    }
                }
            }
    }
    return true;
}
function KDTestFullRunthrough(GameLoops, Init, NGP) {
    let EnemySpawnData = {};
    console.log("Testing full runthrough");
    if (Init) {
        MiniGameKinkyDungeonLevel = 1;
        MiniGameKinkyDungeonCheckpoint = "grv";
        KinkyDungeonInitialize(1);
    }
    for (let i = 0; i < KinkyDungeonMaxLevel * GameLoops; i++) {
        KinkyDungeonHandleStairs('s', true);
        console.log(`Arrived at floor ${MiniGameKinkyDungeonLevel}`);
        if (!EnemySpawnData["" + MiniGameKinkyDungeonCheckpoint]) {
            EnemySpawnData["" + MiniGameKinkyDungeonCheckpoint] = {};
        }
        for (let e of KinkyDungeonEntities) {
            if (EnemySpawnData["" + MiniGameKinkyDungeonCheckpoint][e.Enemy.name] == undefined)
                EnemySpawnData["" + MiniGameKinkyDungeonCheckpoint][e.Enemy.name] = 1;
            else
                EnemySpawnData["" + MiniGameKinkyDungeonCheckpoint][e.Enemy.name] += 1;
        }
        if (KinkyDungeonState == "End") {
            if (NGP)
                KinkyDungeonNewGamePlus();
            else {
                MiniGameKinkyDungeonLevel = 1;
                MiniGameKinkyDungeonCheckpoint = "grv";
                KinkyDungeonState = "Game";
            }
        }
        if (KinkyDungeonEnemies.length < 1) {
            console.log(`Error, no enemies on floor ${MiniGameKinkyDungeonLevel}, iteration ${i}`);
            return false;
        }
        else if (MiniGameKinkyDungeonCheckpoint != KDDefaultJourney[Math.min(KDDefaultJourney.length - 1, Math.floor((MiniGameKinkyDungeonLevel) / KDLevelsPerCheckpoint))]) {
            console.log(`Error, wrong checkpoint on floor ${MiniGameKinkyDungeonLevel}, iteration ${i}: Found ${MiniGameKinkyDungeonCheckpoint}, Checkpoint should be ${Math.floor(MiniGameKinkyDungeonLevel / KDLevelsPerCheckpoint)}`);
            return false;
        }
    }
    console.log(EnemySpawnData);
    return true;
}
function KDTestjailer(iter) {
    let totals = {};
    for (let i = 0; i < iter; i++) {
        KDJailEvents.spawnGuard.trigger(KinkyDungeonJailGuard(), KinkyDungeonPlayerEntity.x, KinkyDungeonPlayerEntity.y);
        if (KinkyDungeonJailGuard()) {
            if (!totals[KinkyDungeonJailGuard().Enemy.name])
                totals[KinkyDungeonJailGuard().Enemy.name] = 1;
            else
                totals[KinkyDungeonJailGuard().Enemy.name] = totals[KinkyDungeonJailGuard().Enemy.name] + 1;
        }
        else {
            if (!totals.null)
                totals.null = 1;
            else
                totals.null = totals.null + 1;
        }
        KDSpliceIndex(KinkyDungeonEntities.indexOf(KinkyDungeonJailGuard()), 1);
        KDGameData.KinkyDungeonJailGuard = 0;
    }
    console.log(totals);
}
async function KDExportTranslationFile() {
    await sleep(1000);
    let file = "";
    for (let c of Object.values(TextScreenCache.cache)) {
        file = file + '\n' + c;
        file = file + '\n';
    }
    navigator.clipboard.writeText(file);
}
let KDBasicArmorWeight = 1.0;
let KDBasicArmorWeight_Cursed = 0.5;
let KDAdvancedArmorWeight = 1.5;
let KDAdvancedArmorWeight_Cursed = 1.0;
let KDBasicArmor = [
    { name: "Breastplate", minLevel: 0, weight: KDBasicArmorWeight,
        armor: "Breastplate",
        norestraint: [...KinkyDungeonGetCurses("Breastplate", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "Bustier", minLevel: 0, weight: KDBasicArmorWeight,
        armor: "Bustier",
        norestraint: [...KinkyDungeonGetCurses("Bustier", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "ChainTunic", minLevel: 0, weight: KDBasicArmorWeight * 0.7,
        armor: "ChainTunic",
        norestraint: [...KinkyDungeonGetCurses("ChainTunic", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "Bracers", minLevel: 0, weight: KDBasicArmorWeight,
        armor: "Bracers",
        norestraint: [...KinkyDungeonGetCurses("Bracers", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "LeatherGloves", minLevel: 0, weight: KDBasicArmorWeight,
        armor: "LeatherGloves",
        norestraint: [...KinkyDungeonGetCurses("LeatherGloves", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "Gauntlets", minLevel: 0, weight: KDBasicArmorWeight,
        armor: "Gauntlets",
        norestraint: [...KinkyDungeonGetCurses("Gauntlets", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "SteelBoots", minLevel: 0, weight: KDBasicArmorWeight,
        armor: "SteelBoots",
        norestraint: [...KinkyDungeonGetCurses("SteelBoots", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "LeatherBoots", minLevel: 0, weight: KDBasicArmorWeight,
        armor: "LeatherBoots",
        norestraint: [...KinkyDungeonGetCurses("LeatherBoots", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
];
let KDAdvancedArmor = [
    { name: "SteelArmor", minLevel: 0, weight: KDAdvancedArmorWeight,
        armor: "SteelArmor",
        norestraint: [...KinkyDungeonGetCurses("SteelArmor", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "SteelSkirt", minLevel: 0, weight: KDAdvancedArmorWeight,
        armor: "SteelSkirt",
        norestraint: [...KinkyDungeonGetCurses("SteelArmor", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "MageArmor", minLevel: 0, weight: KDAdvancedArmorWeight,
        armor: "MageArmor",
        norestraint: [...KinkyDungeonGetCurses("MageArmor", true)], message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
];
let KDBasicArmor_Cursed = [
    { name: "Breastplate_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed,
        armor: "Breastplate",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "Breastplate", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "Bustier_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed,
        armor: "Bustier",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "Bustier", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "ChainTunic_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed * 0.7,
        armor: "ChainTunic",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "ChainTunic", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "Bracers_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed,
        armor: "Bracers",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "Bracers", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "LeatherGloves_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed,
        armor: "LeatherGloves",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "LeatherGloves", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "Gauntlets_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed,
        armor: "Gauntlets",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "Gauntlets", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "SteelBoots_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed,
        armor: "SteelBoots",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "SteelBoots", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "LeatherBoots_Cursed", minLevel: 0, weight: KDBasicArmorWeight_Cursed,
        armor: "LeatherBoots",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "LeatherBoots", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
];
let KDAdvancedArmor_Cursed = [
    { name: "SteelArmor_Cursed", minLevel: 0, weight: KDAdvancedArmorWeight_Cursed,
        armor: "SteelArmor",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "SteelArmor", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "SteelSkirt_Cursed", minLevel: 0, weight: KDAdvancedArmorWeight_Cursed,
        armor: "SteelSkirt",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "SteelSkirt", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
    { name: "MageArmor_Cursed", minLevel: 0, weight: KDAdvancedArmorWeight_Cursed,
        armor: "MageArmor",
        curselevelmin: 0, curselevelmax: 10,
        unlockcurse: ["Basic"],
        norestraintcursed: "MageArmor", message: "LootChestArmor", messageColor: "lightblue", messageTime: 3, allFloors: true },
];
let KinkyDungeonLootTable = {
    "cursedrestraint": [
        ...KDBasicArmor_Cursed,
        ...KDAdvancedArmor_Cursed,
    ],
    "rubble": [
        { name: "smallgold", minLevel: 0, weight: 12, message: "LootRubbleSmallGold", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "knife", minLevel: 0, weight: 5.5, message: "LootRubbleKnife", messageColor: "lightgreen", messageTime: 3, allFloors: true, noweapon: ["Knife"] },
        { name: "pick", minLevel: 0, weight: 2.5, message: "LootRubbleLockpick", messageColor: "lightgreen", messageTime: 3, allFloors: true, prerequisites: ["fewpick"], },
        { name: "redkey", key: true, minLevel: 0, weight: 1, message: "LootRubbleRedKey", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "potion_mana", minLevel: 0, weight: 3, message: "LootPotionMana", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "potion_will", minLevel: 0, weight: 1, message: "LootPotionWill", messageColor: "#ff4444", messageTime: 3, allFloors: true },
        { name: "potion_stamina", minLevel: 0, weight: 4, message: "LootPotionStamina", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "potion_frigid", minLevel: 0, weight: 2, message: "LootPotionFrigid", messageColor: "lightgreen", messageTime: 3, allFloors: true },
    ],
    "shelf": [
        { name: "redkey", key: true, minLevel: 1, weight: 1, message: "LootBookshelfKey", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "bluekey", key: true, minLevel: 0, weight: 0.33, message: "LootBookshelfBlueKey", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "scroll_arms", minLevel: 0, weight: 1, message: "LootBookshelfScroll", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "scroll_legs", minLevel: 0, weight: 1, message: "LootBookshelfScroll", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "scroll_verbal", minLevel: 0, weight: 1, message: "LootBookshelfScroll", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "trap_book", minLevel: 1, weight: 5, message: "LootBookshelfTrap", messageColor: "#ff0000", messageTime: 3, allFloors: true },
    ],
    "pearl": [
        { name: "pearlReward", minLevel: 0, weight: 1, message: "LootPearlChest", messageColor: "lightblue", messageTime: 3, allFloors: true, prerequisites: ["pearlChest"], },
    ],
    "shadow": [
        { name: "slimeThrower", minLevel: 0, weapon: "Slimethrower", weight: 2, message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["Slimethrower"] },
        { name: "StaffDoll", minLevel: 0, weapon: "StaffDoll", weight: 2, message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["StaffDoll"] },
        { name: "staff_incineration", minLevel: 0, weight: .5, weapon: "StaffIncineration", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["StaffIncineration"] },
        { name: "staff_storms", minLevel: 0, weight: .5, weapon: "StaffStorm", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["StaffStorm"] },
        { name: "staff_frostbite", minLevel: 0, weight: .5, weapon: "StaffFrostbite", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["StaffFrostbite"] },
        { name: "staff_bind", minLevel: 0, weight: .5, weapon: "StaffBind", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["StaffBind"] },
        { name: "AncientCores", minLevel: 0, weight: 0.5, message: "LootChestAncientCores", messageColor: "yellow", messageTime: 3, allFloors: true, max: 1 },
        { name: "bluekey", minLevel: 0, weight: 0.5, message: "LootChestBlueKey", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "spell_points", magic: true, minLevel: 0, weight: 5, message: "LootChestSpellPoints", messageColor: "lightblue", messageTime: 3, allFloors: true, max: 1 },
        ...KDAdvancedArmor, ...KDAdvancedArmor_Cursed,
    ],
    "storage": [
        { name: "redkey", key: true, minLevel: 0, weight: 1, message: "LootChestRedKey", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "bola", minLevel: 0, weight: 3, message: "LootChestBola", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "bomb", minLevel: 0, weight: 2, message: "LootChestBomb", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "rope", minLevel: 0, weight: 1, weapon: "Rope", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["Rope"] },
    ],
    "blue": [
        { name: "spell_points", magic: true, minLevel: 0, weight: 1, message: "LootChestSpellPoints", messageColor: "lightblue", messageTime: 3, allFloors: true, max: 1 },
    ],
    "tutorial1": [
        { name: "trap_cuffs", minLevel: 1, weight: 1, lock: "Red", message: "LootChestTrapMagic", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemArms"], power: 2 },
    ],
    "tutorial2": [
        { name: "trap_armbinder", minLevel: 1, weight: 1, message: "LootChestTrapMagic", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemArms"], power: 6 },
    ],
    "chest": [
        { name: "gold", minLevel: 0, weight: 10, message: "LootChestGold", messageColor: "#ffff00", messageTime: 3, allFloors: true },
        { name: "magicknife", minLevel: 0, weight: 1.5, weapon: "EnchKnife", message: "LootChestMagicKnife", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["EnchKnife"] },
        { name: "bluekey", redspecial: 8.5, key: true, minLevel: 3, weight: 0.65, message: "LootChestBlueKey", messageColor: "lightgreen", messageTime: 3, allFloors: true },
        { name: "weapon_boltcutters", minlevel: 5, weight: 0.7, message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["BoltCutters"] },
        { name: "hammer", minLevel: 0, weight: 1, weapon: "Hammer", noweapon: ["Hammer"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "flail", minLevel: 0, weight: 1, weapon: "Flail", noweapon: ["Flail"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "axe", minLevel: 0, weight: 1, weapon: "Axe", noweapon: ["Axe"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "spear", minLevel: 0, weight: 1, weapon: "Spear", noweapon: ["Spear"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "sword", minLevel: 0, weight: 1, weapon: "Sword", noweapon: ["Sword"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "Dirk", minLevel: 0, weight: 1, weapon: "Dirk", noweapon: ["Dirk"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "Foil", minLevel: 0, weight: 0.5, weapon: "Foil", noweapon: ["Foil"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        ...KDBasicArmor, ...KDBasicArmor_Cursed,
        { name: "trap_plug", arousalMode: true, trap: true, minLevel: 1, weight: 1.5, message: "LootChestTrapMagicPlug", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemVulva", "alreadyBelted", "vibe"], power: 3 },
        { name: "trap_nipple", arousalMode: true, trap: true, minLevel: 1, weight: 1.5, message: "LootChestTrapMagicNipple", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemNipples", "alreadyBelted", "vibe"], power: 3 },
        { name: "potions_mana", minLevel: 0, weight: 1, message: "LootPotionsMana", messageColor: "lightblue", messageTime: 3, allFloors: true, prerequisites: ["lowmanapotions"] },
        { name: "manaorb", minLevel: 0, weight: 0.25, message: "LootManaOrb", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "potions_will", minLevel: 0, weight: 1, message: "LootPotionsWill", messageColor: "#ff4444", messageTime: 3, allFloors: true, prerequisites: ["lowwillpotions"] },
    ],
    "lost_items": [
        { name: "lost_items", minLevel: 0, weight: 999999999999, message: "LootCacheLostItems", messageColor: "lightgreen", messageTime: 3, allFloors: true, prerequisites: ["LostItems"] },
    ],
    "cache": [
        { name: "potions_many", minLevel: 0, weight: 0.001, message: "LootPotionsMedley", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "weapon_boltcutters", minLevel: 3, weight: 1, message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["BoltCutters"] },
        { name: "flamberge", minLevel: 3, weight: 0.8, weapon: "Flamberge", noweapon: ["Flamberge"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "Rapier", minLevel: 3, weight: 0.8, weapon: "Rapier", noweapon: ["Rapier"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "Katana", minLevel: 3, weight: 0.8, weapon: "Katana", noweapon: ["Katana"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffFlame", minLevel: 0, weight: 1, weapon: "StaffFlame", noweapon: ["StaffFlame"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffChain", minLevel: 0, weight: 1, weapon: "StaffChain", noweapon: ["StaffChain"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffGlue", minLevel: 0, weight: 1, weapon: "StaffGlue", noweapon: ["StaffGlue"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffElectric", minLevel: 0, weight: 1, weapon: "StaffElectric", noweapon: ["StaffElectric"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffPermafrost", minLevel: 0, weight: 1, weapon: "StaffPermafrost", noweapon: ["StaffPermafrost"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffDoll", minLevel: 5, weight: 0.25, weapon: "StaffDoll", goddess: "Latex", goddessWeight: 1.25, noweapon: ["StaffDoll"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffIncineration", minLevel: 5, weight: 1, weapon: "StaffIncineration", goddess: "Elements", goddessWeight: 0.75, noweapon: ["StaffIncineration"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffStorm", minLevel: 5, weight: 1, weapon: "StaffStorm", goddess: "Elements", goddessWeight: 0.75, noweapon: ["StaffStorm"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffFrostbite", minLevel: 5, weight: 1, weapon: "StaffElectric", goddess: "Elements", goddessWeight: 0.75, noweapon: ["StaffFrostbite"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "StaffBind", minLevel: 5, weight: 1, weapon: "StaffBind", goddess: "Rope", goddessWeight: 2.75, noweapon: ["StaffBind"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "Slimethrower", minLevel: 5, weight: 1, weapon: "Slimethrower", goddess: "Latex", goddessWeight: 1.25, noweapon: ["Slimethrower"], message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3, allFloors: true },
        ...KDBasicArmor, ...KDBasicArmor_Cursed,
    ],
    "gold": [
        { name: "MistressKey", minLevel: 0, weight: 6, message: "LootChestMistressKey", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "AncientCores", max: 1, minLevel: 0, weight: 7, count: 3, message: "LootChestAncientCores", messageColor: "yellow", messageTime: 3, allFloors: true, submissive: 50 },
        { name: "EnchantedBelt", arousalMode: true, minLevel: 0, weight: 4, message: "LootChestEnchantedBelt", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedBelt"] },
        { name: "EnchantedBra", arousalMode: true, minLevel: 0, weight: 4, message: "LootChestEnchantedBra", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedBra"] },
        { name: "EnchantedHeels", minLevel: 0, weight: 4, message: "LootChestEnchantedHeels", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedHeels"] },
        { name: "EnchantedAnkleCuffs", minLevel: 0, weight: 4, message: "LootChestEnchantedAnkleCuffs", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedAnkleCuffs", "EnchantedAnkleCuffs2"] },
        { name: "EnchantedBlindfold", minLevel: 3, weight: 4, message: "LootChestEnchantedBlindfold", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedBlindfold"] },
        { name: "EnchantedMuzzle", minLevel: 0, weight: 4, message: "LootChestEnchantedMuzzle", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedMuzzle"] },
        { name: "EnchantedMittens", minLevel: 3, weight: 4, message: "LootChestEnchantedMittens", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedMittens"] },
        { name: "EnchantedArmbinder", minlevel: 5, weight: 4, message: "LootChestEnchantedArmbinder", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedArmbinder"], submissive: 5 },
        { name: "EnchantedBallGag", minLevel: 0, weight: 4, message: "LootChestEnchantedBallGag", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["EnchantedBallGag"] },
        { name: "PotionCollar", minLevel: 1, weight: 10, message: "LootPotionCollar", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["PotionCollar"] },
    ],
    "lessergold": [
        { name: "scrolls_purity", minLevel: 0, weight: 1, message: "LootChestScrollsPurity", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "MistressKey", minLevel: 0, weight: 1, message: "LootChestMistressKey", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "AncientCores", max: 1, minLevel: 0, weight: 3, message: "LootChestAncientCores", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "magicknife", minLevel: 0, weight: 1, weapon: "EnchKnife", message: "LootChestMagicKnife", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["EnchKnife"] },
        { name: "Scrolls", minLevel: 0, weight: 2, message: "LootChestScrolls", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "spell_points", magic: true, minLevel: 3, weight: 3, message: "LootChestSpellPoints", messageColor: "lightblue", messageTime: 3, special: 100, allFloors: true, max: 1 },
        { name: "manaorbmany", minLevel: 0, weight: 1, message: "LootManaOrbMany", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "MagicSword", minLevel: 3, weight: 0.33, weapon: "MagicSword", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["MagicSword"] },
        { name: "MagicAxe", minLevel: 3, weight: 0.33, weapon: "MagicAxe", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["MagicAxe"] },
        { name: "MagicSpear", minLevel: 3, weight: 0.33, weapon: "MagicSpear", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["MagicSpear"] },
        { name: "MagicFlail", minLevel: 3, weight: 0.33, weapon: "MagicFlail", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["MagicFlail"] },
        { name: "MagicHammer", minLevel: 3, weight: 0.33, weapon: "MagicHammer", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["MagicHammer"] },
        { name: "IceBreaker", minLevel: 2, weight: 0.33, weapon: "IceBreaker", goddess: "Elements", goddessWeight: 3, message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["IceBreaker"] },
        { name: "StormBreaker", minLevel: 2, weight: 0.33, weapon: "StormBreaker", goddess: "Elements", goddessWeight: 3, message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["StormBreaker"] },
        { name: "DarkKatana", minLevel: 2, weight: 0.33, goddess: "Illusion", goddessWeight: 6, weapon: "DarkKatana", message: "LootChestWeapon", messageColor: "lightblue", messageTime: 3,
            allFloors: true, noweapon: ["DarkKatana"] },
        { name: "trap_plug2", arousalMode: true, trap: true, minlevel: 6, weight: 1.5, message: "LootChestTrapMagicPlug", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemVulva", "alreadyBelted", "vibe"], power: 3 },
        { name: "trap_plug2_torment", arousalMode: true, trap: true, lock: "Gold", minlevel: 11, weight: 1, message: "LootChestTrapMagicPlug", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemVulva", "alreadyBelted", "vibe"], power: 5 },
        { name: "trap_nipple2", arousalMode: true, trap: true, minlevel: 7, weight: 4, message: "LootChestTrapMagicNipple", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemNipples", "vibe"], power: 3 },
        { name: "PotionCollar", minLevel: 1, weight: 1.5, message: "LootPotionCollar", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["PotionCollar"] },
    ],
    "silver": [
        { name: "manaorb", minLevel: 0, weight: 4, message: "LootManaOrb", messageColor: "lightblue", messageTime: 3, allFloors: true },
        { name: "biggold", minLevel: 0, weight: 10, message: "LootChestGold", messageColor: "#ffff00", messageTime: 3, allFloors: true },
        { name: "magicknife", minLevel: 0, weight: 2.5, weapon: "EnchKnife", message: "LootChestMagicKnife", messageColor: "lightblue", messageTime: 3, allFloors: true, noweapon: ["EnchKnife"] },
        { name: "scrolls_basic", minLevel: 0, weight: 1.75, message: "LootChestScrollsBasic", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "scrolls_purity", minLevel: 0, weight: 0.75, message: "LootChestScrollsPurity", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "spell_illusion_low", magic: true, minLevel: 0, weight: 0.75, message: "LootChestSpell", messageColor: "lightblue", messageTime: 3, allFloors: true, prerequisites: ["UnlearnedIllusion", "lowlevel"] },
        { name: "spell_conjuration_low", magic: true, minLevel: 0, weight: 0.75, message: "LootChestSpell", messageColor: "lightblue", messageTime: 3, allFloors: true, prerequisites: ["UnlearnedConjure", "lowlevel"] },
        { name: "spell_elemental_low", magic: true, minLevel: 0, weight: 0.75, message: "LootChestSpell", messageColor: "lightblue", messageTime: 3, allFloors: true, prerequisites: ["UnlearnedElements", "lowlevel"] },
        { name: "trap_plug", arousalMode: true, trap: true, minlevel: 5, weight: 1.5, message: "LootChestTrapMagicPlug", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemVulva", "alreadyBelted", "vibe"], power: 3 },
        { name: "trap_plug_tease", arousalMode: true, trap: true, minlevel: 11, weight: 1, message: "LootChestTrapMagicPlug", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemVulva", "alreadyBelted", "vibe"], power: 4 },
        { name: "trap_plug_torment", arousalMode: true, trap: true, minlevel: 15, weight: 0.5, message: "LootChestTrapMagicPlug", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemVulva", "alreadyBelted", "vibe"], power: 5 },
        { name: "trap_plug_thunder", arousalMode: true, trap: true, minlevel: 15, weight: 0.5, message: "LootChestTrapMagicPlug", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemVulva", "alreadyBelted", "vibe"], power: 5 },
        { name: "trap_nipple", arousalMode: true, trap: true, minLevel: 2, weight: 2, message: "LootChestTrapMagicNipple", messageColor: "#ff0000", messageTime: 3, allFloors: true, prerequisites: ["Group_ItemNipples", "vibe"], power: 3 },
        { name: "potions_mana", minLevel: 0, weight: 3, message: "LootPotionsMana", messageColor: "lightblue", messageTime: 3, allFloors: true, prerequisites: ["lowmanapotions"] },
        { name: "potions_will", minLevel: 0, weight: 2, message: "LootPotionsWill", messageColor: "#ff4444", messageTime: 3, allFloors: true, prerequisites: ["lowwillpotions"] },
        { name: "potions_many", minLevel: 1, weight: 2, message: "LootPotionsMedley", messageColor: "lightblue", messageTime: 3, allFloors: true, prerequisites: ["lowpotions"] },
        { name: "grinder", minLevel: 1, weight: 2, message: "LootChestGrinder", messageColor: "yellow", messageTime: 3, allFloors: true },
        { name: "PotionCollar", minLevel: 1, weight: 0.5, message: "LootPotionCollar", messageColor: "yellow", messageTime: 3, allFloors: true, norestraint: ["PotionCollar"] },
    ],
};
let KDLootEvents = {
    "Armor": (Loot, Floor, Replacemsg, Lock) => {
        return {
            value: 0,
            Replacemsg: Replacemsg,
        };
    },
};
let KDMusicLoopTracksChance = {
    "AREA1-GRAVEYARD.ogg": 0.5,
    "AREA2-ANCIENTTOMBS.ogg": 0.5,
    "GENERIC-DOLLRACK.ogg": 0.15,
    "AREA4-MAGICLIBRARY.ogg": 0.5,
    "AREA5-UNDERGROUNDJUNGLE.ogg": 0.5,
    "AREA6-CRYSTALCAVE.ogg": 0.5,
    "AREA7-LOSTTEMPLE.ogg": 0.5,
    "AREA8-ORRERY.ogg": 0.7,
    "AREA9-BELLOWS.ogg": 0.5,
};
let KDCurrentSong = "";
let KDNewSong = "AREA1-GRAVEYARD.ogg";
let KDLastSong = "";
let KDCurrentLoops = 0;
let KDCurrentFade = 1;
let KDMusicFadeTime = 2500;
let KDMusicFadeInTime = 2500;
let KDMusicTickRate = 100;
let KDCurrentMusicSound = null;
let KDCurrentMusicSoundUpdate = null;
function KDGetCheckpoint() {
    return KinkyDungeonMapIndex[MiniGameKinkyDungeonCheckpoint] || 'grv';
}
let lastKDMusicTick = 0;
function KDUpdateMusic() {
    if (KDPatched) {
        KDCurrentMusicSoundUpdate = false;
        let KDMusic = KinkyDungeonMapParams[KDGetCheckpoint()].music;
        if (!KDNewSong) {
            let iter = 0;
            let maxiter = 2;
            KDNewSong = KDLastSong;
            while (iter < maxiter && KDNewSong == KDLastSong) {
                KDNewSong = KDGetByWeight(KDMusic);
                iter++;
            }
        }
        if (performance.now() - lastKDMusicTick < KDMusicTickRate)
            return;
        if (KDCurrentMusicSound) {
            if (!KDCurrentSong && KDNewSong != KDLastSong) {
                if (KDCurrentFade > 0) {
                    let dd = (performance.now() - lastKDMusicTick) / KDMusicFadeTime;
                    KDCurrentFade = Math.max(0, KDCurrentFade - dd);
                }
            }
            else {
                if (KDCurrentFade < 1) {
                    let dd = (performance.now() - lastKDMusicTick) / KDMusicFadeInTime;
                    KDCurrentFade = Math.min(1, KDCurrentFade + dd);
                }
            }
        }
        let globalVolume = KDToggles.Sound && KDToggles.Music ? KDMusicVolume * KDMusicVolumeMult : 0;
        if (globalVolume > 0 && (!KDCurrentMusicSound || KDCurrentMusicSound.ended || KDCurrentMusicSound.paused || (!KDCurrentSong && KDCurrentFade == 0))) {
            KDPlayMusic(KDNewSong, globalVolume);
        }
        else if (KDCurrentMusicSound && KDCurrentSong && !Object.keys(KDMusic).includes(KDCurrentSong)) {
            if (!KDCurrentMusicSoundUpdate)
                KDEndMusic();
        }
        if (KDCurrentMusicSound) {
            KDCurrentMusicSound.volume = Math.min(Player.AudioSettings.Volume * globalVolume, 1) * KDCurrentFade;
        }
        lastKDMusicTick = performance.now();
    }
}
function KDPlayMusic(Sound, Volume) {
    let audio = KDCurrentMusicSound || new Audio();
    let vol = Player.AudioSettings.Volume * (Volume != undefined ? Volume : 1.0);
    KDCurrentMusicSound = audio;
    KDCurrentMusicSoundUpdate = true;
    if (ServerURL == 'foobar') {
        audio.crossOrigin = "Anonymous";
        audio.src = remap("Music/" + (KDModFiles[Sound] || Sound));
    }
    else
        audio.src = "Music/" + (KDModFiles[Sound] || Sound);
    audio.volume = Math.min(vol, 1);
    audio.loop = false;
    audio.addEventListener('ended', function () {
        this.currentTime = 0;
        this.play();
        lastKDMusicTick = performance.now() - 100;
        if (KDRandom() < KDMusicLoopTracksChance[KDCurrentSong]) {
            KDCurrentLoops += 1;
        }
        else {
            KDCurrentSong = "";
            KDNewSong = "";
        }
    }, false);
    audio.play();
    KDCurrentLoops = 0;
    KDLastSong = Sound;
    KDCurrentSong = Sound;
    KDNewSong = "";
}
function KDEndMusic() {
    KDCurrentSong = "";
    KDNewSong = "";
    if (KDCurrentMusicSound) {
        KDCurrentMusicSound.pause();
        KDCurrentMusicSound.currentTime = 0;
        KDCurrentMusicSoundUpdate = true;
    }
}
function KDDelayedActionPrune(tags) {
    KDGameData.DelayedActions = KDGameData.DelayedActions ? KDGameData.DelayedActions.filter((action) => {
        for (let t of tags) {
            if (action.tags.includes(t))
                return false;
        }
        return true;
    }) : [];
}
function KDAddDelayedAction(action) {
    KDGameData.DelayedActions.push(Object.assign({}, action));
}
let KDDelayedActionUpdate = {
    "RequireWill": (action) => {
        if (!(KinkyDungeonStatWill > 0))
            action.time = 0;
    },
};
let KDDelayedActionCommit = {
    "Consumable": (action) => {
        if (KinkyDungeonGetInventoryItem(action.data.Name))
            KinkyDungeonUseConsumable(action.data.Name, action.data.Quantity);
    },
    "Armor": (action) => {
        if (KinkyDungeonGetInventoryItem(action.data.Name))
            KinkyDungeonUseConsumable(action.data.Name, action.data.Quantity);
    },
    "Struggle": (action) => {
        let dynamic = KDGetDynamicItem(action.data.group, action.data.index);
        let restraint = dynamic.restraint;
        let host = dynamic.host;
        if (restraint) {
            KinkyDungeonSetFlag("escaping", 2);
            let lockType = restraint.lock && KDLocks[restraint.lock] ? KDLocks[restraint.lock] : null;
            let struggleType = action.data.escapeData.struggleType;
            if (struggleType == "Struggle" || struggleType == "Remove" || struggleType == "Cut") {
                if (struggleType == "Cut")
                    restraint.cutProgress += action.data.amount;
                else
                    restraint.struggleProgress += action.data.amount;
                let progress = (restraint.struggleProgress || 0) + (restraint.cutProgress || 0);
                if (progress > 1)
                    KDSuccessRemove(struggleType, restraint, lockType, action.data.index, action.data.escapeData, host);
                else
                    KDStunTurns(1, true);
            }
            else if (struggleType == "Unlock") {
                restraint.unlockProgress += action.data.amount;
                if (restraint.unlockProgress > 1)
                    KDSuccessRemove(struggleType, restraint, lockType, action.data.index, action.data.escapeData, host);
                else
                    KDStunTurns(1, true);
            }
            else if (struggleType == "Pick") {
                restraint.pickProgress += action.data.amount;
                if (restraint.pickProgress > 1)
                    KDSuccessRemove(struggleType, restraint, lockType, action.data.index, action.data.escapeData, host);
                else
                    KDStunTurns(1, true);
            }
        }
    },
};
let KDModsLoaded = false;
let KDMods = {};
let KDModIndex = 0;
let KDModCount = 9;
let KDModSpacing = 50;
function KDDrawMods() {
    let count = 0;
    let keys = Object.keys(KDMods);
    for (let i = KDModIndex; i < keys.length && count < KDModCount; i++) {
        DrawTextKD(keys[i], 975, 370 + KDModSpacing * count, "#ffffff", KDTextGray2);
        DrawButtonKDEx("moddelete_" + i, (bdata) => {
            delete KDMods[keys[i]];
            return true;
        }, true, 1275, 350 + KDModSpacing * count, 200, 45, TextGet("KinkyDungeonDeleteMod"), "#ffffff", "");
        count++;
    }
}
function getFileInput() {
    let input = document.createElement('input');
    input.type = 'file';
    input.onchange = _this => {
        let files = Array.from(input.files);
        KDLoadMod(files);
    };
    input.click();
}
function KDLoadMod(files) {
    console.log(files);
    for (let f of files) {
        if (f && f.name) {
            KDMods[f.name] = f;
        }
    }
}
async function KDExecuteMods() {
    var _a, _b, _c, _d;
    KDAllModFiles = [];
    for (let file of Object.values(KDMods)) {
        let entries = await model.getEntries(file, {});
        if (entries && entries.length) {
            entries.forEach((entry, entryIndex) => {
                KDAllModFiles.push(entry);
            });
        }
    }
    for (let entry of KDAllModFiles) {
        console.log(entry);
        const controller = new AbortController();
        const signal = controller.signal;
        const blobURL = await model.getURL(entry, {
            password: undefined,
            onprogress: (index, max) => {
                console.log(`Loading progress: ${index},${max}`);
            },
            signal
        });
        console.log(blobURL);
        let blob = await fetch(blobURL).then(r => r.blob());
        console.log(blob);
        let reader = new FileReader();
        if (entry.filename.endsWith('.js') || entry.filename.endsWith('.ks')) {
            let file = new File([blob], entry.filename);
            reader.onload = function (event) {
                console.log("EXECUTING MOD FILE " + file.name);
                if (typeof event.target.result === "string")
                    eval(event.target.result);
            };
            reader.readAsText(file);
        }
        else {
            KDModFiles[KinkyDungeonRootDirectory + entry.filename] = URL.createObjectURL(blob);
            KDModFiles[KinkyDungeonRootDirectory + "" + entry.filename] = KDModFiles[KinkyDungeonRootDirectory + entry.filename];
            if ((_a = entry.filename) === null || _a === void 0 ? void 0 : _a.startsWith("Data/"))
                KDModFiles["Data/" + entry.filename] = URL.createObjectURL(blob);
            if ((_b = entry.filename) === null || _b === void 0 ? void 0 : _b.startsWith("Models/"))
                KDModFiles["Models/" + entry.filename] = URL.createObjectURL(blob);
            if ((_c = entry.filename) === null || _c === void 0 ? void 0 : _c.startsWith("TextureAtlas/"))
                KDModFiles["TextureAtlas/" + entry.filename] = URL.createObjectURL(blob);
            if ((_d = entry.filename) === null || _d === void 0 ? void 0 : _d.startsWith("Music/"))
                KDModFiles["Music/" + entry.filename] = URL.createObjectURL(blob);
        }
    }
    if (KDAllModFiles.length > 0)
        KDModsLoaded = true;
    KinkyDungeonRefreshRestraintsCache();
    KinkyDungeonRefreshEnemiesCache();
}
if (typeof TransformStream == "undefined") {
    const script = document.createElement("script");
    script.src = "lib/web-streams-polyfill.min.js";
    document.body.appendChild(script);
}
const model = (() => {
    return {
        getEntries(file, options) {
            return (new zip.ZipReader(new zip.BlobReader(file))).getEntries(options);
        },
        async getURL(entry, options) {
            return URL.createObjectURL(await entry.getData(new zip.BlobWriter(), options));
        },
        getEntryFile: function (entry, creationMethod, onend, onprogress) {
            var writer, zipFileEntry;
            function getData() {
                entry.getData(writer, function (blob) {
                    var blobURL = creationMethod == "Blob" ? URL.createObjectURL(blob) : zipFileEntry.toURL();
                    onend(blobURL);
                }, onprogress);
            }
            if (creationMethod == "Blob") {
                writer = new zip.BlobWriter();
                getData();
            }
            else {
                console.log("No blob");
            }
        }
    };
})();
var PIXIapp = new PIXI.Application({
    antialias: false,
    width: 2000,
    height: 1000,
});
document.body.appendChild(PIXIapp.view);
PIXIapp.stage.addChild(kdcanvas);
PIXIapp.stage.addChild(kdui);
function AssetGet(arg1, arg2, arg3) {
    return undefined;
}
window.onload = function () {
    KinkyDungeonRootDirectory = "Game/";
    ServerURL = "foobar";
    CommonIsMobile = CommonDetectMobile();
    TranslationLoad();
    DrawLoad();
    CommonSetScreen("MiniGame", "KinkyDungeon");
    Character = [];
    CharacterNextId = 1;
    CharacterReset(0, "Female3DCG");
    Player.ArousalSettings = {};
    Player.ArousalSettings.VFXFilter = "VFXFilterHeavy";
    Player.OnlineSharedSettings = {};
    Player.OnlineSharedSettings.ItemsAffectExpressions = true;
    Player.AudioSettings = {};
    Player.AudioSettings.Volume = 1;
    Player.ImmersionSettings = {};
    CurrentCharacter = null;
    KinkyDungeonKeybindings = {
        Down: "KeyS",
        DownLeft: "KeyZ",
        DownRight: "KeyC",
        Left: "KeyA",
        Right: "KeyD",
        Skip: "Space",
        Spell1: "Digit1",
        Spell2: "Digit2",
        Spell3: "Digit3",
        Spell4: "Digit4",
        Spell5: "Digit5",
        Up: "KeyW",
        UpLeft: "KeyQ",
        UpRight: "KeyE",
        Wait: "KeyX",
    };
    if (localStorage.getItem("KinkyDungeonKeybindings") && JSON.parse(localStorage.getItem("KinkyDungeonKeybindings"))) {
        KinkyDungeonKeybindings = JSON.parse(localStorage.getItem("KinkyDungeonKeybindings"));
    }
    KinkyDungeonLoad();
    PIXIapp.ticker.add(() => {
        let Timestamp = performance.now();
        DrawProcess(Timestamp);
        TimerRunInterval = Timestamp - TimerLastTime;
        TimerLastTime = Timestamp;
        CurrentTime = CurrentTime + TimerRunInterval;
        if (TimerLastCycleCall + 1700 <= CommonTime()) {
            TimerLastCycleCall = CommonTime();
        }
    });
};
let TimerRunInterval = 0;
let TimerLastTime = 0;
let CurrentTime = 0;
let TimerLastCycleCall = 0;
function MainRun(Timestamp) {
    DrawProcess(Timestamp);
    TimerRunInterval = Timestamp - TimerLastTime;
    TimerLastTime = Timestamp;
    CurrentTime = CurrentTime + TimerRunInterval;
    if (TimerLastCycleCall + 1700 <= CommonTime()) {
        TimerLastCycleCall = CommonTime();
    }
    requestAnimationFrame(MainRun);
}
function KeyDown(event) {
    if (event.repeat)
        return;
    KeyPress = event.keyCode || event.which;
    CommonKeyDown(event);
}
function Click(event) {
    if (!CommonIsMobile) {
        MouseMove(event);
        CommonClick(event);
    }
}
function TouchStart(event) {
    if (CommonIsMobile && PIXICanvas) {
        TouchMove(event.touches[0]);
        CommonClick(event);
        CommonTouchList = event.touches;
    }
}
function TouchEnd(event) {
    if (CommonIsMobile && PIXICanvas)
        CommonTouchList = event.touches;
}
function TouchMove(touch) {
    if (PIXICanvas) {
        MouseX = Math.round((touch.pageX - PIXICanvas.offsetLeft) * 2000 / PIXICanvas.clientWidth);
        MouseY = Math.round((touch.pageY - PIXICanvas.offsetTop) * 1000 / PIXICanvas.clientHeight);
    }
}
function MouseMove(event) {
    if (PIXICanvas) {
        MouseX = Math.round(event.offsetX * 2000 / PIXICanvas.clientWidth);
        MouseY = Math.round(event.offsetY * 1000 / PIXICanvas.clientHeight);
    }
}
function LoseFocus(event) {
    if (event.relatedTarget || event.toElement) {
        MouseX = -1;
        MouseY = -1;
    }
}
PIXI.Assets.init();
let preloadList = [
    "TextureAtlas/game0.json",
    "TextureAtlas/atlas0.json",
];
let lastProgress = 0;
function incrementProgress(amount) {
    return (progress) => {
        console.log(progress);
        if (progress < lastProgress)
            lastProgress = 0;
        KDLoadingDone += (progress - lastProgress) * amount;
        lastProgress = progress;
    };
}
async function LoadTextureAtlas(list, preload = false) {
    for (let dataFile of list) {
        console.log("Found atlas: " + dataFile);
        let amount = 100;
        KDLoadingMax += amount;
    }
    for (let dataFile of list) {
        console.log("Loading" + dataFile);
        let amount = 100;
        let result = preload ? PIXI.Assets.backgroundLoad(dataFile) : PIXI.Assets.load(dataFile);
        result.then(() => {
            console.log(PIXI.Cache);
            KDLoadingDone += amount;
        });
    }
}
LoadTextureAtlas(preloadList);
function ToNamedMap(Named) {
    let list = {};
    for (let n of Named) {
        list[n.Name] = n;
    }
    return list;
}
function ToMap(Array, ...Extra) {
    if (Extra) {
        Array = [...Array, ...Extra];
    }
    let list = {};
    for (let n of Array) {
        list[n] = true;
    }
    return list;
}
function ToMapSubtract(Array, Subtract) {
    let list = {};
    for (let n of Array) {
        list[n] = true;
    }
    for (let n of Subtract) {
        delete list[n];
    }
    return list;
}
function ToMapDefault(Array, Default = "") {
    let list = {};
    for (let n of Array) {
        list[n] = Default;
    }
    return list;
}
let LAYERS_BASE = [
    "Hat",
    "Headband",
    "HairFront",
    "Mask",
    "Circlet",
    "Brows",
    "Hair",
    "Blindfold",
    "Gag",
    "Eyes",
    "Mouth",
    "Blush",
    "Head",
    "HatBack",
    "Shoulders",
    "HairMid",
    "CollarAcc",
    "Collar",
    "ForeSleeveLeft",
    "ForeSleeveDecoLeft",
    "GloveLeft",
    "ForeHandLeft",
    "ForeArmLeft",
    "ForeSleeveRight",
    "ForeSleeveDecoRight",
    "GloveRight",
    "ForeHandRight",
    "ForeArmRight",
    "ChestDeco",
    "ChestStraps",
    "Chestplate",
    "BeltCharm",
    "Belt",
    "BeltDeco",
    "Greaves",
    "Bustier",
    "Harness",
    "Shirt",
    "Straps",
    "NecklaceCharm",
    "Necklace",
    "Bra",
    "Chest",
    "Underbust",
    "Underarms",
    "Corset",
    "SkirtDeco",
    "Skirt",
    "PantLeft",
    "PantRight",
    "Pants",
    "BeltBack",
    "SleeveDecoLeft",
    "SleeveLeft",
    "HandLeft",
    "ArmLeft",
    "ShoeLeft",
    "ShoeRight",
    "StockingLeft",
    "StockingRight",
    "Panties",
    "CorsetLiner",
    "Bodysuit",
    "FootLeft",
    "LegLeft",
    "FootRight",
    "LegRight",
    "FootLeftHogtie",
    "FootRightKneel",
    "Butt",
    "TorsoUpper",
    "TorsoLower",
    "Torso",
    "SleeveDecoRight",
    "SleeveRight",
    "HandRight",
    "ArmRight",
    "BeltFarBack",
    "Coat",
    "Cape",
    "HairBack",
];
let LayerProperties = {
    Eyes: {
        Parent: "Head",
    },
    Hair: {
        Parent: "Head",
    },
    HairFront: {
        Parent: "Head",
    },
    HairMiddle: {
        Parent: "Head",
    },
    HairBack: {
        Parent: "Head",
    },
    Mouth: {
        Parent: "Head",
    },
    Ears: {
        Parent: "Head",
    },
    Nose: {
        Parent: "Head",
    },
};
let LAYER_INCREMENT = 1000;
let MODELHEIGHT = 3500;
let MODELWIDTH = 2480;
let MODEL_SCALE = 1000 / MODELHEIGHT;
let MODEL_XOFFSET = Math.floor((-MODELWIDTH * MODEL_SCALE) / 2);
let ARMPOSES = ["Free", "Boxtie", "Wristtie", "Yoked", "Front"];
let FOREARMPOSES = ["Front"];
let HANDRIGHTPOSES = ["Free", "Boxtie", "Yoked"];
let HANDLEFTPOSES = ["Free", "Yoked"];
let FOREHANDRIGHTPOSES = ["Front"];
let FOREHANDLEFTPOSES = ["Front"];
let LEGPOSES = ["Spread", "Closed", "Kneel", "Hogtie"];
let FOOTRIGHTPOSES = ["Spread", "Closed"];
let FOOTLEFTPOSES = ["Spread", "Closed", "Kneel"];
let KNEELPOSES = ["Kneel"];
let STANDPOSES = ["Spread", "Closed"];
let EYETYPES = ["Neutral", "Surprised", "Dazed", "Closed", "Angry"];
let EYEPOSES = EYETYPES.map((pose) => { return "Eyes" + pose; });
let EYE2POSES = EYETYPES.map((pose) => { return "Eyes2" + pose; });
let BROWTYPES = ["Neutral", "Angry", "Annoyed", "Sad", "Surprised"];
let BROWPOSES = BROWTYPES.map((pose) => { return "Brows" + pose; });
let BROW2POSES = BROWTYPES.map((pose) => { return "Brows2" + pose; });
let MOUTHPOSES = ["MouthNeutral", "MouthDazed", "MouthDistracted", "MouthEmbarrassed", "MouthFrown", "MouthSmile", "MouthSurprised", "MouthPout"];
let BLUSHPOSES = ["BlushLow", "BlushMedium", "BlushHigh", "BlushExtreme"];
let STANDARD_DEFAULTS = ["Hogtie"];
let PoseProperties = {
    Hogtie: {
        rotation: -95,
        pri_rotation: 1,
        offset_x: 0.32,
        offset_y: 0.1,
        pri_offset: 2,
        global_default: "Closed",
        mods: [{
                Layer: "Head",
                rotation: 30,
                rotation_x_anchor: 1190 / MODELWIDTH,
                rotation_y_anchor: 690 / MODELHEIGHT,
                offset_x: 1190 / MODELWIDTH,
                offset_y: 690 / MODELHEIGHT,
            }],
    },
    Kneel: {
        offset_y: 0.15,
        pri_offset: 1,
    },
    Front: {
        global_default: "Boxtie",
    },
};
function ModelGetMaxPose(Poses, CheckVar, FilterVar = null) {
    let maxPose = "";
    for (let p of Object.keys(Poses)) {
        if (PoseProperties[p] && PoseProperties[p][CheckVar] != undefined
            && (!FilterVar || PoseProperties[p][FilterVar])
            && (!maxPose || PoseProperties[p][CheckVar] > PoseProperties[maxPose][CheckVar])) {
            maxPose = p;
        }
    }
    return maxPose;
}
function ModelGetPoseOffsets(Poses) {
    var _a, _b, _c, _d;
    let pose = ModelGetMaxPose(Poses, "pri_offset");
    let x = 0;
    let y = 0;
    if ((_a = PoseProperties[pose]) === null || _a === void 0 ? void 0 : _a.offset_x)
        x = (_b = PoseProperties[pose]) === null || _b === void 0 ? void 0 : _b.offset_x;
    if ((_c = PoseProperties[pose]) === null || _c === void 0 ? void 0 : _c.offset_y)
        y = (_d = PoseProperties[pose]) === null || _d === void 0 ? void 0 : _d.offset_y;
    return { X_Offset: x, Y_Offset: y };
}
function ModelGetPoseRotation(Poses) {
    var _a, _b, _c, _d, _e, _f;
    let pose = ModelGetMaxPose(Poses, "pri_rotation");
    let x = 0.5;
    let y = 0.5;
    let r = 0;
    if ((_a = PoseProperties[pose]) === null || _a === void 0 ? void 0 : _a.rotation_x_anchor)
        x = (_b = PoseProperties[pose]) === null || _b === void 0 ? void 0 : _b.rotation_x_anchor;
    if ((_c = PoseProperties[pose]) === null || _c === void 0 ? void 0 : _c.rotation_y_anchor)
        y = (_d = PoseProperties[pose]) === null || _d === void 0 ? void 0 : _d.rotation_y_anchor;
    if ((_e = PoseProperties[pose]) === null || _e === void 0 ? void 0 : _e.rotation)
        r = (_f = PoseProperties[pose]) === null || _f === void 0 ? void 0 : _f.rotation;
    return { rotation: r, X_Anchor: x, Y_Anchor: y };
}
function ModelGetPoseMods(Poses) {
    var _a;
    let mods = {};
    for (let p of Object.keys(Poses)) {
        if ((_a = PoseProperties[p]) === null || _a === void 0 ? void 0 : _a.mods) {
            for (let mod of PoseProperties[p].mods) {
                if (!mods[mod.Layer])
                    mods[mod.Layer] = [];
                mods[mod.Layer].push(mod);
            }
        }
    }
    return mods;
}
let KDCanvasRenderMap = new Map();
KDCanvasRenderMap.set(KinkyDungeonCanvasPlayer, "temp");
function InitLayers(layers) {
    let table = {};
    let count = 0;
    for (let l of layers) {
        table[l] = count * LAYER_INCREMENT;
        count += 1;
    }
    return table;
}
let ModelLayers = InitLayers(LAYERS_BASE);
let ModelDefs = {};
function AddModel(Model) {
    ModelDefs[Model.Name] = Model;
}
let KDCurrentModels = new Map();
class ModelContainer {
    constructor(Character, Models, Containers, ContainersDrawn, Poses) {
        this.Character = Character;
        this.Containers = Containers;
        this.ContainersDrawn = ContainersDrawn;
        this.Models = Models;
        this.Poses = Poses;
        this.HighestPriority = {};
        this.Update = new Map();
    }
    addModel(Model) {
        this.Models.set(Model.Name, JSON.parse(JSON.stringify(Model)));
    }
    removeModel(Model) {
        this.Models.delete(Model);
    }
}
function ToLayerMap(Layers) {
    return ToNamedMap(Layers);
}
function GetModelLayers(ModelName) {
    if (ModelDefs[ModelName]) {
        return Object.values(ModelDefs[ModelName].Layers);
    }
    return [];
}
function DisposeCharacter(C) {
    if (KDCurrentModels.get(C)) {
        for (let Container of KDCurrentModels.get(C).Containers.values()) {
            Container.Container.destroy();
            kdcanvas.removeChild(Container);
        }
    }
}
function DrawCharacter(C, X, Y, Zoom, IsHeightResizeAllowed = true, DrawCanvas = null, Blend = PIXI.SCALE_MODES.LINEAR, StartMods = []) {
    let MC = !KDCurrentModels.get(C) ? new ModelContainer(C, new Map(), new Map(), new Map(), KDGeneratePoseArray()) : KDCurrentModels.get(C);
    if (MC.Models.size == 0)
        UpdateModels(MC);
    let containerID = `${X},${Y},${Zoom}`;
    if (!MC.Containers.get(containerID)) {
        let Container = {
            Container: new PIXI.Container(),
            SpritesDrawn: new Map(),
            SpriteList: new Map(),
        };
        MC.Containers.set(containerID, Container);
        kdcanvas.addChild(Container.Container);
        Container.Container.sortableChildren = true;
    }
    if (!MC.ContainersDrawn.get(containerID)) {
        MC.ContainersDrawn.set(containerID, MC.Containers.get(containerID));
        MC.Update.delete(containerID);
    }
    if (!MC.Update.get(containerID)) {
        let oldBlend = PIXI.BaseTexture.defaultOptions.scaleMode;
        PIXI.BaseTexture.defaultOptions.scaleMode = Blend;
        DrawCharacterModels(MC, X + Zoom * MODEL_SCALE * MODELWIDTH / 2, Y + Zoom * MODEL_SCALE * MODELHEIGHT / 2, (Zoom * MODEL_SCALE) || MODEL_SCALE, StartMods, MC.Containers.get(containerID));
        MC.Update.set(containerID, true);
        let Container = MC.Containers.get(containerID);
        for (let sprite of Container.SpriteList.entries()) {
            if ((!Container.SpritesDrawn.has(sprite[0]) && sprite[1])) {
                sprite[1].parent.removeChild(sprite[1]);
                Container.SpriteList.delete(sprite[0]);
                sprite[1].destroy();
            }
        }
        Container.SpritesDrawn.clear();
        PIXI.BaseTexture.defaultOptions.scaleMode = oldBlend;
    }
    if (!KDCurrentModels.get(C)) {
        KDCurrentModels.set(C, MC);
    }
}
let DrawModel = DrawCharacter;
function DrawCharacterModels(MC, X, Y, Zoom, StartMods, ContainerContainer) {
    var _a;
    let Models = new Map(MC.Models.entries());
    MC.HighestPriority = {};
    for (let m of Models.values()) {
        for (let l of Object.values(m.Layers)) {
            if (!l.NoOverride)
                MC.HighestPriority[l.Layer] = Math.max(MC.HighestPriority[l.Layer] || -500, l.Pri || -500);
        }
    }
    let { X_Offset, Y_Offset } = ModelGetPoseOffsets(MC.Poses);
    let { rotation, X_Anchor, Y_Anchor } = ModelGetPoseRotation(MC.Poses);
    let mods = ModelGetPoseMods(MC.Poses);
    ContainerContainer.Container.angle = rotation;
    ContainerContainer.Container.pivot.x = MODELWIDTH * Zoom * X_Anchor;
    ContainerContainer.Container.pivot.y = MODELHEIGHT * Zoom * Y_Anchor;
    ContainerContainer.Container.x = X + (MODEL_XOFFSET + MODELWIDTH * X_Offset) * Zoom;
    ContainerContainer.Container.y = Y + (MODELHEIGHT * Y_Offset) * Zoom;
    for (let m of StartMods) {
        if (!mods[m.Layer])
            mods[m.Layer] = [];
        mods[m.Layer].push(m);
    }
    let drawLayers = {};
    for (let m of Models.values()) {
        for (let l of Object.values(m.Layers)) {
            drawLayers[m.Name + "," + l.Name] = ModelDrawLayer(MC, m, l, MC.Poses);
        }
    }
    for (let m of Models.values()) {
        for (let l of Object.values(m.Layers)) {
            if (drawLayers[m.Name + "," + l.Name] && !ModelLayerHidden(drawLayers, MC, m, l, MC.Poses)) {
                let ox = 0;
                let oy = 0;
                let ax = 0;
                let ay = 0;
                let sx = 1;
                let sy = 1;
                let rot = 0;
                let layer = l.Layer;
                while (layer) {
                    let mod_selected = mods[layer] || [];
                    for (let mod of mod_selected) {
                        ox = mod.offset_x || ox;
                        oy = mod.offset_y || oy;
                        ax = mod.rotation_x_anchor || ax;
                        ay = mod.rotation_y_anchor || ay;
                        sx *= mod.scale_x || 1;
                        sy *= mod.scale_y || 1;
                        rot += mod.rotation || 0;
                    }
                    layer = (_a = LayerProperties[layer]) === null || _a === void 0 ? void 0 : _a.Parent;
                }
                let fh = m.Filters ? (m.Filters[l.InheritColor || l.Name] ? FilterHash(m.Filters[l.InheritColor || l.Name]) : "") : "";
                let filter = m.Filters ? (m.Filters[l.InheritColor || l.Name] ?
                    (KDAdjustmentFilterCache.get(fh) || [new __filters.AdjustmentFilter(m.Filters[l.InheritColor || l.Name])])
                    : undefined) : undefined;
                if (filter && !KDAdjustmentFilterCache.get(fh))
                    KDAdjustmentFilterCache.set(FilterHash(m.Filters[l.InheritColor || l.Name]), filter);
                let img = ModelLayerString(m, l, MC.Poses);
                KDDraw(ContainerContainer.Container, ContainerContainer.SpriteList, `layer_${m.Name}_${l.Name}_${img}_${fh}`, img, ox * MODELWIDTH * Zoom, oy * MODELHEIGHT * Zoom, undefined, undefined, rot * Math.PI / 180, {
                    zIndex: -ModelLayers[l.Layer] + (l.Pri || 0),
                    anchorx: (ax - (l.OffsetX / MODELWIDTH || 0)) * (l.AnchorModX || 1),
                    anchory: (ay - (l.OffsetY / MODELHEIGHT || 0)) * (l.AnchorModY || 1),
                    scalex: sx != 1 ? sx : undefined,
                    scaley: sy != 1 ? sy : undefined,
                    filters: filter,
                    cacheAsBitmap: filter != undefined,
                }, false, ContainerContainer.SpritesDrawn, Zoom);
            }
        }
    }
}
function FilterHash(filter) {
    let str = "";
    for (let f of Object.values(filter))
        str = str + "_" + Math.round(f * 1000);
    return str;
}
let KDAdjustmentFilterCache = new Map();
function ModelDrawLayer(MC, Model, Layer, Poses) {
    if (Layer.HideWhenOverridden) {
        if (Layer.HideOverrideLayerMulti) {
            for (let LL of Layer.HideOverrideLayerMulti) {
                let priTest = MC.HighestPriority[LL];
                if (priTest > Layer.Pri)
                    return false;
            }
        }
        else {
            let priTest = MC.HighestPriority[Layer.HideOverrideLayer || Layer.Layer];
            if (priTest > Layer.Pri)
                return false;
        }
    }
    if (Layer.HidePoses) {
        for (let p of Object.keys(Poses)) {
            if (Layer.HidePoses[p]) {
                return false;
            }
        }
    }
    if (Layer.Poses) {
        let found = false;
        for (let p of Object.keys(Poses)) {
            if (Layer.Poses[p]) {
                found = true;
                break;
            }
        }
        if (!found)
            return false;
    }
    return true;
}
function ModelLayerHidden(drawLayers, MC, Model, Layer, Poses) {
    if (Layer.TieToLayer) {
        if (!drawLayers[Model.Name + "," + Layer.Name])
            return true;
    }
    return false;
}
function ModelLayerString(Model, Layer, Poses) {
    return `Models/${Model.Folder}/${LayerSprite(Layer, Poses)}.png`;
}
function LayerSprite(Layer, Poses) {
    let pose = "";
    let foundPose = false;
    let cancel = false;
    if (Layer.MorphPoses) {
        for (let dp of Object.entries(Layer.MorphPoses)) {
            if (Poses[dp[0]] != undefined) {
                pose = dp[1];
                cancel = true;
                foundPose = true;
                break;
            }
        }
    }
    if (!Layer.Invariant) {
        if (Layer.Poses && !cancel) {
            for (let p of Object.keys(Layer.Poses)) {
                if (Poses[p] != undefined) {
                    pose =
                        ((!(Layer.GlobalDefaultOverride && Layer.GlobalDefaultOverride[p])
                            && PoseProperties[p])
                            ? PoseProperties[p].global_default
                            : p)
                            || p;
                    foundPose = true;
                    break;
                }
            }
        }
        if (!foundPose && !cancel && Layer.GlobalDefaultOverride) {
            for (let p of Object.keys(Layer.GlobalDefaultOverride)) {
                if (Poses[p] != undefined) {
                    pose = p;
                    break;
                }
            }
        }
    }
    if (Layer.AppendPose) {
        for (let p of Object.keys(Layer.AppendPose)) {
            if (Poses[p] != undefined && (!Layer.AppendPoseRequire || Layer.AppendPoseRequire[p])) {
                pose = pose + p;
                break;
            }
        }
    }
    return (Layer.Sprite != undefined ? Layer.Sprite : Layer.Name) + pose;
}
function UpdateModels(MC) {
    MC.Models = new Map();
    MC.Update.clear();
    if (!MC.Models.get("Body"))
        MC.addModel(ModelDefs.Body);
    let appearance = MC.Character.Appearance;
    for (let A of appearance) {
        if (A.Model) {
            MC.addModel(A.Model);
        }
    }
}
function KDGetColorableLayers(Model) {
    let ret = [];
    for (let layer of Object.values(Model.Layers)) {
        if (!layer.NoColorize && !layer.InheritColor) {
            ret.push(layer.Name);
        }
    }
    return ret;
}
function KDGeneratePoseArray(ArmsPose = undefined, LegsPose = undefined, EyesPose = undefined, BrowsPose = undefined, BlushPose = undefined, MouthPose = undefined, Eyes2Pose = undefined, Brows2Pose = undefined, ExtraPose = undefined) {
    let poses = {};
    poses[ArmsPose || "Free"] = true;
    poses[LegsPose || "Spread"] = true;
    poses[EyesPose || "EyesNeutral"] = true;
    poses[BrowsPose || "BrowsNeutral"] = true;
    poses[BlushPose || "BlushNone"] = true;
    poses[MouthPose || "MouthNeutral"] = true;
    poses[(Eyes2Pose || EYE2POSES[EYEPOSES.indexOf(EyesPose)] || "Eyes2Neutral")] = true;
    poses[(Brows2Pose || BROW2POSES[BROWPOSES.indexOf(BrowsPose)] || "Brows2Neutral")] = true;
    if (ExtraPose) {
        for (let p of ExtraPose) {
            poses[p] = true;
        }
    }
    return poses;
}
function KDGetPoseOfType(C, Type) {
    var _a;
    let checkArray = [];
    switch (Type) {
        case "Arms":
            checkArray = ARMPOSES;
            break;
        case "Legs":
            checkArray = LEGPOSES;
            break;
        case "Eyes":
            checkArray = EYEPOSES;
            break;
        case "Eyes2":
            checkArray = EYE2POSES;
            break;
        case "Brows":
            checkArray = BROWPOSES;
            break;
        case "Brows2":
            checkArray = BROW2POSES;
            break;
        case "Blush":
            checkArray = BLUSHPOSES;
            break;
        case "Mouth":
            checkArray = MOUTHPOSES;
            break;
    }
    if ((_a = KDCurrentModels.get(C)) === null || _a === void 0 ? void 0 : _a.Poses)
        for (let p of checkArray) {
            if (KDCurrentModels.get(C).Poses[p]) {
                return p;
            }
        }
    return "";
}
AddModel({
    Name: "KoiEyes",
    Folder: "FaceKoi",
    TopLevel: true,
    Group: "Eyes",
    Categories: ["Eyes", "Face"],
    Layers: ToLayerMap([
        { Name: "Eyes", Layer: "Eyes", Pri: 0,
            Sprite: "",
            OffsetX: 942,
            OffsetY: 200,
            AnchorModX: MODELWIDTH / 641,
            AnchorModY: MODELHEIGHT / 664,
            Poses: ToMap(EYEPOSES),
        },
        { Name: "Eyes2", Layer: "Eyes", Pri: 0,
            Sprite: "",
            OffsetX: 942,
            OffsetY: 200,
            AnchorModX: MODELWIDTH / 641,
            AnchorModY: MODELHEIGHT / 664,
            Poses: ToMap(EYE2POSES),
        },
    ])
});
AddModel({
    Name: "KoiBrows",
    Folder: "FaceKoi",
    TopLevel: true,
    Group: "Brows",
    Categories: ["Eyes", "Face"],
    Layers: ToLayerMap([
        { Name: "Brows", Layer: "Brows", Pri: 0,
            Sprite: "",
            OffsetX: 942,
            OffsetY: 200,
            AnchorModX: MODELWIDTH / 641,
            AnchorModY: MODELHEIGHT / 664,
            Poses: ToMap(BROWPOSES),
        },
        { Name: "Brows2", Layer: "Brows", Pri: 0,
            Sprite: "",
            OffsetX: 942,
            OffsetY: 200,
            AnchorModX: MODELWIDTH / 641,
            AnchorModY: MODELHEIGHT / 664,
            Poses: ToMap(BROW2POSES),
        },
    ])
});
AddModel({
    Name: "KoiMouth",
    Folder: "FaceKoi",
    TopLevel: true,
    Group: "Mouth",
    Categories: ["Mouth", "Face"],
    Layers: ToLayerMap([
        { Name: "Mouth", Layer: "Mouth", Pri: 0,
            Sprite: "",
            OffsetX: 942,
            OffsetY: 200,
            AnchorModX: MODELWIDTH / 641,
            AnchorModY: MODELHEIGHT / 664,
            Poses: ToMap(MOUTHPOSES),
        },
    ])
});
AddModel({
    Name: "KoiBlush",
    Folder: "FaceKoi",
    TopLevel: true,
    Group: "Blush",
    Categories: ["Face"],
    Layers: ToLayerMap([
        { Name: "Blush", Layer: "Blush", Pri: 0,
            Sprite: "",
            OffsetX: 942,
            OffsetY: 200,
            AnchorModX: MODELWIDTH / 641,
            AnchorModY: MODELHEIGHT / 664,
            Poses: ToMap(BLUSHPOSES),
        },
    ])
});
AddModel({
    Name: "Braid",
    Folder: "Hair",
    TopLevel: true,
    Group: "Hair",
    Categories: ["Hairstyles"],
    Layers: ToLayerMap([
        { Name: "Braid", Layer: "Hair", Pri: 0,
        },
        { Name: "BraidBack", Layer: "HairBack", Pri: 0,
        },
    ])
});
AddModel({
    Name: "Ahoge",
    Folder: "Hair",
    TopLevel: true,
    Group: "Hair",
    Categories: ["Hairstyles"],
    Layers: ToLayerMap([
        { Name: "Ahoge", Layer: "Hair", Pri: 0,
            HideWhenOverridden: true,
            HideOverrideLayer: "Hat",
        },
    ])
});
AddModel({
    Name: "Body",
    TopLevel: true,
    Categories: ["Body"],
    Folder: "Body",
    Layers: ToLayerMap([
        { Name: "Head", Layer: "Head", Pri: 0,
        },
        { Name: "ArmRight", Layer: "ArmRight", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(ARMPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ArmLeft", Layer: "ArmLeft", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(ARMPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ForeArmRight", Layer: "ForeArmRight", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(FOREARMPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ForeArmLeft", Layer: "ForeArmLeft", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(FOREARMPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "HandRight", Layer: "HandRight", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(HANDRIGHTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "HandLeft", Layer: "HandLeft", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(HANDLEFTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ForeHandRight", Layer: "ForeHandRight", Pri: 0,
            Sprite: "HandRight",
            InheritColor: "Torso",
            Poses: ToMap(FOREHANDRIGHTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ForeHandLeft", Layer: "ForeHandLeft", Pri: 0,
            Sprite: "HandLeft",
            InheritColor: "Torso",
            Poses: ToMap(FOREHANDLEFTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "LegLeft", Layer: "LegLeft", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(LEGPOSES),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "Torso", Layer: "Torso", Pri: 0,
        },
        { Name: "Chest", Layer: "Chest", Pri: 0,
            InheritColor: "Torso",
        },
        { Name: "FootRight", Layer: "FootRight", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(FOOTRIGHTPOSES),
        },
        { Name: "FootRightKneel", Sprite: "FootRight", Layer: "FootRightKneel", Pri: 0,
            InheritColor: "Torso",
            HidePoses: ToMap(["FeetLinked"]),
            Poses: ToMap(["Kneel"]),
        },
        { Name: "FootLeft", Layer: "FootLeft", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(FOOTLEFTPOSES),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "FootLeftHogtie", Layer: "FootLeftHogtie", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(["Hogtie"]),
            MorphPoses: { Hogtie: "" },
        },
        { Name: "LegRight", Layer: "LegRight", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(LEGPOSES),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "Butt", Layer: "Butt", Pri: 0,
            InheritColor: "Torso",
            Poses: ToMap(KNEELPOSES),
        },
    ])
});
AddModel({
    Name: "Catsuit",
    TopLevel: true,
    Categories: ["Suits"],
    Folder: "Catsuit",
    Group: "Catsuit",
    Layers: ToLayerMap([
        { Name: "ArmRight", Layer: "ArmRight", Pri: 1,
            InheritColor: "TorsoUpper",
            Poses: ToMap(ARMPOSES, "Hogtie"),
            GlobalDefaultOverride: ToMap(["Hogtie", "Front"]),
            AppendPose: ToMap(["Hogtie"]),
            AppendPoseRequire: ToMap(["Wristtie"]),
        },
        { Name: "ArmLeft", Layer: "ArmLeft", Pri: 1,
            InheritColor: "TorsoUpper",
            Poses: ToMap(ARMPOSES, "Hogtie"),
            GlobalDefaultOverride: ToMap(["Hogtie", "Front"]),
            AppendPose: ToMap(["Hogtie"]),
            AppendPoseRequire: ToMap(["Wristtie"]),
        },
        { Name: "ForeArmRight", Layer: "ForeArmRight", Pri: 1,
            InheritColor: "TorsoUpper",
            Poses: ToMap(FOREARMPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ForeArmLeft", Layer: "ForeArmLeft", Pri: 1,
            InheritColor: "TorsoUpper",
            Poses: ToMap(FOREARMPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "HandRight", Layer: "HandRight", Pri: 1,
            InheritColor: "TorsoUpper",
            Poses: ToMap(HANDRIGHTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "HandLeft", Layer: "HandLeft", Pri: 1,
            InheritColor: "TorsoUpper",
            Poses: ToMap(HANDLEFTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ForeHandRight", Layer: "ForeHandRight", Pri: 1,
            Sprite: "HandRight",
            InheritColor: "TorsoUpper",
            Poses: ToMap(FOREHANDRIGHTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "ForeHandLeft", Layer: "ForeHandLeft", Pri: 1,
            Sprite: "HandLeft",
            InheritColor: "TorsoUpper",
            Poses: ToMap(FOREHANDLEFTPOSES),
            GlobalDefaultOverride: ToMap(["Front"]),
        },
        { Name: "LegLeft", Layer: "LegLeft", Pri: 1,
            InheritColor: "TorsoLower",
            Poses: ToMap(LEGPOSES),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "TorsoLower", Layer: "TorsoLower", Pri: 1,
        },
        { Name: "TorsoUpper", Layer: "TorsoUpper", Pri: 1,
        },
        { Name: "Chest", Layer: "Chest", Pri: 1,
            InheritColor: "TorsoUpper",
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "FootRight", Layer: "FootRight", Pri: 1,
            InheritColor: "TorsoLower",
            Poses: ToMap(FOOTRIGHTPOSES),
        },
        { Name: "FootRightKneel", Layer: "FootRightKneel", Pri: 1,
            InheritColor: "TorsoLower",
            HidePoses: ToMap(["FeetLinked"]),
            Poses: ToMap(["Kneel"]),
            MorphPoses: { Kneel: "" },
        },
        { Name: "FootLeft", Layer: "FootLeft", Pri: 0,
            InheritColor: "TorsoLower",
            Poses: ToMap(FOOTLEFTPOSES),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "FootLeftHogtie", Layer: "FootLeftHogtie", Pri: 1,
            InheritColor: "TorsoLower",
            Poses: ToMap(["Hogtie"]),
            MorphPoses: { Hogtie: "" },
        },
        { Name: "LegRight", Layer: "LegRight", Pri: 1,
            InheritColor: "TorsoLower",
            Poses: ToMap(LEGPOSES),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "Butt", Layer: "Butt", Pri: 1,
            InheritColor: "TorsoLower",
            Poses: ToMap(KNEELPOSES),
        },
    ])
});
AddModel({
    Name: "Labcoat",
    Folder: "Labcoat",
    TopLevel: true,
    Categories: ["Clothes"],
    Layers: ToLayerMap([
        { Name: "Shoulders", Layer: "Shoulders", Pri: 10,
            Poses: ToMap(["Yoked", "Spread", "Closed", "Kneel"]),
            MorphPoses: { Yoked: "Yoked", Closed: "Spread" },
        },
        { Name: "ShouldersHogtie", Layer: "Shoulders", Pri: 10,
            Poses: ToMapSubtract([...ARMPOSES, "Hogtie"], ["Wristtie", "Yoked"]),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
            HidePoses: ToMap(["Spread", "Closed", "Yoked"]),
            MorphPoses: { Boxtie: "Free", Free: "Free", Hogtie: "" },
        },
        { Name: "Coat", Layer: "Coat", Pri: 0,
            Poses: ToMap(["Kneel", "Yoked", "Spread", "Closed"]),
            HidePoses: ToMap(["Hogtie"]),
            MorphPoses: { Closed: "Spread" },
        },
        { Name: "CoatHogtieFree", Layer: "Cape", Pri: 0,
            Poses: ToMap(["Hogtie"]),
            HidePoses: ToMap(["Wristtie"]),
            MorphPoses: { Hogtie: "" },
        },
        { Name: "Cape", Layer: "Cape", Pri: 0,
            Poses: ToMap(["Hogtie", "Kneel", "Yoked", "Spread", "Closed"]),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
            MorphPoses: { Closed: "Spread" },
        },
    ])
});
AddModel({
    Name: "Pauldrons",
    Folder: "ArmorPlate",
    Parent: "PlateArmor",
    Categories: ["Armor"],
    Layers: ToLayerMap([
        { Name: "Pauldrons", Layer: "Shoulders", Pri: 8,
            Poses: ToMap([...ARMPOSES, "Hogtie"]),
            MorphPoses: { Yoked: "Yoked", Hogtie: "Hogtie", Wristtie: "Free", Boxtie: "Free" },
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "Breastplate",
    Folder: "ArmorPlate",
    Parent: "PlateArmor",
    Categories: ["Armor"],
    Layers: ToLayerMap([
        { Name: "Breastplate", Layer: "Chestplate", Pri: 25,
            Poses: ToMap([...ARMPOSES, "Hogtie"]),
            HideWhenOverridden: true,
            MorphPoses: { Hogtie: "Hogtie" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "PlateBoots",
    Folder: "ArmorPlate",
    Parent: "PlateArmor",
    Categories: ["Shoes"],
    Layers: ToLayerMap([
        { Name: "BootLeft", Layer: "ShoeLeft", Pri: 25,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie"]),
            HideWhenOverridden: true,
        },
        { Name: "BootRight", Layer: "ShoeRight", Pri: 25,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie", "Kneel"]),
            HideWhenOverridden: true,
        },
        { Name: "BootRightKneel", Layer: "FootRightKneel", Pri: 25,
            Poses: ToMap(["Kneel"]),
            HidePoses: ToMap(["FeetLinked"]),
            HideWhenOverridden: true,
            Invariant: true,
        },
        { Name: "BootLeftHogtie", Layer: "FootLeftHogtie", Pri: 25,
            Poses: ToMap(["Hogtie"]),
            HideWhenOverridden: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "Gauntlets",
    Folder: "ArmorPlate",
    Parent: "PlateArmor",
    Categories: ["Gloves"],
    Layers: ToLayerMap([
        { Name: "GauntletLeft", Layer: "GloveLeft", Pri: 15,
            Poses: ToMapSubtract([...ARMPOSES], ["Wristtie", "Boxtie"]),
            HideWhenOverridden: true,
        },
        { Name: "GauntletRight", Layer: "GloveRight", Pri: 15,
            Poses: ToMapSubtract([...ARMPOSES], ["Wristtie"]),
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "PlateArmor",
    Folder: "ArmorPlate",
    TopLevel: true,
    Categories: ["Armor"],
    Layers: ToLayerMap([
        ...GetModelLayers("Breastplate"),
        ...GetModelLayers("Pauldrons"),
        ...GetModelLayers("PlateBoots"),
        ...GetModelLayers("Gauntlets"),
    ])
});
AddModel({
    Name: "ChainShirt",
    Folder: "ArmorChain",
    Parent: "ChainArmor",
    Categories: ["Armor"],
    Layers: ToLayerMap([
        { Name: "ShirtChest", Layer: "Chest", Pri: 5,
            Poses: ToMap([...ARMPOSES, "Hogtie"]),
            MorphPoses: { Hogtie: "Hogtie" },
            Invariant: true,
        },
        { Name: "Shirt", Layer: "CorsetLiner", Pri: 5,
            Poses: ToMap([...ARMPOSES, "Hogtie"]),
            MorphPoses: { Hogtie: "Hogtie" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "ChainSkirt",
    Folder: "ArmorChain",
    Parent: "ChainArmor",
    Categories: ["Armor"],
    Layers: ToLayerMap([
        { Name: "Skirt", Layer: "Greaves", Pri: 15,
            Poses: ToMap([...LEGPOSES]),
            MorphPoses: { Hogtie: "Hogtie", Kneel: "Kneel" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "ChainArmor",
    Folder: "ArmorChain",
    TopLevel: true,
    Categories: ["Armor"],
    Layers: ToLayerMap([
        ...GetModelLayers("ChainShirt"),
        ...GetModelLayers("ChainSkirt"),
    ])
});
AddModel({
    Name: "BanditShorts",
    Folder: "Bandit",
    Parent: "Bandit",
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        { Name: "Shorts", Layer: "Pants", Pri: 7,
            Poses: ToMap([...LEGPOSES]),
        },
    ])
});
AddModel({
    Name: "BanditBreastplate",
    Folder: "Bandit",
    Parent: "Bandit",
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        { Name: "Breastplate", Layer: "Chestplate", Pri: 24,
            Poses: ToMap([...ARMPOSES, "Hogtie"]),
            HideWhenOverridden: true,
            MorphPoses: { Hogtie: "Hogtie" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "Bandit",
    Folder: "Bandit",
    TopLevel: true,
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        ...GetModelLayers("BanditShorts"),
        ...GetModelLayers("BanditBreastplate"),
    ])
});
AddModel({
    Name: "MaidSkirt",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Skirts"],
    Layers: ToLayerMap([
        { Name: "Skirt", Layer: "Skirt", Pri: 14,
            Poses: ToMap([...LEGPOSES]),
            HideWhenOverridden: true,
            MorphPoses: { Hogtie: "Closed", Closed: "Closed", Kneel: "Kneel" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidApron",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "Apron", Layer: "BeltDeco", Pri: 30,
            Poses: ToMap([...LEGPOSES]),
            HideWhenOverridden: true,
            MorphPoses: { Kneel: "Kneel" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidBlouse",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "Blouse", Layer: "CorsetLiner", Pri: 3,
            Poses: ToMap([...ARMPOSES]),
            HideWhenOverridden: true,
            Invariant: true,
        },
        { Name: "BlouseBust", Layer: "Chest", Pri: 3,
            Poses: ToMap([...ARMPOSES]),
            HideWhenOverridden: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidBow",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "Bow", Layer: "CollarAcc", Pri: 1,
            Poses: ToMap([...ARMPOSES]),
            HideWhenOverridden: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidCorset",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Corsets"],
    Layers: ToLayerMap([
        { Name: "Corset", Layer: "Corset", Pri: 1,
            Poses: ToMap([...ARMPOSES]),
            HideWhenOverridden: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidCorsetFull",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Corsets"],
    Layers: ToLayerMap([
        ...GetModelLayers("MaidCorset"),
        { Name: "CorsetStraps", Layer: "Straps", Pri: 1,
            Poses: ToMap([...ARMPOSES]),
            MorphPoses: { Boxtie: "Boxtie", Wristtie: "Boxtie" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidSockLeft",
    Folder: "Maid",
    Parent: "MaidSocks",
    Layers: ToLayerMap([
        { Name: "SockLeft", Layer: "StockingLeft", Pri: 1,
            Poses: ToMap([...LEGPOSES]),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "FootSockLeftHogtie", Layer: "FootLeftHogtie", Pri: 1,
            Poses: ToMap(["Hogtie"]),
            InheritColor: "SockLeft",
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidSockRight",
    Folder: "Maid",
    Parent: "MaidSocks",
    Layers: ToLayerMap([
        { Name: "SockRight", Layer: "StockingRight", Pri: 1,
            Poses: ToMap([...LEGPOSES]),
            GlobalDefaultOverride: ToMap(["Hogtie"]),
        },
        { Name: "FootSockRightKneel", Layer: "FootRightKneel", Pri: 1,
            HidePoses: ToMap(["FeetLinked"]),
            Poses: ToMap(["Kneel"]),
            InheritColor: "SockRight",
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "MaidShoes",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Shoes"],
    Layers: ToLayerMap([
        { Name: "ShoeLeft", Layer: "ShoeLeft", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRight", Layer: "ShoeRight", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie", "Kneel"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRightKneel", Layer: "FootRightKneel", Pri: 1,
            Poses: ToMap(["Kneel"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "ShoeLeftHogtie", Layer: "FootLeftHogtie", Pri: 1,
            Poses: ToMap(["Hogtie"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "MaidSocks",
    Folder: "Maid",
    Parent: "Maid",
    TopLevel: true,
    Categories: ["Socks"],
    Layers: ToLayerMap([
        ...GetModelLayers("MaidSockRight"),
        ...GetModelLayers("MaidSockLeft"),
    ])
});
AddModel({
    Name: "Maid",
    Folder: "Maid",
    TopLevel: true,
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        ...GetModelLayers("MaidSkirt"),
        ...GetModelLayers("MaidBlouse"),
        ...GetModelLayers("MaidCorsetFull"),
        ...GetModelLayers("MaidSocks"),
        ...GetModelLayers("MaidShoes"),
        ...GetModelLayers("MaidBow"),
    ])
});
AddModel({
    Name: "WitchBlouse",
    Folder: "Witch",
    Parent: "Witch",
    TopLevel: true,
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "Blouse", Layer: "Shirt", Pri: 4,
            Poses: ToMap([...ARMPOSES]),
            HideWhenOverridden: true,
        },
        { Name: "BlouseLiner", Layer: "CorsetLiner", Pri: 4,
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "BlouseBust", Layer: "Chest", Pri: 4,
            Poses: ToMap([...ARMPOSES]),
            HideWhenOverridden: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "WitchCorset",
    Folder: "Witch",
    Parent: "Witch",
    TopLevel: true,
    Categories: ["Corsets"],
    Layers: ToLayerMap([
        { Name: "Corset", Layer: "Corset", Pri: 1,
            Poses: ToMap([...ARMPOSES]),
            HideWhenOverridden: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "WitchHat",
    Folder: "Witch",
    Parent: "Witch",
    TopLevel: true,
    Categories: ["Hats"],
    Layers: ToLayerMap([
        { Name: "WitchHat", Layer: "Hat", Pri: 70,
            HideWhenOverridden: true,
            Invariant: true,
        },
        { Name: "WitchHatBack", Layer: "HatBack", Pri: 70,
            HideWhenOverridden: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "ApprenticeHat",
    Folder: "Witch",
    Parent: "Witch",
    TopLevel: true,
    Categories: ["Hats"],
    Layers: ToLayerMap([
        { Name: "ApprenticeHat", Layer: "Hat", Pri: 40,
            HideWhenOverridden: true,
            Invariant: true,
        },
        { Name: "ApprenticeHatPuff", Layer: "Hat", Pri: 40.1,
            HideWhenOverridden: true,
            NoOverride: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "WitchShoes",
    Folder: "Witch",
    Parent: "Witch",
    TopLevel: true,
    Categories: ["Shoes"],
    Layers: ToLayerMap([
        { Name: "ShoeLeft", Layer: "ShoeLeft", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRight", Layer: "ShoeRight", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie", "Kneel"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRightKneel", Layer: "FootRightKneel", Pri: 1,
            Poses: ToMap(["Kneel"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "ShoeLeftHogtie", Layer: "FootLeftHogtie", Pri: 1,
            Poses: ToMap(["Hogtie"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "WitchSkirt",
    Folder: "Witch",
    Parent: "Witch",
    TopLevel: true,
    Categories: ["Skirts"],
    Layers: ToLayerMap([
        { Name: "Skirt", Layer: "Skirt", Pri: 14,
            Poses: ToMap([...LEGPOSES]),
            HideWhenOverridden: true,
            MorphPoses: { Hogtie: "Closed", Closed: "Closed", Kneel: "Kneel" },
            Invariant: true,
        },
        { Name: "SkirtBelt", Layer: "Skirt", Pri: 14.1,
            Poses: ToMap([...LEGPOSES]),
            TieToLayer: "Skirt", NoOverride: true,
            MorphPoses: { Hogtie: "Closed", Closed: "Closed", Kneel: "Kneel" },
            Invariant: true,
        },
        { Name: "SkirtRuffle", Layer: "Skirt", Pri: 14.1,
            Poses: ToMap([...LEGPOSES]),
            TieToLayer: "Skirt", NoOverride: true,
            MorphPoses: { Hogtie: "Closed", Closed: "Closed", Kneel: "Kneel" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "Witch",
    Folder: "Witch",
    TopLevel: true,
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        ...GetModelLayers("WitchSkirt"),
        ...GetModelLayers("WitchCorset"),
        ...GetModelLayers("WitchBlouse"),
        ...GetModelLayers("WitchHat"),
        ...GetModelLayers("WitchShoes"),
    ])
});
AddModel({
    Name: "WarriorBoots",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Shoes"],
    Layers: ToLayerMap([
        { Name: "ShoeLeft", Layer: "ShoeLeft", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRight", Layer: "ShoeRight", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie", "Kneel"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRightKneel", Layer: "FootRightKneel", Pri: 1,
            Poses: ToMap(["Kneel"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "ShoeLeftHogtie", Layer: "FootLeftHogtie", Pri: 1,
            Poses: ToMap(["Hogtie"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "SportsBra",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "Bra", Layer: "Chest", Pri: 5,
            Poses: ToMap([...ARMPOSES]),
            MorphPoses: { Yoked: "Yoked" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "WarriorBustier",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "BustierChest", Layer: "Chest", Pri: 15,
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "Bustier", Layer: "Bustier", Pri: 15,
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "WarriorBelt",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Corsets"],
    Layers: ToLayerMap([
        { Name: "Belt", Layer: "Belt", Pri: 15,
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "DragonNecklace",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "Necklace", Layer: "Necklace", Pri: 5,
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "Necklace", Layer: "NecklaceCharm", Pri: 5,
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "DragonArmband",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "Armband", Layer: "Sleeves", Pri: 3,
            Poses: ToMap(["Yoked", "Wristtie", "Free", "Boxtie", "Front"]),
            MorphPoses: { Yoked: "Yoked", Boxtie: "Boxtie", Free: "Free", Wristtie: "Wristtie", Front: "Boxtie" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "DragonCollar",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "Collar", Layer: "Collar", Pri: 5,
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "WarriorSkirt",
    Folder: "Warrior",
    Parent: "Dragonheart",
    TopLevel: true,
    Categories: ["Skirts"],
    Layers: ToLayerMap([
        { Name: "Skirt", Layer: "Skirt", Pri: 7,
            Poses: ToMap([...LEGPOSES]),
            HideWhenOverridden: true,
            MorphPoses: { Kneel: "Kneel" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "Dragonheart",
    Folder: "Warrior",
    TopLevel: true,
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        ...GetModelLayers("WarriorSkirt"),
        ...GetModelLayers("WarriorBustier"),
        ...GetModelLayers("WarriorBelt"),
        ...GetModelLayers("SportsBra"),
        ...GetModelLayers("WarriorBoots"),
        ...GetModelLayers("DragonCollar"),
        ...GetModelLayers("DragonNecklace"),
        ...GetModelLayers("DragonArmband"),
    ])
});
AddModel({
    Name: "Dragonheart",
    Folder: "Warrior",
    TopLevel: true,
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        ...GetModelLayers("WarriorSkirt"),
        ...GetModelLayers("WarriorBustier"),
        ...GetModelLayers("WarriorBelt"),
        ...GetModelLayers("SportsBra"),
        ...GetModelLayers("WarriorBoots"),
        ...GetModelLayers("DragonCollar"),
        ...GetModelLayers("DragonNecklace"),
        ...GetModelLayers("DragonArmband"),
    ])
});
AddModel({
    Name: "ZombieHat",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Hats"],
    Layers: ToLayerMap([
        { Name: "ZombieHat", Layer: "Hat", Pri: 40,
            HideWhenOverridden: true,
            Invariant: true,
        },
        { Name: "ZombieHatBand", Layer: "Hat", Pri: 41,
            HideWhenOverridden: true,
            NoOverride: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "ZombieChestTalisman",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "ZombieChestTalisman", Layer: "ChestDeco", Pri: 70,
            NoOverride: true,
            Invariant: true,
            MorphPoses: { Kneel: "Kneel" },
        },
    ])
});
AddModel({
    Name: "ZombieTalisman",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "ZombieTalisman", Layer: "Circlet", Pri: 90,
            NoOverride: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "ZombieTalismanBent",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "ZombieTalismanBent", Layer: "Circlet", Pri: 90,
            NoOverride: true,
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "Sandals",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Shoes"],
    Layers: ToLayerMap([
        { Name: "ShoeLeft", Layer: "ShoeLeft", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRight", Layer: "ShoeRight", Pri: 1,
            Poses: ToMapSubtract([...LEGPOSES], ["Hogtie", "Kneel"]),
            HideWhenOverridden: true,
        },
        { Name: "ShoeRightKneel", Layer: "FootRightKneel", Pri: 1,
            Poses: ToMap(["Kneel"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "ShoeLeftHogtie", Layer: "FootLeftHogtie", Pri: 1,
            Poses: ToMap(["Hogtie"]),
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "RobeBra",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "Bra", Layer: "Bra", Pri: 50,
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "Bra", Layer: "Chest", Pri: 50,
            Invariant: true,
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "RobeSleeveLeft",
    Folder: "Robes",
    Parent: "RobeSleeves",
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "SleeveLeft", Layer: "SleeveLeft", Pri: 40,
            Poses: ToMap([...ARMPOSES]),
            GlobalDefaultOverride: ToMap(["Front"]),
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "RobeSleeveRight",
    Folder: "Robes",
    Parent: "RobeSleeves",
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "SleeveRight", Layer: "SleeveRight", Pri: 40,
            Poses: ToMap([...ARMPOSES]),
            GlobalDefaultOverride: ToMap(["Front"]),
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "RobeSleeves",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Sleeves"],
    Layers: ToLayerMap([
        ...GetModelLayers("RobeSleeveLeft"),
        ...GetModelLayers("RobeSleeveRight"),
    ])
});
AddModel({
    Name: "RobeSleeveDecoLeft",
    Folder: "Robes",
    Parent: "RobeSleevesDeco",
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "SleeveDecoLeft", Layer: "SleeveDecoLeft", Pri: 40,
            Poses: ToMap(["Free", "Yoked", "Front"]),
            GlobalDefaultOverride: ToMap(["Front"]),
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "RobeSleeveDecoRight",
    Folder: "Robes",
    Parent: "RobeSleevesDeco",
    Categories: ["Tops"],
    Layers: ToLayerMap([
        { Name: "SleeveDecoRight", Layer: "SleeveDecoRight", Pri: 40,
            Poses: ToMap(["Free", "Yoked", "Front"]),
            GlobalDefaultOverride: ToMap(["Front"]),
            HideWhenOverridden: true,
        },
    ])
});
AddModel({
    Name: "RobeSleevesDeco",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Sleeves"],
    Layers: ToLayerMap([
        ...GetModelLayers("RobeSleeveDecoLeft"),
        ...GetModelLayers("RobeSleeveDecoRight"),
    ])
});
AddModel({
    Name: "Ribbon",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Accessories"],
    Layers: ToLayerMap([
        { Name: "RibbonBelt", Layer: "Belt", Pri: 30,
            Invariant: true,
            HideWhenOverridden: true,
        },
        { Name: "RibbonBack", Layer: "BeltBack", Pri: 30,
            Poses: ToMap(["Wristtie", "Boxtie"]),
            Invariant: true,
            MorphPoses: { Kneel: "Kneel", Hogtie: "Hogtie" },
        },
        { Name: "RibbonFarBack", Layer: "BeltFarBack", Pri: 30,
            Sprite: "RibbonBack",
            Poses: ToMapSubtract([...ARMPOSES], ["Wristtie", "Boxtie"]),
            Invariant: true,
            MorphPoses: { Kneel: "Kneel", Hogtie: "Hogtie" },
        },
    ])
});
AddModel({
    Name: "RobeSkirt",
    Folder: "Robes",
    Parent: "Robes",
    TopLevel: true,
    Categories: ["Skirts"],
    Layers: ToLayerMap([
        { Name: "Skirt", Layer: "Skirt", Pri: 7,
            Poses: ToMap([...LEGPOSES]),
            HideWhenOverridden: true,
            MorphPoses: { Kneel: "Kneel" },
            Invariant: true,
        },
    ])
});
AddModel({
    Name: "Robes",
    Folder: "Robes",
    TopLevel: true,
    Categories: ["Uniforms"],
    Layers: ToLayerMap([
        ...GetModelLayers("Sandals"),
        ...GetModelLayers("RobeSleeves"),
        ...GetModelLayers("RobeSleevesDeco"),
        ...GetModelLayers("RobeSkirt"),
        ...GetModelLayers("RobeBra"),
        ...GetModelLayers("Ribbon"),
    ])
});
AddModel({
    Name: "RopeArms",
    Folder: "Rope",
    Parent: "Rope",
    TopLevel: true,
    Categories: ["Restraints"],
    Layers: ToLayerMap([
        { Name: "ChestUpper", Layer: "ChestStraps", Pri: 0,
            Poses: ToMap([...ARMPOSES]),
            Invariant: true,
        },
        { Name: "ShoulderStraps", Layer: "ChestStraps", Pri: 1,
            Poses: ToMap([...ARMPOSES]),
            Invariant: true,
        },
        { Name: "ChestLower", Layer: "Underbust", Pri: 0,
            Poses: ToMap([...ARMPOSES]),
            Invariant: true,
        },
        { Name: "Arms", Layer: "Underarms", Pri: 0,
            Poses: ToMap(["Wristtie", "Boxtie"]),
        },
    ])
});
let KDModelDresses = {
    "Default": KinkyDungeonDefaultDefaultDress,
    "Prisoner": [
        { Item: "Catsuit", Group: "Suit", Color: "#8A120C", Lost: false },
    ],
    "Bandit": [
        { Item: "Bandit", Group: "Suit", Color: "Default", Lost: false },
    ],
    "GreenLeotard": [
        { Item: "Catsuit", Group: "Suit", Color: "#267237", Lost: false },
    ],
    "Leotard": [
        { Item: "Catsuit", Group: "Suit", Color: "#53428D", Lost: false },
    ],
    "Bikini": [],
    "Lingerie": [
        { Item: "Catsuit", Group: "Suit", Color: "#53428D", Lost: false },
    ],
    "LatexPrisoner": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Dungeon": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Bast": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Dragon": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "SlimeSuit": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "ProtoSlimeSuit": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "BlueSuit": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Bountyhunter": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "BlueSuitPrison": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Wolfgirl": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Maid": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Elven": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
    "Obsidian": [
        { Item: "Catsuit", Group: "Suit", Color: "#444444", Lost: false },
    ],
};
let KDConfirmType = "";
let KinkyDungeonReplaceConfirm = 0;
let KDCurrentOutfit = 0;
let KDMaxOutfits = 10;
let KDMaxOutfitsDisplay = 7;
let KDMaxOutfitsIndex = 0;
let KDOutfitInfo = [];
let KDOutfitStore = {};
let KDOutfitOriginalStore = {};
let KDModelListMax = 13;
let KDModelListViewSkip = 7;
let KDModelList_Categories_index = 0;
let KDModelList_Categories_viewindex = { index: 0 };
let KDModelList_Categories = [];
let KDModelList_Toplevel_index = 0;
let KDModelList_Toplevel_viewindex = { index: 0 };
let KDModelList_Toplevel = [];
let KDModelList_Sublevel_index = 0;
let KDModelList_Sublevel_viewindex = { index: 0 };
let KDModelList_Sublevel = [];
let KDWardrobeCategories = [
    "Uniforms",
    "Suits",
    "Armor",
    "Underwear",
    "Socks",
    "Shoes",
    "Tops",
    "Corsets",
    "Skirts",
    "Pants",
    "Accessories",
    "Hats",
    "Hairstyles",
    "Face",
    "Eyes",
    "Mouth",
    "Body",
];
let KDSelectedModel = null;
let KDColorSliders = {
    gamma: 1,
    saturation: 1,
    contrast: 1,
    brightness: 1,
    red: 1,
    green: 1,
    blue: 1,
    alpha: 1,
};
let KDColorSliderColor = {
    red: "#ff5555",
    green: "#55ff55",
    blue: "#5555ff",
};
let KDCurrentLayer = "";
let KDSavedColorCount = 9;
let KDSavedColors = [];
if (localStorage.getItem("kdcolorfilters"))
    KDSavedColors = JSON.parse(localStorage.getItem("kdcolorfilters"));
for (let i = 0; i < KDSavedColorCount; i++) {
    KDSavedColors.push(Object.assign({}, KDColorSliders));
}
let KDWardrobe_PoseArms = ["Free", "Boxtie", "Wristtie", "Yoked", "Front"];
let KDWardrobe_PoseLegs = ["Spread", "Closed", "Kneel", "Hogtie"];
let KDWardrobe_PoseEyes = EYEPOSES;
let KDWardrobe_PoseEyes2 = EYE2POSES;
let KDWardrobe_PoseBrows = BROWPOSES;
let KDWardrobe_PoseBrows2 = BROW2POSES;
let KDWardrobe_PoseMouth = MOUTHPOSES;
let KDWardrobe_PoseBlush = ["BlushNeutral", ...BLUSHPOSES];
let KDWardrobe_CurrentPoseArms = KDWardrobe_PoseArms[0];
let KDWardrobe_CurrentPoseLegs = KDWardrobe_PoseLegs[0];
let KDWardrobe_CurrentPoseEyes = KDWardrobe_PoseEyes[0];
let KDWardrobe_CurrentPoseEyes2 = KDWardrobe_PoseEyes2[0];
let KDWardrobe_CurrentPoseBrows = KDWardrobe_PoseBrows[0];
let KDWardrobe_CurrentPoseBrows2 = KDWardrobe_PoseBrows2[0];
let KDWardrobe_CurrentPoseMouth = KDWardrobe_PoseMouth[0];
let KDWardrobe_CurrentPoseBlush = KDWardrobe_PoseBlush[0];
function KDInitCurrentPose(blank) {
    KDWardrobe_CurrentPoseArms = blank ? "" : KDWardrobe_PoseArms[0];
    KDWardrobe_CurrentPoseLegs = blank ? "" : KDWardrobe_PoseLegs[0];
    KDWardrobe_CurrentPoseEyes = blank ? "" : KDWardrobe_PoseEyes[0];
    KDWardrobe_CurrentPoseEyes2 = blank ? "" : KDWardrobe_PoseEyes2[0];
    KDWardrobe_CurrentPoseBrows = blank ? "" : KDWardrobe_PoseBrows[0];
    KDWardrobe_CurrentPoseBrows2 = blank ? "" : KDWardrobe_PoseBrows2[0];
    KDWardrobe_CurrentPoseMouth = blank ? "" : KDWardrobe_PoseMouth[0];
    KDWardrobe_CurrentPoseBlush = blank ? "" : KDWardrobe_PoseBlush[0];
}
function KDDrawSavedColors(X, Y, max, C) {
    let spacing = 100;
    let filters = ((KDSelectedModel === null || KDSelectedModel === void 0 ? void 0 : KDSelectedModel.Filters) ? KDSelectedModel.Filters[KDCurrentLayer] : undefined) || KDColorSliders;
    for (let i = 0; i < max && i < KDSavedColors.length; i++) {
        KDDraw(kdcanvas, kdpixisprites, "SavedColor" + i, KinkyDungeonRootDirectory + "UI/greyColor.png", X + spacing * i, Y, 64, 64, undefined, {
            filters: [
                new __filters.AdjustmentFilter(KDSavedColors[i]),
            ]
        });
        DrawButtonKDEx("SavedColorCopy" + i, (bdata) => {
            if (filters && KDSelectedModel) {
                KDSavedColors[i] = Object.assign({}, filters);
                localStorage.setItem("kdcolorfilters", JSON.stringify(KDSavedColors));
            }
            return true;
        }, true, X + spacing * i + 32 - 48, Y + 64, 48, 48, "", "#ffffff", KinkyDungeonRootDirectory + "UI/savedColor_copy.png", undefined, false, true);
        DrawButtonKDEx("SavedColorPaste" + i, (bdata) => {
            if (filters && KDSelectedModel) {
                Object.assign(filters, KDSavedColors[i]);
                KDChangeWardrobe(C);
                if (!KDSelectedModel.Filters)
                    KDSelectedModel.Filters = {};
                KDSelectedModel.Filters[KDCurrentLayer] = Object.assign({}, filters);
                KDCurrentModels.get(C).Models.set(KDSelectedModel.Name, JSON.parse(JSON.stringify(KDSelectedModel)));
            }
            return true;
        }, true, X + spacing * i + 32 + 0, Y + 64, 48, 48, "", "#ffffff", KinkyDungeonRootDirectory + "UI/savedColor_paste.png", undefined, false, true);
    }
}
function KDDrawColorSliders(X, Y, C, Model) {
    let YY = Y;
    let width = 300;
    let layers = KDGetColorableLayers(Model);
    if (!KDCurrentLayer)
        KDCurrentLayer = layers[0] || "";
    let filters = (Model.Filters ? Model.Filters[KDCurrentLayer] : undefined) || KDColorSliders;
    DrawButtonKDEx("ResetCurrentLayer", (bdata) => {
        if (Model.Filters && Model.Filters[KDCurrentLayer]) {
            KDChangeWardrobe(C);
            Model.Filters[KDCurrentLayer] = Object.assign({}, KDColorSliders);
            KDCurrentModels.get(C).Models.set(Model.Name, Model);
        }
        return true;
    }, true, X + width / 2 + 10, YY, width / 2 - 10, 30, TextGet("KDResetLayer"), "#ffffff");
    DrawButtonKDEx("KDCopyLayer", (bdata) => {
        navigator.clipboard.writeText(JSON.stringify(filters));
        return true;
    }, true, X, YY, width / 2 - 10, 30, TextGet("KDCopyLayer"), "#ffffff");
    DrawButtonKDEx("KDPasteLayer", (bdata) => {
        navigator.clipboard.readText()
            .then(text => {
            let parsed = JSON.parse(text);
            if ((parsed === null || parsed === void 0 ? void 0 : parsed.red) != undefined && parsed.green != undefined && parsed.blue != undefined) {
                console.log(Object.assign({}, parsed));
                KDChangeWardrobe(C);
                if (!Model.Filters)
                    Model.Filters = {};
                Model.Filters[KDCurrentLayer] = Object.assign({}, parsed);
                KDCurrentModels.get(C).Models.set(Model.Name, JSON.parse(JSON.stringify(Model)));
            }
        });
        return true;
    }, true, X, YY - 40, width / 2 - 10, 30, TextGet("KDPasteLayer"), "#ffffff");
    YY += 60;
    for (let key of Object.keys(KDColorSliders)) {
        DrawTextFitKD(TextGet("KDColorSlider" + key) + ": " + (Math.round(filters[key] * 10) / 10), X + width / 2, YY, width, "#ffffff", "#000000", 20);
        KinkyDungeonBar(X, YY - 15, width, 30, filters[key] / 5 * 100, KDColorSliderColor[key] || "#ffffff", "#000000");
        if ((mouseDown || MouseClicked) && MouseIn(X, YY - 15, width, 30)) {
            KDChangeWardrobe(C);
            if (!Model.Filters)
                Model.Filters = {};
            if (!Model.Filters[KDCurrentLayer])
                Model.Filters[KDCurrentLayer] = Object.assign({}, KDColorSliders);
            Model.Filters[KDCurrentLayer][key] = (MouseX - X) / width * 5;
            KDCurrentModels.get(C).Models.set(Model.Name, JSON.parse(JSON.stringify(Model)));
            ElementValue("KDSelectedColor", `#${Math.round(Model.Filters[KDCurrentLayer].red / 5 * 255).toString(16)}${Math.round(Model.Filters[KDCurrentLayer].green / 5 * 255).toString(16)}${Math.round(Model.Filters[KDCurrentLayer].blue / 5 * 255).toString(16)}`);
        }
        YY += 50;
    }
    let TF = KDTextField("KDSelectedColor", X, YY, width, 30);
    if (TF.Created) {
        TF.Element.oninput = (event) => {
            let value = ElementValue("KDSelectedColor");
            let RegExp = /^#[0-9A-F]{6}$/i;
            if (RegExp.test(value)) {
                let hex = KDhexToRGB(value);
                if (hex) {
                    let r = 5.0 * (parseInt(hex.r, 16) / 255.0);
                    let g = 5.0 * (parseInt(hex.g, 16) / 255.0);
                    let b = 5.0 * (parseInt(hex.b, 16) / 255.0);
                    KDChangeWardrobe(C);
                    if (!Model.Filters)
                        Model.Filters = {};
                    if (!Model.Filters[KDCurrentLayer])
                        Model.Filters[KDCurrentLayer] = Object.assign({}, KDColorSliders);
                    Model.Filters[KDCurrentLayer].red = r;
                    Model.Filters[KDCurrentLayer].green = g;
                    Model.Filters[KDCurrentLayer].blue = b;
                    KDCurrentModels.get(C).Models.set(Model.Name, JSON.parse(JSON.stringify(Model)));
                }
            }
        };
    }
    YY += 60;
    YY = Y;
    for (let l of layers) {
        DrawButtonKDEx("SelectLayer" + l, (bdata) => {
            KDCurrentLayer = l;
            return true;
        }, true, X - 220, YY, 200, 30, TextGet(`l_${Model.Name}_${l}`), "#ffffff", undefined, undefined, undefined, KDCurrentLayer != l, KDButtonColor);
        YY += 35;
    }
}
function KDDrawPoseButtons(C, X = 1000, Y = 750, allowRemove = false) {
    let buttonClick = (arms, legs, eyes, eyes2, brows, brows2, blush, mouth, update = true) => {
        return (bdata) => {
            KDWardrobe_CurrentPoseArms = arms || KDWardrobe_CurrentPoseArms;
            KDWardrobe_CurrentPoseLegs = legs || KDWardrobe_CurrentPoseLegs;
            if (allowRemove && eyes == KDWardrobe_CurrentPoseEyes)
                KDWardrobe_CurrentPoseEyes = "";
            else
                KDWardrobe_CurrentPoseEyes = eyes || KDWardrobe_CurrentPoseEyes;
            if (allowRemove && eyes2 == KDWardrobe_CurrentPoseEyes2)
                KDWardrobe_CurrentPoseEyes2 = "";
            else
                KDWardrobe_CurrentPoseEyes2 = eyes2 || KDWardrobe_CurrentPoseEyes2;
            if (allowRemove && brows == KDWardrobe_CurrentPoseBrows)
                KDWardrobe_CurrentPoseBrows = "";
            else
                KDWardrobe_CurrentPoseBrows = brows || KDWardrobe_CurrentPoseBrows;
            if (allowRemove && brows2 == KDWardrobe_CurrentPoseBrows2)
                KDWardrobe_CurrentPoseBrows2 = "";
            else
                KDWardrobe_CurrentPoseBrows2 = brows2 || KDWardrobe_CurrentPoseBrows2;
            if (allowRemove && blush == KDWardrobe_CurrentPoseBlush)
                KDWardrobe_CurrentPoseBlush = "";
            else
                KDWardrobe_CurrentPoseBlush = blush || KDWardrobe_CurrentPoseBlush;
            if (allowRemove && mouth == KDWardrobe_CurrentPoseMouth)
                KDWardrobe_CurrentPoseMouth = "";
            else
                KDWardrobe_CurrentPoseMouth = mouth || KDWardrobe_CurrentPoseMouth;
            if (update) {
                KDCurrentModels.get(C).Poses = KDGeneratePoseArray(KDWardrobe_CurrentPoseArms, KDWardrobe_CurrentPoseLegs, KDWardrobe_CurrentPoseEyes, KDWardrobe_CurrentPoseBrows, KDWardrobe_CurrentPoseBlush, KDWardrobe_CurrentPoseMouth, KDWardrobe_CurrentPoseEyes2, KDWardrobe_CurrentPoseBrows2);
                UpdateModels(KDCurrentModels.get(C));
            }
            return true;
        };
    };
    let AvailableArms = KDGetAvailablePosesArms(C);
    let AvailableLegs = KDGetAvailablePosesLegs(C);
    let buttonWidth = 52;
    let buttonSpacing = 60;
    let xoff = KDWardrobe_PoseLegs.length % 2 != KDWardrobe_PoseArms.length % 2 ? buttonWidth / 2 : 0;
    for (let i = 0; i < KDWardrobe_PoseArms.length; i++) {
        DrawButtonKDEx("PoseArms" + i, buttonClick(KDWardrobe_PoseArms[i], KDWardrobe_CurrentPoseLegs, "", "", "", "", "", "", AvailableArms.includes(KDWardrobe_PoseArms[i])), true, X + i * buttonSpacing, Y + 120, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseArms[i] + ".png", undefined, false, KDWardrobe_CurrentPoseArms != KDWardrobe_PoseArms[i], !AvailableArms.includes(KDWardrobe_PoseArms[i]) ? "#ff5555" : KDButtonColor);
    }
    for (let i = 0; i < KDWardrobe_PoseLegs.length; i++) {
        DrawButtonKDEx("PoseLegs" + i, buttonClick(KDWardrobe_CurrentPoseArms, KDWardrobe_PoseLegs[i], "", "", "", "", "", "", AvailableLegs.includes(KDWardrobe_PoseLegs[i])), true, X + xoff + i * buttonSpacing, Y + 180, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseLegs[i] + ".png", undefined, false, KDWardrobe_CurrentPoseLegs != KDWardrobe_PoseLegs[i], !AvailableLegs.includes(KDWardrobe_PoseLegs[i]) ? "#ff5555" : KDButtonColor);
    }
    for (let i = 0; i < KDWardrobe_PoseEyes.length; i++) {
        DrawButtonKDEx("PoseEyes" + i, buttonClick("", "", KDWardrobe_PoseEyes[i]), true, X + i * buttonSpacing, Y, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseEyes[i] + ".png", undefined, undefined, KDWardrobe_CurrentPoseEyes != KDWardrobe_PoseEyes[i], KDButtonColor);
    }
    for (let i = 0; i < KDWardrobe_PoseEyes.length; i++) {
        DrawButtonKDEx("PoseEyes2" + i, buttonClick("", "", "", KDWardrobe_PoseEyes2[i]), true, X + i * buttonSpacing, Y + 60, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseEyes2[i] + ".png", undefined, undefined, KDWardrobe_CurrentPoseEyes2 != KDWardrobe_PoseEyes2[i], KDButtonColor);
    }
    for (let i = 0; i < KDWardrobe_PoseBrows.length; i++) {
        DrawButtonKDEx("PoseBrows" + i, buttonClick("", "", "", "", KDWardrobe_PoseBrows[i]), true, X + 400 + i * buttonSpacing, Y, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseBrows[i] + ".png", undefined, undefined, KDWardrobe_CurrentPoseBrows != KDWardrobe_PoseBrows[i], KDButtonColor);
    }
    for (let i = 0; i < KDWardrobe_PoseBrows2.length; i++) {
        DrawButtonKDEx("PoseBrows2" + i, buttonClick("", "", "", "", "", KDWardrobe_PoseBrows2[i]), true, X + 400 + i * buttonSpacing, Y + 60, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseBrows2[i] + ".png", undefined, undefined, KDWardrobe_CurrentPoseBrows2 != KDWardrobe_PoseBrows2[i], KDButtonColor);
    }
    for (let i = 0; i < KDWardrobe_PoseBlush.length; i++) {
        DrawButtonKDEx("PoseBlush" + i, buttonClick("", "", "", "", "", "", KDWardrobe_PoseBlush[i]), true, X + 400 + i * buttonSpacing, Y + 120, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseBlush[i] + ".png", undefined, undefined, KDWardrobe_CurrentPoseBlush != KDWardrobe_PoseBlush[i], KDButtonColor);
    }
    for (let i = 0; i < KDWardrobe_PoseMouth.length; i++) {
        DrawButtonKDEx("PoseMouth" + i, buttonClick("", "", "", "", "", "", "", KDWardrobe_PoseMouth[i]), true, X + 400 + i * buttonSpacing, Y + 180, buttonWidth, buttonWidth, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/" + KDWardrobe_PoseMouth[i] + ".png", undefined, undefined, KDWardrobe_CurrentPoseMouth != KDWardrobe_PoseMouth[i], KDButtonColor);
    }
}
function KDUpdateModelList(level = 0) {
    var _a;
    if (level <= 0) {
        KDModelList_Categories = [];
        KDModelList_Categories_index = 0;
        KDModelList_Categories_viewindex.index = 0;
        for (let cat of KDWardrobeCategories) {
            KDModelList_Categories.push(cat);
        }
    }
    let category = KDModelList_Categories[KDModelList_Categories_index];
    if (level <= 1 && category) {
        KDModelList_Toplevel = [];
        KDModelList_Toplevel_index = 0;
        KDModelList_Toplevel_viewindex.index = 0;
        for (let model of Object.entries(ModelDefs)) {
            if (model[1].TopLevel && ((_a = model[1].Categories) === null || _a === void 0 ? void 0 : _a.includes(category))) {
                KDModelList_Toplevel.push(model[0]);
            }
        }
    }
    let toplevel = KDModelList_Toplevel[KDModelList_Toplevel_index];
    if (level <= 2) {
        KDModelList_Sublevel = [];
        KDModelList_Sublevel_index = 0;
        KDModelList_Sublevel_viewindex.index = 0;
        if (toplevel) {
            for (let model of Object.entries(ModelDefs)) {
                if (model[1].Parent != toplevel && model[0] == toplevel) {
                    KDModelList_Sublevel.push(model[0]);
                }
            }
            for (let model of Object.entries(ModelDefs)) {
                if (model[1].Parent == toplevel) {
                    KDModelList_Sublevel.push(model[0]);
                }
            }
        }
    }
}
function KDChangeWardrobe(C) {
    try {
        if (!KDOriginalValue)
            KDOriginalValue = LZString.compressToBase64(CharacterAppearanceStringify(KinkyDungeonPlayer));
    }
    catch (e) {
    }
    UpdateModels(KDCurrentModels.get(C));
}
function KDDrawModelList(X, C) {
    var _a;
    let clickCategory = (index) => {
        return (bdata) => {
            KDModelList_Categories_index = index;
            KDUpdateModelList(1);
            return true;
        };
    };
    let clickToplevel = (index) => {
        return (bdata) => {
            KDModelList_Toplevel_index = index;
            KDUpdateModelList(2);
            return true;
        };
    };
    let clickSublevel = (index, name) => {
        return (bdata) => {
            var _a, _b;
            let removed = false;
            for (let appIndex = 0; appIndex < C.Appearance.length; appIndex++) {
                if (((_b = (_a = C.Appearance[appIndex]) === null || _a === void 0 ? void 0 : _a.Model) === null || _b === void 0 ? void 0 : _b.Name) == name) {
                    if (KDModelList_Sublevel_index == index) {
                        KDChangeWardrobe(C);
                        C.Appearance.splice(appIndex, 1);
                        UpdateModels(KDCurrentModels.get(C));
                    }
                    removed = true;
                    break;
                }
            }
            if (!removed) {
                let M = ModelDefs[name];
                if (M) {
                    KDChangeWardrobe(C);
                    KDAddModel(C, M.Group || M.Name, M, "Default", undefined);
                    UpdateModels(KDCurrentModels.get(C));
                }
            }
            KDModelList_Sublevel_index = index;
            KDUpdateModelList(3);
            return true;
        };
    };
    let buttonHeight = 40;
    let buttonSpacing = 45;
    let hasCategories = {};
    let hasTopLevel = {};
    let models = KDCurrentModels.get(C).Models.values();
    for (let m of models) {
        if (m.Categories) {
            for (let cat of m.Categories) {
                hasCategories[cat] = true;
            }
        }
        if (m.Parent) {
            hasTopLevel[m.Parent] = true;
        }
    }
    let faded = "#888888";
    KDSelectedModel = null;
    for (let i = 0; i < KDModelListMax; i++) {
        let index_cat = i + KDModelList_Categories_viewindex.index;
        let category = KDModelList_Categories[index_cat];
        if (category)
            DrawButtonKDEx("ClickCategory" + i, clickCategory(index_cat), true, X + 0, 100 + buttonSpacing * i, 190, buttonHeight, category, hasCategories[category] ? "#ffffff" : faded, "", undefined, undefined, index_cat != KDModelList_Categories_index, KDButtonColor);
        let index_top = i + KDModelList_Toplevel_viewindex.index;
        let toplevel = KDModelList_Toplevel[index_top];
        if (toplevel)
            DrawButtonKDEx("ClickToplevel" + i, clickToplevel(index_top), true, X + 220, 100 + buttonSpacing * i, 190, buttonHeight, toplevel, (KDCurrentModels.get(C).Models.has(toplevel) || hasTopLevel[toplevel]) ? "#ffffff" : faded, "", undefined, undefined, index_top != KDModelList_Toplevel_index, KDButtonColor);
        let index_sub = i + KDModelList_Sublevel_viewindex.index;
        let sublevel = KDModelList_Sublevel[index_sub];
        if (sublevel) {
            DrawButtonKDEx("ClickSublevel" + i, clickSublevel(index_sub, sublevel), true, X + 440, 100 + buttonSpacing * i, 190, buttonHeight, sublevel, KDCurrentModels.get(C).Models.has(sublevel) ? "#ffffff" : faded, "", undefined, undefined, index_sub != KDModelList_Sublevel_index, KDButtonColor);
            if (index_sub == KDModelList_Sublevel_index && KDCurrentModels.get(C).Models.has(sublevel)) {
                KDSelectedModel = (_a = C.Appearance.find((value) => {
                    return value.Model.Name == sublevel;
                })) === null || _a === void 0 ? void 0 : _a.Model;
            }
        }
    }
    let cullIndex = () => {
        KDModelList_Toplevel_viewindex.index = Math.max(0, Math.min(KDModelList_Toplevel.length - 5, KDModelList_Toplevel_viewindex.index));
        KDModelList_Sublevel_viewindex.index = Math.max(0, Math.min(KDModelList_Sublevel.length - 5, KDModelList_Sublevel_viewindex.index));
        KDModelList_Categories_viewindex.index = Math.max(0, Math.min(KDModelList_Categories.length - 5, KDModelList_Categories_viewindex.index));
    };
    DrawButtonKDEx("KDModelList_Toplevel_V", (bdata) => {
        KDModelList_Toplevel_viewindex.index += 5;
        cullIndex();
        return true;
    }, true, X + 220 + 20, 100 + buttonSpacing * KDModelListMax, 150, buttonHeight, "v", KDModelList_Toplevel_viewindex.index + KDModelListMax < KDModelList_Toplevel_viewindex.index ? "#ffffff" : "#888888", "");
    DrawButtonKDEx("KDModelList_Toplevel_^", (bdata) => {
        KDModelList_Toplevel_viewindex.index -= 5;
        cullIndex();
        return true;
    }, true, X + 220 + 20, 100 + buttonSpacing * -1, 150, buttonHeight, "^", KDModelList_Toplevel_viewindex.index > 0 ? "#ffffff" : "#888888", "");
    DrawButtonKDEx("KDModelList_Sublevel_V", (bdata) => {
        KDModelList_Sublevel_viewindex.index += 5;
        cullIndex();
        return true;
    }, true, X + 440 + 20, 100 + buttonSpacing * KDModelListMax, 150, buttonHeight, "v", KDModelList_Sublevel_viewindex.index + KDModelListMax < KDModelList_Sublevel_viewindex.index ? "#ffffff" : "#888888", "");
    DrawButtonKDEx("KDModelList_Sublevel_^", (bdata) => {
        KDModelList_Sublevel_viewindex.index -= 5;
        cullIndex();
        return true;
    }, true, X + 440 + 20, 100 + buttonSpacing * -1, 150, buttonHeight, "^", KDModelList_Sublevel_viewindex.index > 0 ? "#ffffff" : "#888888", "");
    DrawButtonKDEx("KDModelList_Categories_V", (bdata) => {
        KDModelList_Categories_viewindex.index += 5;
        cullIndex();
        return true;
    }, true, X + 0 + 20, 100 + buttonSpacing * KDModelListMax, 150, buttonHeight, "v", (KDModelList_Categories_viewindex.index + KDModelListMax < KDModelList_Categories_viewindex.index) ? "#ffffff" : "#888888", "");
    DrawButtonKDEx("KDModelList_Categories_^", (bdata) => {
        KDModelList_Categories_viewindex.index -= 5;
        cullIndex();
        return true;
    }, true, X + 0 + 20, 100 + buttonSpacing * -1, 150, buttonHeight, "^", KDModelList_Categories_viewindex.index > 0 ? "#ffffff" : "#888888", "");
    cullIndex();
}
function KDDrawWardrobe(screen, Character) {
    if (KDOutfitInfo.length == 0)
        KDRefreshOutfitInfo();
    let C = Character || KinkyDungeonPlayer;
    KDTextField("KDOutfitName", 25, 5, 450, 30);
    if (!ElementValue("KDOutfitName")) {
        ElementValue("KDOutfitName", KDOutfitInfo[KDCurrentOutfit]);
    }
    KDDrawModelList(720, C);
    if (KDPlayerSetPose)
        KDDrawPoseButtons(C);
    else {
        KDDrawSavedColors(1060, 870, KDSavedColorCount, C);
    }
    DrawButtonKDEx("SetPose", (bdata) => {
        KDPlayerSetPose = !KDPlayerSetPose;
        return true;
    }, true, 884, 790, 60, 60, "", "#ffffff", KinkyDungeonRootDirectory + "Poses/SetPose.png", "", false, false, KDPlayerSetPose ? KDTextGray3 : KDButtonColor);
    if (KDSelectedModel) {
        KDDrawColorSliders(1600, 100, C, KDSelectedModel);
    }
    else {
        KDCurrentLayer = "";
    }
    let clickButton = (index) => {
        return (bdata) => {
            KDOutfitStore[KDCurrentOutfit] = LZString.compressToBase64(CharacterAppearanceStringify(KinkyDungeonPlayer));
            KDOutfitOriginalStore[KDCurrentOutfit] = KDOriginalValue;
            KDCurrentOutfit = index;
            ElementValue("KDOutfitName", "");
            localStorage.setItem("kdcurrentoutfit", KDCurrentOutfit + "");
            let NewOutfit = KDOutfitStore[KDCurrentOutfit] || localStorage.getItem("kinkydungeonappearance" + KDCurrentOutfit);
            if (NewOutfit) {
                KDOriginalValue = KDOutfitOriginalStore[KDCurrentOutfit] || "";
                CharacterAppearanceRestore(KinkyDungeonPlayer, LZString.decompressFromBase64(NewOutfit));
                CharacterRefresh(KinkyDungeonPlayer);
                KDInitProtectedGroups();
                KinkyDungeonDressPlayer();
            }
            else {
                KDGetDressList().Default = KinkyDungeonDefaultDefaultDress;
                CharacterAppearanceRestore(KinkyDungeonPlayer, CharacterAppearanceStringify(KinkyDungeonPlayerCharacter ? KinkyDungeonPlayerCharacter : Player));
                CharacterReleaseTotal(KinkyDungeonPlayer);
                KinkyDungeonSetDress("Default", "Default");
                KinkyDungeonDressPlayer();
                KDInitProtectedGroups();
            }
            return true;
        };
    };
    for (let i = 0; i < KDOutfitInfo.length && i < KDMaxOutfitsDisplay; i++) {
        let index = i + KDMaxOutfitsIndex;
        DrawButtonKDEx("ClickOutfit" + i, clickButton(index), true, 475, 100 + 50 * i, 200, 45, KDOutfitInfo[index] + (((index == KDCurrentOutfit && KDOriginalValue) || KDOutfitOriginalStore[index]) ? "(*)" : ""), index == KDCurrentOutfit ? "#ffffff" : "#888888", "");
    }
    DrawButtonKDEx("ResetOutfit", (bdata) => {
        if (KDConfirmType == "reset" && KinkyDungeonReplaceConfirm > 0) {
            KDChangeWardrobe(C);
            KDGetDressList().Default = KinkyDungeonDefaultDefaultDress;
            CharacterAppearanceRestore(KinkyDungeonPlayer, CharacterAppearanceStringify(KinkyDungeonPlayerCharacter ? KinkyDungeonPlayerCharacter : Player));
            CharacterReleaseTotal(KinkyDungeonPlayer);
            KinkyDungeonSetDress("Default", "Default");
            KinkyDungeonDressPlayer();
            KDInitProtectedGroups();
            UpdateModels(KDCurrentModels.get(KinkyDungeonPlayer));
            KinkyDungeonConfigAppearance = true;
            KinkyDungeonReplaceConfirm = 0;
            return true;
        }
        else {
            KDConfirmType = "reset";
            KinkyDungeonReplaceConfirm = 2;
            return true;
        }
    }, true, 475, 860, 220, 60, TextGet((KinkyDungeonReplaceConfirm > 0 && KDConfirmType == 'reset') ?
        "KinkyDungeonConfirm" :
        "KinkyDungeonDressPlayerReset"), "#ffffff", "");
    DrawButtonKDEx("StripOutfit", (bdata) => {
        if (KDConfirmType == "strip" && KinkyDungeonReplaceConfirm > 0) {
            KDChangeWardrobe(C);
            CharacterAppearanceRestore(KinkyDungeonPlayer, CharacterAppearanceStringify(KinkyDungeonPlayerCharacter ? KinkyDungeonPlayerCharacter : Player));
            CharacterReleaseTotal(KinkyDungeonPlayer);
            KinkyDungeonSetDress("Bikini", "Bikini");
            KinkyDungeonDressPlayer();
            KDInitProtectedGroups();
            KinkyDungeonConfigAppearance = true;
            KinkyDungeonReplaceConfirm = 0;
            return true;
        }
        else {
            KDConfirmType = "strip";
            KinkyDungeonReplaceConfirm = 2;
            return true;
        }
    }, true, 475, 790, 220, 60, TextGet((KinkyDungeonReplaceConfirm > 0 && KDConfirmType == 'strip') ?
        "KDConfirmStrip" :
        "KDDressStrip"), "#ffffff", "");
    DrawButtonKDEx("LoadFromCode", (bdata) => {
        KinkyDungeonState = "LoadOutfit";
        LZString.compressToBase64(CharacterAppearanceStringify(KinkyDungeonPlayer));
        CharacterReleaseTotal(KinkyDungeonPlayer);
        ElementCreateTextArea("saveInputField");
        ElementValue("saveInputField", LZString.compressToBase64(CharacterAppearanceStringify(KinkyDungeonPlayer)));
        return true;
    }, true, 475, 930, 220, 60, TextGet("KinkyDungeonDressPlayerImport"), "#ffffff", "");
    DrawButtonKDEx("KDWardrobeCancel", (bdata) => {
        if (KDConfirmType == "revert" && KinkyDungeonReplaceConfirm > 0) {
            KinkyDungeonReplaceConfirm = 0;
            KDRestoreOutfit();
            KDOriginalValue = "";
            return true;
        }
        else {
            KDConfirmType = "revert";
            KinkyDungeonReplaceConfirm = 2;
            return true;
        }
    }, true, 725, 860, 220, 60, TextGet((KinkyDungeonReplaceConfirm > 0 && KDConfirmType == 'revert') ?
        "KDWardrobeCancelConfirm" :
        "KDWardrobeCancel"), KDOriginalValue ? "#ffffff" : "#888888", "");
    DrawButtonKDEx("KDWardrobeSaveOutfit", (bdata) => {
        if (KDConfirmType == "save" && KinkyDungeonReplaceConfirm > 0) {
            if (ElementValue("KDOutfitName")) {
                KDOutfitInfo[KDCurrentOutfit] = ElementValue("KDOutfitName");
                KDSaveOutfitInfo();
            }
            KinkyDungeonReplaceConfirm = 0;
            localStorage.setItem("kinkydungeonappearance" + KDCurrentOutfit, LZString.compressToBase64(CharacterAppearanceStringify(KinkyDungeonPlayer)));
            KinkyDungeonDressSet();
            KDOriginalValue = "";
            KDRefreshOutfitInfo();
            return true;
        }
        else {
            KDConfirmType = "save";
            KinkyDungeonReplaceConfirm = 2;
            return true;
        }
    }, true, 725, 930, 220, 60, TextGet((KinkyDungeonReplaceConfirm > 0 && KDConfirmType == 'save') ?
        "KDWardrobeSaveOutfitConfirm" :
        "KDWardrobeSaveOutfit"), KDOriginalValue ? "#ffffff" : "#888888", "");
    DrawButtonKDEx("KDWardrobeSave", (bdata) => {
        KinkyDungeonState = "Menu";
        KinkyDungeonDressSet();
        return true;
    }, true, 30, 942, 440, 50, TextGet("KDWardrobeSave"), "#ffffff", "");
}
function KDSaveCodeOutfit() {
    KDChangeWardrobe(KinkyDungeonPlayer);
    let decompressed = LZString.decompressFromBase64(ElementValue("saveInputField"));
    let stringified = "";
    if (decompressed) {
        let origAppearance = KinkyDungeonPlayer.Appearance;
        try {
            CharacterAppearanceRestore(KinkyDungeonPlayer, decompressed);
            CharacterRefresh(KinkyDungeonPlayer);
            KDInitProtectedGroups();
            stringified = CharacterAppearanceStringify(KinkyDungeonPlayer);
        }
        catch (e) {
            KinkyDungeonPlayer.Appearance = origAppearance;
            try {
                let parsed = JSON.parse(decompressed);
                if (parsed.length > 0) {
                    if (!StandalonePatched) {
                        for (let g of parsed) {
                            InventoryWear(KinkyDungeonPlayer, g.Name, g.Group, g.Color);
                        }
                        CharacterRefresh(KinkyDungeonPlayer);
                    }
                    KDInitProtectedGroups();
                    stringified = CharacterAppearanceStringify(KinkyDungeonPlayer);
                }
                else {
                    console.log("Invalid code. Maybe its corrupt?");
                }
            }
            catch (error) {
                console.log("Invalid code.");
            }
        }
    }
    KinkyDungeonDressPlayer();
    if (stringified) {
        localStorage.setItem("kinkydungeonappearance" + KDCurrentOutfit, stringified);
        KDSaveOutfitInfo();
        KDRefreshOutfitInfo();
    }
    KinkyDungeonNewDress = true;
}
function KDRestoreOutfit() {
    if (KDOriginalValue) {
        CharacterAppearanceRestore(KinkyDungeonPlayer, LZString.decompressFromBase64(KDOriginalValue));
        CharacterRefresh(KinkyDungeonPlayer);
        KDInitProtectedGroups();
        KinkyDungeonDressPlayer();
    }
}
function KDSaveOutfitInfo() {
    localStorage.setItem("kdOutfitMeta", JSON.stringify(KDOutfitInfo));
}
function KDRefreshOutfitInfo() {
    let loaded = JSON.parse(localStorage.getItem("kdOutfitMeta"));
    if (!(loaded === null || loaded === void 0 ? void 0 : loaded.length) || typeof loaded === 'string') {
        loaded = [];
    }
    if ((loaded === null || loaded === void 0 ? void 0 : loaded.length) != undefined) {
        KDOutfitInfo = loaded;
        if (loaded.length < KDMaxOutfits) {
            for (let i = 1; i <= KDMaxOutfits; i++) {
                if (i > loaded.length) {
                    KDOutfitInfo.push("Outfit" + i);
                }
            }
        }
    }
}
//# sourceMappingURL=main.js.map